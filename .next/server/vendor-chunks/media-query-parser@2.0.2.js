"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/media-query-parser@2.0.2";
exports.ids = ["vendor-chunks/media-query-parser@2.0.2"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/media-query-parser@2.0.2/node_modules/media-query-parser/dist/media-query-parser.esm.js":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/media-query-parser@2.0.2/node_modules/media-query-parser/dist/media-query-parser.esm.js ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   consumeEscape: () => (/* binding */ consumeEscape),\n/* harmony export */   consumeIdent: () => (/* binding */ consumeIdent),\n/* harmony export */   consumeIdentLike: () => (/* binding */ consumeIdentLike),\n/* harmony export */   consumeIdentUnsafe: () => (/* binding */ consumeIdentUnsafe),\n/* harmony export */   consumeNumber: () => (/* binding */ consumeNumber),\n/* harmony export */   consumeNumeric: () => (/* binding */ consumeNumeric),\n/* harmony export */   consumeString: () => (/* binding */ consumeString),\n/* harmony export */   consumeUrl: () => (/* binding */ consumeUrl),\n/* harmony export */   lexicalAnalysis: () => (/* binding */ lexicalAnalysis),\n/* harmony export */   removeWhitespace: () => (/* binding */ removeWhitespace),\n/* harmony export */   syntacticAnalysis: () => (/* binding */ syntacticAnalysis),\n/* harmony export */   toAST: () => (/* binding */ toAST),\n/* harmony export */   toUnflattenedAST: () => (/* binding */ toUnflattenedAST),\n/* harmony export */   tokenizeMediaCondition: () => (/* binding */ tokenizeMediaCondition),\n/* harmony export */   tokenizeMediaFeature: () => (/* binding */ tokenizeMediaFeature),\n/* harmony export */   tokenizeMediaQuery: () => (/* binding */ tokenizeMediaQuery),\n/* harmony export */   tokenizeRange: () => (/* binding */ tokenizeRange),\n/* harmony export */   wouldStartIdentifier: () => (/* binding */ wouldStartIdentifier)\n/* harmony export */ });\n/*! @license MediaQueryParser - MIT License - Tom Golden (github@tbjgolden.com) */ /*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ var __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nfunction __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nfunction __values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __read(o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while((n === void 0 || n-- > 0) && !(r = i.next()).done)ar.push(r.value);\n    } catch (error) {\n        e = {\n            error: error\n        };\n    } finally{\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        } finally{\n            if (e) throw e.error;\n        }\n    }\n    return ar;\n}\nvar weirdNewlines = /(\\u000D|\\u000C|\\u000D\\u000A)/g;\nvar nullOrSurrogates = /[\\u0000\\uD800-\\uDFFF]/g;\nvar commentRegex = /(\\/\\*)[\\s\\S]*?(\\*\\/)/g;\nvar lexicalAnalysis = function lexicalAnalysis(str, index) {\n    if (index === void 0) {\n        index = 0;\n    }\n    str = str.replace(weirdNewlines, \"\\n\").replace(nullOrSurrogates, \"ï¿½\");\n    str = str.replace(commentRegex, \"\");\n    var tokens = [];\n    for(; index < str.length; index += 1){\n        var code = str.charCodeAt(index);\n        if (code === 0x0009 || code === 0x0020 || code === 0x000a) {\n            var code_1 = str.charCodeAt(++index);\n            while(code_1 === 0x0009 || code_1 === 0x0020 || code_1 === 0x000a){\n                code_1 = str.charCodeAt(++index);\n            }\n            index -= 1;\n            tokens.push({\n                type: \"<whitespace-token>\"\n            });\n        } else if (code === 0x0022) {\n            var result = consumeString(str, index);\n            if (result === null) {\n                return null;\n            }\n            var _a = __read(result, 2), lastIndex = _a[0], value = _a[1];\n            tokens.push({\n                type: \"<string-token>\",\n                value: value\n            });\n            index = lastIndex;\n        } else if (code === 0x0023) {\n            if (index + 1 < str.length) {\n                var nextCode = str.charCodeAt(index + 1);\n                if (nextCode === 0x005f || nextCode >= 0x0041 && nextCode <= 0x005a || nextCode >= 0x0061 && nextCode <= 0x007a || nextCode >= 0x0080 || nextCode >= 0x0030 && nextCode <= 0x0039 || nextCode === 0x005c && index + 2 < str.length && str.charCodeAt(index + 2) !== 0x000a) {\n                    var flag = wouldStartIdentifier(str, index + 1) ? \"id\" : \"unrestricted\";\n                    var result = consumeIdentUnsafe(str, index + 1);\n                    if (result !== null) {\n                        var _b = __read(result, 2), lastIndex = _b[0], value = _b[1];\n                        tokens.push({\n                            type: \"<hash-token>\",\n                            value: value.toLowerCase(),\n                            flag: flag\n                        });\n                        index = lastIndex;\n                        continue;\n                    }\n                }\n            }\n            tokens.push({\n                type: \"<delim-token>\",\n                value: code\n            });\n        } else if (code === 0x0027) {\n            var result = consumeString(str, index);\n            if (result === null) {\n                return null;\n            }\n            var _c = __read(result, 2), lastIndex = _c[0], value = _c[1];\n            tokens.push({\n                type: \"<string-token>\",\n                value: value\n            });\n            index = lastIndex;\n        } else if (code === 0x0028) {\n            tokens.push({\n                type: \"<(-token>\"\n            });\n        } else if (code === 0x0029) {\n            tokens.push({\n                type: \"<)-token>\"\n            });\n        } else if (code === 0x002b) {\n            var plusNumeric = consumeNumeric(str, index);\n            if (plusNumeric === null) {\n                tokens.push({\n                    type: \"<delim-token>\",\n                    value: code\n                });\n            } else {\n                var _d = __read(plusNumeric, 2), lastIndex = _d[0], tokenTuple = _d[1];\n                if (tokenTuple[0] === \"<dimension-token>\") {\n                    tokens.push({\n                        type: \"<dimension-token>\",\n                        value: tokenTuple[1],\n                        unit: tokenTuple[2].toLowerCase(),\n                        flag: \"number\"\n                    });\n                } else if (tokenTuple[0] === \"<number-token>\") {\n                    tokens.push({\n                        type: tokenTuple[0],\n                        value: tokenTuple[1],\n                        flag: tokenTuple[2]\n                    });\n                } else {\n                    tokens.push({\n                        type: tokenTuple[0],\n                        value: tokenTuple[1],\n                        flag: \"number\"\n                    });\n                }\n                index = lastIndex;\n            }\n        } else if (code === 0x002c) {\n            tokens.push({\n                type: \"<comma-token>\"\n            });\n        } else if (code === 0x002d) {\n            var minusNumeric = consumeNumeric(str, index);\n            if (minusNumeric !== null) {\n                var _e = __read(minusNumeric, 2), lastIndex = _e[0], tokenTuple = _e[1];\n                if (tokenTuple[0] === \"<dimension-token>\") {\n                    tokens.push({\n                        type: \"<dimension-token>\",\n                        value: tokenTuple[1],\n                        unit: tokenTuple[2].toLowerCase(),\n                        flag: \"number\"\n                    });\n                } else if (tokenTuple[0] === \"<number-token>\") {\n                    tokens.push({\n                        type: tokenTuple[0],\n                        value: tokenTuple[1],\n                        flag: tokenTuple[2]\n                    });\n                } else {\n                    tokens.push({\n                        type: tokenTuple[0],\n                        value: tokenTuple[1],\n                        flag: \"number\"\n                    });\n                }\n                index = lastIndex;\n                continue;\n            }\n            if (index + 2 < str.length) {\n                var nextCode = str.charCodeAt(index + 1);\n                var nextNextCode = str.charCodeAt(index + 2);\n                if (nextCode === 0x002d && nextNextCode === 0x003e) {\n                    tokens.push({\n                        type: \"<CDC-token>\"\n                    });\n                    index += 2;\n                    continue;\n                }\n            }\n            var result = consumeIdentLike(str, index);\n            if (result !== null) {\n                var _f = __read(result, 3), lastIndex = _f[0], value = _f[1], type = _f[2];\n                tokens.push({\n                    type: type,\n                    value: value\n                });\n                index = lastIndex;\n                continue;\n            }\n            tokens.push({\n                type: \"<delim-token>\",\n                value: code\n            });\n        } else if (code === 0x002e) {\n            var minusNumeric = consumeNumeric(str, index);\n            if (minusNumeric === null) {\n                tokens.push({\n                    type: \"<delim-token>\",\n                    value: code\n                });\n            } else {\n                var _g = __read(minusNumeric, 2), lastIndex = _g[0], tokenTuple = _g[1];\n                if (tokenTuple[0] === \"<dimension-token>\") {\n                    tokens.push({\n                        type: \"<dimension-token>\",\n                        value: tokenTuple[1],\n                        unit: tokenTuple[2].toLowerCase(),\n                        flag: \"number\"\n                    });\n                } else if (tokenTuple[0] === \"<number-token>\") {\n                    tokens.push({\n                        type: tokenTuple[0],\n                        value: tokenTuple[1],\n                        flag: tokenTuple[2]\n                    });\n                } else {\n                    tokens.push({\n                        type: tokenTuple[0],\n                        value: tokenTuple[1],\n                        flag: \"number\"\n                    });\n                }\n                index = lastIndex;\n                continue;\n            }\n        } else if (code === 0x003a) {\n            tokens.push({\n                type: \"<colon-token>\"\n            });\n        } else if (code === 0x003b) {\n            tokens.push({\n                type: \"<semicolon-token>\"\n            });\n        } else if (code === 0x003c) {\n            if (index + 3 < str.length) {\n                var nextCode = str.charCodeAt(index + 1);\n                var nextNextCode = str.charCodeAt(index + 2);\n                var nextNextNextCode = str.charCodeAt(index + 3);\n                if (nextCode === 0x0021 && nextNextCode === 0x002d && nextNextNextCode === 0x002d) {\n                    tokens.push({\n                        type: \"<CDO-token>\"\n                    });\n                    index += 3;\n                    continue;\n                }\n            }\n            tokens.push({\n                type: \"<delim-token>\",\n                value: code\n            });\n        } else if (code === 0x0040) {\n            var result = consumeIdent(str, index + 1);\n            if (result !== null) {\n                var _h = __read(result, 2), lastIndex = _h[0], value = _h[1];\n                tokens.push({\n                    type: \"<at-keyword-token>\",\n                    value: value.toLowerCase()\n                });\n                index = lastIndex;\n                continue;\n            }\n            tokens.push({\n                type: \"<delim-token>\",\n                value: code\n            });\n        } else if (code === 0x005b) {\n            tokens.push({\n                type: \"<[-token>\"\n            });\n        } else if (code === 0x005c) {\n            var result = consumeEscape(str, index);\n            if (result === null) {\n                return null;\n            }\n            var _j = __read(result, 2), lastIndex = _j[0], value = _j[1];\n            str = str.slice(0, index) + value + str.slice(lastIndex + 1);\n            index -= 1;\n        } else if (code === 0x005d) {\n            tokens.push({\n                type: \"<]-token>\"\n            });\n        } else if (code === 0x007b) {\n            tokens.push({\n                type: \"<{-token>\"\n            });\n        } else if (code === 0x007d) {\n            tokens.push({\n                type: \"<}-token>\"\n            });\n        } else if (code >= 0x0030 && code <= 0x0039) {\n            var result = consumeNumeric(str, index);\n            var _k = __read(result, 2), lastIndex = _k[0], tokenTuple = _k[1];\n            if (tokenTuple[0] === \"<dimension-token>\") {\n                tokens.push({\n                    type: \"<dimension-token>\",\n                    value: tokenTuple[1],\n                    unit: tokenTuple[2].toLowerCase(),\n                    flag: \"number\"\n                });\n            } else if (tokenTuple[0] === \"<number-token>\") {\n                tokens.push({\n                    type: tokenTuple[0],\n                    value: tokenTuple[1],\n                    flag: tokenTuple[2]\n                });\n            } else {\n                tokens.push({\n                    type: tokenTuple[0],\n                    value: tokenTuple[1],\n                    flag: \"number\"\n                });\n            }\n            index = lastIndex;\n        } else if (code === 0x005f || code >= 0x0041 && code <= 0x005a || code >= 0x0061 && code <= 0x007a || code >= 0x0080) {\n            var result = consumeIdentLike(str, index);\n            if (result === null) {\n                return null;\n            }\n            var _l = __read(result, 3), lastIndex = _l[0], value = _l[1], type = _l[2];\n            tokens.push({\n                type: type,\n                value: value\n            });\n            index = lastIndex;\n        } else {\n            tokens.push({\n                type: \"<delim-token>\",\n                value: code\n            });\n        }\n    }\n    tokens.push({\n        type: \"<EOF-token>\"\n    });\n    return tokens;\n};\nvar consumeString = function consumeString(str, index) {\n    if (str.length <= index + 1) return null;\n    var firstCode = str.charCodeAt(index);\n    var charCodes = [];\n    for(var i = index + 1; i < str.length; i += 1){\n        var code = str.charCodeAt(i);\n        if (code === firstCode) {\n            return [\n                i,\n                String.fromCharCode.apply(null, charCodes)\n            ];\n        } else if (code === 0x005c) {\n            var result = consumeEscape(str, i);\n            if (result === null) return null;\n            var _a = __read(result, 2), lastIndex = _a[0], charCode = _a[1];\n            charCodes.push(charCode);\n            i = lastIndex;\n        } else if (code === 0x000a) {\n            return null;\n        } else {\n            charCodes.push(code);\n        }\n    }\n    return null;\n};\nvar wouldStartIdentifier = function wouldStartIdentifier(str, index) {\n    if (str.length <= index) return false;\n    var code = str.charCodeAt(index);\n    if (code === 0x002d) {\n        if (str.length <= index + 1) return false;\n        var nextCode = str.charCodeAt(index + 1);\n        if (nextCode === 0x002d || nextCode === 0x005f || nextCode >= 0x0041 && nextCode <= 0x005a || nextCode >= 0x0061 && nextCode <= 0x007a || nextCode >= 0x0080) {\n            return true;\n        } else if (nextCode === 0x005c) {\n            if (str.length <= index + 2) return false;\n            var nextNextCode = str.charCodeAt(index + 2);\n            return nextNextCode !== 0x000a;\n        } else {\n            return false;\n        }\n    } else if (code === 0x005f || code >= 0x0041 && code <= 0x005a || code >= 0x0061 && code <= 0x007a || code >= 0x0080) {\n        return true;\n    } else if (code === 0x005c) {\n        if (str.length <= index + 1) return false;\n        var nextCode = str.charCodeAt(index + 1);\n        return nextCode !== 0x000a;\n    } else {\n        return false;\n    }\n};\nvar consumeEscape = function consumeEscape(str, index) {\n    if (str.length <= index + 1) return null;\n    if (str.charCodeAt(index) !== 0x005c) return null;\n    var code = str.charCodeAt(index + 1);\n    if (code === 0x000a) {\n        return null;\n    } else if (code >= 0x0030 && code <= 0x0039 || code >= 0x0041 && code <= 0x0046 || code >= 0x0061 && code <= 0x0066) {\n        var hexCharCodes = [\n            code\n        ];\n        var min = Math.min(index + 7, str.length);\n        var i = index + 2;\n        for(; i < min; i += 1){\n            var code_2 = str.charCodeAt(i);\n            if (code_2 >= 0x0030 && code_2 <= 0x0039 || code_2 >= 0x0041 && code_2 <= 0x0046 || code_2 >= 0x0061 && code_2 <= 0x0066) {\n                hexCharCodes.push(code_2);\n            } else {\n                break;\n            }\n        }\n        if (i < str.length) {\n            var code_3 = str.charCodeAt(i);\n            if (code_3 === 0x0009 || code_3 === 0x0020 || code_3 === 0x000a) {\n                i += 1;\n            }\n        }\n        return [\n            i - 1,\n            parseInt(String.fromCharCode.apply(null, hexCharCodes), 16)\n        ];\n    } else {\n        return [\n            index + 1,\n            code\n        ];\n    }\n};\nvar consumeNumeric = function consumeNumeric(str, index) {\n    var numberResult = consumeNumber(str, index);\n    if (numberResult === null) return null;\n    var _a = __read(numberResult, 3), numberEndIndex = _a[0], numberValue = _a[1], numberFlag = _a[2];\n    var identResult = consumeIdent(str, numberEndIndex + 1);\n    if (identResult !== null) {\n        var _b = __read(identResult, 2), identEndIndex = _b[0], identValue = _b[1];\n        return [\n            identEndIndex,\n            [\n                \"<dimension-token>\",\n                numberValue,\n                identValue\n            ]\n        ];\n    }\n    if (numberEndIndex + 1 < str.length && str.charCodeAt(numberEndIndex + 1) === 0x0025) {\n        return [\n            numberEndIndex + 1,\n            [\n                \"<percentage-token>\",\n                numberValue\n            ]\n        ];\n    }\n    return [\n        numberEndIndex,\n        [\n            \"<number-token>\",\n            numberValue,\n            numberFlag\n        ]\n    ];\n};\nvar consumeNumber = function consumeNumber(str, index) {\n    if (str.length <= index) return null;\n    var flag = \"integer\";\n    var numberChars = [];\n    var firstCode = str.charCodeAt(index);\n    if (firstCode === 0x002b || firstCode === 0x002d) {\n        index += 1;\n        if (firstCode === 0x002d) numberChars.push(0x002d);\n    }\n    while(index < str.length){\n        var code = str.charCodeAt(index);\n        if (code >= 0x0030 && code <= 0x0039) {\n            numberChars.push(code);\n            index += 1;\n        } else {\n            break;\n        }\n    }\n    if (index + 1 < str.length) {\n        var nextCode = str.charCodeAt(index);\n        var nextNextCode = str.charCodeAt(index + 1);\n        if (nextCode === 0x002e && nextNextCode >= 0x0030 && nextNextCode <= 0x0039) {\n            numberChars.push(nextCode, nextNextCode);\n            flag = \"number\";\n            index += 2;\n            while(index < str.length){\n                var code = str.charCodeAt(index);\n                if (code >= 0x0030 && code <= 0x0039) {\n                    numberChars.push(code);\n                    index += 1;\n                } else {\n                    break;\n                }\n            }\n        }\n    }\n    if (index + 1 < str.length) {\n        var nextCode = str.charCodeAt(index);\n        var nextNextCode = str.charCodeAt(index + 1);\n        var nextNextNextCode = str.charCodeAt(index + 2);\n        if (nextCode === 0x0045 || nextCode === 0x0065) {\n            var nextNextIsDigit = nextNextCode >= 0x0030 && nextNextCode <= 0x0039;\n            if (nextNextIsDigit || (nextNextCode === 0x002b || nextNextCode === 0x002d) && nextNextNextCode >= 0x0030 && nextNextNextCode <= 0x0039) {\n                flag = \"number\";\n                if (nextNextIsDigit) {\n                    numberChars.push(0x0045, nextNextCode);\n                    index += 2;\n                } else if (nextNextCode === 0x002d) {\n                    numberChars.push(0x0045, 0x002d, nextNextNextCode);\n                    index += 3;\n                } else {\n                    numberChars.push(0x0045, nextNextNextCode);\n                    index += 3;\n                }\n                while(index < str.length){\n                    var code = str.charCodeAt(index);\n                    if (code >= 0x0030 && code <= 0x0039) {\n                        numberChars.push(code);\n                        index += 1;\n                    } else {\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    var numberString = String.fromCharCode.apply(null, numberChars);\n    var value = flag === \"number\" ? parseFloat(numberString) : parseInt(numberString);\n    if (value === -0) value = 0;\n    return Number.isNaN(value) ? null : [\n        index - 1,\n        value,\n        flag\n    ];\n};\nvar consumeIdentUnsafe = function consumeIdentUnsafe(str, index) {\n    if (str.length <= index) {\n        return null;\n    }\n    var identChars = [];\n    for(var code = str.charCodeAt(index); index < str.length; code = str.charCodeAt(++index)){\n        if (code === 0x002d || code === 0x005f || code >= 0x0041 && code <= 0x005a || code >= 0x0061 && code <= 0x007a || code >= 0x0080 || code >= 0x0030 && code <= 0x0039) {\n            identChars.push(code);\n            continue;\n        } else {\n            var result = consumeEscape(str, index);\n            if (result !== null) {\n                var _a = __read(result, 2), lastIndex = _a[0], code_4 = _a[1];\n                identChars.push(code_4);\n                index = lastIndex;\n                continue;\n            }\n        }\n        break;\n    }\n    return index === 0 ? null : [\n        index - 1,\n        String.fromCharCode.apply(null, identChars)\n    ];\n};\nvar consumeIdent = function consumeIdent(str, index) {\n    if (str.length <= index || !wouldStartIdentifier(str, index)) {\n        return null;\n    }\n    var identChars = [];\n    for(var code = str.charCodeAt(index); index < str.length; code = str.charCodeAt(++index)){\n        if (code === 0x002d || code === 0x005f || code >= 0x0041 && code <= 0x005a || code >= 0x0061 && code <= 0x007a || code >= 0x0080 || code >= 0x0030 && code <= 0x0039) {\n            identChars.push(code);\n            continue;\n        } else {\n            var result = consumeEscape(str, index);\n            if (result !== null) {\n                var _a = __read(result, 2), lastIndex = _a[0], code_5 = _a[1];\n                identChars.push(code_5);\n                index = lastIndex;\n                continue;\n            }\n        }\n        break;\n    }\n    return [\n        index - 1,\n        String.fromCharCode.apply(null, identChars)\n    ];\n};\nvar consumeUrl = function consumeUrl(str, index) {\n    var code = str.charCodeAt(index);\n    while(code === 0x0009 || code === 0x0020 || code === 0x000a){\n        code = str.charCodeAt(++index);\n    }\n    var urlChars = [];\n    var hasFinishedWord = false;\n    while(index < str.length){\n        if (code === 0x0029) {\n            return [\n                index,\n                String.fromCharCode.apply(null, urlChars)\n            ];\n        } else if (code === 0x0022 || code === 0x0027 || code === 0x0028) {\n            return null;\n        } else if (code === 0x0009 || code === 0x0020 || code === 0x000a) {\n            if (!hasFinishedWord && urlChars.length !== 0) hasFinishedWord = true;\n        } else if (code === 0x005c) {\n            var result = consumeEscape(str, index);\n            if (result === null || hasFinishedWord) return null;\n            var _a = __read(result, 2), lastIndex = _a[0], value = _a[1];\n            urlChars.push(value);\n            index = lastIndex;\n        } else {\n            if (hasFinishedWord) return null;\n            urlChars.push(code);\n        }\n        code = str.charCodeAt(++index);\n    }\n    return null;\n};\nvar consumeIdentLike = function consumeIdentLike(str, index) {\n    var result = consumeIdent(str, index);\n    if (result === null) return null;\n    var _a = __read(result, 2), lastIndex = _a[0], value = _a[1];\n    if (value.toLowerCase() === \"url\") {\n        if (str.length > lastIndex + 1) {\n            var nextCode = str.charCodeAt(lastIndex + 1);\n            if (nextCode === 0x0028) {\n                for(var offset = 2; lastIndex + offset < str.length; offset += 1){\n                    var nextNextCode = str.charCodeAt(lastIndex + offset);\n                    if (nextNextCode === 0x0022 || nextNextCode === 0x0027) {\n                        return [\n                            lastIndex + 1,\n                            value.toLowerCase(),\n                            \"<function-token>\"\n                        ];\n                    } else if (nextNextCode !== 0x0009 && nextNextCode !== 0x0020 && nextNextCode !== 0x000a) {\n                        var result_1 = consumeUrl(str, lastIndex + offset);\n                        if (result_1 === null) return null;\n                        var _b = __read(result_1, 2), lastUrlIndex = _b[0], value_1 = _b[1];\n                        return [\n                            lastUrlIndex,\n                            value_1,\n                            \"<url-token>\"\n                        ];\n                    }\n                }\n                return [\n                    lastIndex + 1,\n                    value.toLowerCase(),\n                    \"<function-token>\"\n                ];\n            }\n        }\n    } else if (str.length > lastIndex + 1) {\n        var nextCode = str.charCodeAt(lastIndex + 1);\n        if (nextCode === 0x0028) {\n            return [\n                lastIndex + 1,\n                value.toLowerCase(),\n                \"<function-token>\"\n            ];\n        }\n    }\n    return [\n        lastIndex,\n        value.toLowerCase(),\n        \"<ident-token>\"\n    ];\n};\nvar simplifyAST = function simplifyAST(ast) {\n    for(var i = ast.length - 1; i >= 0; i--){\n        ast[i] = simplifyMediaQuery(ast[i]);\n    }\n    return ast;\n};\nvar simplifyMediaQuery = function simplifyMediaQuery(mediaQuery) {\n    if (mediaQuery.mediaCondition === null) return mediaQuery;\n    var mediaCondition = simplifyMediaCondition(mediaQuery.mediaCondition);\n    if (mediaCondition.operator === null && mediaCondition.children.length === 1 && \"children\" in mediaCondition.children[0]) {\n        mediaCondition = mediaCondition.children[0];\n    }\n    return {\n        mediaPrefix: mediaQuery.mediaPrefix,\n        mediaType: mediaQuery.mediaType,\n        mediaCondition: mediaCondition\n    };\n};\nvar simplifyMediaCondition = function simplifyMediaCondition(mediaCondition) {\n    for(var i = mediaCondition.children.length - 1; i >= 0; i--){\n        var unsimplifiedChild = mediaCondition.children[i];\n        if (!(\"context\" in unsimplifiedChild)) {\n            var child = simplifyMediaCondition(unsimplifiedChild);\n            if (child.operator === null && child.children.length === 1) {\n                mediaCondition.children[i] = child.children[0];\n            } else if (child.operator === mediaCondition.operator && (child.operator === \"and\" || child.operator === \"or\")) {\n                var spliceArgs = [\n                    i,\n                    1\n                ];\n                for(var i_1 = 0; i_1 < child.children.length; i_1++){\n                    spliceArgs.push(child.children[i_1]);\n                }\n                mediaCondition.children.splice.apply(mediaCondition.children, spliceArgs);\n            }\n        }\n    }\n    return mediaCondition;\n};\nvar createError = function createError(message, err) {\n    if (err instanceof Error) {\n        return new Error(\"\".concat(err.message.trim(), \"\\n\").concat(message.trim()));\n    } else {\n        return new Error(message.trim());\n    }\n};\nvar toAST = function toAST(str) {\n    return simplifyAST(toUnflattenedAST(str));\n};\nvar toUnflattenedAST = function toUnflattenedAST(str) {\n    var tokenList = lexicalAnalysis(str.trim());\n    if (tokenList === null) {\n        throw createError(\"Failed tokenizing\");\n    }\n    var startIndex = 0;\n    var endIndex = tokenList.length - 1;\n    if (tokenList[0].type === \"<at-keyword-token>\" && tokenList[0].value === \"media\") {\n        if (tokenList[1].type !== \"<whitespace-token>\") {\n            throw createError(\"Expected whitespace after media\");\n        }\n        startIndex = 2;\n        for(var i = 2; i < tokenList.length - 1; i++){\n            var token = tokenList[i];\n            if (token.type === \"<{-token>\") {\n                endIndex = i;\n                break;\n            } else if (token.type === \"<semicolon-token>\") {\n                throw createError(\"Expected '{' in media query but found ';'\");\n            }\n        }\n    }\n    tokenList = tokenList.slice(startIndex, endIndex);\n    return syntacticAnalysis(tokenList);\n};\nvar removeWhitespace = function removeWhitespace(tokenList) {\n    var newTokenList = [];\n    var before = false;\n    for(var i = 0; i < tokenList.length; i++){\n        if (tokenList[i].type === \"<whitespace-token>\") {\n            before = true;\n            if (newTokenList.length > 0) {\n                newTokenList[newTokenList.length - 1].wsAfter = true;\n            }\n        } else {\n            newTokenList.push(__assign(__assign({}, tokenList[i]), {\n                wsBefore: before,\n                wsAfter: false\n            }));\n            before = false;\n        }\n    }\n    return newTokenList;\n};\nvar syntacticAnalysis = function syntacticAnalysis(tokenList) {\n    var e_1, _a;\n    var mediaQueryList = [\n        []\n    ];\n    for(var i = 0; i < tokenList.length; i++){\n        var token = tokenList[i];\n        if (token.type === \"<comma-token>\") {\n            mediaQueryList.push([]);\n        } else {\n            mediaQueryList[mediaQueryList.length - 1].push(token);\n        }\n    }\n    var mediaQueries = mediaQueryList.map(removeWhitespace);\n    if (mediaQueries.length === 1 && mediaQueries[0].length === 0) {\n        return [\n            {\n                mediaCondition: null,\n                mediaPrefix: null,\n                mediaType: \"all\"\n            }\n        ];\n    } else {\n        var mediaQueryTokens = mediaQueries.map(function(mediaQueryTokens) {\n            if (mediaQueryTokens.length === 0) {\n                return null;\n            } else {\n                return tokenizeMediaQuery(mediaQueryTokens);\n            }\n        });\n        var nonNullMediaQueryTokens = [];\n        try {\n            for(var mediaQueryTokens_1 = __values(mediaQueryTokens), mediaQueryTokens_1_1 = mediaQueryTokens_1.next(); !mediaQueryTokens_1_1.done; mediaQueryTokens_1_1 = mediaQueryTokens_1.next()){\n                var mediaQueryToken = mediaQueryTokens_1_1.value;\n                if (mediaQueryToken !== null) {\n                    nonNullMediaQueryTokens.push(mediaQueryToken);\n                }\n            }\n        } catch (e_1_1) {\n            e_1 = {\n                error: e_1_1\n            };\n        } finally{\n            try {\n                if (mediaQueryTokens_1_1 && !mediaQueryTokens_1_1.done && (_a = mediaQueryTokens_1[\"return\"])) _a.call(mediaQueryTokens_1);\n            } finally{\n                if (e_1) throw e_1.error;\n            }\n        }\n        if (nonNullMediaQueryTokens.length === 0) {\n            throw createError(\"No valid media queries\");\n        }\n        return nonNullMediaQueryTokens;\n    }\n};\nvar tokenizeMediaQuery = function tokenizeMediaQuery(tokens) {\n    var firstToken = tokens[0];\n    if (firstToken.type === \"<(-token>\") {\n        try {\n            return {\n                mediaPrefix: null,\n                mediaType: \"all\",\n                mediaCondition: tokenizeMediaCondition(tokens, true)\n            };\n        } catch (err) {\n            throw createError(\"Expected media condition after '('\", err);\n        }\n    } else if (firstToken.type === \"<ident-token>\") {\n        var mediaPrefix = null;\n        var mediaType = void 0;\n        var value = firstToken.value;\n        if (value === \"only\" || value === \"not\") {\n            mediaPrefix = value;\n        }\n        var firstIndex = mediaPrefix === null ? 0 : 1;\n        if (tokens.length <= firstIndex) {\n            throw createError(\"Expected extra token in media query\");\n        }\n        var firstNonUnaryToken = tokens[firstIndex];\n        if (firstNonUnaryToken.type === \"<ident-token>\") {\n            var value_1 = firstNonUnaryToken.value;\n            if (value_1 === \"all\") {\n                mediaType = \"all\";\n            } else if (value_1 === \"print\" || value_1 === \"screen\") {\n                mediaType = value_1;\n            } else if (value_1 === \"tty\" || value_1 === \"tv\" || value_1 === \"projection\" || value_1 === \"handheld\" || value_1 === \"braille\" || value_1 === \"embossed\" || value_1 === \"aural\" || value_1 === \"speech\") {\n                mediaPrefix = mediaPrefix === \"not\" ? null : \"not\";\n                mediaType = \"all\";\n            } else {\n                throw createError(\"Unknown ident '\".concat(value_1, \"' in media query\"));\n            }\n        } else if (mediaPrefix === \"not\" && firstNonUnaryToken.type === \"<(-token>\") {\n            var tokensWithParens = [\n                {\n                    type: \"<(-token>\",\n                    wsBefore: false,\n                    wsAfter: false\n                }\n            ];\n            tokensWithParens.push.apply(tokensWithParens, tokens);\n            tokensWithParens.push({\n                type: \"<)-token>\",\n                wsBefore: false,\n                wsAfter: false\n            });\n            try {\n                return {\n                    mediaPrefix: null,\n                    mediaType: \"all\",\n                    mediaCondition: tokenizeMediaCondition(tokensWithParens, true)\n                };\n            } catch (err) {\n                throw createError(\"Expected media condition after '('\", err);\n            }\n        } else {\n            throw createError(\"Invalid media query\");\n        }\n        if (firstIndex + 1 === tokens.length) {\n            return {\n                mediaPrefix: mediaPrefix,\n                mediaType: mediaType,\n                mediaCondition: null\n            };\n        } else if (firstIndex + 4 < tokens.length) {\n            var secondNonUnaryToken = tokens[firstIndex + 1];\n            if (secondNonUnaryToken.type === \"<ident-token>\" && secondNonUnaryToken.value === \"and\") {\n                try {\n                    return {\n                        mediaPrefix: mediaPrefix,\n                        mediaType: mediaType,\n                        mediaCondition: tokenizeMediaCondition(tokens.slice(firstIndex + 2), false)\n                    };\n                } catch (err) {\n                    throw createError(\"Expected media condition after 'and'\", err);\n                }\n            } else {\n                throw createError(\"Expected 'and' after media prefix\");\n            }\n        } else {\n            throw createError(\"Expected media condition after media prefix\");\n        }\n    } else {\n        throw createError(\"Expected media condition or media prefix\");\n    }\n};\nvar tokenizeMediaCondition = function tokenizeMediaCondition(tokens, mayContainOr, previousOperator) {\n    if (previousOperator === void 0) {\n        previousOperator = null;\n    }\n    if (tokens.length < 3 || tokens[0].type !== \"<(-token>\" || tokens[tokens.length - 1].type !== \"<)-token>\") {\n        throw new Error(\"Invalid media condition\");\n    }\n    var endIndexOfFirstFeature = tokens.length - 1;\n    var maxDepth = 0;\n    var count = 0;\n    for(var i = 0; i < tokens.length; i++){\n        var token = tokens[i];\n        if (token.type === \"<(-token>\") {\n            count += 1;\n            maxDepth = Math.max(maxDepth, count);\n        } else if (token.type === \"<)-token>\") {\n            count -= 1;\n        }\n        if (count === 0) {\n            endIndexOfFirstFeature = i;\n            break;\n        }\n    }\n    if (count !== 0) {\n        throw new Error(\"Mismatched parens\\nInvalid media condition\");\n    }\n    var child;\n    var featureTokens = tokens.slice(0, endIndexOfFirstFeature + 1);\n    if (maxDepth === 1) {\n        child = tokenizeMediaFeature(featureTokens);\n    } else {\n        if (featureTokens[1].type === \"<ident-token>\" && featureTokens[1].value === \"not\") {\n            child = tokenizeMediaCondition(featureTokens.slice(2, -1), true, \"not\");\n        } else {\n            child = tokenizeMediaCondition(featureTokens.slice(1, -1), true);\n        }\n    }\n    if (endIndexOfFirstFeature === tokens.length - 1) {\n        return {\n            operator: previousOperator,\n            children: [\n                child\n            ]\n        };\n    } else {\n        var nextToken = tokens[endIndexOfFirstFeature + 1];\n        if (nextToken.type !== \"<ident-token>\") {\n            throw new Error(\"Invalid operator\\nInvalid media condition\");\n        } else if (previousOperator !== null && previousOperator !== nextToken.value) {\n            throw new Error(\"'\".concat(nextToken.value, \"' and '\").concat(previousOperator, \"' must not be at same level\\nInvalid media condition\"));\n        } else if (nextToken.value === \"or\" && !mayContainOr) {\n            throw new Error(\"Cannot use 'or' at top level of a media query\\nInvalid media condition\");\n        } else if (nextToken.value !== \"and\" && nextToken.value !== \"or\") {\n            throw new Error(\"Invalid operator: '\".concat(nextToken.value, \"'\\nInvalid media condition\"));\n        }\n        var siblings = tokenizeMediaCondition(tokens.slice(endIndexOfFirstFeature + 2), mayContainOr, nextToken.value);\n        return {\n            operator: nextToken.value,\n            children: [\n                child\n            ].concat(siblings.children)\n        };\n    }\n};\nvar tokenizeMediaFeature = function tokenizeMediaFeature(rawTokens) {\n    if (rawTokens.length < 3 || rawTokens[0].type !== \"<(-token>\" || rawTokens[rawTokens.length - 1].type !== \"<)-token>\") {\n        throw new Error(\"Invalid media feature\");\n    }\n    var tokens = [\n        rawTokens[0]\n    ];\n    for(var i = 1; i < rawTokens.length; i++){\n        if (i < rawTokens.length - 2) {\n            var a = rawTokens[i];\n            var b = rawTokens[i + 1];\n            var c = rawTokens[i + 2];\n            if (a.type === \"<number-token>\" && a.value > 0 && b.type === \"<delim-token>\" && b.value === 0x002f && c.type === \"<number-token>\" && c.value > 0) {\n                tokens.push({\n                    type: \"<ratio-token>\",\n                    numerator: a.value,\n                    denominator: c.value,\n                    wsBefore: a.wsBefore,\n                    wsAfter: c.wsAfter\n                });\n                i += 2;\n                continue;\n            }\n        }\n        tokens.push(rawTokens[i]);\n    }\n    var nextToken = tokens[1];\n    if (nextToken.type === \"<ident-token>\" && tokens.length === 3) {\n        return {\n            context: \"boolean\",\n            feature: nextToken.value\n        };\n    } else if (tokens.length === 5 && tokens[1].type === \"<ident-token>\" && tokens[2].type === \"<colon-token>\") {\n        var valueToken = tokens[3];\n        if (valueToken.type === \"<number-token>\" || valueToken.type === \"<dimension-token>\" || valueToken.type === \"<ratio-token>\" || valueToken.type === \"<ident-token>\") {\n            var feature = tokens[1].value;\n            var prefix = null;\n            var slice = feature.slice(0, 4);\n            if (slice === \"min-\") {\n                prefix = \"min\";\n                feature = feature.slice(4);\n            } else if (slice === \"max-\") {\n                prefix = \"max\";\n                feature = feature.slice(4);\n            }\n            valueToken.wsBefore;\n            valueToken.wsAfter;\n            var value = __rest(valueToken, [\n                \"wsBefore\",\n                \"wsAfter\"\n            ]);\n            return {\n                context: \"value\",\n                prefix: prefix,\n                feature: feature,\n                value: value\n            };\n        }\n    } else if (tokens.length >= 5) {\n        try {\n            var range = tokenizeRange(tokens);\n            return {\n                context: \"range\",\n                feature: range.featureName,\n                range: range\n            };\n        } catch (err) {\n            throw createError(\"Invalid media feature\", err);\n        }\n    }\n    throw new Error(\"Invalid media feature\");\n};\nvar tokenizeRange = function tokenizeRange(tokens) {\n    var _a, _b, _c, _d;\n    if (tokens.length < 5 || tokens[0].type !== \"<(-token>\" || tokens[tokens.length - 1].type !== \"<)-token>\") {\n        throw new Error(\"Invalid range\");\n    }\n    var range = {\n        leftToken: null,\n        leftOp: null,\n        featureName: \"\",\n        rightOp: null,\n        rightToken: null\n    };\n    var hasLeft = tokens[1].type === \"<number-token>\" || tokens[1].type === \"<dimension-token>\" || tokens[1].type === \"<ratio-token>\" || tokens[1].type === \"<ident-token>\" && tokens[1].value === \"infinite\";\n    if (tokens[2].type === \"<delim-token>\") {\n        if (tokens[2].value === 0x003c) {\n            if (tokens[3].type === \"<delim-token>\" && tokens[3].value === 0x003d && !tokens[3].wsBefore) {\n                range[hasLeft ? \"leftOp\" : \"rightOp\"] = \"<=\";\n            } else {\n                range[hasLeft ? \"leftOp\" : \"rightOp\"] = \"<\";\n            }\n        } else if (tokens[2].value === 0x003e) {\n            if (tokens[3].type === \"<delim-token>\" && tokens[3].value === 0x003d && !tokens[3].wsBefore) {\n                range[hasLeft ? \"leftOp\" : \"rightOp\"] = \">=\";\n            } else {\n                range[hasLeft ? \"leftOp\" : \"rightOp\"] = \">\";\n            }\n        } else if (tokens[2].value === 0x003d) {\n            range[hasLeft ? \"leftOp\" : \"rightOp\"] = \"=\";\n        } else {\n            throw new Error(\"Invalid range\");\n        }\n        if (hasLeft) {\n            range.leftToken = tokens[1];\n        } else if (tokens[1].type === \"<ident-token>\") {\n            range.featureName = tokens[1].value;\n        } else {\n            throw new Error(\"Invalid range\");\n        }\n        var tokenIndexAfterFirstOp = 2 + ((_b = (_a = range[hasLeft ? \"leftOp\" : \"rightOp\"]) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);\n        var tokenAfterFirstOp = tokens[tokenIndexAfterFirstOp];\n        if (hasLeft) {\n            if (tokenAfterFirstOp.type === \"<ident-token>\") {\n                range.featureName = tokenAfterFirstOp.value;\n                if (tokens.length >= 7) {\n                    var secondOpToken = tokens[tokenIndexAfterFirstOp + 1];\n                    var followingToken = tokens[tokenIndexAfterFirstOp + 2];\n                    if (secondOpToken.type === \"<delim-token>\") {\n                        var charCode = secondOpToken.value;\n                        if (charCode === 0x003c) {\n                            if (followingToken.type === \"<delim-token>\" && followingToken.value === 0x003d && !followingToken.wsBefore) {\n                                range.rightOp = \"<=\";\n                            } else {\n                                range.rightOp = \"<\";\n                            }\n                        } else if (charCode === 0x003e) {\n                            if (followingToken.type === \"<delim-token>\" && followingToken.value === 0x003d && !followingToken.wsBefore) {\n                                range.rightOp = \">=\";\n                            } else {\n                                range.rightOp = \">\";\n                            }\n                        } else {\n                            throw new Error(\"Invalid range\");\n                        }\n                        var tokenAfterSecondOp = tokens[tokenIndexAfterFirstOp + 1 + ((_d = (_c = range.rightOp) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0)];\n                        range.rightToken = tokenAfterSecondOp;\n                    } else {\n                        throw new Error(\"Invalid range\");\n                    }\n                } else if (tokenIndexAfterFirstOp + 2 !== tokens.length) {\n                    throw new Error(\"Invalid range\");\n                }\n            } else {\n                throw new Error(\"Invalid range\");\n            }\n        } else {\n            range.rightToken = tokenAfterFirstOp;\n        }\n        var validRange = null;\n        var lt = range.leftToken, leftOp = range.leftOp, featureName = range.featureName, rightOp = range.rightOp, rt = range.rightToken;\n        var leftToken = null;\n        if (lt !== null) {\n            if (lt.type === \"<ident-token>\") {\n                var type = lt.type, value = lt.value;\n                if (value === \"infinite\") {\n                    leftToken = {\n                        type: type,\n                        value: value\n                    };\n                }\n            } else if (lt.type === \"<number-token>\" || lt.type === \"<dimension-token>\" || lt.type === \"<ratio-token>\") {\n                lt.wsBefore;\n                lt.wsAfter;\n                var ltNoWS = __rest(lt, [\n                    \"wsBefore\",\n                    \"wsAfter\"\n                ]);\n                leftToken = ltNoWS;\n            }\n        }\n        var rightToken = null;\n        if (rt !== null) {\n            if (rt.type === \"<ident-token>\") {\n                var type = rt.type, value = rt.value;\n                if (value === \"infinite\") {\n                    rightToken = {\n                        type: type,\n                        value: value\n                    };\n                }\n            } else if (rt.type === \"<number-token>\" || rt.type === \"<dimension-token>\" || rt.type === \"<ratio-token>\") {\n                rt.wsBefore;\n                rt.wsAfter;\n                var rtNoWS = __rest(rt, [\n                    \"wsBefore\",\n                    \"wsAfter\"\n                ]);\n                rightToken = rtNoWS;\n            }\n        }\n        if (leftToken !== null && rightToken !== null) {\n            if ((leftOp === \"<\" || leftOp === \"<=\") && (rightOp === \"<\" || rightOp === \"<=\")) {\n                validRange = {\n                    leftToken: leftToken,\n                    leftOp: leftOp,\n                    featureName: featureName,\n                    rightOp: rightOp,\n                    rightToken: rightToken\n                };\n            } else if ((leftOp === \">\" || leftOp === \">=\") && (rightOp === \">\" || rightOp === \">=\")) {\n                validRange = {\n                    leftToken: leftToken,\n                    leftOp: leftOp,\n                    featureName: featureName,\n                    rightOp: rightOp,\n                    rightToken: rightToken\n                };\n            } else {\n                throw new Error(\"Invalid range\");\n            }\n        } else if (leftToken === null && leftOp === null && rightOp !== null && rightToken !== null) {\n            validRange = {\n                leftToken: leftToken,\n                leftOp: leftOp,\n                featureName: featureName,\n                rightOp: rightOp,\n                rightToken: rightToken\n            };\n        } else if (leftToken !== null && leftOp !== null && rightOp === null && rightToken === null) {\n            validRange = {\n                leftToken: leftToken,\n                leftOp: leftOp,\n                featureName: featureName,\n                rightOp: rightOp,\n                rightToken: rightToken\n            };\n        }\n        return validRange;\n    } else {\n        throw new Error(\"Invalid range\");\n    }\n};\n //# sourceMappingURL=media-query-parser.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vbWVkaWEtcXVlcnktcGFyc2VyQDIuMC4yL25vZGVfbW9kdWxlcy9tZWRpYS1xdWVyeS1wYXJzZXIvZGlzdC9tZWRpYS1xdWVyeS1wYXJzZXIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGdGQUFnRixHQUVoRjs7Ozs7Ozs7Ozs7Ozs4RUFhOEUsR0FFOUUsSUFBSUEsV0FBVztJQUNYQSxXQUFXQyxPQUFPQyxNQUFNLElBQUksU0FBU0YsU0FBU0csQ0FBQztRQUMzQyxJQUFLLElBQUlDLEdBQUdDLElBQUksR0FBR0MsSUFBSUMsVUFBVUMsTUFBTSxFQUFFSCxJQUFJQyxHQUFHRCxJQUFLO1lBQ2pERCxJQUFJRyxTQUFTLENBQUNGLEVBQUU7WUFDaEIsSUFBSyxJQUFJSSxLQUFLTCxFQUFHLElBQUlILE9BQU9TLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNSLEdBQUdLLElBQUlOLENBQUMsQ0FBQ00sRUFBRSxHQUFHTCxDQUFDLENBQUNLLEVBQUU7UUFDaEY7UUFDQSxPQUFPTjtJQUNYO0lBQ0EsT0FBT0gsU0FBU2EsS0FBSyxDQUFDLElBQUksRUFBRU47QUFDaEM7QUFFQSxTQUFTTyxPQUFPVixDQUFDLEVBQUVXLENBQUM7SUFDaEIsSUFBSVosSUFBSSxDQUFDO0lBQ1QsSUFBSyxJQUFJTSxLQUFLTCxFQUFHLElBQUlILE9BQU9TLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDQyxJQUFJLENBQUNSLEdBQUdLLE1BQU1NLEVBQUVDLE9BQU8sQ0FBQ1AsS0FBSyxHQUM5RU4sQ0FBQyxDQUFDTSxFQUFFLEdBQUdMLENBQUMsQ0FBQ0ssRUFBRTtJQUNmLElBQUlMLEtBQUssUUFBUSxPQUFPSCxPQUFPZ0IscUJBQXFCLEtBQUssWUFDckQsSUFBSyxJQUFJWixJQUFJLEdBQUdJLElBQUlSLE9BQU9nQixxQkFBcUIsQ0FBQ2IsSUFBSUMsSUFBSUksRUFBRUQsTUFBTSxFQUFFSCxJQUFL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QTtnQkFDWEMsUUFBUUE7Z0JBQ1JGLGFBQWFBO2dCQUNiRyxTQUFTQTtnQkFDVEMsWUFBWUE7WUFDZDtRQUNGLE9BQU8sSUFBSUgsY0FBYyxRQUFRQyxXQUFXLFFBQVFDLFlBQVksUUFBUUMsZUFBZSxNQUFNO1lBQzNGTyxhQUFhO2dCQUNYVixXQUFXQTtnQkFDWEMsUUFBUUE7Z0JBQ1JGLGFBQWFBO2dCQUNiRyxTQUFTQTtnQkFDVEMsWUFBWUE7WUFDZDtRQUNGO1FBRUEsT0FBT087SUFDVCxPQUFPO1FBQ0wsTUFBTSxJQUFJakUsTUFBTTtJQUNsQjtBQUNGO0FBRTZULENBQzdULGtEQUFrRCIsInNvdXJjZXMiOlsid2VicGFjazovL25vdGFzY2FtLXByb3RvY29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL21lZGlhLXF1ZXJ5LXBhcnNlckAyLjAuMi9ub2RlX21vZHVsZXMvbWVkaWEtcXVlcnktcGFyc2VyL2Rpc3QvbWVkaWEtcXVlcnktcGFyc2VyLmVzbS5qcz8zZGE2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBAbGljZW5zZSBNZWRpYVF1ZXJ5UGFyc2VyIC0gTUlUIExpY2Vuc2UgLSBUb20gR29sZGVuIChnaXRodWJAdGJqZ29sZGVuLmNvbSkgKi9cblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbnZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XG5cbnZhciB3ZWlyZE5ld2xpbmVzID0gLyhcXHUwMDBEfFxcdTAwMEN8XFx1MDAwRFxcdTAwMEEpL2c7XG52YXIgbnVsbE9yU3Vycm9nYXRlcyA9IC9bXFx1MDAwMFxcdUQ4MDAtXFx1REZGRl0vZztcbnZhciBjb21tZW50UmVnZXggPSAvKFxcL1xcKilbXFxzXFxTXSo/KFxcKlxcLykvZztcbnZhciBsZXhpY2FsQW5hbHlzaXMgPSBmdW5jdGlvbiBsZXhpY2FsQW5hbHlzaXMoc3RyLCBpbmRleCkge1xuICBpZiAoaW5kZXggPT09IHZvaWQgMCkge1xuICAgIGluZGV4ID0gMDtcbiAgfVxuXG4gIHN0ciA9IHN0ci5yZXBsYWNlKHdlaXJkTmV3bGluZXMsICdcXG4nKS5yZXBsYWNlKG51bGxPclN1cnJvZ2F0ZXMsIFwiXFx1RkZGRFwiKTtcbiAgc3RyID0gc3RyLnJlcGxhY2UoY29tbWVudFJlZ2V4LCAnJyk7XG4gIHZhciB0b2tlbnMgPSBbXTtcblxuICBmb3IgKDsgaW5kZXggPCBzdHIubGVuZ3RoOyBpbmRleCArPSAxKSB7XG4gICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7XG5cbiAgICBpZiAoY29kZSA9PT0gMHgwMDA5IHx8IGNvZGUgPT09IDB4MDAyMCB8fCBjb2RlID09PSAweDAwMGEpIHtcbiAgICAgIHZhciBjb2RlXzEgPSBzdHIuY2hhckNvZGVBdCgrK2luZGV4KTtcblxuICAgICAgd2hpbGUgKGNvZGVfMSA9PT0gMHgwMDA5IHx8IGNvZGVfMSA9PT0gMHgwMDIwIHx8IGNvZGVfMSA9PT0gMHgwMDBhKSB7XG4gICAgICAgIGNvZGVfMSA9IHN0ci5jaGFyQ29kZUF0KCsraW5kZXgpO1xuICAgICAgfVxuXG4gICAgICBpbmRleCAtPSAxO1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPHdoaXRlc3BhY2UtdG9rZW4+J1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwMjIpIHtcbiAgICAgIHZhciByZXN1bHQgPSBjb25zdW1lU3RyaW5nKHN0ciwgaW5kZXgpO1xuXG4gICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2EgPSBfX3JlYWQocmVzdWx0LCAyKSxcbiAgICAgICAgICBsYXN0SW5kZXggPSBfYVswXSxcbiAgICAgICAgICB2YWx1ZSA9IF9hWzFdO1xuXG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICc8c3RyaW5nLXRva2VuPicsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgICBpbmRleCA9IGxhc3RJbmRleDtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDAyMykge1xuICAgICAgaWYgKGluZGV4ICsgMSA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5leHRDb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcblxuICAgICAgICBpZiAobmV4dENvZGUgPT09IDB4MDA1ZiB8fCBuZXh0Q29kZSA+PSAweDAwNDEgJiYgbmV4dENvZGUgPD0gMHgwMDVhIHx8IG5leHRDb2RlID49IDB4MDA2MSAmJiBuZXh0Q29kZSA8PSAweDAwN2EgfHwgbmV4dENvZGUgPj0gMHgwMDgwIHx8IG5leHRDb2RlID49IDB4MDAzMCAmJiBuZXh0Q29kZSA8PSAweDAwMzkgfHwgbmV4dENvZGUgPT09IDB4MDA1YyAmJiBpbmRleCArIDIgPCBzdHIubGVuZ3RoICYmIHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMikgIT09IDB4MDAwYSkge1xuICAgICAgICAgIHZhciBmbGFnID0gd291bGRTdGFydElkZW50aWZpZXIoc3RyLCBpbmRleCArIDEpID8gJ2lkJyA6ICd1bnJlc3RyaWN0ZWQnO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBjb25zdW1lSWRlbnRVbnNhZmUoc3RyLCBpbmRleCArIDEpO1xuXG4gICAgICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIF9iID0gX19yZWFkKHJlc3VsdCwgMiksXG4gICAgICAgICAgICAgICAgbGFzdEluZGV4ID0gX2JbMF0sXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBfYlsxXTtcblxuICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICB0eXBlOiAnPGhhc2gtdG9rZW4+JyxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICAgIGZsYWc6IGZsYWdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPGRlbGltLXRva2VuPicsXG4gICAgICAgIHZhbHVlOiBjb2RlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDAyNykge1xuICAgICAgdmFyIHJlc3VsdCA9IGNvbnN1bWVTdHJpbmcoc3RyLCBpbmRleCk7XG5cbiAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBfYyA9IF9fcmVhZChyZXN1bHQsIDIpLFxuICAgICAgICAgIGxhc3RJbmRleCA9IF9jWzBdLFxuICAgICAgICAgIHZhbHVlID0gX2NbMV07XG5cbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJzxzdHJpbmctdG9rZW4+JyxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9KTtcbiAgICAgIGluZGV4ID0gbGFzdEluZGV4O1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDI4KSB7XG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICc8KC10b2tlbj4nXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDAyOSkge1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPCktdG9rZW4+J1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwMmIpIHtcbiAgICAgIHZhciBwbHVzTnVtZXJpYyA9IGNvbnN1bWVOdW1lcmljKHN0ciwgaW5kZXgpO1xuXG4gICAgICBpZiAocGx1c051bWVyaWMgPT09IG51bGwpIHtcbiAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6ICc8ZGVsaW0tdG9rZW4+JyxcbiAgICAgICAgICB2YWx1ZTogY29kZVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfZCA9IF9fcmVhZChwbHVzTnVtZXJpYywgMiksXG4gICAgICAgICAgICBsYXN0SW5kZXggPSBfZFswXSxcbiAgICAgICAgICAgIHRva2VuVHVwbGUgPSBfZFsxXTtcblxuICAgICAgICBpZiAodG9rZW5UdXBsZVswXSA9PT0gJzxkaW1lbnNpb24tdG9rZW4+Jykge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6ICc8ZGltZW5zaW9uLXRva2VuPicsXG4gICAgICAgICAgICB2YWx1ZTogdG9rZW5UdXBsZVsxXSxcbiAgICAgICAgICAgIHVuaXQ6IHRva2VuVHVwbGVbMl0udG9Mb3dlckNhc2UoKSxcbiAgICAgICAgICAgIGZsYWc6ICdudW1iZXInXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodG9rZW5UdXBsZVswXSA9PT0gJzxudW1iZXItdG9rZW4+Jykge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IHRva2VuVHVwbGVbMF0sXG4gICAgICAgICAgICB2YWx1ZTogdG9rZW5UdXBsZVsxXSxcbiAgICAgICAgICAgIGZsYWc6IHRva2VuVHVwbGVbMl1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiB0b2tlblR1cGxlWzBdLFxuICAgICAgICAgICAgdmFsdWU6IHRva2VuVHVwbGVbMV0sXG4gICAgICAgICAgICBmbGFnOiAnbnVtYmVyJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwMmMpIHtcbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJzxjb21tYS10b2tlbj4nXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDAyZCkge1xuICAgICAgdmFyIG1pbnVzTnVtZXJpYyA9IGNvbnN1bWVOdW1lcmljKHN0ciwgaW5kZXgpO1xuXG4gICAgICBpZiAobWludXNOdW1lcmljICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBfZSA9IF9fcmVhZChtaW51c051bWVyaWMsIDIpLFxuICAgICAgICAgICAgbGFzdEluZGV4ID0gX2VbMF0sXG4gICAgICAgICAgICB0b2tlblR1cGxlID0gX2VbMV07XG5cbiAgICAgICAgaWYgKHRva2VuVHVwbGVbMF0gPT09ICc8ZGltZW5zaW9uLXRva2VuPicpIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnPGRpbWVuc2lvbi10b2tlbj4nLFxuICAgICAgICAgICAgdmFsdWU6IHRva2VuVHVwbGVbMV0sXG4gICAgICAgICAgICB1bml0OiB0b2tlblR1cGxlWzJdLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICBmbGFnOiAnbnVtYmVyJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRva2VuVHVwbGVbMF0gPT09ICc8bnVtYmVyLXRva2VuPicpIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiB0b2tlblR1cGxlWzBdLFxuICAgICAgICAgICAgdmFsdWU6IHRva2VuVHVwbGVbMV0sXG4gICAgICAgICAgICBmbGFnOiB0b2tlblR1cGxlWzJdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogdG9rZW5UdXBsZVswXSxcbiAgICAgICAgICAgIHZhbHVlOiB0b2tlblR1cGxlWzFdLFxuICAgICAgICAgICAgZmxhZzogJ251bWJlcidcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluZGV4ICsgMiA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5leHRDb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcbiAgICAgICAgdmFyIG5leHROZXh0Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMik7XG5cbiAgICAgICAgaWYgKG5leHRDb2RlID09PSAweDAwMmQgJiYgbmV4dE5leHRDb2RlID09PSAweDAwM2UpIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnPENEQy10b2tlbj4nXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcmVzdWx0ID0gY29uc3VtZUlkZW50TGlrZShzdHIsIGluZGV4KTtcblxuICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX2YgPSBfX3JlYWQocmVzdWx0LCAzKSxcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IF9mWzBdLFxuICAgICAgICAgICAgdmFsdWUgPSBfZlsxXSxcbiAgICAgICAgICAgIHR5cGUgPSBfZlsyXTtcblxuICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPGRlbGltLXRva2VuPicsXG4gICAgICAgIHZhbHVlOiBjb2RlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDAyZSkge1xuICAgICAgdmFyIG1pbnVzTnVtZXJpYyA9IGNvbnN1bWVOdW1lcmljKHN0ciwgaW5kZXgpO1xuXG4gICAgICBpZiAobWludXNOdW1lcmljID09PSBudWxsKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnPGRlbGltLXRva2VuPicsXG4gICAgICAgICAgdmFsdWU6IGNvZGVcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX2cgPSBfX3JlYWQobWludXNOdW1lcmljLCAyKSxcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IF9nWzBdLFxuICAgICAgICAgICAgdG9rZW5UdXBsZSA9IF9nWzFdO1xuXG4gICAgICAgIGlmICh0b2tlblR1cGxlWzBdID09PSAnPGRpbWVuc2lvbi10b2tlbj4nKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJzxkaW1lbnNpb24tdG9rZW4+JyxcbiAgICAgICAgICAgIHZhbHVlOiB0b2tlblR1cGxlWzFdLFxuICAgICAgICAgICAgdW5pdDogdG9rZW5UdXBsZVsyXS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgZmxhZzogJ251bWJlcidcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0b2tlblR1cGxlWzBdID09PSAnPG51bWJlci10b2tlbj4nKSB7XG4gICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogdG9rZW5UdXBsZVswXSxcbiAgICAgICAgICAgIHZhbHVlOiB0b2tlblR1cGxlWzFdLFxuICAgICAgICAgICAgZmxhZzogdG9rZW5UdXBsZVsyXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IHRva2VuVHVwbGVbMF0sXG4gICAgICAgICAgICB2YWx1ZTogdG9rZW5UdXBsZVsxXSxcbiAgICAgICAgICAgIGZsYWc6ICdudW1iZXInXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwM2EpIHtcbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJzxjb2xvbi10b2tlbj4nXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDAzYikge1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPHNlbWljb2xvbi10b2tlbj4nXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDAzYykge1xuICAgICAgaWYgKGluZGV4ICsgMyA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5leHRDb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcbiAgICAgICAgdmFyIG5leHROZXh0Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMik7XG4gICAgICAgIHZhciBuZXh0TmV4dE5leHRDb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXggKyAzKTtcblxuICAgICAgICBpZiAobmV4dENvZGUgPT09IDB4MDAyMSAmJiBuZXh0TmV4dENvZGUgPT09IDB4MDAyZCAmJiBuZXh0TmV4dE5leHRDb2RlID09PSAweDAwMmQpIHtcbiAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnPENETy10b2tlbj4nXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaW5kZXggKz0gMztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICc8ZGVsaW0tdG9rZW4+JyxcbiAgICAgICAgdmFsdWU6IGNvZGVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDQwKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gY29uc3VtZUlkZW50KHN0ciwgaW5kZXggKyAxKTtcblxuICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX2ggPSBfX3JlYWQocmVzdWx0LCAyKSxcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IF9oWzBdLFxuICAgICAgICAgICAgdmFsdWUgPSBfaFsxXTtcblxuICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogJzxhdC1rZXl3b3JkLXRva2VuPicsXG4gICAgICAgICAgdmFsdWU6IHZhbHVlLnRvTG93ZXJDYXNlKClcbiAgICAgICAgfSk7XG4gICAgICAgIGluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPGRlbGltLXRva2VuPicsXG4gICAgICAgIHZhbHVlOiBjb2RlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDA1Yikge1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPFstdG9rZW4+J1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwNWMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBjb25zdW1lRXNjYXBlKHN0ciwgaW5kZXgpO1xuXG4gICAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2ogPSBfX3JlYWQocmVzdWx0LCAyKSxcbiAgICAgICAgICBsYXN0SW5kZXggPSBfalswXSxcbiAgICAgICAgICB2YWx1ZSA9IF9qWzFdO1xuXG4gICAgICBzdHIgPSBzdHIuc2xpY2UoMCwgaW5kZXgpICsgdmFsdWUgKyBzdHIuc2xpY2UobGFzdEluZGV4ICsgMSk7XG4gICAgICBpbmRleCAtPSAxO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDVkKSB7XG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6ICc8XS10b2tlbj4nXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDA3Yikge1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPHstdG9rZW4+J1xuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwN2QpIHtcbiAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJzx9LXRva2VuPidcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY29kZSA+PSAweDAwMzAgJiYgY29kZSA8PSAweDAwMzkpIHtcbiAgICAgIHZhciByZXN1bHQgPSBjb25zdW1lTnVtZXJpYyhzdHIsIGluZGV4KTtcblxuICAgICAgdmFyIF9rID0gX19yZWFkKHJlc3VsdCwgMiksXG4gICAgICAgICAgbGFzdEluZGV4ID0gX2tbMF0sXG4gICAgICAgICAgdG9rZW5UdXBsZSA9IF9rWzFdO1xuXG4gICAgICBpZiAodG9rZW5UdXBsZVswXSA9PT0gJzxkaW1lbnNpb24tdG9rZW4+Jykge1xuICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgdHlwZTogJzxkaW1lbnNpb24tdG9rZW4+JyxcbiAgICAgICAgICB2YWx1ZTogdG9rZW5UdXBsZVsxXSxcbiAgICAgICAgICB1bml0OiB0b2tlblR1cGxlWzJdLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgZmxhZzogJ251bWJlcidcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHRva2VuVHVwbGVbMF0gPT09ICc8bnVtYmVyLXRva2VuPicpIHtcbiAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgIHR5cGU6IHRva2VuVHVwbGVbMF0sXG4gICAgICAgICAgdmFsdWU6IHRva2VuVHVwbGVbMV0sXG4gICAgICAgICAgZmxhZzogdG9rZW5UdXBsZVsyXVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiB0b2tlblR1cGxlWzBdLFxuICAgICAgICAgIHZhbHVlOiB0b2tlblR1cGxlWzFdLFxuICAgICAgICAgIGZsYWc6ICdudW1iZXInXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpbmRleCA9IGxhc3RJbmRleDtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDA1ZiB8fCBjb2RlID49IDB4MDA0MSAmJiBjb2RlIDw9IDB4MDA1YSB8fCBjb2RlID49IDB4MDA2MSAmJiBjb2RlIDw9IDB4MDA3YSB8fCBjb2RlID49IDB4MDA4MCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGNvbnN1bWVJZGVudExpa2Uoc3RyLCBpbmRleCk7XG5cbiAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBfbCA9IF9fcmVhZChyZXN1bHQsIDMpLFxuICAgICAgICAgIGxhc3RJbmRleCA9IF9sWzBdLFxuICAgICAgICAgIHZhbHVlID0gX2xbMV0sXG4gICAgICAgICAgdHlwZSA9IF9sWzJdO1xuXG4gICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgfSk7XG4gICAgICBpbmRleCA9IGxhc3RJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICB0eXBlOiAnPGRlbGltLXRva2VuPicsXG4gICAgICAgIHZhbHVlOiBjb2RlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICB0b2tlbnMucHVzaCh7XG4gICAgdHlwZTogJzxFT0YtdG9rZW4+J1xuICB9KTtcbiAgcmV0dXJuIHRva2Vucztcbn07XG52YXIgY29uc3VtZVN0cmluZyA9IGZ1bmN0aW9uIGNvbnN1bWVTdHJpbmcoc3RyLCBpbmRleCkge1xuICBpZiAoc3RyLmxlbmd0aCA8PSBpbmRleCArIDEpIHJldHVybiBudWxsO1xuICB2YXIgZmlyc3RDb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXgpO1xuICB2YXIgY2hhckNvZGVzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IGluZGV4ICsgMTsgaSA8IHN0ci5sZW5ndGg7IGkgKz0gMSkge1xuICAgIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoY29kZSA9PT0gZmlyc3RDb2RlKSB7XG4gICAgICByZXR1cm4gW2ksIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgY2hhckNvZGVzKV07XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwNWMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBjb25zdW1lRXNjYXBlKHN0ciwgaSk7XG4gICAgICBpZiAocmVzdWx0ID09PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICAgICAgdmFyIF9hID0gX19yZWFkKHJlc3VsdCwgMiksXG4gICAgICAgICAgbGFzdEluZGV4ID0gX2FbMF0sXG4gICAgICAgICAgY2hhckNvZGUgPSBfYVsxXTtcblxuICAgICAgY2hhckNvZGVzLnB1c2goY2hhckNvZGUpO1xuICAgICAgaSA9IGxhc3RJbmRleDtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MDAwYSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoYXJDb2Rlcy5wdXNoKGNvZGUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcbnZhciB3b3VsZFN0YXJ0SWRlbnRpZmllciA9IGZ1bmN0aW9uIHdvdWxkU3RhcnRJZGVudGlmaWVyKHN0ciwgaW5kZXgpIHtcbiAgaWYgKHN0ci5sZW5ndGggPD0gaW5kZXgpIHJldHVybiBmYWxzZTtcbiAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7XG5cbiAgaWYgKGNvZGUgPT09IDB4MDAyZCkge1xuICAgIGlmIChzdHIubGVuZ3RoIDw9IGluZGV4ICsgMSkgcmV0dXJuIGZhbHNlO1xuICAgIHZhciBuZXh0Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMSk7XG5cbiAgICBpZiAobmV4dENvZGUgPT09IDB4MDAyZCB8fCBuZXh0Q29kZSA9PT0gMHgwMDVmIHx8IG5leHRDb2RlID49IDB4MDA0MSAmJiBuZXh0Q29kZSA8PSAweDAwNWEgfHwgbmV4dENvZGUgPj0gMHgwMDYxICYmIG5leHRDb2RlIDw9IDB4MDA3YSB8fCBuZXh0Q29kZSA+PSAweDAwODApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAobmV4dENvZGUgPT09IDB4MDA1Yykge1xuICAgICAgaWYgKHN0ci5sZW5ndGggPD0gaW5kZXggKyAyKSByZXR1cm4gZmFsc2U7XG4gICAgICB2YXIgbmV4dE5leHRDb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXggKyAyKTtcbiAgICAgIHJldHVybiBuZXh0TmV4dENvZGUgIT09IDB4MDAwYTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwNWYgfHwgY29kZSA+PSAweDAwNDEgJiYgY29kZSA8PSAweDAwNWEgfHwgY29kZSA+PSAweDAwNjEgJiYgY29kZSA8PSAweDAwN2EgfHwgY29kZSA+PSAweDAwODApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwNWMpIHtcbiAgICBpZiAoc3RyLmxlbmd0aCA8PSBpbmRleCArIDEpIHJldHVybiBmYWxzZTtcbiAgICB2YXIgbmV4dENvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCArIDEpO1xuICAgIHJldHVybiBuZXh0Q29kZSAhPT0gMHgwMDBhO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbnZhciBjb25zdW1lRXNjYXBlID0gZnVuY3Rpb24gY29uc3VtZUVzY2FwZShzdHIsIGluZGV4KSB7XG4gIGlmIChzdHIubGVuZ3RoIDw9IGluZGV4ICsgMSkgcmV0dXJuIG51bGw7XG4gIGlmIChzdHIuY2hhckNvZGVBdChpbmRleCkgIT09IDB4MDA1YykgcmV0dXJuIG51bGw7XG4gIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcblxuICBpZiAoY29kZSA9PT0gMHgwMDBhKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAoY29kZSA+PSAweDAwMzAgJiYgY29kZSA8PSAweDAwMzkgfHwgY29kZSA+PSAweDAwNDEgJiYgY29kZSA8PSAweDAwNDYgfHwgY29kZSA+PSAweDAwNjEgJiYgY29kZSA8PSAweDAwNjYpIHtcbiAgICB2YXIgaGV4Q2hhckNvZGVzID0gW2NvZGVdO1xuICAgIHZhciBtaW4gPSBNYXRoLm1pbihpbmRleCArIDcsIHN0ci5sZW5ndGgpO1xuICAgIHZhciBpID0gaW5kZXggKyAyO1xuXG4gICAgZm9yICg7IGkgPCBtaW47IGkgKz0gMSkge1xuICAgICAgdmFyIGNvZGVfMiA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICBpZiAoY29kZV8yID49IDB4MDAzMCAmJiBjb2RlXzIgPD0gMHgwMDM5IHx8IGNvZGVfMiA+PSAweDAwNDEgJiYgY29kZV8yIDw9IDB4MDA0NiB8fCBjb2RlXzIgPj0gMHgwMDYxICYmIGNvZGVfMiA8PSAweDAwNjYpIHtcbiAgICAgICAgaGV4Q2hhckNvZGVzLnB1c2goY29kZV8yKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpIDwgc3RyLmxlbmd0aCkge1xuICAgICAgdmFyIGNvZGVfMyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgICBpZiAoY29kZV8zID09PSAweDAwMDkgfHwgY29kZV8zID09PSAweDAwMjAgfHwgY29kZV8zID09PSAweDAwMGEpIHtcbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbaSAtIDEsIHBhcnNlSW50KFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgaGV4Q2hhckNvZGVzKSwgMTYpXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW2luZGV4ICsgMSwgY29kZV07XG4gIH1cbn07XG52YXIgY29uc3VtZU51bWVyaWMgPSBmdW5jdGlvbiBjb25zdW1lTnVtZXJpYyhzdHIsIGluZGV4KSB7XG4gIHZhciBudW1iZXJSZXN1bHQgPSBjb25zdW1lTnVtYmVyKHN0ciwgaW5kZXgpO1xuICBpZiAobnVtYmVyUmVzdWx0ID09PSBudWxsKSByZXR1cm4gbnVsbDtcblxuICB2YXIgX2EgPSBfX3JlYWQobnVtYmVyUmVzdWx0LCAzKSxcbiAgICAgIG51bWJlckVuZEluZGV4ID0gX2FbMF0sXG4gICAgICBudW1iZXJWYWx1ZSA9IF9hWzFdLFxuICAgICAgbnVtYmVyRmxhZyA9IF9hWzJdO1xuXG4gIHZhciBpZGVudFJlc3VsdCA9IGNvbnN1bWVJZGVudChzdHIsIG51bWJlckVuZEluZGV4ICsgMSk7XG5cbiAgaWYgKGlkZW50UmVzdWx0ICE9PSBudWxsKSB7XG4gICAgdmFyIF9iID0gX19yZWFkKGlkZW50UmVzdWx0LCAyKSxcbiAgICAgICAgaWRlbnRFbmRJbmRleCA9IF9iWzBdLFxuICAgICAgICBpZGVudFZhbHVlID0gX2JbMV07XG5cbiAgICByZXR1cm4gW2lkZW50RW5kSW5kZXgsIFsnPGRpbWVuc2lvbi10b2tlbj4nLCBudW1iZXJWYWx1ZSwgaWRlbnRWYWx1ZV1dO1xuICB9XG5cbiAgaWYgKG51bWJlckVuZEluZGV4ICsgMSA8IHN0ci5sZW5ndGggJiYgc3RyLmNoYXJDb2RlQXQobnVtYmVyRW5kSW5kZXggKyAxKSA9PT0gMHgwMDI1KSB7XG4gICAgcmV0dXJuIFtudW1iZXJFbmRJbmRleCArIDEsIFsnPHBlcmNlbnRhZ2UtdG9rZW4+JywgbnVtYmVyVmFsdWVdXTtcbiAgfVxuXG4gIHJldHVybiBbbnVtYmVyRW5kSW5kZXgsIFsnPG51bWJlci10b2tlbj4nLCBudW1iZXJWYWx1ZSwgbnVtYmVyRmxhZ11dO1xufTtcbnZhciBjb25zdW1lTnVtYmVyID0gZnVuY3Rpb24gY29uc3VtZU51bWJlcihzdHIsIGluZGV4KSB7XG4gIGlmIChzdHIubGVuZ3RoIDw9IGluZGV4KSByZXR1cm4gbnVsbDtcbiAgdmFyIGZsYWcgPSAnaW50ZWdlcic7XG4gIHZhciBudW1iZXJDaGFycyA9IFtdO1xuICB2YXIgZmlyc3RDb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXgpO1xuXG4gIGlmIChmaXJzdENvZGUgPT09IDB4MDAyYiB8fCBmaXJzdENvZGUgPT09IDB4MDAyZCkge1xuICAgIGluZGV4ICs9IDE7XG4gICAgaWYgKGZpcnN0Q29kZSA9PT0gMHgwMDJkKSBudW1iZXJDaGFycy5wdXNoKDB4MDAyZCk7XG4gIH1cblxuICB3aGlsZSAoaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7XG5cbiAgICBpZiAoY29kZSA+PSAweDAwMzAgJiYgY29kZSA8PSAweDAwMzkpIHtcbiAgICAgIG51bWJlckNoYXJzLnB1c2goY29kZSk7XG4gICAgICBpbmRleCArPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoaW5kZXggKyAxIDwgc3RyLmxlbmd0aCkge1xuICAgIHZhciBuZXh0Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4KTtcbiAgICB2YXIgbmV4dE5leHRDb2RlID0gc3RyLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcblxuICAgIGlmIChuZXh0Q29kZSA9PT0gMHgwMDJlICYmIG5leHROZXh0Q29kZSA+PSAweDAwMzAgJiYgbmV4dE5leHRDb2RlIDw9IDB4MDAzOSkge1xuICAgICAgbnVtYmVyQ2hhcnMucHVzaChuZXh0Q29kZSwgbmV4dE5leHRDb2RlKTtcbiAgICAgIGZsYWcgPSAnbnVtYmVyJztcbiAgICAgIGluZGV4ICs9IDI7XG5cbiAgICAgIHdoaWxlIChpbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7XG5cbiAgICAgICAgaWYgKGNvZGUgPj0gMHgwMDMwICYmIGNvZGUgPD0gMHgwMDM5KSB7XG4gICAgICAgICAgbnVtYmVyQ2hhcnMucHVzaChjb2RlKTtcbiAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGluZGV4ICsgMSA8IHN0ci5sZW5ndGgpIHtcbiAgICB2YXIgbmV4dENvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7XG4gICAgdmFyIG5leHROZXh0Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4ICsgMSk7XG4gICAgdmFyIG5leHROZXh0TmV4dENvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCArIDIpO1xuXG4gICAgaWYgKG5leHRDb2RlID09PSAweDAwNDUgfHwgbmV4dENvZGUgPT09IDB4MDA2NSkge1xuICAgICAgdmFyIG5leHROZXh0SXNEaWdpdCA9IG5leHROZXh0Q29kZSA+PSAweDAwMzAgJiYgbmV4dE5leHRDb2RlIDw9IDB4MDAzOTtcblxuICAgICAgaWYgKG5leHROZXh0SXNEaWdpdCB8fCAobmV4dE5leHRDb2RlID09PSAweDAwMmIgfHwgbmV4dE5leHRDb2RlID09PSAweDAwMmQpICYmIG5leHROZXh0TmV4dENvZGUgPj0gMHgwMDMwICYmIG5leHROZXh0TmV4dENvZGUgPD0gMHgwMDM5KSB7XG4gICAgICAgIGZsYWcgPSAnbnVtYmVyJztcblxuICAgICAgICBpZiAobmV4dE5leHRJc0RpZ2l0KSB7XG4gICAgICAgICAgbnVtYmVyQ2hhcnMucHVzaCgweDAwNDUsIG5leHROZXh0Q29kZSk7XG4gICAgICAgICAgaW5kZXggKz0gMjtcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0TmV4dENvZGUgPT09IDB4MDAyZCkge1xuICAgICAgICAgIG51bWJlckNoYXJzLnB1c2goMHgwMDQ1LCAweDAwMmQsIG5leHROZXh0TmV4dENvZGUpO1xuICAgICAgICAgIGluZGV4ICs9IDM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbnVtYmVyQ2hhcnMucHVzaCgweDAwNDUsIG5leHROZXh0TmV4dENvZGUpO1xuICAgICAgICAgIGluZGV4ICs9IDM7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoaW5kZXggPCBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7XG5cbiAgICAgICAgICBpZiAoY29kZSA+PSAweDAwMzAgJiYgY29kZSA8PSAweDAwMzkpIHtcbiAgICAgICAgICAgIG51bWJlckNoYXJzLnB1c2goY29kZSk7XG4gICAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgbnVtYmVyU3RyaW5nID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBudW1iZXJDaGFycyk7XG4gIHZhciB2YWx1ZSA9IGZsYWcgPT09ICdudW1iZXInID8gcGFyc2VGbG9hdChudW1iZXJTdHJpbmcpIDogcGFyc2VJbnQobnVtYmVyU3RyaW5nKTtcbiAgaWYgKHZhbHVlID09PSAtMCkgdmFsdWUgPSAwO1xuICByZXR1cm4gTnVtYmVyLmlzTmFOKHZhbHVlKSA/IG51bGwgOiBbaW5kZXggLSAxLCB2YWx1ZSwgZmxhZ107XG59O1xudmFyIGNvbnN1bWVJZGVudFVuc2FmZSA9IGZ1bmN0aW9uIGNvbnN1bWVJZGVudFVuc2FmZShzdHIsIGluZGV4KSB7XG4gIGlmIChzdHIubGVuZ3RoIDw9IGluZGV4KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgaWRlbnRDaGFycyA9IFtdO1xuXG4gIGZvciAodmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7IGluZGV4IDwgc3RyLmxlbmd0aDsgY29kZSA9IHN0ci5jaGFyQ29kZUF0KCsraW5kZXgpKSB7XG4gICAgaWYgKGNvZGUgPT09IDB4MDAyZCB8fCBjb2RlID09PSAweDAwNWYgfHwgY29kZSA+PSAweDAwNDEgJiYgY29kZSA8PSAweDAwNWEgfHwgY29kZSA+PSAweDAwNjEgJiYgY29kZSA8PSAweDAwN2EgfHwgY29kZSA+PSAweDAwODAgfHwgY29kZSA+PSAweDAwMzAgJiYgY29kZSA8PSAweDAwMzkpIHtcbiAgICAgIGlkZW50Q2hhcnMucHVzaChjb2RlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVzdWx0ID0gY29uc3VtZUVzY2FwZShzdHIsIGluZGV4KTtcblxuICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX2EgPSBfX3JlYWQocmVzdWx0LCAyKSxcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IF9hWzBdLFxuICAgICAgICAgICAgY29kZV80ID0gX2FbMV07XG5cbiAgICAgICAgaWRlbnRDaGFycy5wdXNoKGNvZGVfNCk7XG4gICAgICAgIGluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBpbmRleCA9PT0gMCA/IG51bGwgOiBbaW5kZXggLSAxLCBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGlkZW50Q2hhcnMpXTtcbn07XG52YXIgY29uc3VtZUlkZW50ID0gZnVuY3Rpb24gY29uc3VtZUlkZW50KHN0ciwgaW5kZXgpIHtcbiAgaWYgKHN0ci5sZW5ndGggPD0gaW5kZXggfHwgIXdvdWxkU3RhcnRJZGVudGlmaWVyKHN0ciwgaW5kZXgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgaWRlbnRDaGFycyA9IFtdO1xuXG4gIGZvciAodmFyIGNvZGUgPSBzdHIuY2hhckNvZGVBdChpbmRleCk7IGluZGV4IDwgc3RyLmxlbmd0aDsgY29kZSA9IHN0ci5jaGFyQ29kZUF0KCsraW5kZXgpKSB7XG4gICAgaWYgKGNvZGUgPT09IDB4MDAyZCB8fCBjb2RlID09PSAweDAwNWYgfHwgY29kZSA+PSAweDAwNDEgJiYgY29kZSA8PSAweDAwNWEgfHwgY29kZSA+PSAweDAwNjEgJiYgY29kZSA8PSAweDAwN2EgfHwgY29kZSA+PSAweDAwODAgfHwgY29kZSA+PSAweDAwMzAgJiYgY29kZSA8PSAweDAwMzkpIHtcbiAgICAgIGlkZW50Q2hhcnMucHVzaChjb2RlKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcmVzdWx0ID0gY29uc3VtZUVzY2FwZShzdHIsIGluZGV4KTtcblxuICAgICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX2EgPSBfX3JlYWQocmVzdWx0LCAyKSxcbiAgICAgICAgICAgIGxhc3RJbmRleCA9IF9hWzBdLFxuICAgICAgICAgICAgY29kZV81ID0gX2FbMV07XG5cbiAgICAgICAgaWRlbnRDaGFycy5wdXNoKGNvZGVfNSk7XG4gICAgICAgIGluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBbaW5kZXggLSAxLCBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGlkZW50Q2hhcnMpXTtcbn07XG52YXIgY29uc3VtZVVybCA9IGZ1bmN0aW9uIGNvbnN1bWVVcmwoc3RyLCBpbmRleCkge1xuICB2YXIgY29kZSA9IHN0ci5jaGFyQ29kZUF0KGluZGV4KTtcblxuICB3aGlsZSAoY29kZSA9PT0gMHgwMDA5IHx8IGNvZGUgPT09IDB4MDAyMCB8fCBjb2RlID09PSAweDAwMGEpIHtcbiAgICBjb2RlID0gc3RyLmNoYXJDb2RlQXQoKytpbmRleCk7XG4gIH1cblxuICB2YXIgdXJsQ2hhcnMgPSBbXTtcbiAgdmFyIGhhc0ZpbmlzaGVkV29yZCA9IGZhbHNlO1xuXG4gIHdoaWxlIChpbmRleCA8IHN0ci5sZW5ndGgpIHtcbiAgICBpZiAoY29kZSA9PT0gMHgwMDI5KSB7XG4gICAgICByZXR1cm4gW2luZGV4LCBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIHVybENoYXJzKV07XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwMjIgfHwgY29kZSA9PT0gMHgwMDI3IHx8IGNvZGUgPT09IDB4MDAyOCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDAwMDkgfHwgY29kZSA9PT0gMHgwMDIwIHx8IGNvZGUgPT09IDB4MDAwYSkge1xuICAgICAgaWYgKCFoYXNGaW5pc2hlZFdvcmQgJiYgdXJsQ2hhcnMubGVuZ3RoICE9PSAwKSBoYXNGaW5pc2hlZFdvcmQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgwMDVjKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gY29uc3VtZUVzY2FwZShzdHIsIGluZGV4KTtcbiAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgaGFzRmluaXNoZWRXb3JkKSByZXR1cm4gbnVsbDtcblxuICAgICAgdmFyIF9hID0gX19yZWFkKHJlc3VsdCwgMiksXG4gICAgICAgICAgbGFzdEluZGV4ID0gX2FbMF0sXG4gICAgICAgICAgdmFsdWUgPSBfYVsxXTtcblxuICAgICAgdXJsQ2hhcnMucHVzaCh2YWx1ZSk7XG4gICAgICBpbmRleCA9IGxhc3RJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhc0ZpbmlzaGVkV29yZCkgcmV0dXJuIG51bGw7XG4gICAgICB1cmxDaGFycy5wdXNoKGNvZGUpO1xuICAgIH1cblxuICAgIGNvZGUgPSBzdHIuY2hhckNvZGVBdCgrK2luZGV4KTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufTtcbnZhciBjb25zdW1lSWRlbnRMaWtlID0gZnVuY3Rpb24gY29uc3VtZUlkZW50TGlrZShzdHIsIGluZGV4KSB7XG4gIHZhciByZXN1bHQgPSBjb25zdW1lSWRlbnQoc3RyLCBpbmRleCk7XG4gIGlmIChyZXN1bHQgPT09IG51bGwpIHJldHVybiBudWxsO1xuXG4gIHZhciBfYSA9IF9fcmVhZChyZXN1bHQsIDIpLFxuICAgICAgbGFzdEluZGV4ID0gX2FbMF0sXG4gICAgICB2YWx1ZSA9IF9hWzFdO1xuXG4gIGlmICh2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSAndXJsJykge1xuICAgIGlmIChzdHIubGVuZ3RoID4gbGFzdEluZGV4ICsgMSkge1xuICAgICAgdmFyIG5leHRDb2RlID0gc3RyLmNoYXJDb2RlQXQobGFzdEluZGV4ICsgMSk7XG5cbiAgICAgIGlmIChuZXh0Q29kZSA9PT0gMHgwMDI4KSB7XG4gICAgICAgIGZvciAodmFyIG9mZnNldCA9IDI7IGxhc3RJbmRleCArIG9mZnNldCA8IHN0ci5sZW5ndGg7IG9mZnNldCArPSAxKSB7XG4gICAgICAgICAgdmFyIG5leHROZXh0Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGxhc3RJbmRleCArIG9mZnNldCk7XG5cbiAgICAgICAgICBpZiAobmV4dE5leHRDb2RlID09PSAweDAwMjIgfHwgbmV4dE5leHRDb2RlID09PSAweDAwMjcpIHtcbiAgICAgICAgICAgIHJldHVybiBbbGFzdEluZGV4ICsgMSwgdmFsdWUudG9Mb3dlckNhc2UoKSwgJzxmdW5jdGlvbi10b2tlbj4nXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5leHROZXh0Q29kZSAhPT0gMHgwMDA5ICYmIG5leHROZXh0Q29kZSAhPT0gMHgwMDIwICYmIG5leHROZXh0Q29kZSAhPT0gMHgwMDBhKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0XzEgPSBjb25zdW1lVXJsKHN0ciwgbGFzdEluZGV4ICsgb2Zmc2V0KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHRfMSA9PT0gbnVsbCkgcmV0dXJuIG51bGw7XG5cbiAgICAgICAgICAgIHZhciBfYiA9IF9fcmVhZChyZXN1bHRfMSwgMiksXG4gICAgICAgICAgICAgICAgbGFzdFVybEluZGV4ID0gX2JbMF0sXG4gICAgICAgICAgICAgICAgdmFsdWVfMSA9IF9iWzFdO1xuXG4gICAgICAgICAgICByZXR1cm4gW2xhc3RVcmxJbmRleCwgdmFsdWVfMSwgJzx1cmwtdG9rZW4+J107XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtsYXN0SW5kZXggKyAxLCB2YWx1ZS50b0xvd2VyQ2FzZSgpLCAnPGZ1bmN0aW9uLXRva2VuPiddO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChzdHIubGVuZ3RoID4gbGFzdEluZGV4ICsgMSkge1xuICAgIHZhciBuZXh0Q29kZSA9IHN0ci5jaGFyQ29kZUF0KGxhc3RJbmRleCArIDEpO1xuXG4gICAgaWYgKG5leHRDb2RlID09PSAweDAwMjgpIHtcbiAgICAgIHJldHVybiBbbGFzdEluZGV4ICsgMSwgdmFsdWUudG9Mb3dlckNhc2UoKSwgJzxmdW5jdGlvbi10b2tlbj4nXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gW2xhc3RJbmRleCwgdmFsdWUudG9Mb3dlckNhc2UoKSwgJzxpZGVudC10b2tlbj4nXTtcbn07XG5cbnZhciBzaW1wbGlmeUFTVCA9IGZ1bmN0aW9uIHNpbXBsaWZ5QVNUKGFzdCkge1xuICBmb3IgKHZhciBpID0gYXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgYXN0W2ldID0gc2ltcGxpZnlNZWRpYVF1ZXJ5KGFzdFtpXSk7XG4gIH1cblxuICByZXR1cm4gYXN0O1xufTtcblxudmFyIHNpbXBsaWZ5TWVkaWFRdWVyeSA9IGZ1bmN0aW9uIHNpbXBsaWZ5TWVkaWFRdWVyeShtZWRpYVF1ZXJ5KSB7XG4gIGlmIChtZWRpYVF1ZXJ5Lm1lZGlhQ29uZGl0aW9uID09PSBudWxsKSByZXR1cm4gbWVkaWFRdWVyeTtcbiAgdmFyIG1lZGlhQ29uZGl0aW9uID0gc2ltcGxpZnlNZWRpYUNvbmRpdGlvbihtZWRpYVF1ZXJ5Lm1lZGlhQ29uZGl0aW9uKTtcblxuICBpZiAobWVkaWFDb25kaXRpb24ub3BlcmF0b3IgPT09IG51bGwgJiYgbWVkaWFDb25kaXRpb24uY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmICdjaGlsZHJlbicgaW4gbWVkaWFDb25kaXRpb24uY2hpbGRyZW5bMF0pIHtcbiAgICBtZWRpYUNvbmRpdGlvbiA9IG1lZGlhQ29uZGl0aW9uLmNoaWxkcmVuWzBdO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBtZWRpYVByZWZpeDogbWVkaWFRdWVyeS5tZWRpYVByZWZpeCxcbiAgICBtZWRpYVR5cGU6IG1lZGlhUXVlcnkubWVkaWFUeXBlLFxuICAgIG1lZGlhQ29uZGl0aW9uOiBtZWRpYUNvbmRpdGlvblxuICB9O1xufTtcblxudmFyIHNpbXBsaWZ5TWVkaWFDb25kaXRpb24gPSBmdW5jdGlvbiBzaW1wbGlmeU1lZGlhQ29uZGl0aW9uKG1lZGlhQ29uZGl0aW9uKSB7XG4gIGZvciAodmFyIGkgPSBtZWRpYUNvbmRpdGlvbi5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciB1bnNpbXBsaWZpZWRDaGlsZCA9IG1lZGlhQ29uZGl0aW9uLmNoaWxkcmVuW2ldO1xuXG4gICAgaWYgKCEoJ2NvbnRleHQnIGluIHVuc2ltcGxpZmllZENoaWxkKSkge1xuICAgICAgdmFyIGNoaWxkID0gc2ltcGxpZnlNZWRpYUNvbmRpdGlvbih1bnNpbXBsaWZpZWRDaGlsZCk7XG5cbiAgICAgIGlmIChjaGlsZC5vcGVyYXRvciA9PT0gbnVsbCAmJiBjaGlsZC5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgbWVkaWFDb25kaXRpb24uY2hpbGRyZW5baV0gPSBjaGlsZC5jaGlsZHJlblswXTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGQub3BlcmF0b3IgPT09IG1lZGlhQ29uZGl0aW9uLm9wZXJhdG9yICYmIChjaGlsZC5vcGVyYXRvciA9PT0gJ2FuZCcgfHwgY2hpbGQub3BlcmF0b3IgPT09ICdvcicpKSB7XG4gICAgICAgIHZhciBzcGxpY2VBcmdzID0gW2ksIDFdO1xuXG4gICAgICAgIGZvciAodmFyIGlfMSA9IDA7IGlfMSA8IGNoaWxkLmNoaWxkcmVuLmxlbmd0aDsgaV8xKyspIHtcbiAgICAgICAgICBzcGxpY2VBcmdzLnB1c2goY2hpbGQuY2hpbGRyZW5baV8xXSk7XG4gICAgICAgIH1cblxuICAgICAgICBtZWRpYUNvbmRpdGlvbi5jaGlsZHJlbi5zcGxpY2UuYXBwbHkobWVkaWFDb25kaXRpb24uY2hpbGRyZW4sIHNwbGljZUFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtZWRpYUNvbmRpdGlvbjtcbn07XG5cbnZhciBjcmVhdGVFcnJvciA9IGZ1bmN0aW9uIGNyZWF0ZUVycm9yKG1lc3NhZ2UsIGVycikge1xuICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKFwiXCIuY29uY2F0KGVyci5tZXNzYWdlLnRyaW0oKSwgXCJcXG5cIikuY29uY2F0KG1lc3NhZ2UudHJpbSgpKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihtZXNzYWdlLnRyaW0oKSk7XG4gIH1cbn07XG5cbnZhciB0b0FTVCA9IGZ1bmN0aW9uIHRvQVNUKHN0cikge1xuICByZXR1cm4gc2ltcGxpZnlBU1QodG9VbmZsYXR0ZW5lZEFTVChzdHIpKTtcbn07XG52YXIgdG9VbmZsYXR0ZW5lZEFTVCA9IGZ1bmN0aW9uIHRvVW5mbGF0dGVuZWRBU1Qoc3RyKSB7XG4gIHZhciB0b2tlbkxpc3QgPSBsZXhpY2FsQW5hbHlzaXMoc3RyLnRyaW0oKSk7XG5cbiAgaWYgKHRva2VuTGlzdCA9PT0gbnVsbCkge1xuICAgIHRocm93IGNyZWF0ZUVycm9yKCdGYWlsZWQgdG9rZW5pemluZycpO1xuICB9XG5cbiAgdmFyIHN0YXJ0SW5kZXggPSAwO1xuICB2YXIgZW5kSW5kZXggPSB0b2tlbkxpc3QubGVuZ3RoIC0gMTtcblxuICBpZiAodG9rZW5MaXN0WzBdLnR5cGUgPT09ICc8YXQta2V5d29yZC10b2tlbj4nICYmIHRva2VuTGlzdFswXS52YWx1ZSA9PT0gJ21lZGlhJykge1xuICAgIGlmICh0b2tlbkxpc3RbMV0udHlwZSAhPT0gJzx3aGl0ZXNwYWNlLXRva2VuPicpIHtcbiAgICAgIHRocm93IGNyZWF0ZUVycm9yKCdFeHBlY3RlZCB3aGl0ZXNwYWNlIGFmdGVyIG1lZGlhJyk7XG4gICAgfVxuXG4gICAgc3RhcnRJbmRleCA9IDI7XG5cbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IHRva2VuTGlzdC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIHZhciB0b2tlbiA9IHRva2VuTGlzdFtpXTtcblxuICAgICAgaWYgKHRva2VuLnR5cGUgPT09ICc8ey10b2tlbj4nKSB7XG4gICAgICAgIGVuZEluZGV4ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKHRva2VuLnR5cGUgPT09ICc8c2VtaWNvbG9uLXRva2VuPicpIHtcbiAgICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoXCJFeHBlY3RlZCAneycgaW4gbWVkaWEgcXVlcnkgYnV0IGZvdW5kICc7J1wiKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0b2tlbkxpc3QgPSB0b2tlbkxpc3Quc2xpY2Uoc3RhcnRJbmRleCwgZW5kSW5kZXgpO1xuICByZXR1cm4gc3ludGFjdGljQW5hbHlzaXModG9rZW5MaXN0KTtcbn07XG52YXIgcmVtb3ZlV2hpdGVzcGFjZSA9IGZ1bmN0aW9uIHJlbW92ZVdoaXRlc3BhY2UodG9rZW5MaXN0KSB7XG4gIHZhciBuZXdUb2tlbkxpc3QgPSBbXTtcbiAgdmFyIGJlZm9yZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHRva2VuTGlzdFtpXS50eXBlID09PSAnPHdoaXRlc3BhY2UtdG9rZW4+Jykge1xuICAgICAgYmVmb3JlID0gdHJ1ZTtcblxuICAgICAgaWYgKG5ld1Rva2VuTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgIG5ld1Rva2VuTGlzdFtuZXdUb2tlbkxpc3QubGVuZ3RoIC0gMV0ud3NBZnRlciA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1Rva2VuTGlzdC5wdXNoKF9fYXNzaWduKF9fYXNzaWduKHt9LCB0b2tlbkxpc3RbaV0pLCB7XG4gICAgICAgIHdzQmVmb3JlOiBiZWZvcmUsXG4gICAgICAgIHdzQWZ0ZXI6IGZhbHNlXG4gICAgICB9KSk7XG4gICAgICBiZWZvcmUgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3VG9rZW5MaXN0O1xufTtcbnZhciBzeW50YWN0aWNBbmFseXNpcyA9IGZ1bmN0aW9uIHN5bnRhY3RpY0FuYWx5c2lzKHRva2VuTGlzdCkge1xuICB2YXIgZV8xLCBfYTtcblxuICB2YXIgbWVkaWFRdWVyeUxpc3QgPSBbW11dO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRva2VuID0gdG9rZW5MaXN0W2ldO1xuXG4gICAgaWYgKHRva2VuLnR5cGUgPT09ICc8Y29tbWEtdG9rZW4+Jykge1xuICAgICAgbWVkaWFRdWVyeUxpc3QucHVzaChbXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lZGlhUXVlcnlMaXN0W21lZGlhUXVlcnlMaXN0Lmxlbmd0aCAtIDFdLnB1c2godG9rZW4pO1xuICAgIH1cbiAgfVxuXG4gIHZhciBtZWRpYVF1ZXJpZXMgPSBtZWRpYVF1ZXJ5TGlzdC5tYXAocmVtb3ZlV2hpdGVzcGFjZSk7XG5cbiAgaWYgKG1lZGlhUXVlcmllcy5sZW5ndGggPT09IDEgJiYgbWVkaWFRdWVyaWVzWzBdLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbe1xuICAgICAgbWVkaWFDb25kaXRpb246IG51bGwsXG4gICAgICBtZWRpYVByZWZpeDogbnVsbCxcbiAgICAgIG1lZGlhVHlwZTogJ2FsbCdcbiAgICB9XTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbWVkaWFRdWVyeVRva2VucyA9IG1lZGlhUXVlcmllcy5tYXAoZnVuY3Rpb24gKG1lZGlhUXVlcnlUb2tlbnMpIHtcbiAgICAgIGlmIChtZWRpYVF1ZXJ5VG9rZW5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0b2tlbml6ZU1lZGlhUXVlcnkobWVkaWFRdWVyeVRva2Vucyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIG5vbk51bGxNZWRpYVF1ZXJ5VG9rZW5zID0gW107XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgbWVkaWFRdWVyeVRva2Vuc18xID0gX192YWx1ZXMobWVkaWFRdWVyeVRva2VucyksIG1lZGlhUXVlcnlUb2tlbnNfMV8xID0gbWVkaWFRdWVyeVRva2Vuc18xLm5leHQoKTsgIW1lZGlhUXVlcnlUb2tlbnNfMV8xLmRvbmU7IG1lZGlhUXVlcnlUb2tlbnNfMV8xID0gbWVkaWFRdWVyeVRva2Vuc18xLm5leHQoKSkge1xuICAgICAgICB2YXIgbWVkaWFRdWVyeVRva2VuID0gbWVkaWFRdWVyeVRva2Vuc18xXzEudmFsdWU7XG5cbiAgICAgICAgaWYgKG1lZGlhUXVlcnlUb2tlbiAhPT0gbnVsbCkge1xuICAgICAgICAgIG5vbk51bGxNZWRpYVF1ZXJ5VG9rZW5zLnB1c2gobWVkaWFRdWVyeVRva2VuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVfMV8xKSB7XG4gICAgICBlXzEgPSB7XG4gICAgICAgIGVycm9yOiBlXzFfMVxuICAgICAgfTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKG1lZGlhUXVlcnlUb2tlbnNfMV8xICYmICFtZWRpYVF1ZXJ5VG9rZW5zXzFfMS5kb25lICYmIChfYSA9IG1lZGlhUXVlcnlUb2tlbnNfMVtcInJldHVyblwiXSkpIF9hLmNhbGwobWVkaWFRdWVyeVRva2Vuc18xKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobm9uTnVsbE1lZGlhUXVlcnlUb2tlbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBjcmVhdGVFcnJvcignTm8gdmFsaWQgbWVkaWEgcXVlcmllcycpO1xuICAgIH1cblxuICAgIHJldHVybiBub25OdWxsTWVkaWFRdWVyeVRva2VucztcbiAgfVxufTtcbnZhciB0b2tlbml6ZU1lZGlhUXVlcnkgPSBmdW5jdGlvbiB0b2tlbml6ZU1lZGlhUXVlcnkodG9rZW5zKSB7XG4gIHZhciBmaXJzdFRva2VuID0gdG9rZW5zWzBdO1xuXG4gIGlmIChmaXJzdFRva2VuLnR5cGUgPT09ICc8KC10b2tlbj4nKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1lZGlhUHJlZml4OiBudWxsLFxuICAgICAgICBtZWRpYVR5cGU6ICdhbGwnLFxuICAgICAgICBtZWRpYUNvbmRpdGlvbjogdG9rZW5pemVNZWRpYUNvbmRpdGlvbih0b2tlbnMsIHRydWUpXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoXCJFeHBlY3RlZCBtZWRpYSBjb25kaXRpb24gYWZ0ZXIgJygnXCIsIGVycik7XG4gICAgfVxuICB9IGVsc2UgaWYgKGZpcnN0VG9rZW4udHlwZSA9PT0gJzxpZGVudC10b2tlbj4nKSB7XG4gICAgdmFyIG1lZGlhUHJlZml4ID0gbnVsbDtcbiAgICB2YXIgbWVkaWFUeXBlID0gdm9pZCAwO1xuICAgIHZhciB2YWx1ZSA9IGZpcnN0VG9rZW4udmFsdWU7XG5cbiAgICBpZiAodmFsdWUgPT09ICdvbmx5JyB8fCB2YWx1ZSA9PT0gJ25vdCcpIHtcbiAgICAgIG1lZGlhUHJlZml4ID0gdmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIGZpcnN0SW5kZXggPSBtZWRpYVByZWZpeCA9PT0gbnVsbCA/IDAgOiAxO1xuXG4gICAgaWYgKHRva2Vucy5sZW5ndGggPD0gZmlyc3RJbmRleCkge1xuICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoXCJFeHBlY3RlZCBleHRyYSB0b2tlbiBpbiBtZWRpYSBxdWVyeVwiKTtcbiAgICB9XG5cbiAgICB2YXIgZmlyc3ROb25VbmFyeVRva2VuID0gdG9rZW5zW2ZpcnN0SW5kZXhdO1xuXG4gICAgaWYgKGZpcnN0Tm9uVW5hcnlUb2tlbi50eXBlID09PSAnPGlkZW50LXRva2VuPicpIHtcbiAgICAgIHZhciB2YWx1ZV8xID0gZmlyc3ROb25VbmFyeVRva2VuLnZhbHVlO1xuXG4gICAgICBpZiAodmFsdWVfMSA9PT0gJ2FsbCcpIHtcbiAgICAgICAgbWVkaWFUeXBlID0gJ2FsbCc7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlXzEgPT09ICdwcmludCcgfHwgdmFsdWVfMSA9PT0gJ3NjcmVlbicpIHtcbiAgICAgICAgbWVkaWFUeXBlID0gdmFsdWVfMTtcbiAgICAgIH0gZWxzZSBpZiAodmFsdWVfMSA9PT0gJ3R0eScgfHwgdmFsdWVfMSA9PT0gJ3R2JyB8fCB2YWx1ZV8xID09PSAncHJvamVjdGlvbicgfHwgdmFsdWVfMSA9PT0gJ2hhbmRoZWxkJyB8fCB2YWx1ZV8xID09PSAnYnJhaWxsZScgfHwgdmFsdWVfMSA9PT0gJ2VtYm9zc2VkJyB8fCB2YWx1ZV8xID09PSAnYXVyYWwnIHx8IHZhbHVlXzEgPT09ICdzcGVlY2gnKSB7XG4gICAgICAgIG1lZGlhUHJlZml4ID0gbWVkaWFQcmVmaXggPT09ICdub3QnID8gbnVsbCA6ICdub3QnO1xuICAgICAgICBtZWRpYVR5cGUgPSAnYWxsJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKFwiVW5rbm93biBpZGVudCAnXCIuY29uY2F0KHZhbHVlXzEsIFwiJyBpbiBtZWRpYSBxdWVyeVwiKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtZWRpYVByZWZpeCA9PT0gJ25vdCcgJiYgZmlyc3ROb25VbmFyeVRva2VuLnR5cGUgPT09ICc8KC10b2tlbj4nKSB7XG4gICAgICB2YXIgdG9rZW5zV2l0aFBhcmVucyA9IFt7XG4gICAgICAgIHR5cGU6ICc8KC10b2tlbj4nLFxuICAgICAgICB3c0JlZm9yZTogZmFsc2UsXG4gICAgICAgIHdzQWZ0ZXI6IGZhbHNlXG4gICAgICB9XTtcbiAgICAgIHRva2Vuc1dpdGhQYXJlbnMucHVzaC5hcHBseSh0b2tlbnNXaXRoUGFyZW5zLCB0b2tlbnMpO1xuICAgICAgdG9rZW5zV2l0aFBhcmVucy5wdXNoKHtcbiAgICAgICAgdHlwZTogJzwpLXRva2VuPicsXG4gICAgICAgIHdzQmVmb3JlOiBmYWxzZSxcbiAgICAgICAgd3NBZnRlcjogZmFsc2VcbiAgICAgIH0pO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1lZGlhUHJlZml4OiBudWxsLFxuICAgICAgICAgIG1lZGlhVHlwZTogJ2FsbCcsXG4gICAgICAgICAgbWVkaWFDb25kaXRpb246IHRva2VuaXplTWVkaWFDb25kaXRpb24odG9rZW5zV2l0aFBhcmVucywgdHJ1ZSlcbiAgICAgICAgfTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBjcmVhdGVFcnJvcihcIkV4cGVjdGVkIG1lZGlhIGNvbmRpdGlvbiBhZnRlciAnKCdcIiwgZXJyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoJ0ludmFsaWQgbWVkaWEgcXVlcnknKTtcbiAgICB9XG5cbiAgICBpZiAoZmlyc3RJbmRleCArIDEgPT09IHRva2Vucy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1lZGlhUHJlZml4OiBtZWRpYVByZWZpeCxcbiAgICAgICAgbWVkaWFUeXBlOiBtZWRpYVR5cGUsXG4gICAgICAgIG1lZGlhQ29uZGl0aW9uOiBudWxsXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZmlyc3RJbmRleCArIDQgPCB0b2tlbnMubGVuZ3RoKSB7XG4gICAgICB2YXIgc2Vjb25kTm9uVW5hcnlUb2tlbiA9IHRva2Vuc1tmaXJzdEluZGV4ICsgMV07XG5cbiAgICAgIGlmIChzZWNvbmROb25VbmFyeVRva2VuLnR5cGUgPT09ICc8aWRlbnQtdG9rZW4+JyAmJiBzZWNvbmROb25VbmFyeVRva2VuLnZhbHVlID09PSAnYW5kJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZWRpYVByZWZpeDogbWVkaWFQcmVmaXgsXG4gICAgICAgICAgICBtZWRpYVR5cGU6IG1lZGlhVHlwZSxcbiAgICAgICAgICAgIG1lZGlhQ29uZGl0aW9uOiB0b2tlbml6ZU1lZGlhQ29uZGl0aW9uKHRva2Vucy5zbGljZShmaXJzdEluZGV4ICsgMiksIGZhbHNlKVxuICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIHRocm93IGNyZWF0ZUVycm9yKFwiRXhwZWN0ZWQgbWVkaWEgY29uZGl0aW9uIGFmdGVyICdhbmQnXCIsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGNyZWF0ZUVycm9yKFwiRXhwZWN0ZWQgJ2FuZCcgYWZ0ZXIgbWVkaWEgcHJlZml4XCIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBjcmVhdGVFcnJvcignRXhwZWN0ZWQgbWVkaWEgY29uZGl0aW9uIGFmdGVyIG1lZGlhIHByZWZpeCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBjcmVhdGVFcnJvcignRXhwZWN0ZWQgbWVkaWEgY29uZGl0aW9uIG9yIG1lZGlhIHByZWZpeCcpO1xuICB9XG59O1xudmFyIHRva2VuaXplTWVkaWFDb25kaXRpb24gPSBmdW5jdGlvbiB0b2tlbml6ZU1lZGlhQ29uZGl0aW9uKHRva2VucywgbWF5Q29udGFpbk9yLCBwcmV2aW91c09wZXJhdG9yKSB7XG4gIGlmIChwcmV2aW91c09wZXJhdG9yID09PSB2b2lkIDApIHtcbiAgICBwcmV2aW91c09wZXJhdG9yID0gbnVsbDtcbiAgfVxuXG4gIGlmICh0b2tlbnMubGVuZ3RoIDwgMyB8fCB0b2tlbnNbMF0udHlwZSAhPT0gJzwoLXRva2VuPicgfHwgdG9rZW5zW3Rva2Vucy5sZW5ndGggLSAxXS50eXBlICE9PSAnPCktdG9rZW4+Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZWRpYSBjb25kaXRpb24nKTtcbiAgfVxuXG4gIHZhciBlbmRJbmRleE9mRmlyc3RGZWF0dXJlID0gdG9rZW5zLmxlbmd0aCAtIDE7XG4gIHZhciBtYXhEZXB0aCA9IDA7XG4gIHZhciBjb3VudCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICBpZiAodG9rZW4udHlwZSA9PT0gJzwoLXRva2VuPicpIHtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgICBtYXhEZXB0aCA9IE1hdGgubWF4KG1heERlcHRoLCBjb3VudCk7XG4gICAgfSBlbHNlIGlmICh0b2tlbi50eXBlID09PSAnPCktdG9rZW4+Jykge1xuICAgICAgY291bnQgLT0gMTtcbiAgICB9XG5cbiAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgIGVuZEluZGV4T2ZGaXJzdEZlYXR1cmUgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKGNvdW50ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNaXNtYXRjaGVkIHBhcmVuc1xcbkludmFsaWQgbWVkaWEgY29uZGl0aW9uJyk7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBmZWF0dXJlVG9rZW5zID0gdG9rZW5zLnNsaWNlKDAsIGVuZEluZGV4T2ZGaXJzdEZlYXR1cmUgKyAxKTtcblxuICBpZiAobWF4RGVwdGggPT09IDEpIHtcbiAgICBjaGlsZCA9IHRva2VuaXplTWVkaWFGZWF0dXJlKGZlYXR1cmVUb2tlbnMpO1xuICB9IGVsc2Uge1xuICAgIGlmIChmZWF0dXJlVG9rZW5zWzFdLnR5cGUgPT09ICc8aWRlbnQtdG9rZW4+JyAmJiBmZWF0dXJlVG9rZW5zWzFdLnZhbHVlID09PSAnbm90Jykge1xuICAgICAgY2hpbGQgPSB0b2tlbml6ZU1lZGlhQ29uZGl0aW9uKGZlYXR1cmVUb2tlbnMuc2xpY2UoMiwgLTEpLCB0cnVlLCAnbm90Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNoaWxkID0gdG9rZW5pemVNZWRpYUNvbmRpdGlvbihmZWF0dXJlVG9rZW5zLnNsaWNlKDEsIC0xKSwgdHJ1ZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZEluZGV4T2ZGaXJzdEZlYXR1cmUgPT09IHRva2Vucy5sZW5ndGggLSAxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9wZXJhdG9yOiBwcmV2aW91c09wZXJhdG9yLFxuICAgICAgY2hpbGRyZW46IFtjaGlsZF1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHZhciBuZXh0VG9rZW4gPSB0b2tlbnNbZW5kSW5kZXhPZkZpcnN0RmVhdHVyZSArIDFdO1xuXG4gICAgaWYgKG5leHRUb2tlbi50eXBlICE9PSAnPGlkZW50LXRva2VuPicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBvcGVyYXRvclxcbkludmFsaWQgbWVkaWEgY29uZGl0aW9uJyk7XG4gICAgfSBlbHNlIGlmIChwcmV2aW91c09wZXJhdG9yICE9PSBudWxsICYmIHByZXZpb3VzT3BlcmF0b3IgIT09IG5leHRUb2tlbi52YWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ1wiLmNvbmNhdChuZXh0VG9rZW4udmFsdWUsIFwiJyBhbmQgJ1wiKS5jb25jYXQocHJldmlvdXNPcGVyYXRvciwgXCInIG11c3Qgbm90IGJlIGF0IHNhbWUgbGV2ZWxcXG5JbnZhbGlkIG1lZGlhIGNvbmRpdGlvblwiKSk7XG4gICAgfSBlbHNlIGlmIChuZXh0VG9rZW4udmFsdWUgPT09ICdvcicgJiYgIW1heUNvbnRhaW5Pcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVzZSAnb3InIGF0IHRvcCBsZXZlbCBvZiBhIG1lZGlhIHF1ZXJ5XFxuSW52YWxpZCBtZWRpYSBjb25kaXRpb25cIik7XG4gICAgfSBlbHNlIGlmIChuZXh0VG9rZW4udmFsdWUgIT09ICdhbmQnICYmIG5leHRUb2tlbi52YWx1ZSAhPT0gJ29yJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBvcGVyYXRvcjogJ1wiLmNvbmNhdChuZXh0VG9rZW4udmFsdWUsIFwiJ1xcbkludmFsaWQgbWVkaWEgY29uZGl0aW9uXCIpKTtcbiAgICB9XG5cbiAgICB2YXIgc2libGluZ3MgPSB0b2tlbml6ZU1lZGlhQ29uZGl0aW9uKHRva2Vucy5zbGljZShlbmRJbmRleE9mRmlyc3RGZWF0dXJlICsgMiksIG1heUNvbnRhaW5PciwgbmV4dFRva2VuLnZhbHVlKTtcbiAgICByZXR1cm4ge1xuICAgICAgb3BlcmF0b3I6IG5leHRUb2tlbi52YWx1ZSxcbiAgICAgIGNoaWxkcmVuOiBbY2hpbGRdLmNvbmNhdChzaWJsaW5ncy5jaGlsZHJlbilcbiAgICB9O1xuICB9XG59O1xudmFyIHRva2VuaXplTWVkaWFGZWF0dXJlID0gZnVuY3Rpb24gdG9rZW5pemVNZWRpYUZlYXR1cmUocmF3VG9rZW5zKSB7XG4gIGlmIChyYXdUb2tlbnMubGVuZ3RoIDwgMyB8fCByYXdUb2tlbnNbMF0udHlwZSAhPT0gJzwoLXRva2VuPicgfHwgcmF3VG9rZW5zW3Jhd1Rva2Vucy5sZW5ndGggLSAxXS50eXBlICE9PSAnPCktdG9rZW4+Jykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtZWRpYSBmZWF0dXJlJyk7XG4gIH1cblxuICB2YXIgdG9rZW5zID0gW3Jhd1Rva2Vuc1swXV07XG5cbiAgZm9yICh2YXIgaSA9IDE7IGkgPCByYXdUb2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoaSA8IHJhd1Rva2Vucy5sZW5ndGggLSAyKSB7XG4gICAgICB2YXIgYSA9IHJhd1Rva2Vuc1tpXTtcbiAgICAgIHZhciBiID0gcmF3VG9rZW5zW2kgKyAxXTtcbiAgICAgIHZhciBjID0gcmF3VG9rZW5zW2kgKyAyXTtcblxuICAgICAgaWYgKGEudHlwZSA9PT0gJzxudW1iZXItdG9rZW4+JyAmJiBhLnZhbHVlID4gMCAmJiBiLnR5cGUgPT09ICc8ZGVsaW0tdG9rZW4+JyAmJiBiLnZhbHVlID09PSAweDAwMmYgJiYgYy50eXBlID09PSAnPG51bWJlci10b2tlbj4nICYmIGMudmFsdWUgPiAwKSB7XG4gICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiAnPHJhdGlvLXRva2VuPicsXG4gICAgICAgICAgbnVtZXJhdG9yOiBhLnZhbHVlLFxuICAgICAgICAgIGRlbm9taW5hdG9yOiBjLnZhbHVlLFxuICAgICAgICAgIHdzQmVmb3JlOiBhLndzQmVmb3JlLFxuICAgICAgICAgIHdzQWZ0ZXI6IGMud3NBZnRlclxuICAgICAgICB9KTtcbiAgICAgICAgaSArPSAyO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0b2tlbnMucHVzaChyYXdUb2tlbnNbaV0pO1xuICB9XG5cbiAgdmFyIG5leHRUb2tlbiA9IHRva2Vuc1sxXTtcblxuICBpZiAobmV4dFRva2VuLnR5cGUgPT09ICc8aWRlbnQtdG9rZW4+JyAmJiB0b2tlbnMubGVuZ3RoID09PSAzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRleHQ6ICdib29sZWFuJyxcbiAgICAgIGZlYXR1cmU6IG5leHRUb2tlbi52YWx1ZVxuICAgIH07XG4gIH0gZWxzZSBpZiAodG9rZW5zLmxlbmd0aCA9PT0gNSAmJiB0b2tlbnNbMV0udHlwZSA9PT0gJzxpZGVudC10b2tlbj4nICYmIHRva2Vuc1syXS50eXBlID09PSAnPGNvbG9uLXRva2VuPicpIHtcbiAgICB2YXIgdmFsdWVUb2tlbiA9IHRva2Vuc1szXTtcblxuICAgIGlmICh2YWx1ZVRva2VuLnR5cGUgPT09ICc8bnVtYmVyLXRva2VuPicgfHwgdmFsdWVUb2tlbi50eXBlID09PSAnPGRpbWVuc2lvbi10b2tlbj4nIHx8IHZhbHVlVG9rZW4udHlwZSA9PT0gJzxyYXRpby10b2tlbj4nIHx8IHZhbHVlVG9rZW4udHlwZSA9PT0gJzxpZGVudC10b2tlbj4nKSB7XG4gICAgICB2YXIgZmVhdHVyZSA9IHRva2Vuc1sxXS52YWx1ZTtcbiAgICAgIHZhciBwcmVmaXggPSBudWxsO1xuICAgICAgdmFyIHNsaWNlID0gZmVhdHVyZS5zbGljZSgwLCA0KTtcblxuICAgICAgaWYgKHNsaWNlID09PSAnbWluLScpIHtcbiAgICAgICAgcHJlZml4ID0gJ21pbic7XG4gICAgICAgIGZlYXR1cmUgPSBmZWF0dXJlLnNsaWNlKDQpO1xuICAgICAgfSBlbHNlIGlmIChzbGljZSA9PT0gJ21heC0nKSB7XG4gICAgICAgIHByZWZpeCA9ICdtYXgnO1xuICAgICAgICBmZWF0dXJlID0gZmVhdHVyZS5zbGljZSg0KTtcbiAgICAgIH1cblxuICAgICAgdmFsdWVUb2tlbi53c0JlZm9yZTtcbiAgICAgICAgICB2YWx1ZVRva2VuLndzQWZ0ZXI7XG4gICAgICAgICAgdmFyIHZhbHVlID0gX19yZXN0KHZhbHVlVG9rZW4sIFtcIndzQmVmb3JlXCIsIFwid3NBZnRlclwiXSk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRleHQ6ICd2YWx1ZScsXG4gICAgICAgIHByZWZpeDogcHJlZml4LFxuICAgICAgICBmZWF0dXJlOiBmZWF0dXJlLFxuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKHRva2Vucy5sZW5ndGggPj0gNSkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgcmFuZ2UgPSB0b2tlbml6ZVJhbmdlKHRva2Vucyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250ZXh0OiAncmFuZ2UnLFxuICAgICAgICBmZWF0dXJlOiByYW5nZS5mZWF0dXJlTmFtZSxcbiAgICAgICAgcmFuZ2U6IHJhbmdlXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgY3JlYXRlRXJyb3IoJ0ludmFsaWQgbWVkaWEgZmVhdHVyZScsIGVycik7XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1lZGlhIGZlYXR1cmUnKTtcbn07XG52YXIgdG9rZW5pemVSYW5nZSA9IGZ1bmN0aW9uIHRva2VuaXplUmFuZ2UodG9rZW5zKSB7XG4gIHZhciBfYSwgX2IsIF9jLCBfZDtcblxuICBpZiAodG9rZW5zLmxlbmd0aCA8IDUgfHwgdG9rZW5zWzBdLnR5cGUgIT09ICc8KC10b2tlbj4nIHx8IHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0udHlwZSAhPT0gJzwpLXRva2VuPicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmFuZ2UnKTtcbiAgfVxuXG4gIHZhciByYW5nZSA9IHtcbiAgICBsZWZ0VG9rZW46IG51bGwsXG4gICAgbGVmdE9wOiBudWxsLFxuICAgIGZlYXR1cmVOYW1lOiAnJyxcbiAgICByaWdodE9wOiBudWxsLFxuICAgIHJpZ2h0VG9rZW46IG51bGxcbiAgfTtcbiAgdmFyIGhhc0xlZnQgPSB0b2tlbnNbMV0udHlwZSA9PT0gJzxudW1iZXItdG9rZW4+JyB8fCB0b2tlbnNbMV0udHlwZSA9PT0gJzxkaW1lbnNpb24tdG9rZW4+JyB8fCB0b2tlbnNbMV0udHlwZSA9PT0gJzxyYXRpby10b2tlbj4nIHx8IHRva2Vuc1sxXS50eXBlID09PSAnPGlkZW50LXRva2VuPicgJiYgdG9rZW5zWzFdLnZhbHVlID09PSAnaW5maW5pdGUnO1xuXG4gIGlmICh0b2tlbnNbMl0udHlwZSA9PT0gJzxkZWxpbS10b2tlbj4nKSB7XG4gICAgaWYgKHRva2Vuc1syXS52YWx1ZSA9PT0gMHgwMDNjKSB7XG4gICAgICBpZiAodG9rZW5zWzNdLnR5cGUgPT09ICc8ZGVsaW0tdG9rZW4+JyAmJiB0b2tlbnNbM10udmFsdWUgPT09IDB4MDAzZCAmJiAhdG9rZW5zWzNdLndzQmVmb3JlKSB7XG4gICAgICAgIHJhbmdlW2hhc0xlZnQgPyAnbGVmdE9wJyA6ICdyaWdodE9wJ10gPSAnPD0nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZ2VbaGFzTGVmdCA/ICdsZWZ0T3AnIDogJ3JpZ2h0T3AnXSA9ICc8JztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRva2Vuc1syXS52YWx1ZSA9PT0gMHgwMDNlKSB7XG4gICAgICBpZiAodG9rZW5zWzNdLnR5cGUgPT09ICc8ZGVsaW0tdG9rZW4+JyAmJiB0b2tlbnNbM10udmFsdWUgPT09IDB4MDAzZCAmJiAhdG9rZW5zWzNdLndzQmVmb3JlKSB7XG4gICAgICAgIHJhbmdlW2hhc0xlZnQgPyAnbGVmdE9wJyA6ICdyaWdodE9wJ10gPSAnPj0nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZ2VbaGFzTGVmdCA/ICdsZWZ0T3AnIDogJ3JpZ2h0T3AnXSA9ICc+JztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRva2Vuc1syXS52YWx1ZSA9PT0gMHgwMDNkKSB7XG4gICAgICByYW5nZVtoYXNMZWZ0ID8gJ2xlZnRPcCcgOiAncmlnaHRPcCddID0gJz0nO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcmFuZ2UnKTtcbiAgICB9XG5cbiAgICBpZiAoaGFzTGVmdCkge1xuICAgICAgcmFuZ2UubGVmdFRva2VuID0gdG9rZW5zWzFdO1xuICAgIH0gZWxzZSBpZiAodG9rZW5zWzFdLnR5cGUgPT09ICc8aWRlbnQtdG9rZW4+Jykge1xuICAgICAgcmFuZ2UuZmVhdHVyZU5hbWUgPSB0b2tlbnNbMV0udmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByYW5nZScpO1xuICAgIH1cblxuICAgIHZhciB0b2tlbkluZGV4QWZ0ZXJGaXJzdE9wID0gMiArICgoX2IgPSAoX2EgPSByYW5nZVtoYXNMZWZ0ID8gJ2xlZnRPcCcgOiAncmlnaHRPcCddKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKTtcbiAgICB2YXIgdG9rZW5BZnRlckZpcnN0T3AgPSB0b2tlbnNbdG9rZW5JbmRleEFmdGVyRmlyc3RPcF07XG5cbiAgICBpZiAoaGFzTGVmdCkge1xuICAgICAgaWYgKHRva2VuQWZ0ZXJGaXJzdE9wLnR5cGUgPT09ICc8aWRlbnQtdG9rZW4+Jykge1xuICAgICAgICByYW5nZS5mZWF0dXJlTmFtZSA9IHRva2VuQWZ0ZXJGaXJzdE9wLnZhbHVlO1xuXG4gICAgICAgIGlmICh0b2tlbnMubGVuZ3RoID49IDcpIHtcbiAgICAgICAgICB2YXIgc2Vjb25kT3BUb2tlbiA9IHRva2Vuc1t0b2tlbkluZGV4QWZ0ZXJGaXJzdE9wICsgMV07XG4gICAgICAgICAgdmFyIGZvbGxvd2luZ1Rva2VuID0gdG9rZW5zW3Rva2VuSW5kZXhBZnRlckZpcnN0T3AgKyAyXTtcblxuICAgICAgICAgIGlmIChzZWNvbmRPcFRva2VuLnR5cGUgPT09ICc8ZGVsaW0tdG9rZW4+Jykge1xuICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gc2Vjb25kT3BUb2tlbi52YWx1ZTtcblxuICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09PSAweDAwM2MpIHtcbiAgICAgICAgICAgICAgaWYgKGZvbGxvd2luZ1Rva2VuLnR5cGUgPT09ICc8ZGVsaW0tdG9rZW4+JyAmJiBmb2xsb3dpbmdUb2tlbi52YWx1ZSA9PT0gMHgwMDNkICYmICFmb2xsb3dpbmdUb2tlbi53c0JlZm9yZSkge1xuICAgICAgICAgICAgICAgIHJhbmdlLnJpZ2h0T3AgPSAnPD0nO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJhbmdlLnJpZ2h0T3AgPSAnPCc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUgPT09IDB4MDAzZSkge1xuICAgICAgICAgICAgICBpZiAoZm9sbG93aW5nVG9rZW4udHlwZSA9PT0gJzxkZWxpbS10b2tlbj4nICYmIGZvbGxvd2luZ1Rva2VuLnZhbHVlID09PSAweDAwM2QgJiYgIWZvbGxvd2luZ1Rva2VuLndzQmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgcmFuZ2UucmlnaHRPcCA9ICc+PSc7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmFuZ2UucmlnaHRPcCA9ICc+JztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJhbmdlJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0b2tlbkFmdGVyU2Vjb25kT3AgPSB0b2tlbnNbdG9rZW5JbmRleEFmdGVyRmlyc3RPcCArIDEgKyAoKF9kID0gKF9jID0gcmFuZ2UucmlnaHRPcCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmxlbmd0aCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogMCldO1xuICAgICAgICAgICAgcmFuZ2UucmlnaHRUb2tlbiA9IHRva2VuQWZ0ZXJTZWNvbmRPcDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJhbmdlJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRva2VuSW5kZXhBZnRlckZpcnN0T3AgKyAyICE9PSB0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJhbmdlJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByYW5nZScpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZS5yaWdodFRva2VuID0gdG9rZW5BZnRlckZpcnN0T3A7XG4gICAgfVxuXG4gICAgdmFyIHZhbGlkUmFuZ2UgPSBudWxsO1xuICAgIHZhciBsdCA9IHJhbmdlLmxlZnRUb2tlbixcbiAgICAgICAgbGVmdE9wID0gcmFuZ2UubGVmdE9wLFxuICAgICAgICBmZWF0dXJlTmFtZSA9IHJhbmdlLmZlYXR1cmVOYW1lLFxuICAgICAgICByaWdodE9wID0gcmFuZ2UucmlnaHRPcCxcbiAgICAgICAgcnQgPSByYW5nZS5yaWdodFRva2VuO1xuICAgIHZhciBsZWZ0VG9rZW4gPSBudWxsO1xuXG4gICAgaWYgKGx0ICE9PSBudWxsKSB7XG4gICAgICBpZiAobHQudHlwZSA9PT0gJzxpZGVudC10b2tlbj4nKSB7XG4gICAgICAgIHZhciB0eXBlID0gbHQudHlwZSxcbiAgICAgICAgICAgIHZhbHVlID0gbHQudmFsdWU7XG5cbiAgICAgICAgaWYgKHZhbHVlID09PSAnaW5maW5pdGUnKSB7XG4gICAgICAgICAgbGVmdFRva2VuID0ge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobHQudHlwZSA9PT0gJzxudW1iZXItdG9rZW4+JyB8fCBsdC50eXBlID09PSAnPGRpbWVuc2lvbi10b2tlbj4nIHx8IGx0LnR5cGUgPT09ICc8cmF0aW8tdG9rZW4+Jykge1xuICAgICAgICBsdC53c0JlZm9yZTtcbiAgICAgICAgICAgIGx0LndzQWZ0ZXI7XG4gICAgICAgICAgICB2YXIgbHROb1dTID0gX19yZXN0KGx0LCBbXCJ3c0JlZm9yZVwiLCBcIndzQWZ0ZXJcIl0pO1xuXG4gICAgICAgIGxlZnRUb2tlbiA9IGx0Tm9XUztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmlnaHRUb2tlbiA9IG51bGw7XG5cbiAgICBpZiAocnQgIT09IG51bGwpIHtcbiAgICAgIGlmIChydC50eXBlID09PSAnPGlkZW50LXRva2VuPicpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBydC50eXBlLFxuICAgICAgICAgICAgdmFsdWUgPSBydC52YWx1ZTtcblxuICAgICAgICBpZiAodmFsdWUgPT09ICdpbmZpbml0ZScpIHtcbiAgICAgICAgICByaWdodFRva2VuID0ge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocnQudHlwZSA9PT0gJzxudW1iZXItdG9rZW4+JyB8fCBydC50eXBlID09PSAnPGRpbWVuc2lvbi10b2tlbj4nIHx8IHJ0LnR5cGUgPT09ICc8cmF0aW8tdG9rZW4+Jykge1xuICAgICAgICBydC53c0JlZm9yZTtcbiAgICAgICAgICAgIHJ0LndzQWZ0ZXI7XG4gICAgICAgICAgICB2YXIgcnROb1dTID0gX19yZXN0KHJ0LCBbXCJ3c0JlZm9yZVwiLCBcIndzQWZ0ZXJcIl0pO1xuXG4gICAgICAgIHJpZ2h0VG9rZW4gPSBydE5vV1M7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGxlZnRUb2tlbiAhPT0gbnVsbCAmJiByaWdodFRva2VuICE9PSBudWxsKSB7XG4gICAgICBpZiAoKGxlZnRPcCA9PT0gJzwnIHx8IGxlZnRPcCA9PT0gJzw9JykgJiYgKHJpZ2h0T3AgPT09ICc8JyB8fCByaWdodE9wID09PSAnPD0nKSkge1xuICAgICAgICB2YWxpZFJhbmdlID0ge1xuICAgICAgICAgIGxlZnRUb2tlbjogbGVmdFRva2VuLFxuICAgICAgICAgIGxlZnRPcDogbGVmdE9wLFxuICAgICAgICAgIGZlYXR1cmVOYW1lOiBmZWF0dXJlTmFtZSxcbiAgICAgICAgICByaWdodE9wOiByaWdodE9wLFxuICAgICAgICAgIHJpZ2h0VG9rZW46IHJpZ2h0VG9rZW5cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoKGxlZnRPcCA9PT0gJz4nIHx8IGxlZnRPcCA9PT0gJz49JykgJiYgKHJpZ2h0T3AgPT09ICc+JyB8fCByaWdodE9wID09PSAnPj0nKSkge1xuICAgICAgICB2YWxpZFJhbmdlID0ge1xuICAgICAgICAgIGxlZnRUb2tlbjogbGVmdFRva2VuLFxuICAgICAgICAgIGxlZnRPcDogbGVmdE9wLFxuICAgICAgICAgIGZlYXR1cmVOYW1lOiBmZWF0dXJlTmFtZSxcbiAgICAgICAgICByaWdodE9wOiByaWdodE9wLFxuICAgICAgICAgIHJpZ2h0VG9rZW46IHJpZ2h0VG9rZW5cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByYW5nZScpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGVmdFRva2VuID09PSBudWxsICYmIGxlZnRPcCA9PT0gbnVsbCAmJiByaWdodE9wICE9PSBudWxsICYmIHJpZ2h0VG9rZW4gIT09IG51bGwpIHtcbiAgICAgIHZhbGlkUmFuZ2UgPSB7XG4gICAgICAgIGxlZnRUb2tlbjogbGVmdFRva2VuLFxuICAgICAgICBsZWZ0T3A6IGxlZnRPcCxcbiAgICAgICAgZmVhdHVyZU5hbWU6IGZlYXR1cmVOYW1lLFxuICAgICAgICByaWdodE9wOiByaWdodE9wLFxuICAgICAgICByaWdodFRva2VuOiByaWdodFRva2VuXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAobGVmdFRva2VuICE9PSBudWxsICYmIGxlZnRPcCAhPT0gbnVsbCAmJiByaWdodE9wID09PSBudWxsICYmIHJpZ2h0VG9rZW4gPT09IG51bGwpIHtcbiAgICAgIHZhbGlkUmFuZ2UgPSB7XG4gICAgICAgIGxlZnRUb2tlbjogbGVmdFRva2VuLFxuICAgICAgICBsZWZ0T3A6IGxlZnRPcCxcbiAgICAgICAgZmVhdHVyZU5hbWU6IGZlYXR1cmVOYW1lLFxuICAgICAgICByaWdodE9wOiByaWdodE9wLFxuICAgICAgICByaWdodFRva2VuOiByaWdodFRva2VuXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB2YWxpZFJhbmdlO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByYW5nZScpO1xuICB9XG59O1xuXG5leHBvcnQgeyBjb25zdW1lRXNjYXBlLCBjb25zdW1lSWRlbnQsIGNvbnN1bWVJZGVudExpa2UsIGNvbnN1bWVJZGVudFVuc2FmZSwgY29uc3VtZU51bWJlciwgY29uc3VtZU51bWVyaWMsIGNvbnN1bWVTdHJpbmcsIGNvbnN1bWVVcmwsIGxleGljYWxBbmFseXNpcywgcmVtb3ZlV2hpdGVzcGFjZSwgc3ludGFjdGljQW5hbHlzaXMsIHRvQVNULCB0b1VuZmxhdHRlbmVkQVNULCB0b2tlbml6ZU1lZGlhQ29uZGl0aW9uLCB0b2tlbml6ZU1lZGlhRmVhdHVyZSwgdG9rZW5pemVNZWRpYVF1ZXJ5LCB0b2tlbml6ZVJhbmdlLCB3b3VsZFN0YXJ0SWRlbnRpZmllciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWVkaWEtcXVlcnktcGFyc2VyLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6WyJfX2Fzc2lnbiIsIk9iamVjdCIsImFzc2lnbiIsInQiLCJzIiwiaSIsIm4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJwIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXBwbHkiLCJfX3Jlc3QiLCJlIiwiaW5kZXhPZiIsImdldE93blByb3BlcnR5U3ltYm9scyIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiX192YWx1ZXMiLCJvIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJtIiwibmV4dCIsInZhbHVlIiwiZG9uZSIsIlR5cGVFcnJvciIsIl9fcmVhZCIsInIiLCJhciIsInB1c2giLCJlcnJvciIsIndlaXJkTmV3bGluZXMiLCJudWxsT3JTdXJyb2dhdGVzIiwiY29tbWVudFJlZ2V4IiwibGV4aWNhbEFuYWx5c2lzIiwic3RyIiwiaW5kZXgiLCJyZXBsYWNlIiwidG9rZW5zIiwiY29kZSIsImNoYXJDb2RlQXQiLCJjb2RlXzEiLCJ0eXBlIiwicmVzdWx0IiwiY29uc3VtZVN0cmluZyIsIl9hIiwibGFzdEluZGV4IiwibmV4dENvZGUiLCJmbGFnIiwid291bGRTdGFydElkZW50aWZpZXIiLCJjb25zdW1lSWRlbnRVbnNhZmUiLCJfYiIsInRvTG93ZXJDYXNlIiwiX2MiLCJwbHVzTnVtZXJpYyIsImNvbnN1bWVOdW1lcmljIiwiX2QiLCJ0b2tlblR1cGxlIiwidW5pdCIsIm1pbnVzTnVtZXJpYyIsIl9lIiwibmV4dE5leHRDb2RlIiwiY29uc3VtZUlkZW50TGlrZSIsIl9mIiwiX2ciLCJuZXh0TmV4dE5leHRDb2RlIiwiY29uc3VtZUlkZW50IiwiX2giLCJjb25zdW1lRXNjYXBlIiwiX2oiLCJzbGljZSIsIl9rIiwiX2wiLCJmaXJzdENvZGUiLCJjaGFyQ29kZXMiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJjaGFyQ29kZSIsImhleENoYXJDb2RlcyIsIm1pbiIsIk1hdGgiLCJjb2RlXzIiLCJjb2RlXzMiLCJwYXJzZUludCIsIm51bWJlclJlc3VsdCIsImNvbnN1bWVOdW1iZXIiLCJudW1iZXJFbmRJbmRleCIsIm51bWJlclZhbHVlIiwibnVtYmVyRmxhZyIsImlkZW50UmVzdWx0IiwiaWRlbnRFbmRJbmRleCIsImlkZW50VmFsdWUiLCJudW1iZXJDaGFycyIsIm5leHROZXh0SXNEaWdpdCIsIm51bWJlclN0cmluZyIsInBhcnNlRmxvYXQiLCJOdW1iZXIiLCJpc05hTiIsImlkZW50Q2hhcnMiLCJjb2RlXzQiLCJjb2RlXzUiLCJjb25zdW1lVXJsIiwidXJsQ2hhcnMiLCJoYXNGaW5pc2hlZFdvcmQiLCJvZmZzZXQiLCJyZXN1bHRfMSIsImxhc3RVcmxJbmRleCIsInZhbHVlXzEiLCJzaW1wbGlmeUFTVCIsImFzdCIsInNpbXBsaWZ5TWVkaWFRdWVyeSIsIm1lZGlhUXVlcnkiLCJtZWRpYUNvbmRpdGlvbiIsInNpbXBsaWZ5TWVkaWFDb25kaXRpb24iLCJvcGVyYXRvciIsImNoaWxkcmVuIiwibWVkaWFQcmVmaXgiLCJtZWRpYVR5cGUiLCJ1bnNpbXBsaWZpZWRDaGlsZCIsImNoaWxkIiwic3BsaWNlQXJncyIsImlfMSIsInNwbGljZSIsImNyZWF0ZUVycm9yIiwibWVzc2FnZSIsImVyciIsIkVycm9yIiwiY29uY2F0IiwidHJpbSIsInRvQVNUIiwidG9VbmZsYXR0ZW5lZEFTVCIsInRva2VuTGlzdCIsInN0YXJ0SW5kZXgiLCJlbmRJbmRleCIsInRva2VuIiwic3ludGFjdGljQW5hbHlzaXMiLCJyZW1vdmVXaGl0ZXNwYWNlIiwibmV3VG9rZW5MaXN0IiwiYmVmb3JlIiwid3NBZnRlciIsIndzQmVmb3JlIiwiZV8xIiwibWVkaWFRdWVyeUxpc3QiLCJtZWRpYVF1ZXJpZXMiLCJtYXAiLCJtZWRpYVF1ZXJ5VG9rZW5zIiwidG9rZW5pemVNZWRpYVF1ZXJ5Iiwibm9uTnVsbE1lZGlhUXVlcnlUb2tlbnMiLCJtZWRpYVF1ZXJ5VG9rZW5zXzEiLCJtZWRpYVF1ZXJ5VG9rZW5zXzFfMSIsIm1lZGlhUXVlcnlUb2tlbiIsImVfMV8xIiwiZmlyc3RUb2tlbiIsInRva2VuaXplTWVkaWFDb25kaXRpb24iLCJmaXJzdEluZGV4IiwiZmlyc3ROb25VbmFyeVRva2VuIiwidG9rZW5zV2l0aFBhcmVucyIsInNlY29uZE5vblVuYXJ5VG9rZW4iLCJtYXlDb250YWluT3IiLCJwcmV2aW91c09wZXJhdG9yIiwiZW5kSW5kZXhPZkZpcnN0RmVhdHVyZSIsIm1heERlcHRoIiwiY291bnQiLCJtYXgiLCJmZWF0dXJlVG9rZW5zIiwidG9rZW5pemVNZWRpYUZlYXR1cmUiLCJuZXh0VG9rZW4iLCJzaWJsaW5ncyIsInJhd1Rva2VucyIsImEiLCJiIiwiYyIsIm51bWVyYXRvciIsImRlbm9taW5hdG9yIiwiY29udGV4dCIsImZlYXR1cmUiLCJ2YWx1ZVRva2VuIiwicHJlZml4IiwicmFuZ2UiLCJ0b2tlbml6ZVJhbmdlIiwiZmVhdHVyZU5hbWUiLCJsZWZ0VG9rZW4iLCJsZWZ0T3AiLCJyaWdodE9wIiwicmlnaHRUb2tlbiIsImhhc0xlZnQiLCJ0b2tlbkluZGV4QWZ0ZXJGaXJzdE9wIiwidG9rZW5BZnRlckZpcnN0T3AiLCJzZWNvbmRPcFRva2VuIiwiZm9sbG93aW5nVG9rZW4iLCJ0b2tlbkFmdGVyU2Vjb25kT3AiLCJ2YWxpZFJhbmdlIiwibHQiLCJydCIsImx0Tm9XUyIsInJ0Tm9XUyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/media-query-parser@2.0.2/node_modules/media-query-parser/dist/media-query-parser.esm.js\n");

/***/ })

};
;