"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@mysten+bcs@0.11.1";
exports.ids = ["vendor-chunks/@mysten+bcs@0.11.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/b58.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/b58.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromB58: () => (/* binding */ fromB58),\n/* harmony export */   toB58: () => (/* binding */ toB58)\n/* harmony export */ });\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bs58 */ \"(ssr)/./node_modules/.pnpm/bs58@5.0.0/node_modules/bs58/index.js\");\n\nconst toB58 = (buffer)=>bs58__WEBPACK_IMPORTED_MODULE_0__.encode(buffer);\nconst fromB58 = (str)=>bs58__WEBPACK_IMPORTED_MODULE_0__.decode(str);\n //# sourceMappingURL=b58.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG15c3RlbitiY3NAMC4xMS4xL25vZGVfbW9kdWxlcy9AbXlzdGVuL2Jjcy9kaXN0L2VzbS9iNTguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXdCO0FBQ3hCLE1BQU1DLFFBQVEsQ0FBQ0MsU0FBV0Ysd0NBQVcsQ0FBQ0U7QUFDdEMsTUFBTUUsVUFBVSxDQUFDQyxNQUFRTCx3Q0FBVyxDQUFDSztBQUluQyxDQUNGLCtCQUErQiIsInNvdXJjZXMiOlsid2VicGFjazovL25vdGFzY2FtLXByb3RvY29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BteXN0ZW4rYmNzQDAuMTEuMS9ub2RlX21vZHVsZXMvQG15c3Rlbi9iY3MvZGlzdC9lc20vYjU4LmpzP2MzZmYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGJzNTggZnJvbSBcImJzNThcIjtcbmNvbnN0IHRvQjU4ID0gKGJ1ZmZlcikgPT4gYnM1OC5lbmNvZGUoYnVmZmVyKTtcbmNvbnN0IGZyb21CNTggPSAoc3RyKSA9PiBiczU4LmRlY29kZShzdHIpO1xuZXhwb3J0IHtcbiAgZnJvbUI1OCxcbiAgdG9CNThcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iNTguanMubWFwXG4iXSwibmFtZXMiOlsiYnM1OCIsInRvQjU4IiwiYnVmZmVyIiwiZW5jb2RlIiwiZnJvbUI1OCIsInN0ciIsImRlY29kZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/b58.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/b64.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/b64.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromB64: () => (/* binding */ fromB64),\n/* harmony export */   toB64: () => (/* binding */ toB64)\n/* harmony export */ });\nfunction fromB64(base64String) {\n    return Uint8Array.from(atob(base64String), (char)=>char.charCodeAt(0));\n}\nconst CHUNK_SIZE = 8192;\nfunction toB64(bytes) {\n    if (bytes.length < CHUNK_SIZE) {\n        return btoa(String.fromCharCode(...bytes));\n    }\n    let output = \"\";\n    for(var i = 0; i < bytes.length; i += CHUNK_SIZE){\n        const chunk = bytes.slice(i, i + CHUNK_SIZE);\n        output += String.fromCharCode(...chunk);\n    }\n    return btoa(output);\n}\n //# sourceMappingURL=b64.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG15c3RlbitiY3NAMC4xMS4xL25vZGVfbW9kdWxlcy9AbXlzdGVuL2Jjcy9kaXN0L2VzbS9iNjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxTQUFTQSxRQUFRQyxZQUFZO0lBQzNCLE9BQU9DLFdBQVdDLElBQUksQ0FBQ0MsS0FBS0gsZUFBZSxDQUFDSSxPQUFTQSxLQUFLQyxVQUFVLENBQUM7QUFDdkU7QUFDQSxNQUFNQyxhQUFhO0FBQ25CLFNBQVNDLE1BQU1DLEtBQUs7SUFDbEIsSUFBSUEsTUFBTUMsTUFBTSxHQUFHSCxZQUFZO1FBQzdCLE9BQU9JLEtBQUtDLE9BQU9DLFlBQVksSUFBSUo7SUFDckM7SUFDQSxJQUFJSyxTQUFTO0lBQ2IsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlOLE1BQU1DLE1BQU0sRUFBRUssS0FBS1IsV0FBWTtRQUNqRCxNQUFNUyxRQUFRUCxNQUFNUSxLQUFLLENBQUNGLEdBQUdBLElBQUlSO1FBQ2pDTyxVQUFVRixPQUFPQyxZQUFZLElBQUlHO0lBQ25DO0lBQ0EsT0FBT0wsS0FBS0c7QUFDZDtBQUlFLENBQ0YsK0JBQStCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbm90YXNjYW0tcHJvdG9jb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vQG15c3RlbitiY3NAMC4xMS4xL25vZGVfbW9kdWxlcy9AbXlzdGVuL2Jjcy9kaXN0L2VzbS9iNjQuanM/OWZjZCJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBmcm9tQjY0KGJhc2U2NFN0cmluZykge1xuICByZXR1cm4gVWludDhBcnJheS5mcm9tKGF0b2IoYmFzZTY0U3RyaW5nKSwgKGNoYXIpID0+IGNoYXIuY2hhckNvZGVBdCgwKSk7XG59XG5jb25zdCBDSFVOS19TSVpFID0gODE5MjtcbmZ1bmN0aW9uIHRvQjY0KGJ5dGVzKSB7XG4gIGlmIChieXRlcy5sZW5ndGggPCBDSFVOS19TSVpFKSB7XG4gICAgcmV0dXJuIGJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZSguLi5ieXRlcykpO1xuICB9XG4gIGxldCBvdXRwdXQgPSBcIlwiO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSBDSFVOS19TSVpFKSB7XG4gICAgY29uc3QgY2h1bmsgPSBieXRlcy5zbGljZShpLCBpICsgQ0hVTktfU0laRSk7XG4gICAgb3V0cHV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoLi4uY2h1bmspO1xuICB9XG4gIHJldHVybiBidG9hKG91dHB1dCk7XG59XG5leHBvcnQge1xuICBmcm9tQjY0LFxuICB0b0I2NFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWI2NC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJmcm9tQjY0IiwiYmFzZTY0U3RyaW5nIiwiVWludDhBcnJheSIsImZyb20iLCJhdG9iIiwiY2hhciIsImNoYXJDb2RlQXQiLCJDSFVOS19TSVpFIiwidG9CNjQiLCJieXRlcyIsImxlbmd0aCIsImJ0b2EiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJvdXRwdXQiLCJpIiwiY2h1bmsiLCJzbGljZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/b64.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/bcs-type.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/bcs-type.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BcsType: () => (/* binding */ BcsType),\n/* harmony export */   SerializedBcs: () => (/* binding */ SerializedBcs),\n/* harmony export */   bigUIntBcsType: () => (/* binding */ bigUIntBcsType),\n/* harmony export */   dynamicSizeBcsType: () => (/* binding */ dynamicSizeBcsType),\n/* harmony export */   fixedSizeBcsType: () => (/* binding */ fixedSizeBcsType),\n/* harmony export */   isSerializedBcs: () => (/* binding */ isSerializedBcs),\n/* harmony export */   lazyBcsType: () => (/* binding */ lazyBcsType),\n/* harmony export */   stringLikeBcsType: () => (/* binding */ stringLikeBcsType),\n/* harmony export */   uIntBcsType: () => (/* binding */ uIntBcsType)\n/* harmony export */ });\n/* harmony import */ var _b58_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./b58.js */ \"(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/b58.js\");\n/* harmony import */ var _b64_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./b64.js */ \"(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/b64.js\");\n/* harmony import */ var _hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hex.js */ \"(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/hex.js\");\n/* harmony import */ var _reader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./reader.js */ \"(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/reader.js\");\n/* harmony import */ var _uleb_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./uleb.js */ \"(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/uleb.js\");\n/* harmony import */ var _writer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./writer.js */ \"(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/writer.js\");\nvar __accessCheck = (obj, member, msg)=>{\n    if (!member.has(obj)) throw TypeError(\"Cannot \" + msg);\n};\nvar __privateGet = (obj, member, getter)=>{\n    __accessCheck(obj, member, \"read from private field\");\n    return getter ? getter.call(obj) : member.get(obj);\n};\nvar __privateAdd = (obj, member, value)=>{\n    if (member.has(obj)) throw TypeError(\"Cannot add the same private member more than once\");\n    member instanceof WeakSet ? member.add(obj) : member.set(obj, value);\n};\nvar __privateSet = (obj, member, value, setter)=>{\n    __accessCheck(obj, member, \"write to private field\");\n    setter ? setter.call(obj, value) : member.set(obj, value);\n    return value;\n};\nvar _write, _serialize, _schema, _bytes;\n\n\n\n\n\n\nconst _BcsType = class {\n    constructor(options){\n        __privateAdd(this, _write, void 0);\n        __privateAdd(this, _serialize, void 0);\n        this.name = options.name;\n        this.read = options.read;\n        this.serializedSize = options.serializedSize ?? (()=>null);\n        __privateSet(this, _write, options.write);\n        __privateSet(this, _serialize, options.serialize ?? ((value, options2)=>{\n            const writer = new _writer_js__WEBPACK_IMPORTED_MODULE_0__.BcsWriter({\n                size: this.serializedSize(value) ?? void 0,\n                ...options2\n            });\n            __privateGet(this, _write).call(this, value, writer);\n            return writer.toBytes();\n        }));\n        this.validate = options.validate ?? (()=>{});\n    }\n    write(value, writer) {\n        this.validate(value);\n        __privateGet(this, _write).call(this, value, writer);\n    }\n    serialize(value, options) {\n        this.validate(value);\n        return new SerializedBcs(this, __privateGet(this, _serialize).call(this, value, options));\n    }\n    parse(bytes) {\n        const reader = new _reader_js__WEBPACK_IMPORTED_MODULE_1__.BcsReader(bytes);\n        return this.read(reader);\n    }\n    transform({ name, input, output }) {\n        return new _BcsType({\n            name: name ?? this.name,\n            read: (reader)=>output(this.read(reader)),\n            write: (value, writer)=>__privateGet(this, _write).call(this, input(value), writer),\n            serializedSize: (value)=>this.serializedSize(input(value)),\n            serialize: (value, options)=>__privateGet(this, _serialize).call(this, input(value), options),\n            validate: (value)=>this.validate(input(value))\n        });\n    }\n};\nlet BcsType = _BcsType;\n_write = new WeakMap();\n_serialize = new WeakMap();\nconst SERIALIZED_BCS_BRAND = Symbol.for(\"@mysten/serialized-bcs\");\nfunction isSerializedBcs(obj) {\n    return !!obj && typeof obj === \"object\" && obj[SERIALIZED_BCS_BRAND] === true;\n}\nclass SerializedBcs {\n    constructor(type, schema){\n        __privateAdd(this, _schema, void 0);\n        __privateAdd(this, _bytes, void 0);\n        __privateSet(this, _schema, type);\n        __privateSet(this, _bytes, schema);\n    }\n    // Used to brand SerializedBcs so that they can be identified, even between multiple copies\n    // of the @mysten/bcs package are installed\n    get [SERIALIZED_BCS_BRAND]() {\n        return true;\n    }\n    toBytes() {\n        return __privateGet(this, _bytes);\n    }\n    toHex() {\n        return (0,_hex_js__WEBPACK_IMPORTED_MODULE_2__.toHEX)(__privateGet(this, _bytes));\n    }\n    toBase64() {\n        return (0,_b64_js__WEBPACK_IMPORTED_MODULE_3__.toB64)(__privateGet(this, _bytes));\n    }\n    toBase58() {\n        return (0,_b58_js__WEBPACK_IMPORTED_MODULE_4__.toB58)(__privateGet(this, _bytes));\n    }\n    parse() {\n        return __privateGet(this, _schema).parse(__privateGet(this, _bytes));\n    }\n}\n_schema = new WeakMap();\n_bytes = new WeakMap();\nfunction fixedSizeBcsType({ size, ...options }) {\n    return new BcsType({\n        ...options,\n        serializedSize: ()=>size\n    });\n}\nfunction uIntBcsType({ readMethod, writeMethod, ...options }) {\n    return fixedSizeBcsType({\n        ...options,\n        read: (reader)=>reader[readMethod](),\n        write: (value, writer)=>writer[writeMethod](value),\n        validate: (value)=>{\n            if (value < 0 || value > options.maxValue) {\n                throw new TypeError(`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`);\n            }\n            options.validate?.(value);\n        }\n    });\n}\nfunction bigUIntBcsType({ readMethod, writeMethod, ...options }) {\n    return fixedSizeBcsType({\n        ...options,\n        read: (reader)=>reader[readMethod](),\n        write: (value, writer)=>writer[writeMethod](BigInt(value)),\n        validate: (val)=>{\n            const value = BigInt(val);\n            if (value < 0 || value > options.maxValue) {\n                throw new TypeError(`Invalid ${options.name} value: ${value}. Expected value in range 0-${options.maxValue}`);\n            }\n            options.validate?.(value);\n        }\n    });\n}\nfunction dynamicSizeBcsType({ serialize, ...options }) {\n    const type = new BcsType({\n        ...options,\n        serialize,\n        write: (value, writer)=>{\n            for (const byte of type.serialize(value).toBytes()){\n                writer.write8(byte);\n            }\n        }\n    });\n    return type;\n}\nfunction stringLikeBcsType({ toBytes, fromBytes, ...options }) {\n    return new BcsType({\n        ...options,\n        read: (reader)=>{\n            const length = reader.readULEB();\n            const bytes = reader.readBytes(length);\n            return fromBytes(bytes);\n        },\n        write: (hex, writer)=>{\n            const bytes = toBytes(hex);\n            writer.writeULEB(bytes.length);\n            for(let i = 0; i < bytes.length; i++){\n                writer.write8(bytes[i]);\n            }\n        },\n        serialize: (value)=>{\n            const bytes = toBytes(value);\n            const size = (0,_uleb_js__WEBPACK_IMPORTED_MODULE_5__.ulebEncode)(bytes.length);\n            const result = new Uint8Array(size.length + bytes.length);\n            result.set(size, 0);\n            result.set(bytes, size.length);\n            return result;\n        },\n        validate: (value)=>{\n            if (typeof value !== \"string\") {\n                throw new TypeError(`Invalid ${options.name} value: ${value}. Expected string`);\n            }\n            options.validate?.(value);\n        }\n    });\n}\nfunction lazyBcsType(cb) {\n    let lazyType = null;\n    function getType() {\n        if (!lazyType) {\n            lazyType = cb();\n        }\n        return lazyType;\n    }\n    return new BcsType({\n        name: \"lazy\",\n        read: (data)=>getType().read(data),\n        serializedSize: (value)=>getType().serializedSize(value),\n        write: (value, writer)=>getType().write(value, writer),\n        serialize: (value, options)=>getType().serialize(value, options).toBytes()\n    });\n}\n //# sourceMappingURL=bcs-type.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG15c3RlbitiY3NAMC4xMS4xL25vZGVfbW9kdWxlcy9AbXlzdGVuL2Jjcy9kaXN0L2VzbS9iY3MtdHlwZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxJQUFJQSxnQkFBZ0IsQ0FBQ0MsS0FBS0MsUUFBUUM7SUFDaEMsSUFBSSxDQUFDRCxPQUFPRSxHQUFHLENBQUNILE1BQ2QsTUFBTUksVUFBVSxZQUFZRjtBQUNoQztBQUNBLElBQUlHLGVBQWUsQ0FBQ0wsS0FBS0MsUUFBUUs7SUFDL0JQLGNBQWNDLEtBQUtDLFFBQVE7SUFDM0IsT0FBT0ssU0FBU0EsT0FBT0MsSUFBSSxDQUFDUCxPQUFPQyxPQUFPTyxHQUFHLENBQUNSO0FBQ2hEO0FBQ0EsSUFBSVMsZUFBZSxDQUFDVCxLQUFLQyxRQUFRUztJQUMvQixJQUFJVCxPQUFPRSxHQUFHLENBQUNILE1BQ2IsTUFBTUksVUFBVTtJQUNsQkgsa0JBQWtCVSxVQUFVVixPQUFPVyxHQUFHLENBQUNaLE9BQU9DLE9BQU9ZLEdBQUcsQ0FBQ2IsS0FBS1U7QUFDaEU7QUFDQSxJQUFJSSxlQUFlLENBQUNkLEtBQUtDLFFBQVFTLE9BQU9LO0lBQ3RDaEIsY0FBY0MsS0FBS0MsUUFBUTtJQUMzQmMsU0FBU0EsT0FBT1IsSUFBSSxDQUFDUCxLQUFLVSxTQUFTVCxPQUFPWSxHQUFHLENBQUNiLEtBQUtVO0lBQ25ELE9BQU9BO0FBQ1Q7QUFDQSxJQUFJTSxRQUFRQyxZQUFZQyxTQUFTQztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0Q7QUFDQztBQUN4QyxNQUFNTyxXQUFXO0lBQ2ZDLFlBQVlDLE9BQU8sQ0FBRTtRQUNuQm5CLGFBQWEsSUFBSSxFQUFFTyxRQUFRLEtBQUs7UUFDaENQLGFBQWEsSUFBSSxFQUFFUSxZQUFZLEtBQUs7UUFDcEMsSUFBSSxDQUFDWSxJQUFJLEdBQUdELFFBQVFDLElBQUk7UUFDeEIsSUFBSSxDQUFDQyxJQUFJLEdBQUdGLFFBQVFF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YWNrOi8vbm90YXNjYW0tcHJvdG9jb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vQG15c3RlbitiY3NAMC4xMS4xL25vZGVfbW9kdWxlcy9AbXlzdGVuL2Jjcy9kaXN0L2VzbS9iY3MtdHlwZS5qcz9hYzcyIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2FjY2Vzc0NoZWNrID0gKG9iaiwgbWVtYmVyLCBtc2cpID0+IHtcbiAgaWYgKCFtZW1iZXIuaGFzKG9iaikpXG4gICAgdGhyb3cgVHlwZUVycm9yKFwiQ2Fubm90IFwiICsgbXNnKTtcbn07XG52YXIgX19wcml2YXRlR2V0ID0gKG9iaiwgbWVtYmVyLCBnZXR0ZXIpID0+IHtcbiAgX19hY2Nlc3NDaGVjayhvYmosIG1lbWJlciwgXCJyZWFkIGZyb20gcHJpdmF0ZSBmaWVsZFwiKTtcbiAgcmV0dXJuIGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiBtZW1iZXIuZ2V0KG9iaik7XG59O1xudmFyIF9fcHJpdmF0ZUFkZCA9IChvYmosIG1lbWJlciwgdmFsdWUpID0+IHtcbiAgaWYgKG1lbWJlci5oYXMob2JqKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJDYW5ub3QgYWRkIHRoZSBzYW1lIHByaXZhdGUgbWVtYmVyIG1vcmUgdGhhbiBvbmNlXCIpO1xuICBtZW1iZXIgaW5zdGFuY2VvZiBXZWFrU2V0ID8gbWVtYmVyLmFkZChvYmopIDogbWVtYmVyLnNldChvYmosIHZhbHVlKTtcbn07XG52YXIgX19wcml2YXRlU2V0ID0gKG9iaiwgbWVtYmVyLCB2YWx1ZSwgc2V0dGVyKSA9PiB7XG4gIF9fYWNjZXNzQ2hlY2sob2JqLCBtZW1iZXIsIFwid3JpdGUgdG8gcHJpdmF0ZSBmaWVsZFwiKTtcbiAgc2V0dGVyID8gc2V0dGVyLmNhbGwob2JqLCB2YWx1ZSkgOiBtZW1iZXIuc2V0KG9iaiwgdmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xudmFyIF93cml0ZSwgX3NlcmlhbGl6ZSwgX3NjaGVtYSwgX2J5dGVzO1xuaW1wb3J0IHsgdG9CNTggfSBmcm9tIFwiLi9iNTguanNcIjtcbmltcG9ydCB7IHRvQjY0IH0gZnJvbSBcIi4vYjY0LmpzXCI7XG5pbXBvcnQgeyB0b0hFWCB9IGZyb20gXCIuL2hleC5qc1wiO1xuaW1wb3J0IHsgQmNzUmVhZGVyIH0gZnJvbSBcIi4vcmVhZGVyLmpzXCI7XG5pbXBvcnQgeyB1bGViRW5jb2RlIH0gZnJvbSBcIi4vdWxlYi5qc1wiO1xuaW1wb3J0IHsgQmNzV3JpdGVyIH0gZnJvbSBcIi4vd3JpdGVyLmpzXCI7XG5jb25zdCBfQmNzVHlwZSA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIF9fcHJpdmF0ZUFkZCh0aGlzLCBfd3JpdGUsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9zZXJpYWxpemUsIHZvaWQgMCk7XG4gICAgdGhpcy5uYW1lID0gb3B0aW9ucy5uYW1lO1xuICAgIHRoaXMucmVhZCA9IG9wdGlvbnMucmVhZDtcbiAgICB0aGlzLnNlcmlhbGl6ZWRTaXplID0gb3B0aW9ucy5zZXJpYWxpemVkU2l6ZSA/PyAoKCkgPT4gbnVsbCk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF93cml0ZSwgb3B0aW9ucy53cml0ZSk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9zZXJpYWxpemUsIG9wdGlvbnMuc2VyaWFsaXplID8/ICgodmFsdWUsIG9wdGlvbnMyKSA9PiB7XG4gICAgICBjb25zdCB3cml0ZXIgPSBuZXcgQmNzV3JpdGVyKHsgc2l6ZTogdGhpcy5zZXJpYWxpemVkU2l6ZSh2YWx1ZSkgPz8gdm9pZCAwLCAuLi5vcHRpb25zMiB9KTtcbiAgICAgIF9fcHJpdmF0ZUdldCh0aGlzLCBfd3JpdGUpLmNhbGwodGhpcywgdmFsdWUsIHdyaXRlcik7XG4gICAgICByZXR1cm4gd3JpdGVyLnRvQnl0ZXMoKTtcbiAgICB9KSk7XG4gICAgdGhpcy52YWxpZGF0ZSA9IG9wdGlvbnMudmFsaWRhdGUgPz8gKCgpID0+IHtcbiAgICB9KTtcbiAgfVxuICB3cml0ZSh2YWx1ZSwgd3JpdGVyKSB7XG4gICAgdGhpcy52YWxpZGF0ZSh2YWx1ZSk7XG4gICAgX19wcml2YXRlR2V0KHRoaXMsIF93cml0ZSkuY2FsbCh0aGlzLCB2YWx1ZSwgd3JpdGVyKTtcbiAgfVxuICBzZXJpYWxpemUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICB0aGlzLnZhbGlkYXRlKHZhbHVlKTtcbiAgICByZXR1cm4gbmV3IFNlcmlhbGl6ZWRCY3ModGhpcywgX19wcml2YXRlR2V0KHRoaXMsIF9zZXJpYWxpemUpLmNhbGwodGhpcywgdmFsdWUsIG9wdGlvbnMpKTtcbiAgfVxuICBwYXJzZShieXRlcykge1xuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBCY3NSZWFkZXIoYnl0ZXMpO1xuICAgIHJldHVybiB0aGlzLnJlYWQocmVhZGVyKTtcbiAgfVxuICB0cmFuc2Zvcm0oe1xuICAgIG5hbWUsXG4gICAgaW5wdXQsXG4gICAgb3V0cHV0XG4gIH0pIHtcbiAgICByZXR1cm4gbmV3IF9CY3NUeXBlKHtcbiAgICAgIG5hbWU6IG5hbWUgPz8gdGhpcy5uYW1lLFxuICAgICAgcmVhZDogKHJlYWRlcikgPT4gb3V0cHV0KHRoaXMucmVhZChyZWFkZXIpKSxcbiAgICAgIHdyaXRlOiAodmFsdWUsIHdyaXRlcikgPT4gX19wcml2YXRlR2V0KHRoaXMsIF93cml0ZSkuY2FsbCh0aGlzLCBpbnB1dCh2YWx1ZSksIHdyaXRlciksXG4gICAgICBzZXJpYWxpemVkU2l6ZTogKHZhbHVlKSA9PiB0aGlzLnNlcmlhbGl6ZWRTaXplKGlucHV0KHZhbHVlKSksXG4gICAgICBzZXJpYWxpemU6ICh2YWx1ZSwgb3B0aW9ucykgPT4gX19wcml2YXRlR2V0KHRoaXMsIF9zZXJpYWxpemUpLmNhbGwodGhpcywgaW5wdXQodmFsdWUpLCBvcHRpb25zKSxcbiAgICAgIHZhbGlkYXRlOiAodmFsdWUpID0+IHRoaXMudmFsaWRhdGUoaW5wdXQodmFsdWUpKVxuICAgIH0pO1xuICB9XG59O1xubGV0IEJjc1R5cGUgPSBfQmNzVHlwZTtcbl93cml0ZSA9IG5ldyBXZWFrTWFwKCk7XG5fc2VyaWFsaXplID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IFNFUklBTElaRURfQkNTX0JSQU5EID0gU3ltYm9sLmZvcihcIkBteXN0ZW4vc2VyaWFsaXplZC1iY3NcIik7XG5mdW5jdGlvbiBpc1NlcmlhbGl6ZWRCY3Mob2JqKSB7XG4gIHJldHVybiAhIW9iaiAmJiB0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiICYmIG9ialtTRVJJQUxJWkVEX0JDU19CUkFORF0gPT09IHRydWU7XG59XG5jbGFzcyBTZXJpYWxpemVkQmNzIHtcbiAgY29uc3RydWN0b3IodHlwZSwgc2NoZW1hKSB7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9zY2hlbWEsIHZvaWQgMCk7XG4gICAgX19wcml2YXRlQWRkKHRoaXMsIF9ieXRlcywgdm9pZCAwKTtcbiAgICBfX3ByaXZhdGVTZXQodGhpcywgX3NjaGVtYSwgdHlwZSk7XG4gICAgX19wcml2YXRlU2V0KHRoaXMsIF9ieXRlcywgc2NoZW1hKTtcbiAgfVxuICAvLyBVc2VkIHRvIGJyYW5kIFNlcmlhbGl6ZWRCY3Mgc28gdGhhdCB0aGV5IGNhbiBiZSBpZGVudGlmaWVkLCBldmVuIGJldHdlZW4gbXVsdGlwbGUgY29waWVzXG4gIC8vIG9mIHRoZSBAbXlzdGVuL2JjcyBwYWNrYWdlIGFyZSBpbnN0YWxsZWRcbiAgZ2V0IFtTRVJJQUxJWkVEX0JDU19CUkFORF0oKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdG9CeXRlcygpIHtcbiAgICByZXR1cm4gX19wcml2YXRlR2V0KHRoaXMsIF9ieXRlcyk7XG4gIH1cbiAgdG9IZXgoKSB7XG4gICAgcmV0dXJuIHRvSEVYKF9fcHJpdmF0ZUdldCh0aGlzLCBfYnl0ZXMpKTtcbiAgfVxuICB0b0Jhc2U2NCgpIHtcbiAgICByZXR1cm4gdG9CNjQoX19wcml2YXRlR2V0KHRoaXMsIF9ieXRlcykpO1xuICB9XG4gIHRvQmFzZTU4KCkge1xuICAgIHJldHVybiB0b0I1OChfX3ByaXZhdGVHZXQodGhpcywgX2J5dGVzKSk7XG4gIH1cbiAgcGFyc2UoKSB7XG4gICAgcmV0dXJuIF9fcHJpdmF0ZUdldCh0aGlzLCBfc2NoZW1hKS5wYXJzZShfX3ByaXZhdGVHZXQodGhpcywgX2J5dGVzKSk7XG4gIH1cbn1cbl9zY2hlbWEgPSBuZXcgV2Vha01hcCgpO1xuX2J5dGVzID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGZpeGVkU2l6ZUJjc1R5cGUoe1xuICBzaXplLFxuICAuLi5vcHRpb25zXG59KSB7XG4gIHJldHVybiBuZXcgQmNzVHlwZSh7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBzZXJpYWxpemVkU2l6ZTogKCkgPT4gc2l6ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIHVJbnRCY3NUeXBlKHtcbiAgcmVhZE1ldGhvZCxcbiAgd3JpdGVNZXRob2QsXG4gIC4uLm9wdGlvbnNcbn0pIHtcbiAgcmV0dXJuIGZpeGVkU2l6ZUJjc1R5cGUoe1xuICAgIC4uLm9wdGlvbnMsXG4gICAgcmVhZDogKHJlYWRlcikgPT4gcmVhZGVyW3JlYWRNZXRob2RdKCksXG4gICAgd3JpdGU6ICh2YWx1ZSwgd3JpdGVyKSA9PiB3cml0ZXJbd3JpdGVNZXRob2RdKHZhbHVlKSxcbiAgICB2YWxpZGF0ZTogKHZhbHVlKSA9PiB7XG4gICAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID4gb3B0aW9ucy5tYXhWYWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIGBJbnZhbGlkICR7b3B0aW9ucy5uYW1lfSB2YWx1ZTogJHt2YWx1ZX0uIEV4cGVjdGVkIHZhbHVlIGluIHJhbmdlIDAtJHtvcHRpb25zLm1heFZhbHVlfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIG9wdGlvbnMudmFsaWRhdGU/Lih2YWx1ZSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGJpZ1VJbnRCY3NUeXBlKHtcbiAgcmVhZE1ldGhvZCxcbiAgd3JpdGVNZXRob2QsXG4gIC4uLm9wdGlvbnNcbn0pIHtcbiAgcmV0dXJuIGZpeGVkU2l6ZUJjc1R5cGUoe1xuICAgIC4uLm9wdGlvbnMsXG4gICAgcmVhZDogKHJlYWRlcikgPT4gcmVhZGVyW3JlYWRNZXRob2RdKCksXG4gICAgd3JpdGU6ICh2YWx1ZSwgd3JpdGVyKSA9PiB3cml0ZXJbd3JpdGVNZXRob2RdKEJpZ0ludCh2YWx1ZSkpLFxuICAgIHZhbGlkYXRlOiAodmFsKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IEJpZ0ludCh2YWwpO1xuICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+IG9wdGlvbnMubWF4VmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICBgSW52YWxpZCAke29wdGlvbnMubmFtZX0gdmFsdWU6ICR7dmFsdWV9LiBFeHBlY3RlZCB2YWx1ZSBpbiByYW5nZSAwLSR7b3B0aW9ucy5tYXhWYWx1ZX1gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBvcHRpb25zLnZhbGlkYXRlPy4odmFsdWUpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBkeW5hbWljU2l6ZUJjc1R5cGUoe1xuICBzZXJpYWxpemUsXG4gIC4uLm9wdGlvbnNcbn0pIHtcbiAgY29uc3QgdHlwZSA9IG5ldyBCY3NUeXBlKHtcbiAgICAuLi5vcHRpb25zLFxuICAgIHNlcmlhbGl6ZSxcbiAgICB3cml0ZTogKHZhbHVlLCB3cml0ZXIpID0+IHtcbiAgICAgIGZvciAoY29uc3QgYnl0ZSBvZiB0eXBlLnNlcmlhbGl6ZSh2YWx1ZSkudG9CeXRlcygpKSB7XG4gICAgICAgIHdyaXRlci53cml0ZTgoYnl0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHR5cGU7XG59XG5mdW5jdGlvbiBzdHJpbmdMaWtlQmNzVHlwZSh7XG4gIHRvQnl0ZXMsXG4gIGZyb21CeXRlcyxcbiAgLi4ub3B0aW9uc1xufSkge1xuICByZXR1cm4gbmV3IEJjc1R5cGUoe1xuICAgIC4uLm9wdGlvbnMsXG4gICAgcmVhZDogKHJlYWRlcikgPT4ge1xuICAgICAgY29uc3QgbGVuZ3RoID0gcmVhZGVyLnJlYWRVTEVCKCk7XG4gICAgICBjb25zdCBieXRlcyA9IHJlYWRlci5yZWFkQnl0ZXMobGVuZ3RoKTtcbiAgICAgIHJldHVybiBmcm9tQnl0ZXMoYnl0ZXMpO1xuICAgIH0sXG4gICAgd3JpdGU6IChoZXgsIHdyaXRlcikgPT4ge1xuICAgICAgY29uc3QgYnl0ZXMgPSB0b0J5dGVzKGhleCk7XG4gICAgICB3cml0ZXIud3JpdGVVTEVCKGJ5dGVzLmxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHdyaXRlci53cml0ZTgoYnl0ZXNbaV0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2VyaWFsaXplOiAodmFsdWUpID0+IHtcbiAgICAgIGNvbnN0IGJ5dGVzID0gdG9CeXRlcyh2YWx1ZSk7XG4gICAgICBjb25zdCBzaXplID0gdWxlYkVuY29kZShieXRlcy5sZW5ndGgpO1xuICAgICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZS5sZW5ndGggKyBieXRlcy5sZW5ndGgpO1xuICAgICAgcmVzdWx0LnNldChzaXplLCAwKTtcbiAgICAgIHJlc3VsdC5zZXQoYnl0ZXMsIHNpemUubGVuZ3RoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcbiAgICB2YWxpZGF0ZTogKHZhbHVlKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEludmFsaWQgJHtvcHRpb25zLm5hbWV9IHZhbHVlOiAke3ZhbHVlfS4gRXhwZWN0ZWQgc3RyaW5nYCk7XG4gICAgICB9XG4gICAgICBvcHRpb25zLnZhbGlkYXRlPy4odmFsdWUpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBsYXp5QmNzVHlwZShjYikge1xuICBsZXQgbGF6eVR5cGUgPSBudWxsO1xuICBmdW5jdGlvbiBnZXRUeXBlKCkge1xuICAgIGlmICghbGF6eVR5cGUpIHtcbiAgICAgIGxhenlUeXBlID0gY2IoKTtcbiAgICB9XG4gICAgcmV0dXJuIGxhenlUeXBlO1xuICB9XG4gIHJldHVybiBuZXcgQmNzVHlwZSh7XG4gICAgbmFtZTogXCJsYXp5XCIsXG4gICAgcmVhZDogKGRhdGEpID0+IGdldFR5cGUoKS5yZWFkKGRhdGEpLFxuICAgIHNlcmlhbGl6ZWRTaXplOiAodmFsdWUpID0+IGdldFR5cGUoKS5zZXJpYWxpemVkU2l6ZSh2YWx1ZSksXG4gICAgd3JpdGU6ICh2YWx1ZSwgd3JpdGVyKSA9PiBnZXRUeXBlKCkud3JpdGUodmFsdWUsIHdyaXRlciksXG4gICAgc2VyaWFsaXplOiAodmFsdWUsIG9wdGlvbnMpID0+IGdldFR5cGUoKS5zZXJpYWxpemUodmFsdWUsIG9wdGlvbnMpLnRvQnl0ZXMoKVxuICB9KTtcbn1cbmV4cG9ydCB7XG4gIEJjc1R5cGUsXG4gIFNlcmlhbGl6ZWRCY3MsXG4gIGJpZ1VJbnRCY3NUeXBlLFxuICBkeW5hbWljU2l6ZUJjc1R5cGUsXG4gIGZpeGVkU2l6ZUJjc1R5cGUsXG4gIGlzU2VyaWFsaXplZEJjcyxcbiAgbGF6eUJjc1R5cGUsXG4gIHN0cmluZ0xpa2VCY3NUeXBlLFxuICB1SW50QmNzVHlwZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJjcy10eXBlLmpzLm1hcFxuIl0sIm5hbWVzIjpbIl9fYWNjZXNzQ2hlY2siLCJvYmoiLCJtZW1iZXIiLCJtc2ciLCJoYXMiLCJUeXBlRXJyb3IiLCJfX3ByaXZhdGVHZXQiLCJnZXR0ZXIiLCJjYWxsIiwiZ2V0IiwiX19wcml2YXRlQWRkIiwidmFsdWUiLCJXZWFrU2V0IiwiYWRkIiwic2V0IiwiX19wcml2YXRlU2V0Iiwic2V0dGVyIiwiX3dyaXRlIiwiX3NlcmlhbGl6ZSIsIl9zY2hlbWEiLCJfYnl0ZXMiLCJ0b0I1OCIsInRvQjY0IiwidG9IRVgiLCJCY3NSZWFkZXIiLCJ1bGViRW5jb2RlIiwiQmNzV3JpdGVyIiwiX0Jjc1R5cGUiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJuYW1lIiwicmVhZCIsInNlcmlhbGl6ZWRTaXplIiwid3JpdGUiLCJzZXJpYWxpemUiLCJvcHRpb25zMiIsIndyaXRlciIsInNpemUiLCJ0b0J5dGVzIiwidmFsaWRhdGUiLCJTZXJpYWxpemVkQmNzIiwicGFyc2UiLCJieXRlcyIsInJlYWRlciIsInRyYW5zZm9ybSIsImlucHV0Iiwib3V0cHV0IiwiQmNzVHlwZSIsIldlYWtNYXAiLCJTRVJJQUxJWkVEX0JDU19CUkFORCIsIlN5bWJvbCIsImZvciIsImlzU2VyaWFsaXplZEJjcyIsInR5cGUiLCJzY2hlbWEiLCJ0b0hleCIsInRvQmFzZTY0IiwidG9CYXNlNTgiLCJmaXhlZFNpemVCY3NUeXBlIiwidUludEJjc1R5cGUiLCJyZWFkTWV0aG9kIiwid3JpdGVNZXRob2QiLCJtYXhWYWx1ZSIsImJpZ1VJbnRCY3NUeXBlIiwiQmlnSW50IiwidmFsIiwiZHluYW1pY1NpemVCY3NUeXBlIiwiYnl0ZSIsIndyaXRlOCIsInN0cmluZ0xpa2VCY3NUeXBlIiwiZnJvbUJ5dGVzIiwibGVuZ3RoIiwicmVhZFVMRUIiLCJyZWFkQnl0ZXMiLCJoZXgiLCJ3cml0ZVVMRUIiLCJpIiwicmVzdWx0IiwiVWludDhBcnJheSIsImxhenlCY3NUeXBlIiwiY2IiLCJsYXp5VHlwZSIsImdldFR5cGUiLCJkYXRhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/bcs-type.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/bcs.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/bcs.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bcs: () => (/* binding */ bcs)\n/* harmony export */ });\n/* harmony import */ var _bcs_type_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bcs-type.js */ \"(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/bcs-type.js\");\n/* harmony import */ var _uleb_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./uleb.js */ \"(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/uleb.js\");\n\n\nconst bcs = {\n    /**\n   * Creates a BcsType that can be used to read and write an 8-bit unsigned integer.\n   * @example\n   * bcs.u8().serialize(255).toBytes() // Uint8Array [ 255 ]\n   */ u8 (options) {\n        return (0,_bcs_type_js__WEBPACK_IMPORTED_MODULE_0__.uIntBcsType)({\n            name: \"u8\",\n            readMethod: \"read8\",\n            writeMethod: \"write8\",\n            size: 1,\n            maxValue: 2 ** 8 - 1,\n            ...options\n        });\n    },\n    /**\n   * Creates a BcsType that can be used to read and write a 16-bit unsigned integer.\n   * @example\n   * bcs.u16().serialize(65535).toBytes() // Uint8Array [ 255, 255 ]\n   */ u16 (options) {\n        return (0,_bcs_type_js__WEBPACK_IMPORTED_MODULE_0__.uIntBcsType)({\n            name: \"u16\",\n            readMethod: \"read16\",\n            writeMethod: \"write16\",\n            size: 2,\n            maxValue: 2 ** 16 - 1,\n            ...options\n        });\n    },\n    /**\n   * Creates a BcsType that can be used to read and write a 32-bit unsigned integer.\n   * @example\n   * bcs.u32().serialize(4294967295).toBytes() // Uint8Array [ 255, 255, 255, 255 ]\n   */ u32 (options) {\n        return (0,_bcs_type_js__WEBPACK_IMPORTED_MODULE_0__.uIntBcsType)({\n            name: \"u32\",\n            readMethod: \"read32\",\n            writeMethod: \"write32\",\n            size: 4,\n            maxValue: 2 ** 32 - 1,\n            ...options\n        });\n    },\n    /**\n   * Creates a BcsType that can be used to read and write a 64-bit unsigned integer.\n   * @example\n   * bcs.u64().serialize(1).toBytes() // Uint8Array [ 1, 0, 0, 0, 0, 0, 0, 0 ]\n   */ u64 (options) {\n        return (0,_bcs_type_js__WEBPACK_IMPORTED_MODULE_0__.bigUIntBcsType)({\n            name: \"u64\",\n            readMethod: \"read64\",\n            writeMethod: \"write64\",\n            size: 8,\n            maxValue: 2n ** 64n - 1n,\n            ...options\n        });\n    },\n    /**\n   * Creates a BcsType that can be used to read and write a 128-bit unsigned integer.\n   * @example\n   * bcs.u128().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n   */ u128 (options) {\n        return (0,_bcs_type_js__WEBPACK_IMPORTED_MODULE_0__.bigUIntBcsType)({\n            name: \"u128\",\n            readMethod: \"read128\",\n            writeMethod: \"write128\",\n            size: 16,\n            maxValue: 2n ** 128n - 1n,\n            ...options\n        });\n    },\n    /**\n   * Creates a BcsType that can be used to read and write a 256-bit unsigned integer.\n   * @example\n   * bcs.u256().serialize(1).toBytes() // Uint8Array [ 1, ..., 0 ]\n   */ u256 (options) {\n        return (0,_bcs_type_js__WEBPACK_IMPORTED_MODULE_0__.bigUIntBcsType)({\n            name: \"u256\",\n            readMethod: \"read256\",\n            writeMethod: \"write256\",\n            size: 32,\n            maxValue: 2n ** 256n - 1n,\n            ...options\n        });\n    },\n    /**\n   * Creates a BcsType that can be used to read and write boolean values.\n   * @example\n   * bcs.bool().serialize(true).toBytes() // Uint8Array [ 1 ]\n   */ bool (options) {\n        return (0,_bcs_type_js__WEBPACK_IMPORTED_MODULE_0__.fixedSizeBcsType)({\n            name: \"bool\",\n            size: 1,\n            read: (reader)=>reader.read8() === 1,\n            write: (value, writer)=>writer.write8(value ? 1 : 0),\n            ...options,\n            validate: (value)=>{\n                options?.validate?.(value);\n                if (typeof value !== \"boolean\") {\n                    throw new TypeError(`Expected boolean, found ${typeof value}`);\n                }\n            }\n        });\n    },\n    /**\n   * Creates a BcsType that can be used to read and write unsigned LEB encoded integers\n   * @example\n   *\n   */ uleb128 (options) {\n        return (0,_bcs_type_js__WEBPACK_IMPORTED_MODULE_0__.dynamicSizeBcsType)({\n            name: \"uleb128\",\n            read: (reader)=>reader.readULEB(),\n            serialize: (value)=>{\n                return Uint8Array.from((0,_uleb_js__WEBPACK_IMPORTED_MODULE_1__.ulebEncode)(value));\n            },\n            ...options\n        });\n    },\n    /**\n   * Creates a BcsType representing a fixed length byte array\n   * @param size The number of bytes this types represents\n   * @example\n   * bcs.bytes(3).serialize(new Uint8Array([1, 2, 3])).toBytes() // Uint8Array [1, 2, 3]\n   */ bytes (size, options) {\n        return (0,_bcs_type_js__WEBPACK_IMPORTED_MODULE_0__.fixedSizeBcsType)({\n            name: `bytes[${size}]`,\n            size,\n            read: (reader)=>reader.readBytes(size),\n            write: (value, writer)=>{\n                for(let i = 0; i < size; i++){\n                    writer.write8(value[i] ?? 0);\n                }\n            },\n            ...options,\n            validate: (value)=>{\n                options?.validate?.(value);\n                if (!(\"length\" in value)) {\n                    throw new TypeError(`Expected array, found ${typeof value}`);\n                }\n                if (value.length !== size) {\n                    throw new TypeError(`Expected array of length ${size}, found ${value.length}`);\n                }\n            }\n        });\n    },\n    /**\n   * Creates a BcsType that can ser/de string values.  Strings will be UTF-8 encoded\n   * @example\n   * bcs.string().serialize('a').toBytes() // Uint8Array [ 1, 97 ]\n   */ string (options) {\n        return (0,_bcs_type_js__WEBPACK_IMPORTED_MODULE_0__.stringLikeBcsType)({\n            name: \"string\",\n            toBytes: (value)=>new TextEncoder().encode(value),\n            fromBytes: (bytes)=>new TextDecoder().decode(bytes),\n            ...options\n        });\n    },\n    /**\n   * Creates a BcsType that represents a fixed length array of a given type\n   * @param size The number of elements in the array\n   * @param type The BcsType of each element in the array\n   * @example\n   * bcs.fixedArray(3, bcs.u8()).serialize([1, 2, 3]).toBytes() // Uint8Array [ 1, 2, 3 ]\n   */ fixedArray (size, type, options) {\n        return new _bcs_type_js__WEBPACK_IMPORTED_MODULE_0__.BcsType({\n            name: `${type.name}[${size}]`,\n            read: (reader)=>{\n                const result = new Array(size);\n                for(let i = 0; i < size; i++){\n                    result[i] = type.read(reader);\n                }\n                return result;\n            },\n            write: (value, writer)=>{\n                for (const item of value){\n                    type.write(item, writer);\n                }\n            },\n            ...options,\n            validate: (value)=>{\n                options?.validate?.(value);\n                if (!(\"length\" in value)) {\n                    throw new TypeError(`Expected array, found ${typeof value}`);\n                }\n                if (value.length !== size) {\n                    throw new TypeError(`Expected array of length ${size}, found ${value.length}`);\n                }\n            }\n        });\n    },\n    /**\n   * Creates a BcsType representing an optional value\n   * @param type The BcsType of the optional value\n   * @example\n   * bcs.option(bcs.u8()).serialize(null).toBytes() // Uint8Array [ 0 ]\n   * bcs.option(bcs.u8()).serialize(1).toBytes() // Uint8Array [ 1, 1 ]\n   */ option (type) {\n        return bcs.enum(`Option<${type.name}>`, {\n            None: null,\n            Some: type\n        }).transform({\n            input: (value)=>{\n                if (value == null) {\n                    return {\n                        None: true\n                    };\n                }\n                return {\n                    Some: value\n                };\n            },\n            output: (value)=>{\n                if (\"Some\" in value) {\n                    return value.Some;\n                }\n                return null;\n            }\n        });\n    },\n    /**\n   * Creates a BcsType representing a variable length vector of a given type\n   * @param type The BcsType of each element in the vector\n   *\n   * @example\n   * bcs.vector(bcs.u8()).toBytes([1, 2, 3]) // Uint8Array [ 3, 1, 2, 3 ]\n   */ vector (type, options) {\n        return new _bcs_type_js__WEBPACK_IMPORTED_MODULE_0__.BcsType({\n            name: `vector<${type.name}>`,\n            read: (reader)=>{\n                const length = reader.readULEB();\n                const result = new Array(length);\n                for(let i = 0; i < length; i++){\n                    result[i] = type.read(reader);\n                }\n                return result;\n            },\n            write: (value, writer)=>{\n                writer.writeULEB(value.length);\n                for (const item of value){\n                    type.write(item, writer);\n                }\n            },\n            ...options,\n            validate: (value)=>{\n                options?.validate?.(value);\n                if (!(\"length\" in value)) {\n                    throw new TypeError(`Expected array, found ${typeof value}`);\n                }\n            }\n        });\n    },\n    /**\n   * Creates a BcsType representing a tuple of a given set of types\n   * @param types The BcsTypes for each element in the tuple\n   *\n   * @example\n   * const tuple = bcs.tuple([bcs.u8(), bcs.string(), bcs.bool()])\n   * tuple.serialize([1, 'a', true]).toBytes() // Uint8Array [ 1, 1, 97, 1 ]\n   */ tuple (types, options) {\n        return new _bcs_type_js__WEBPACK_IMPORTED_MODULE_0__.BcsType({\n            name: `(${types.map((t)=>t.name).join(\", \")})`,\n            serializedSize: (values)=>{\n                let total = 0;\n                for(let i = 0; i < types.length; i++){\n                    const size = types[i].serializedSize(values[i]);\n                    if (size == null) {\n                        return null;\n                    }\n                    total += size;\n                }\n                return total;\n            },\n            read: (reader)=>{\n                const result = [];\n                for (const type of types){\n                    result.push(type.read(reader));\n                }\n                return result;\n            },\n            write: (value, writer)=>{\n                for(let i = 0; i < types.length; i++){\n                    types[i].write(value[i], writer);\n                }\n            },\n            ...options,\n            validate: (value)=>{\n                options?.validate?.(value);\n                if (!Array.isArray(value)) {\n                    throw new TypeError(`Expected array, found ${typeof value}`);\n                }\n                if (value.length !== types.length) {\n                    throw new TypeError(`Expected array of length ${types.length}, found ${value.length}`);\n                }\n            }\n        });\n    },\n    /**\n   * Creates a BcsType representing a struct of a given set of fields\n   * @param name The name of the struct\n   * @param fields The fields of the struct. The order of the fields affects how data is serialized and deserialized\n   *\n   * @example\n   * const struct = bcs.struct('MyStruct', {\n   *  a: bcs.u8(),\n   *  b: bcs.string(),\n   * })\n   * struct.serialize({ a: 1, b: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n   */ struct (name, fields, options) {\n        const canonicalOrder = Object.entries(fields);\n        return new _bcs_type_js__WEBPACK_IMPORTED_MODULE_0__.BcsType({\n            name,\n            serializedSize: (values)=>{\n                let total = 0;\n                for (const [field, type] of canonicalOrder){\n                    const size = type.serializedSize(values[field]);\n                    if (size == null) {\n                        return null;\n                    }\n                    total += size;\n                }\n                return total;\n            },\n            read: (reader)=>{\n                const result = {};\n                for (const [field, type] of canonicalOrder){\n                    result[field] = type.read(reader);\n                }\n                return result;\n            },\n            write: (value, writer)=>{\n                for (const [field, type] of canonicalOrder){\n                    type.write(value[field], writer);\n                }\n            },\n            ...options,\n            validate: (value)=>{\n                options?.validate?.(value);\n                if (typeof value !== \"object\" || value == null) {\n                    throw new TypeError(`Expected object, found ${typeof value}`);\n                }\n            }\n        });\n    },\n    /**\n   * Creates a BcsType representing an enum of a given set of options\n   * @param name The name of the enum\n   * @param values The values of the enum. The order of the values affects how data is serialized and deserialized.\n   * null can be used to represent a variant with no data.\n   *\n   * @example\n   * const enum = bcs.enum('MyEnum', {\n   *   A: bcs.u8(),\n   *   B: bcs.string(),\n   *   C: null,\n   * })\n   * enum.serialize({ A: 1 }).toBytes() // Uint8Array [ 0, 1 ]\n   * enum.serialize({ B: 'a' }).toBytes() // Uint8Array [ 1, 1, 97 ]\n   * enum.serialize({ C: true }).toBytes() // Uint8Array [ 2 ]\n   */ enum (name, values, options) {\n        const canonicalOrder = Object.entries(values);\n        return new _bcs_type_js__WEBPACK_IMPORTED_MODULE_0__.BcsType({\n            name,\n            read: (reader)=>{\n                const index = reader.readULEB();\n                const [name2, type] = canonicalOrder[index];\n                return {\n                    [name2]: type?.read(reader) ?? true\n                };\n            },\n            write: (value, writer)=>{\n                const [name2, val] = Object.entries(value)[0];\n                for(let i = 0; i < canonicalOrder.length; i++){\n                    const [optionName, optionType] = canonicalOrder[i];\n                    if (optionName === name2) {\n                        writer.writeULEB(i);\n                        optionType?.write(val, writer);\n                        return;\n                    }\n                }\n            },\n            ...options,\n            validate: (value)=>{\n                options?.validate?.(value);\n                if (typeof value !== \"object\" || value == null) {\n                    throw new TypeError(`Expected object, found ${typeof value}`);\n                }\n                const keys = Object.keys(value);\n                if (keys.length !== 1) {\n                    throw new TypeError(`Expected object with one key, found ${keys.length}`);\n                }\n                const [name2] = keys;\n                if (!Object.hasOwn(values, name2)) {\n                    throw new TypeError(`Invalid enum variant ${name2}`);\n                }\n            }\n        });\n    },\n    /**\n   * Creates a BcsType representing a map of a given key and value type\n   * @param keyType The BcsType of the key\n   * @param valueType The BcsType of the value\n   * @example\n   * const map = bcs.map(bcs.u8(), bcs.string())\n   * map.serialize(new Map([[2, 'a']])).toBytes() // Uint8Array [ 1, 2, 1, 97 ]\n   */ map (keyType, valueType) {\n        return bcs.vector(bcs.tuple([\n            keyType,\n            valueType\n        ])).transform({\n            name: `Map<${keyType.name}, ${valueType.name}>`,\n            input: (value)=>{\n                return [\n                    ...value.entries()\n                ];\n            },\n            output: (value)=>{\n                const result = /* @__PURE__ */ new Map();\n                for (const [key, val] of value){\n                    result.set(key, val);\n                }\n                return result;\n            }\n        });\n    },\n    /**\n   * @deprecated\n   *\n   * Generics should be implemented as generic typescript functions instead:\n   *\n   * ```ts\n   * function VecMap<K, V>, (K: BcsType<K>, V: BcsType<V>) {\n   *   return bcs.struct('VecMap<K, V>', {\n   *     keys: bcs.vector(K),\n   *     values: bcs.vector(V),\n   *   })\n   * }\n   * ```\n   */ generic (_names, cb) {\n        return (...types)=>{\n            return cb(...types).transform({\n                name: `${cb.name}<${types.map((t)=>t.name).join(\", \")}>`,\n                input: (value)=>value,\n                output: (value)=>value\n            });\n        };\n    },\n    /**\n   * Creates a BcsType that wraps another BcsType which is lazily evaluated. This is useful for creating recursive types.\n   * @param cb A callback that returns the BcsType\n   */ lazy (cb) {\n        return (0,_bcs_type_js__WEBPACK_IMPORTED_MODULE_0__.lazyBcsType)(cb);\n    }\n};\n //# sourceMappingURL=bcs.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG15c3RlbitiY3NAMC4xMS4xL25vZGVfbW9kdWxlcy9AbXlzdGVuL2Jjcy9kaXN0L2VzbS9iY3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBUXVCO0FBQ2dCO0FBQ3ZDLE1BQU1RLE1BQU07SUFDVjs7OztHQUlDLEdBQ0RDLElBQUdDLE9BQU87UUFDUixPQUFPSix5REFBV0EsQ0FBQztZQUNqQkssTUFBTTtZQUNOQyxZQUFZO1lBQ1pDLGFBQWE7WUFDYkMsTUFBTTtZQUNOQyxVQUFVLEtBQUssSUFBSTtZQUNuQixHQUFHTCxPQUFPO1FBQ1o7SUFDRjtJQUNBOzs7O0dBSUMsR0FDRE0sS0FBSU4sT0FBTztRQUNULE9BQU9KLHlEQUFXQSxDQUFDO1lBQ2pCSyxNQUFNO1lBQ05DLFlBQVk7WUFDWkMsYUFBYTtZQUNiQyxNQUFNO1lBQ05DLFVBQVUsS0FBSyxLQUFLO1lBQ3BCLEdBQUdMLE9BQU87UUFDWjtJQUNGO0lBQ0E7Ozs7R0FJQyxHQUNETyxLQUFJUCxPQUFPO1FBQ1QsT0FBT0oseURBQVdBLENBQUM7WUFDakJLLE1BQU07WUFDTkMsWUFBWTtZQUNaQyxhQUFhO1lBQ2JDLE1BQU07WUFDTkMsVUFBVSxLQUFLLEtBQUs7WUFDcEIsR0FBR0wsT0FBTztRQUNaO0lBQ0Y7SUFDQTs7OztHQUlDLEdBQ0RRLEtBQUlSLE9BQU87UUFDVCxPQUFPVCw0REFBY0EsQ0FBQztZQUNwQlUsTUFBTTtZQUNOQyxZQUFZO1lBQ1pDLGFBQWE7WUFDYkMsTUFBTTtZQUNOQyxVQUFVLEVBQUUsSUFBSSxHQUFHLEdBQUcsRUFBRTtZQUN4QixHQUFHTCxPQUFPO1FBQ1o7SUFDRjtJQUNBOzs7O0dBSUMsR0FDRFMsTUFBS1QsT0FBTztRQUNWLE9BQU9ULDREQUFjQSxDQUFDO1lBQ3BCVSxNQUFNO1lBQ05DLFlBQVk7WUFDWkMsYUFBYTtZQUNiQyxNQUFNO1lBQ05DLFVBQVUsRUFBRSxJQUFJLElBQUksR0FBRyxFQUFFO1lBQ3pCLEdBQUdM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QUV5RSxRQUFRekUsSUFBSSxDQUFDLEVBQUUsRUFBRTBFLFVBQVUxRSxJQUFJLENBQUMsQ0FBQyxDQUFDO1lBQy9DOEMsT0FBTyxDQUFDL0I7Z0JBQ04sT0FBTzt1QkFBSUEsTUFBTWlELE9BQU87aUJBQUc7WUFDN0I7WUFDQWpCLFFBQVEsQ0FBQ2hDO2dCQUNQLE1BQU11QixTQUFTLGFBQWEsR0FBRyxJQUFJcUM7Z0JBQ25DLEtBQUssTUFBTSxDQUFDQyxLQUFLUixJQUFJLElBQUlyRCxNQUFPO29CQUM5QnVCLE9BQU91QyxHQUFHLENBQUNELEtBQUtSO2dCQUNsQjtnQkFDQSxPQUFPOUI7WUFDVDtRQUNGO0lBQ0Y7SUFDQTs7Ozs7Ozs7Ozs7OztHQWFDLEdBQ0R3QyxTQUFRQyxNQUFNLEVBQUVDLEVBQUU7UUFDaEIsT0FBTyxDQUFDLEdBQUc3QjtZQUNULE9BQU82QixNQUFNN0IsT0FBT04sU0FBUyxDQUFDO2dCQUM1QjdDLE1BQU0sQ0FBQyxFQUFFZ0YsR0FBR2hGLElBQUksQ0FBQyxDQUFDLEVBQUVtRCxNQUFNQyxHQUFHLENBQUMsQ0FBQ0MsSUFBTUEsRUFBRXJELElBQUksRUFBRXNELElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztnQkFDMURSLE9BQU8sQ0FBQy9CLFFBQVVBO2dCQUNsQmdDLFFBQVEsQ0FBQ2hDLFFBQVVBO1lBQ3JCO1FBQ0Y7SUFDRjtJQUNBOzs7R0FHQyxHQUNEa0UsTUFBS0QsRUFBRTtRQUNMLE9BQU92Rix5REFBV0EsQ0FBQ3VGO0lBQ3JCO0FBQ0Y7QUFHRSxDQUNGLCtCQUErQiIsInNvdXJjZXMiOlsid2VicGFjazovL25vdGFzY2FtLXByb3RvY29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BteXN0ZW4rYmNzQDAuMTEuMS9ub2RlX21vZHVsZXMvQG15c3Rlbi9iY3MvZGlzdC9lc20vYmNzLmpzPzgxMmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQmNzVHlwZSxcbiAgYmlnVUludEJjc1R5cGUsXG4gIGR5bmFtaWNTaXplQmNzVHlwZSxcbiAgZml4ZWRTaXplQmNzVHlwZSxcbiAgbGF6eUJjc1R5cGUsXG4gIHN0cmluZ0xpa2VCY3NUeXBlLFxuICB1SW50QmNzVHlwZVxufSBmcm9tIFwiLi9iY3MtdHlwZS5qc1wiO1xuaW1wb3J0IHsgdWxlYkVuY29kZSB9IGZyb20gXCIuL3VsZWIuanNcIjtcbmNvbnN0IGJjcyA9IHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBCY3NUeXBlIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVhZCBhbmQgd3JpdGUgYW4gOC1iaXQgdW5zaWduZWQgaW50ZWdlci5cbiAgICogQGV4YW1wbGVcbiAgICogYmNzLnU4KCkuc2VyaWFsaXplKDI1NSkudG9CeXRlcygpIC8vIFVpbnQ4QXJyYXkgWyAyNTUgXVxuICAgKi9cbiAgdTgob3B0aW9ucykge1xuICAgIHJldHVybiB1SW50QmNzVHlwZSh7XG4gICAgICBuYW1lOiBcInU4XCIsXG4gICAgICByZWFkTWV0aG9kOiBcInJlYWQ4XCIsXG4gICAgICB3cml0ZU1ldGhvZDogXCJ3cml0ZThcIixcbiAgICAgIHNpemU6IDEsXG4gICAgICBtYXhWYWx1ZTogMiAqKiA4IC0gMSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9KTtcbiAgfSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBCY3NUeXBlIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVhZCBhbmQgd3JpdGUgYSAxNi1iaXQgdW5zaWduZWQgaW50ZWdlci5cbiAgICogQGV4YW1wbGVcbiAgICogYmNzLnUxNigpLnNlcmlhbGl6ZSg2NTUzNSkudG9CeXRlcygpIC8vIFVpbnQ4QXJyYXkgWyAyNTUsIDI1NSBdXG4gICAqL1xuICB1MTYob3B0aW9ucykge1xuICAgIHJldHVybiB1SW50QmNzVHlwZSh7XG4gICAgICBuYW1lOiBcInUxNlwiLFxuICAgICAgcmVhZE1ldGhvZDogXCJyZWFkMTZcIixcbiAgICAgIHdyaXRlTWV0aG9kOiBcIndyaXRlMTZcIixcbiAgICAgIHNpemU6IDIsXG4gICAgICBtYXhWYWx1ZTogMiAqKiAxNiAtIDEsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG4gIH0sXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgQmNzVHlwZSB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlYWQgYW5kIHdyaXRlIGEgMzItYml0IHVuc2lnbmVkIGludGVnZXIuXG4gICAqIEBleGFtcGxlXG4gICAqIGJjcy51MzIoKS5zZXJpYWxpemUoNDI5NDk2NzI5NSkudG9CeXRlcygpIC8vIFVpbnQ4QXJyYXkgWyAyNTUsIDI1NSwgMjU1LCAyNTUgXVxuICAgKi9cbiAgdTMyKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdUludEJjc1R5cGUoe1xuICAgICAgbmFtZTogXCJ1MzJcIixcbiAgICAgIHJlYWRNZXRob2Q6IFwicmVhZDMyXCIsXG4gICAgICB3cml0ZU1ldGhvZDogXCJ3cml0ZTMyXCIsXG4gICAgICBzaXplOiA0LFxuICAgICAgbWF4VmFsdWU6IDIgKiogMzIgLSAxLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pO1xuICB9LFxuICAvKipcbiAgICogQ3JlYXRlcyBhIEJjc1R5cGUgdGhhdCBjYW4gYmUgdXNlZCB0byByZWFkIGFuZCB3cml0ZSBhIDY0LWJpdCB1bnNpZ25lZCBpbnRlZ2VyLlxuICAgKiBAZXhhbXBsZVxuICAgKiBiY3MudTY0KCkuc2VyaWFsaXplKDEpLnRvQnl0ZXMoKSAvLyBVaW50OEFycmF5IFsgMSwgMCwgMCwgMCwgMCwgMCwgMCwgMCBdXG4gICAqL1xuICB1NjQob3B0aW9ucykge1xuICAgIHJldHVybiBiaWdVSW50QmNzVHlwZSh7XG4gICAgICBuYW1lOiBcInU2NFwiLFxuICAgICAgcmVhZE1ldGhvZDogXCJyZWFkNjRcIixcbiAgICAgIHdyaXRlTWV0aG9kOiBcIndyaXRlNjRcIixcbiAgICAgIHNpemU6IDgsXG4gICAgICBtYXhWYWx1ZTogMm4gKiogNjRuIC0gMW4sXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG4gIH0sXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgQmNzVHlwZSB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlYWQgYW5kIHdyaXRlIGEgMTI4LWJpdCB1bnNpZ25lZCBpbnRlZ2VyLlxuICAgKiBAZXhhbXBsZVxuICAgKiBiY3MudTEyOCgpLnNlcmlhbGl6ZSgxKS50b0J5dGVzKCkgLy8gVWludDhBcnJheSBbIDEsIC4uLiwgMCBdXG4gICAqL1xuICB1MTI4KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYmlnVUludEJjc1R5cGUoe1xuICAgICAgbmFtZTogXCJ1MTI4XCIsXG4gICAgICByZWFkTWV0aG9kOiBcInJlYWQxMjhcIixcbiAgICAgIHdyaXRlTWV0aG9kOiBcIndyaXRlMTI4XCIsXG4gICAgICBzaXplOiAxNixcbiAgICAgIG1heFZhbHVlOiAybiAqKiAxMjhuIC0gMW4sXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG4gIH0sXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgQmNzVHlwZSB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlYWQgYW5kIHdyaXRlIGEgMjU2LWJpdCB1bnNpZ25lZCBpbnRlZ2VyLlxuICAgKiBAZXhhbXBsZVxuICAgKiBiY3MudTI1NigpLnNlcmlhbGl6ZSgxKS50b0J5dGVzKCkgLy8gVWludDhBcnJheSBbIDEsIC4uLiwgMCBdXG4gICAqL1xuICB1MjU2KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYmlnVUludEJjc1R5cGUoe1xuICAgICAgbmFtZTogXCJ1MjU2XCIsXG4gICAgICByZWFkTWV0aG9kOiBcInJlYWQyNTZcIixcbiAgICAgIHdyaXRlTWV0aG9kOiBcIndyaXRlMjU2XCIsXG4gICAgICBzaXplOiAzMixcbiAgICAgIG1heFZhbHVlOiAybiAqKiAyNTZuIC0gMW4sXG4gICAgICAuLi5vcHRpb25zXG4gICAgfSk7XG4gIH0sXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgQmNzVHlwZSB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlYWQgYW5kIHdyaXRlIGJvb2xlYW4gdmFsdWVzLlxuICAgKiBAZXhhbXBsZVxuICAgKiBiY3MuYm9vbCgpLnNlcmlhbGl6ZSh0cnVlKS50b0J5dGVzKCkgLy8gVWludDhBcnJheSBbIDEgXVxuICAgKi9cbiAgYm9vbChvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZpeGVkU2l6ZUJjc1R5cGUoe1xuICAgICAgbmFtZTogXCJib29sXCIsXG4gICAgICBzaXplOiAxLFxuICAgICAgcmVhZDogKHJlYWRlcikgPT4gcmVhZGVyLnJlYWQ4KCkgPT09IDEsXG4gICAgICB3cml0ZTogKHZhbHVlLCB3cml0ZXIpID0+IHdyaXRlci53cml0ZTgodmFsdWUgPyAxIDogMCksXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgdmFsaWRhdGU6ICh2YWx1ZSkgPT4ge1xuICAgICAgICBvcHRpb25zPy52YWxpZGF0ZT8uKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBib29sZWFuLCBmb3VuZCAke3R5cGVvZiB2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICAvKipcbiAgICogQ3JlYXRlcyBhIEJjc1R5cGUgdGhhdCBjYW4gYmUgdXNlZCB0byByZWFkIGFuZCB3cml0ZSB1bnNpZ25lZCBMRUIgZW5jb2RlZCBpbnRlZ2Vyc1xuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKi9cbiAgdWxlYjEyOChvcHRpb25zKSB7XG4gICAgcmV0dXJuIGR5bmFtaWNTaXplQmNzVHlwZSh7XG4gICAgICBuYW1lOiBcInVsZWIxMjhcIixcbiAgICAgIHJlYWQ6IChyZWFkZXIpID0+IHJlYWRlci5yZWFkVUxFQigpLFxuICAgICAgc2VyaWFsaXplOiAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbSh1bGViRW5jb2RlKHZhbHVlKSk7XG4gICAgICB9LFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pO1xuICB9LFxuICAvKipcbiAgICogQ3JlYXRlcyBhIEJjc1R5cGUgcmVwcmVzZW50aW5nIGEgZml4ZWQgbGVuZ3RoIGJ5dGUgYXJyYXlcbiAgICogQHBhcmFtIHNpemUgVGhlIG51bWJlciBvZiBieXRlcyB0aGlzIHR5cGVzIHJlcHJlc2VudHNcbiAgICogQGV4YW1wbGVcbiAgICogYmNzLmJ5dGVzKDMpLnNlcmlhbGl6ZShuZXcgVWludDhBcnJheShbMSwgMiwgM10pKS50b0J5dGVzKCkgLy8gVWludDhBcnJheSBbMSwgMiwgM11cbiAgICovXG4gIGJ5dGVzKHNpemUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gZml4ZWRTaXplQmNzVHlwZSh7XG4gICAgICBuYW1lOiBgYnl0ZXNbJHtzaXplfV1gLFxuICAgICAgc2l6ZSxcbiAgICAgIHJlYWQ6IChyZWFkZXIpID0+IHJlYWRlci5yZWFkQnl0ZXMoc2l6ZSksXG4gICAgICB3cml0ZTogKHZhbHVlLCB3cml0ZXIpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICB3cml0ZXIud3JpdGU4KHZhbHVlW2ldID8/IDApO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHZhbGlkYXRlOiAodmFsdWUpID0+IHtcbiAgICAgICAgb3B0aW9ucz8udmFsaWRhdGU/Lih2YWx1ZSk7XG4gICAgICAgIGlmICghKFwibGVuZ3RoXCIgaW4gdmFsdWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgYXJyYXksIGZvdW5kICR7dHlwZW9mIHZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggIT09IHNpemUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBhcnJheSBvZiBsZW5ndGggJHtzaXplfSwgZm91bmQgJHt2YWx1ZS5sZW5ndGh9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBCY3NUeXBlIHRoYXQgY2FuIHNlci9kZSBzdHJpbmcgdmFsdWVzLiAgU3RyaW5ncyB3aWxsIGJlIFVURi04IGVuY29kZWRcbiAgICogQGV4YW1wbGVcbiAgICogYmNzLnN0cmluZygpLnNlcmlhbGl6ZSgnYScpLnRvQnl0ZXMoKSAvLyBVaW50OEFycmF5IFsgMSwgOTcgXVxuICAgKi9cbiAgc3RyaW5nKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gc3RyaW5nTGlrZUJjc1R5cGUoe1xuICAgICAgbmFtZTogXCJzdHJpbmdcIixcbiAgICAgIHRvQnl0ZXM6ICh2YWx1ZSkgPT4gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHZhbHVlKSxcbiAgICAgIGZyb21CeXRlczogKGJ5dGVzKSA9PiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnl0ZXMpLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pO1xuICB9LFxuICAvKipcbiAgICogQ3JlYXRlcyBhIEJjc1R5cGUgdGhhdCByZXByZXNlbnRzIGEgZml4ZWQgbGVuZ3RoIGFycmF5IG9mIGEgZ2l2ZW4gdHlwZVxuICAgKiBAcGFyYW0gc2l6ZSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBhcnJheVxuICAgKiBAcGFyYW0gdHlwZSBUaGUgQmNzVHlwZSBvZiBlYWNoIGVsZW1lbnQgaW4gdGhlIGFycmF5XG4gICAqIEBleGFtcGxlXG4gICAqIGJjcy5maXhlZEFycmF5KDMsIGJjcy51OCgpKS5zZXJpYWxpemUoWzEsIDIsIDNdKS50b0J5dGVzKCkgLy8gVWludDhBcnJheSBbIDEsIDIsIDMgXVxuICAgKi9cbiAgZml4ZWRBcnJheShzaXplLCB0eXBlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBCY3NUeXBlKHtcbiAgICAgIG5hbWU6IGAke3R5cGUubmFtZX1bJHtzaXplfV1gLFxuICAgICAgcmVhZDogKHJlYWRlcikgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgcmVzdWx0W2ldID0gdHlwZS5yZWFkKHJlYWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogKHZhbHVlLCB3cml0ZXIpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHZhbHVlKSB7XG4gICAgICAgICAgdHlwZS53cml0ZShpdGVtLCB3cml0ZXIpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHZhbGlkYXRlOiAodmFsdWUpID0+IHtcbiAgICAgICAgb3B0aW9ucz8udmFsaWRhdGU/Lih2YWx1ZSk7XG4gICAgICAgIGlmICghKFwibGVuZ3RoXCIgaW4gdmFsdWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgYXJyYXksIGZvdW5kICR7dHlwZW9mIHZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggIT09IHNpemUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBhcnJheSBvZiBsZW5ndGggJHtzaXplfSwgZm91bmQgJHt2YWx1ZS5sZW5ndGh9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBCY3NUeXBlIHJlcHJlc2VudGluZyBhbiBvcHRpb25hbCB2YWx1ZVxuICAgKiBAcGFyYW0gdHlwZSBUaGUgQmNzVHlwZSBvZiB0aGUgb3B0aW9uYWwgdmFsdWVcbiAgICogQGV4YW1wbGVcbiAgICogYmNzLm9wdGlvbihiY3MudTgoKSkuc2VyaWFsaXplKG51bGwpLnRvQnl0ZXMoKSAvLyBVaW50OEFycmF5IFsgMCBdXG4gICAqIGJjcy5vcHRpb24oYmNzLnU4KCkpLnNlcmlhbGl6ZSgxKS50b0J5dGVzKCkgLy8gVWludDhBcnJheSBbIDEsIDEgXVxuICAgKi9cbiAgb3B0aW9uKHR5cGUpIHtcbiAgICByZXR1cm4gYmNzLmVudW0oYE9wdGlvbjwke3R5cGUubmFtZX0+YCwge1xuICAgICAgTm9uZTogbnVsbCxcbiAgICAgIFNvbWU6IHR5cGVcbiAgICB9KS50cmFuc2Zvcm0oe1xuICAgICAgaW5wdXQ6ICh2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB7IE5vbmU6IHRydWUgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBTb21lOiB2YWx1ZSB9O1xuICAgICAgfSxcbiAgICAgIG91dHB1dDogKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmIChcIlNvbWVcIiBpbiB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiB2YWx1ZS5Tb21lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICAvKipcbiAgICogQ3JlYXRlcyBhIEJjc1R5cGUgcmVwcmVzZW50aW5nIGEgdmFyaWFibGUgbGVuZ3RoIHZlY3RvciBvZiBhIGdpdmVuIHR5cGVcbiAgICogQHBhcmFtIHR5cGUgVGhlIEJjc1R5cGUgb2YgZWFjaCBlbGVtZW50IGluIHRoZSB2ZWN0b3JcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYmNzLnZlY3RvcihiY3MudTgoKSkudG9CeXRlcyhbMSwgMiwgM10pIC8vIFVpbnQ4QXJyYXkgWyAzLCAxLCAyLCAzIF1cbiAgICovXG4gIHZlY3Rvcih0eXBlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBCY3NUeXBlKHtcbiAgICAgIG5hbWU6IGB2ZWN0b3I8JHt0eXBlLm5hbWV9PmAsXG4gICAgICByZWFkOiAocmVhZGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHJlYWRlci5yZWFkVUxFQigpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgIHJlc3VsdFtpXSA9IHR5cGUucmVhZChyZWFkZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgd3JpdGU6ICh2YWx1ZSwgd3JpdGVyKSA9PiB7XG4gICAgICAgIHdyaXRlci53cml0ZVVMRUIodmFsdWUubGVuZ3RoKTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHZhbHVlKSB7XG4gICAgICAgICAgdHlwZS53cml0ZShpdGVtLCB3cml0ZXIpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHZhbGlkYXRlOiAodmFsdWUpID0+IHtcbiAgICAgICAgb3B0aW9ucz8udmFsaWRhdGU/Lih2YWx1ZSk7XG4gICAgICAgIGlmICghKFwibGVuZ3RoXCIgaW4gdmFsdWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgYXJyYXksIGZvdW5kICR7dHlwZW9mIHZhbHVlfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgQmNzVHlwZSByZXByZXNlbnRpbmcgYSB0dXBsZSBvZiBhIGdpdmVuIHNldCBvZiB0eXBlc1xuICAgKiBAcGFyYW0gdHlwZXMgVGhlIEJjc1R5cGVzIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIHR1cGxlXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHR1cGxlID0gYmNzLnR1cGxlKFtiY3MudTgoKSwgYmNzLnN0cmluZygpLCBiY3MuYm9vbCgpXSlcbiAgICogdHVwbGUuc2VyaWFsaXplKFsxLCAnYScsIHRydWVdKS50b0J5dGVzKCkgLy8gVWludDhBcnJheSBbIDEsIDEsIDk3LCAxIF1cbiAgICovXG4gIHR1cGxlKHR5cGVzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBCY3NUeXBlKHtcbiAgICAgIG5hbWU6IGAoJHt0eXBlcy5tYXAoKHQpID0+IHQubmFtZSkuam9pbihcIiwgXCIpfSlgLFxuICAgICAgc2VyaWFsaXplZFNpemU6ICh2YWx1ZXMpID0+IHtcbiAgICAgICAgbGV0IHRvdGFsID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHNpemUgPSB0eXBlc1tpXS5zZXJpYWxpemVkU2l6ZSh2YWx1ZXNbaV0pO1xuICAgICAgICAgIGlmIChzaXplID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0b3RhbCArPSBzaXplO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICAgIH0sXG4gICAgICByZWFkOiAocmVhZGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2YgdHlwZXMpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh0eXBlLnJlYWQocmVhZGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH0sXG4gICAgICB3cml0ZTogKHZhbHVlLCB3cml0ZXIpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHR5cGVzW2ldLndyaXRlKHZhbHVlW2ldLCB3cml0ZXIpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHZhbGlkYXRlOiAodmFsdWUpID0+IHtcbiAgICAgICAgb3B0aW9ucz8udmFsaWRhdGU/Lih2YWx1ZSk7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBhcnJheSwgZm91bmQgJHt0eXBlb2YgdmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gdHlwZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgYXJyYXkgb2YgbGVuZ3RoICR7dHlwZXMubGVuZ3RofSwgZm91bmQgJHt2YWx1ZS5sZW5ndGh9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBCY3NUeXBlIHJlcHJlc2VudGluZyBhIHN0cnVjdCBvZiBhIGdpdmVuIHNldCBvZiBmaWVsZHNcbiAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIHN0cnVjdFxuICAgKiBAcGFyYW0gZmllbGRzIFRoZSBmaWVsZHMgb2YgdGhlIHN0cnVjdC4gVGhlIG9yZGVyIG9mIHRoZSBmaWVsZHMgYWZmZWN0cyBob3cgZGF0YSBpcyBzZXJpYWxpemVkIGFuZCBkZXNlcmlhbGl6ZWRcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3Qgc3RydWN0ID0gYmNzLnN0cnVjdCgnTXlTdHJ1Y3QnLCB7XG4gICAqICBhOiBiY3MudTgoKSxcbiAgICogIGI6IGJjcy5zdHJpbmcoKSxcbiAgICogfSlcbiAgICogc3RydWN0LnNlcmlhbGl6ZSh7IGE6IDEsIGI6ICdhJyB9KS50b0J5dGVzKCkgLy8gVWludDhBcnJheSBbIDEsIDEsIDk3IF1cbiAgICovXG4gIHN0cnVjdChuYW1lLCBmaWVsZHMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBjYW5vbmljYWxPcmRlciA9IE9iamVjdC5lbnRyaWVzKGZpZWxkcyk7XG4gICAgcmV0dXJuIG5ldyBCY3NUeXBlKHtcbiAgICAgIG5hbWUsXG4gICAgICBzZXJpYWxpemVkU2l6ZTogKHZhbHVlcykgPT4ge1xuICAgICAgICBsZXQgdG90YWwgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IFtmaWVsZCwgdHlwZV0gb2YgY2Fub25pY2FsT3JkZXIpIHtcbiAgICAgICAgICBjb25zdCBzaXplID0gdHlwZS5zZXJpYWxpemVkU2l6ZSh2YWx1ZXNbZmllbGRdKTtcbiAgICAgICAgICBpZiAoc2l6ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdG90YWwgKz0gc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgICB9LFxuICAgICAgcmVhZDogKHJlYWRlcikgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBbZmllbGQsIHR5cGVdIG9mIGNhbm9uaWNhbE9yZGVyKSB7XG4gICAgICAgICAgcmVzdWx0W2ZpZWxkXSA9IHR5cGUucmVhZChyZWFkZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgICAgd3JpdGU6ICh2YWx1ZSwgd3JpdGVyKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgW2ZpZWxkLCB0eXBlXSBvZiBjYW5vbmljYWxPcmRlcikge1xuICAgICAgICAgIHR5cGUud3JpdGUodmFsdWVbZmllbGRdLCB3cml0ZXIpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHZhbGlkYXRlOiAodmFsdWUpID0+IHtcbiAgICAgICAgb3B0aW9ucz8udmFsaWRhdGU/Lih2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIG9iamVjdCwgZm91bmQgJHt0eXBlb2YgdmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBCY3NUeXBlIHJlcHJlc2VudGluZyBhbiBlbnVtIG9mIGEgZ2l2ZW4gc2V0IG9mIG9wdGlvbnNcbiAgICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGVudW1cbiAgICogQHBhcmFtIHZhbHVlcyBUaGUgdmFsdWVzIG9mIHRoZSBlbnVtLiBUaGUgb3JkZXIgb2YgdGhlIHZhbHVlcyBhZmZlY3RzIGhvdyBkYXRhIGlzIHNlcmlhbGl6ZWQgYW5kIGRlc2VyaWFsaXplZC5cbiAgICogbnVsbCBjYW4gYmUgdXNlZCB0byByZXByZXNlbnQgYSB2YXJpYW50IHdpdGggbm8gZGF0YS5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgZW51bSA9IGJjcy5lbnVtKCdNeUVudW0nLCB7XG4gICAqICAgQTogYmNzLnU4KCksXG4gICAqICAgQjogYmNzLnN0cmluZygpLFxuICAgKiAgIEM6IG51bGwsXG4gICAqIH0pXG4gICAqIGVudW0uc2VyaWFsaXplKHsgQTogMSB9KS50b0J5dGVzKCkgLy8gVWludDhBcnJheSBbIDAsIDEgXVxuICAgKiBlbnVtLnNlcmlhbGl6ZSh7IEI6ICdhJyB9KS50b0J5dGVzKCkgLy8gVWludDhBcnJheSBbIDEsIDEsIDk3IF1cbiAgICogZW51bS5zZXJpYWxpemUoeyBDOiB0cnVlIH0pLnRvQnl0ZXMoKSAvLyBVaW50OEFycmF5IFsgMiBdXG4gICAqL1xuICBlbnVtKG5hbWUsIHZhbHVlcywgb3B0aW9ucykge1xuICAgIGNvbnN0IGNhbm9uaWNhbE9yZGVyID0gT2JqZWN0LmVudHJpZXModmFsdWVzKTtcbiAgICByZXR1cm4gbmV3IEJjc1R5cGUoe1xuICAgICAgbmFtZSxcbiAgICAgIHJlYWQ6IChyZWFkZXIpID0+IHtcbiAgICAgICAgY29uc3QgaW5kZXggPSByZWFkZXIucmVhZFVMRUIoKTtcbiAgICAgICAgY29uc3QgW25hbWUyLCB0eXBlXSA9IGNhbm9uaWNhbE9yZGVyW2luZGV4XTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBbbmFtZTJdOiB0eXBlPy5yZWFkKHJlYWRlcikgPz8gdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHdyaXRlOiAodmFsdWUsIHdyaXRlcikgPT4ge1xuICAgICAgICBjb25zdCBbbmFtZTIsIHZhbF0gPSBPYmplY3QuZW50cmllcyh2YWx1ZSlbMF07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2Fub25pY2FsT3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBbb3B0aW9uTmFtZSwgb3B0aW9uVHlwZV0gPSBjYW5vbmljYWxPcmRlcltpXTtcbiAgICAgICAgICBpZiAob3B0aW9uTmFtZSA9PT0gbmFtZTIpIHtcbiAgICAgICAgICAgIHdyaXRlci53cml0ZVVMRUIoaSk7XG4gICAgICAgICAgICBvcHRpb25UeXBlPy53cml0ZSh2YWwsIHdyaXRlcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHZhbGlkYXRlOiAodmFsdWUpID0+IHtcbiAgICAgICAgb3B0aW9ucz8udmFsaWRhdGU/Lih2YWx1ZSk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEV4cGVjdGVkIG9iamVjdCwgZm91bmQgJHt0eXBlb2YgdmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgRXhwZWN0ZWQgb2JqZWN0IHdpdGggb25lIGtleSwgZm91bmQgJHtrZXlzLmxlbmd0aH1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBbbmFtZTJdID0ga2V5cztcbiAgICAgICAgaWYgKCFPYmplY3QuaGFzT3duKHZhbHVlcywgbmFtZTIpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBlbnVtIHZhcmlhbnQgJHtuYW1lMn1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuICAvKipcbiAgICogQ3JlYXRlcyBhIEJjc1R5cGUgcmVwcmVzZW50aW5nIGEgbWFwIG9mIGEgZ2l2ZW4ga2V5IGFuZCB2YWx1ZSB0eXBlXG4gICAqIEBwYXJhbSBrZXlUeXBlIFRoZSBCY3NUeXBlIG9mIHRoZSBrZXlcbiAgICogQHBhcmFtIHZhbHVlVHlwZSBUaGUgQmNzVHlwZSBvZiB0aGUgdmFsdWVcbiAgICogQGV4YW1wbGVcbiAgICogY29uc3QgbWFwID0gYmNzLm1hcChiY3MudTgoKSwgYmNzLnN0cmluZygpKVxuICAgKiBtYXAuc2VyaWFsaXplKG5ldyBNYXAoW1syLCAnYSddXSkpLnRvQnl0ZXMoKSAvLyBVaW50OEFycmF5IFsgMSwgMiwgMSwgOTcgXVxuICAgKi9cbiAgbWFwKGtleVR5cGUsIHZhbHVlVHlwZSkge1xuICAgIHJldHVybiBiY3MudmVjdG9yKGJjcy50dXBsZShba2V5VHlwZSwgdmFsdWVUeXBlXSkpLnRyYW5zZm9ybSh7XG4gICAgICBuYW1lOiBgTWFwPCR7a2V5VHlwZS5uYW1lfSwgJHt2YWx1ZVR5cGUubmFtZX0+YCxcbiAgICAgIGlucHV0OiAodmFsdWUpID0+IHtcbiAgICAgICAgcmV0dXJuIFsuLi52YWx1ZS5lbnRyaWVzKCldO1xuICAgICAgfSxcbiAgICAgIG91dHB1dDogKHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsXSBvZiB2YWx1ZSkge1xuICAgICAgICAgIHJlc3VsdC5zZXQoa2V5LCB2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKlxuICAgKiBHZW5lcmljcyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYXMgZ2VuZXJpYyB0eXBlc2NyaXB0IGZ1bmN0aW9ucyBpbnN0ZWFkOlxuICAgKlxuICAgKiBgYGB0c1xuICAgKiBmdW5jdGlvbiBWZWNNYXA8SywgVj4sIChLOiBCY3NUeXBlPEs+LCBWOiBCY3NUeXBlPFY+KSB7XG4gICAqICAgcmV0dXJuIGJjcy5zdHJ1Y3QoJ1ZlY01hcDxLLCBWPicsIHtcbiAgICogICAgIGtleXM6IGJjcy52ZWN0b3IoSyksXG4gICAqICAgICB2YWx1ZXM6IGJjcy52ZWN0b3IoViksXG4gICAqICAgfSlcbiAgICogfVxuICAgKiBgYGBcbiAgICovXG4gIGdlbmVyaWMoX25hbWVzLCBjYikge1xuICAgIHJldHVybiAoLi4udHlwZXMpID0+IHtcbiAgICAgIHJldHVybiBjYiguLi50eXBlcykudHJhbnNmb3JtKHtcbiAgICAgICAgbmFtZTogYCR7Y2IubmFtZX08JHt0eXBlcy5tYXAoKHQpID0+IHQubmFtZSkuam9pbihcIiwgXCIpfT5gLFxuICAgICAgICBpbnB1dDogKHZhbHVlKSA9PiB2YWx1ZSxcbiAgICAgICAgb3V0cHV0OiAodmFsdWUpID0+IHZhbHVlXG4gICAgICB9KTtcbiAgICB9O1xuICB9LFxuICAvKipcbiAgICogQ3JlYXRlcyBhIEJjc1R5cGUgdGhhdCB3cmFwcyBhbm90aGVyIEJjc1R5cGUgd2hpY2ggaXMgbGF6aWx5IGV2YWx1YXRlZC4gVGhpcyBpcyB1c2VmdWwgZm9yIGNyZWF0aW5nIHJlY3Vyc2l2ZSB0eXBlcy5cbiAgICogQHBhcmFtIGNiIEEgY2FsbGJhY2sgdGhhdCByZXR1cm5zIHRoZSBCY3NUeXBlXG4gICAqL1xuICBsYXp5KGNiKSB7XG4gICAgcmV0dXJuIGxhenlCY3NUeXBlKGNiKTtcbiAgfVxufTtcbmV4cG9ydCB7XG4gIGJjc1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJjcy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJCY3NUeXBlIiwiYmlnVUludEJjc1R5cGUiLCJkeW5hbWljU2l6ZUJjc1R5cGUiLCJmaXhlZFNpemVCY3NUeXBlIiwibGF6eUJjc1R5cGUiLCJzdHJpbmdMaWtlQmNzVHlwZSIsInVJbnRCY3NUeXBlIiwidWxlYkVuY29kZSIsImJjcyIsInU4Iiwib3B0aW9ucyIsIm5hbWUiLCJyZWFkTWV0aG9kIiwid3JpdGVNZXRob2QiLCJzaXplIiwibWF4VmFsdWUiLCJ1MTYiLCJ1MzIiLCJ1NjQiLCJ1MTI4IiwidTI1NiIsImJvb2wiLCJyZWFkIiwicmVhZGVyIiwicmVhZDgiLCJ3cml0ZSIsInZhbHVlIiwid3JpdGVyIiwid3JpdGU4IiwidmFsaWRhdGUiLCJUeXBlRXJyb3IiLCJ1bGViMTI4IiwicmVhZFVMRUIiLCJzZXJpYWxpemUiLCJVaW50OEFycmF5IiwiZnJvbSIsImJ5dGVzIiwicmVhZEJ5dGVzIiwiaSIsImxlbmd0aCIsInN0cmluZyIsInRvQnl0ZXMiLCJUZXh0RW5jb2RlciIsImVuY29kZSIsImZyb21CeXRlcyIsIlRleHREZWNvZGVyIiwiZGVjb2RlIiwiZml4ZWRBcnJheSIsInR5cGUiLCJyZXN1bHQiLCJBcnJheSIsIml0ZW0iLCJvcHRpb24iLCJlbnVtIiwiTm9uZSIsIlNvbWUiLCJ0cmFuc2Zvcm0iLCJpbnB1dCIsIm91dHB1dCIsInZlY3RvciIsIndyaXRlVUxFQiIsInR1cGxlIiwidHlwZXMiLCJtYXAiLCJ0Iiwiam9pbiIsInNlcmlhbGl6ZWRTaXplIiwidmFsdWVzIiwidG90YWwiLCJwdXNoIiwiaXNBcnJheSIsInN0cnVjdCIsImZpZWxkcyIsImNhbm9uaWNhbE9yZGVyIiwiT2JqZWN0IiwiZW50cmllcyIsImZpZWxkIiwiaW5kZXgiLCJuYW1lMiIsInZhbCIsIm9wdGlvbk5hbWUiLCJvcHRpb25UeXBlIiwia2V5cyIsImhhc093biIsImtleVR5cGUiLCJ2YWx1ZVR5cGUiLCJNYXAiLCJrZXkiLCJzZXQiLCJnZW5lcmljIiwiX25hbWVzIiwiY2IiLCJsYXp5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/bcs.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/hex.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/hex.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fromHEX: () => (/* binding */ fromHEX),\n/* harmony export */   toHEX: () => (/* binding */ toHEX)\n/* harmony export */ });\nfunction fromHEX(hexStr) {\n    const normalized = hexStr.startsWith(\"0x\") ? hexStr.slice(2) : hexStr;\n    const padded = normalized.length % 2 === 0 ? normalized : `0${normalized}}`;\n    const intArr = padded.match(/.{2}/g)?.map((byte)=>parseInt(byte, 16)) ?? [];\n    return Uint8Array.from(intArr);\n}\nfunction toHEX(bytes) {\n    return bytes.reduce((str, byte)=>str + byte.toString(16).padStart(2, \"0\"), \"\");\n}\n //# sourceMappingURL=hex.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG15c3RlbitiY3NAMC4xMS4xL25vZGVfbW9kdWxlcy9AbXlzdGVuL2Jjcy9kaXN0L2VzbS9oZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxTQUFTQSxRQUFRQyxNQUFNO0lBQ3JCLE1BQU1DLGFBQWFELE9BQU9FLFVBQVUsQ0FBQyxRQUFRRixPQUFPRyxLQUFLLENBQUMsS0FBS0g7SUFDL0QsTUFBTUksU0FBU0gsV0FBV0ksTUFBTSxHQUFHLE1BQU0sSUFBSUosYUFBYSxDQUFDLENBQUMsRUFBRUEsV0FBVyxDQUFDLENBQUM7SUFDM0UsTUFBTUssU0FBU0YsT0FBT0csS0FBSyxDQUFDLFVBQVVDLElBQUksQ0FBQ0MsT0FBU0MsU0FBU0QsTUFBTSxRQUFRLEVBQUU7SUFDN0UsT0FBT0UsV0FBV0MsSUFBSSxDQUFDTjtBQUN6QjtBQUNBLFNBQVNPLE1BQU1DLEtBQUs7SUFDbEIsT0FBT0EsTUFBTUMsTUFBTSxDQUFDLENBQUNDLEtBQUtQLE9BQVNPLE1BQU1QLEtBQUtRLFFBQVEsQ0FBQyxJQUFJQyxRQUFRLENBQUMsR0FBRyxNQUFNO0FBQy9FO0FBSUUsQ0FDRiwrQkFBK0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3Rhc2NhbS1wcm90b2NvbC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AbXlzdGVuK2Jjc0AwLjExLjEvbm9kZV9tb2R1bGVzL0BteXN0ZW4vYmNzL2Rpc3QvZXNtL2hleC5qcz80Zjg1Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGZyb21IRVgoaGV4U3RyKSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSBoZXhTdHIuc3RhcnRzV2l0aChcIjB4XCIpID8gaGV4U3RyLnNsaWNlKDIpIDogaGV4U3RyO1xuICBjb25zdCBwYWRkZWQgPSBub3JtYWxpemVkLmxlbmd0aCAlIDIgPT09IDAgPyBub3JtYWxpemVkIDogYDAke25vcm1hbGl6ZWR9fWA7XG4gIGNvbnN0IGludEFyciA9IHBhZGRlZC5tYXRjaCgvLnsyfS9nKT8ubWFwKChieXRlKSA9PiBwYXJzZUludChieXRlLCAxNikpID8/IFtdO1xuICByZXR1cm4gVWludDhBcnJheS5mcm9tKGludEFycik7XG59XG5mdW5jdGlvbiB0b0hFWChieXRlcykge1xuICByZXR1cm4gYnl0ZXMucmVkdWNlKChzdHIsIGJ5dGUpID0+IHN0ciArIGJ5dGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgXCJcIik7XG59XG5leHBvcnQge1xuICBmcm9tSEVYLFxuICB0b0hFWFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhleC5qcy5tYXBcbiJdLCJuYW1lcyI6WyJmcm9tSEVYIiwiaGV4U3RyIiwibm9ybWFsaXplZCIsInN0YXJ0c1dpdGgiLCJzbGljZSIsInBhZGRlZCIsImxlbmd0aCIsImludEFyciIsIm1hdGNoIiwibWFwIiwiYnl0ZSIsInBhcnNlSW50IiwiVWludDhBcnJheSIsImZyb20iLCJ0b0hFWCIsImJ5dGVzIiwicmVkdWNlIiwic3RyIiwidG9TdHJpbmciLCJwYWRTdGFydCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/hex.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/legacy-registry.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/legacy-registry.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BCS: () => (/* binding */ BCS),\n/* harmony export */   getRustConfig: () => (/* binding */ getRustConfig),\n/* harmony export */   getSuiMoveConfig: () => (/* binding */ getSuiMoveConfig),\n/* harmony export */   registerPrimitives: () => (/* binding */ registerPrimitives)\n/* harmony export */ });\n/* harmony import */ var _b58_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./b58.js */ \"(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/b58.js\");\n/* harmony import */ var _b64_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./b64.js */ \"(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/b64.js\");\n/* harmony import */ var _bcs_type_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bcs-type.js */ \"(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/bcs-type.js\");\n/* harmony import */ var _hex_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hex.js */ \"(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/hex.js\");\n/* harmony import */ var _reader_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./reader.js */ \"(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/reader.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/utils.js\");\n/* harmony import */ var _writer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./writer.js */ \"(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/writer.js\");\n\n\n\n\n\n\n\nconst SUI_ADDRESS_LENGTH = 32;\nconst _BCS = class {\n    /**\n   * Construct a BCS instance with a prepared schema.\n   *\n   * @param schema A prepared schema with type definitions\n   * @param withPrimitives Whether to register primitive types by default\n   */ constructor(schema){\n        /**\n     * Map of kind `TypeName => TypeInterface`. Holds all\n     * callbacks for (de)serialization of every registered type.\n     *\n     * If the value stored is a string, it is treated as an alias.\n     */ this.types = /* @__PURE__ */ new Map();\n        /**\n     * Count temp keys to generate a new one when requested.\n     */ this.counter = 0;\n        if (schema instanceof _BCS) {\n            this.schema = schema.schema;\n            this.types = new Map(schema.types);\n            return;\n        }\n        this.schema = schema;\n        this.registerAddressType(_BCS.ADDRESS, schema.addressLength, schema.addressEncoding);\n        this.registerVectorType(schema.vectorType);\n        if (schema.types && schema.types.structs) {\n            for (let name of Object.keys(schema.types.structs)){\n                this.registerStructType(name, schema.types.structs[name]);\n            }\n        }\n        if (schema.types && schema.types.enums) {\n            for (let name of Object.keys(schema.types.enums)){\n                this.registerEnumType(name, schema.types.enums[name]);\n            }\n        }\n        if (schema.types && schema.types.aliases) {\n            for (let name of Object.keys(schema.types.aliases)){\n                this.registerAlias(name, schema.types.aliases[name]);\n            }\n        }\n        if (schema.withPrimitives !== false) {\n            registerPrimitives(this);\n        }\n    }\n    /**\n   * Name of the key to use for temporary struct definitions.\n   * Returns a temp key + index (for a case when multiple temp\n   * structs are processed).\n   */ tempKey() {\n        return `bcs-struct-${++this.counter}`;\n    }\n    /**\n   * Serialize data into bcs.\n   *\n   * @example\n   * bcs.registerVectorType('vector<u8>', 'u8');\n   *\n   * let serialized = BCS\n   *   .set('vector<u8>', [1,2,3,4,5,6])\n   *   .toBytes();\n   *\n   * console.assert(toHex(serialized) === '06010203040506');\n   *\n   * @param type Name of the type to serialize (must be registered) or a struct type.\n   * @param data Data to serialize.\n   * @param size Serialization buffer size. Default 1024 = 1KB.\n   * @return A BCS reader instance. Usually you'd want to call `.toBytes()`\n   */ ser(type, data, options) {\n        if (typeof type === \"string\" || Array.isArray(type)) {\n            const { name, params } = this.parseTypeName(type);\n            return this.getTypeInterface(name).encode(this, data, options, params);\n        }\n        if (typeof type === \"object\") {\n            const key = this.tempKey();\n            const temp = new _BCS(this);\n            return temp.registerStructType(key, type).ser(key, data, options);\n        }\n        throw new Error(`Incorrect type passed into the '.ser()' function. \n${JSON.stringify(type)}`);\n    }\n    /**\n   * Deserialize BCS into a JS type.\n   *\n   * @example\n   * let num = bcs.ser('u64', '4294967295').toString('hex');\n   * let deNum = bcs.de('u64', num, 'hex');\n   * console.assert(deNum.toString(10) === '4294967295');\n   *\n   * @param type Name of the type to deserialize (must be registered) or a struct type definition.\n   * @param data Data to deserialize.\n   * @param encoding Optional - encoding to use if data is of type String\n   * @return Deserialized data.\n   */ de(type, data, encoding) {\n        if (typeof data === \"string\") {\n            if (encoding) {\n                data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.decodeStr)(data, encoding);\n            } else {\n                throw new Error(\"To pass a string to `bcs.de`, specify encoding\");\n            }\n        }\n        if (typeof type === \"string\" || Array.isArray(type)) {\n            const { name, params } = this.parseTypeName(type);\n            return this.getTypeInterface(name).decode(this, data, params);\n        }\n        if (typeof type === \"object\") {\n            const temp = new _BCS(this);\n            const key = this.tempKey();\n            return temp.registerStructType(key, type).de(key, data, encoding);\n        }\n        throw new Error(`Incorrect type passed into the '.de()' function. \n${JSON.stringify(type)}`);\n    }\n    /**\n   * Check whether a `TypeInterface` has been loaded for a `type`.\n   * @param type Name of the type to check.\n   * @returns\n   */ hasType(type) {\n        return this.types.has(type);\n    }\n    /**\n   * Create an alias for a type.\n   * WARNING: this can potentially lead to recursion\n   * @param name Alias to use\n   * @param forType Type to reference\n   * @returns\n   *\n   * @example\n   * ```\n   * let bcs = new BCS(getSuiMoveConfig());\n   * bcs.registerAlias('ObjectDigest', BCS.BASE58);\n   * let b58_digest = bcs.de('ObjectDigest', '<digest_bytes>', 'base64');\n   * ```\n   */ registerAlias(name, forType) {\n        this.types.set(name, forType);\n        return this;\n    }\n    /**\n   * Method to register new types for BCS internal representation.\n   * For each registered type 2 callbacks must be specified and one is optional:\n   *\n   * - encodeCb(writer, data) - write a way to serialize data with BcsWriter;\n   * - decodeCb(reader) - write a way to deserialize data with BcsReader;\n   * - validateCb(data) - validate data - either return bool or throw an error\n   *\n   * @example\n   * // our type would be a string that consists only of numbers\n   * bcs.registerType('number_string',\n   *    (writer, data) => writer.writeVec(data, (w, el) => w.write8(el)),\n   *    (reader) => reader.readVec((r) => r.read8()).join(''), // read each value as u8\n   *    (value) => /[0-9]+/.test(value) // test that it has at least one digit\n   * );\n   * console.log(Array.from(bcs.ser('number_string', '12345').toBytes()) == [5,1,2,3,4,5]);\n   *\n   * @param name\n   * @param encodeCb Callback to encode a value.\n   * @param decodeCb Callback to decode a value.\n   * @param validateCb Optional validator Callback to check type before serialization.\n   */ registerType(typeName, encodeCb, decodeCb, validateCb = ()=>true) {\n        const { name, params: generics } = this.parseTypeName(typeName);\n        this.types.set(name, {\n            encode (self, data, options, typeParams) {\n                const typeMap = generics.reduce((acc, value, index)=>{\n                    return Object.assign(acc, {\n                        [value]: typeParams[index]\n                    });\n                }, {});\n                return this._encodeRaw.call(self, new _writer_js__WEBPACK_IMPORTED_MODULE_1__.BcsWriter(options), data, typeParams, typeMap);\n            },\n            decode (self, data, typeParams) {\n                const typeMap = generics.reduce((acc, value, index)=>{\n                    return Object.assign(acc, {\n                        [value]: typeParams[index]\n                    });\n                }, {});\n                return this._decodeRaw.call(self, new _reader_js__WEBPACK_IMPORTED_MODULE_2__.BcsReader(data), typeParams, typeMap);\n            },\n            // these methods should always be used with caution as they require pre-defined\n            // reader and writer and mainly exist to allow multi-field (de)serialization;\n            _encodeRaw (writer, data, typeParams, typeMap) {\n                if (validateCb(data)) {\n                    return encodeCb.call(this, writer, data, typeParams, typeMap);\n                } else {\n                    throw new Error(`Validation failed for type ${name}, data: ${data}`);\n                }\n            },\n            _decodeRaw (reader, typeParams, typeMap) {\n                return decodeCb.call(this, reader, typeParams, typeMap);\n            }\n        });\n        return this;\n    }\n    /**\n  \t * Method to register BcsType instances to the registry\n  \t * Types are registered with a callback that provides BcsType instances for each generic\n  \t * passed to the type.\n  \t *\n  \t * - createType(...generics) - Return a BcsType instance\n  \t *\n  \t * @example\n  \t * // our type would be a string that consists only of numbers\n  \t * bcs.registerType('Box<T>', (T) => {\n  \t * \t\treturn bcs.struct({\n  \t * \t\t\tvalue: T\n  \t * \t\t});\n  \t * });\n  \n  \t * console.log(Array.from(bcs.ser('Box<string>', '12345').toBytes()) == [5,1,2,3,4,5]);\n  \t *\n  \t * @param name\n  \t * @param createType a Callback to create the BcsType with any passed in generics\n  \t */ registerBcsType(typeName, createType) {\n        this.registerType(typeName, (writer, data, typeParams)=>{\n            const generics = typeParams.map((param)=>new _bcs_type_js__WEBPACK_IMPORTED_MODULE_3__.BcsType({\n                    name: String(param),\n                    write: (data2, writer2)=>{\n                        const { name, params } = this.parseTypeName(param);\n                        const typeInterface = this.getTypeInterface(name);\n                        const typeMap = params.reduce((acc, value, index)=>{\n                            return Object.assign(acc, {\n                                [value]: typeParams[index]\n                            });\n                        }, {});\n                        return typeInterface._encodeRaw.call(this, writer2, data2, params, typeMap);\n                    },\n                    read: ()=>{\n                        throw new Error(\"Not implemented\");\n                    }\n                }));\n            createType(...generics).write(data, writer);\n            return writer;\n        }, (reader, typeParams)=>{\n            const generics = typeParams.map((param)=>new _bcs_type_js__WEBPACK_IMPORTED_MODULE_3__.BcsType({\n                    name: String(param),\n                    write: (_data, _writer)=>{\n                        throw new Error(\"Not implemented\");\n                    },\n                    read: (reader2)=>{\n                        const { name, params } = this.parseTypeName(param);\n                        const typeInterface = this.getTypeInterface(name);\n                        const typeMap = params.reduce((acc, value, index)=>{\n                            return Object.assign(acc, {\n                                [value]: typeParams[index]\n                            });\n                        }, {});\n                        return typeInterface._decodeRaw.call(this, reader2, params, typeMap);\n                    }\n                }));\n            return createType(...generics).read(reader);\n        });\n        return this;\n    }\n    /**\n   * Register an address type which is a sequence of U8s of specified length.\n   * @example\n   * bcs.registerAddressType('address', SUI_ADDRESS_LENGTH);\n   * let addr = bcs.de('address', 'c3aca510c785c7094ac99aeaa1e69d493122444df50bb8a99dfa790c654a79af');\n   *\n   * @param name Name of the address type.\n   * @param length Byte length of the address.\n   * @param encoding Encoding to use for the address type\n   * @returns\n   */ registerAddressType(name, length, encoding = \"hex\") {\n        switch(encoding){\n            case \"base64\":\n                return this.registerType(name, function encodeAddress(writer, data) {\n                    return (0,_b64_js__WEBPACK_IMPORTED_MODULE_4__.fromB64)(data).reduce((writer2, el)=>writer2.write8(el), writer);\n                }, function decodeAddress(reader) {\n                    return (0,_b64_js__WEBPACK_IMPORTED_MODULE_4__.toB64)(reader.readBytes(length));\n                });\n            case \"hex\":\n                return this.registerType(name, function encodeAddress(writer, data) {\n                    return (0,_hex_js__WEBPACK_IMPORTED_MODULE_5__.fromHEX)(data).reduce((writer2, el)=>writer2.write8(el), writer);\n                }, function decodeAddress(reader) {\n                    return (0,_hex_js__WEBPACK_IMPORTED_MODULE_5__.toHEX)(reader.readBytes(length));\n                });\n            default:\n                throw new Error(\"Unsupported encoding! Use either hex or base64\");\n        }\n    }\n    /**\n   * Register custom vector type inside the bcs.\n   *\n   * @example\n   * bcs.registerVectorType('vector<T>'); // generic registration\n   * let array = bcs.de('vector<u8>', '06010203040506', 'hex'); // [1,2,3,4,5,6];\n   * let again = bcs.ser('vector<u8>', [1,2,3,4,5,6]).toString('hex');\n   *\n   * @param name Name of the type to register\n   * @param elementType Optional name of the inner type of the vector\n   * @return Returns self for chaining.\n   */ registerVectorType(typeName) {\n        let { name, params } = this.parseTypeName(typeName);\n        if (params.length > 1) {\n            throw new Error(\"Vector can have only one type parameter; got \" + name);\n        }\n        return this.registerType(typeName, function encodeVector(writer, data, typeParams, typeMap) {\n            return writer.writeVec(data, (writer2, el)=>{\n                let elementType = typeParams[0];\n                if (!elementType) {\n                    throw new Error(`Incorrect number of type parameters passed a to vector '${typeName}'`);\n                }\n                let { name: name2, params: params2 } = this.parseTypeName(elementType);\n                if (this.hasType(name2)) {\n                    return this.getTypeInterface(name2)._encodeRaw.call(this, writer2, el, params2, typeMap);\n                }\n                if (!(name2 in typeMap)) {\n                    throw new Error(`Unable to find a matching type definition for ${name2} in vector; make sure you passed a generic`);\n                }\n                let { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name2]);\n                return this.getTypeInterface(innerName)._encodeRaw.call(this, writer2, el, innerParams, typeMap);\n            });\n        }, function decodeVector(reader, typeParams, typeMap) {\n            return reader.readVec((reader2)=>{\n                let elementType = typeParams[0];\n                if (!elementType) {\n                    throw new Error(`Incorrect number of type parameters passed to a vector '${typeName}'`);\n                }\n                let { name: name2, params: params2 } = this.parseTypeName(elementType);\n                if (this.hasType(name2)) {\n                    return this.getTypeInterface(name2)._decodeRaw.call(this, reader2, params2, typeMap);\n                }\n                if (!(name2 in typeMap)) {\n                    throw new Error(`Unable to find a matching type definition for ${name2} in vector; make sure you passed a generic`);\n                }\n                let { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name2]);\n                return this.getTypeInterface(innerName)._decodeRaw.call(this, reader2, innerParams, typeMap);\n            });\n        });\n    }\n    /**\n   * Safe method to register a custom Move struct. The first argument is a name of the\n   * struct which is only used on the FrontEnd and has no affect on serialization results,\n   * and the second is a struct description passed as an Object.\n   *\n   * The description object MUST have the same order on all of the platforms (ie in Move\n   * or in Rust).\n   *\n   * @example\n   * // Move / Rust struct\n   * // struct Coin {\n   * //   value: u64,\n   * //   owner: vector<u8>, // name // Vec<u8> in Rust\n   * //   is_locked: bool,\n   * // }\n   *\n   * bcs.registerStructType('Coin', {\n   *   value: bcs.U64,\n   *   owner: bcs.STRING,\n   *   is_locked: bcs.BOOL\n   * });\n   *\n   * // Created in Rust with diem/bcs\n   * // let rust_bcs_str = '80d1b105600000000e4269672057616c6c65742047757900';\n   * let rust_bcs_str = [ // using an Array here as BCS works with Uint8Array\n   *  128, 209, 177,   5,  96,  0,  0,\n   *    0,  14,  66, 105, 103, 32, 87,\n   *   97, 108, 108, 101, 116, 32, 71,\n   *  117, 121,   0\n   * ];\n   *\n   * // Let's encode the value as well\n   * let test_set = bcs.ser('Coin', {\n   *   owner: 'Big Wallet Guy',\n   *   value: '412412400000',\n   *   is_locked: false,\n   * });\n   *\n   * console.assert(Array.from(test_set.toBytes()) === rust_bcs_str, 'Whoopsie, result mismatch');\n   *\n   * @param name Name of the type to register.\n   * @param fields Fields of the struct. Must be in the correct order.\n   * @return Returns BCS for chaining.\n   */ registerStructType(typeName, fields) {\n        for(let key in fields){\n            let internalName = this.tempKey();\n            let value = fields[key];\n            if (!Array.isArray(value) && typeof value !== \"string\") {\n                fields[key] = internalName;\n                this.registerStructType(internalName, value);\n            }\n        }\n        let struct = Object.freeze(fields);\n        let canonicalOrder = Object.keys(struct);\n        let { name: structName, params: generics } = this.parseTypeName(typeName);\n        return this.registerType(typeName, function encodeStruct(writer, data, typeParams, typeMap) {\n            if (!data || data.constructor !== Object) {\n                throw new Error(`Expected ${structName} to be an Object, got: ${data}`);\n            }\n            if (typeParams.length !== generics.length) {\n                throw new Error(`Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`);\n            }\n            for (let key of canonicalOrder){\n                if (!(key in data)) {\n                    throw new Error(`Struct ${structName} requires field ${key}:${struct[key]}`);\n                }\n                const { name: fieldType, params: fieldParams } = this.parseTypeName(struct[key]);\n                if (!generics.includes(fieldType)) {\n                    this.getTypeInterface(fieldType)._encodeRaw.call(this, writer, data[key], fieldParams, typeMap);\n                } else {\n                    const paramIdx = generics.indexOf(fieldType);\n                    let { name, params } = this.parseTypeName(typeParams[paramIdx]);\n                    if (this.hasType(name)) {\n                        this.getTypeInterface(name)._encodeRaw.call(this, writer, data[key], params, typeMap);\n                        continue;\n                    }\n                    if (!(name in typeMap)) {\n                        throw new Error(`Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`);\n                    }\n                    let { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);\n                    this.getTypeInterface(innerName)._encodeRaw.call(this, writer, data[key], innerParams, typeMap);\n                }\n            }\n            return writer;\n        }, function decodeStruct(reader, typeParams, typeMap) {\n            if (typeParams.length !== generics.length) {\n                throw new Error(`Incorrect number of generic parameters passed; expected: ${generics.length}, got: ${typeParams.length}`);\n            }\n            let result = {};\n            for (let key of canonicalOrder){\n                const { name: fieldName, params: fieldParams } = this.parseTypeName(struct[key]);\n                if (!generics.includes(fieldName)) {\n                    result[key] = this.getTypeInterface(fieldName)._decodeRaw.call(this, reader, fieldParams, typeMap);\n                } else {\n                    const paramIdx = generics.indexOf(fieldName);\n                    let { name, params } = this.parseTypeName(typeParams[paramIdx]);\n                    if (this.hasType(name)) {\n                        result[key] = this.getTypeInterface(name)._decodeRaw.call(this, reader, params, typeMap);\n                        continue;\n                    }\n                    if (!(name in typeMap)) {\n                        throw new Error(`Unable to find a matching type definition for ${name} in ${structName}; make sure you passed a generic`);\n                    }\n                    let { name: innerName, params: innerParams } = this.parseTypeName(typeMap[name]);\n                    result[key] = this.getTypeInterface(innerName)._decodeRaw.call(this, reader, innerParams, typeMap);\n                }\n            }\n            return result;\n        });\n    }\n    /**\n   * Safe method to register custom enum type where each invariant holds the value of another type.\n   * @example\n   * bcs.registerStructType('Coin', { value: 'u64' });\n   * bcs.registerEnumType('MyEnum', {\n   *  single: 'Coin',\n   *  multi: 'vector<Coin>',\n   *  empty: null\n   * });\n   *\n   * console.log(\n   *  bcs.de('MyEnum', 'AICWmAAAAAAA', 'base64'), // { single: { value: 10000000 } }\n   *  bcs.de('MyEnum', 'AQIBAAAAAAAAAAIAAAAAAAAA', 'base64')  // { multi: [ { value: 1 }, { value: 2 } ] }\n   * )\n   *\n   * // and serialization\n   * bcs.ser('MyEnum', { single: { value: 10000000 } }).toBytes();\n   * bcs.ser('MyEnum', { multi: [ { value: 1 }, { value: 2 } ] });\n   *\n   * @param name\n   * @param variants\n   */ registerEnumType(typeName, variants) {\n        for(let key in variants){\n            let internalName = this.tempKey();\n            let value = variants[key];\n            if (value !== null && !Array.isArray(value) && typeof value !== \"string\") {\n                variants[key] = internalName;\n                this.registerStructType(internalName, value);\n            }\n        }\n        let struct = Object.freeze(variants);\n        let canonicalOrder = Object.keys(struct);\n        let { name, params: canonicalTypeParams } = this.parseTypeName(typeName);\n        return this.registerType(typeName, function encodeEnum(writer, data, typeParams, typeMap) {\n            if (!data) {\n                throw new Error(`Unable to write enum \"${name}\", missing data.\nReceived: \"${data}\"`);\n            }\n            if (typeof data !== \"object\") {\n                throw new Error(`Incorrect data passed into enum \"${name}\", expected object with properties: \"${canonicalOrder.join(\" | \")}\".\nReceived: \"${JSON.stringify(data)}\"`);\n            }\n            let key = Object.keys(data)[0];\n            if (key === void 0) {\n                throw new Error(`Empty object passed as invariant of the enum \"${name}\"`);\n            }\n            let orderByte = canonicalOrder.indexOf(key);\n            if (orderByte === -1) {\n                throw new Error(`Unknown invariant of the enum \"${name}\", allowed values: \"${canonicalOrder.join(\" | \")}\"; received \"${key}\"`);\n            }\n            let invariant = canonicalOrder[orderByte];\n            let invariantType = struct[invariant];\n            writer.write8(orderByte);\n            if (invariantType === null) {\n                return writer;\n            }\n            let paramIndex = canonicalTypeParams.indexOf(invariantType);\n            let typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];\n            {\n                let { name: name2, params } = this.parseTypeName(typeOrParam);\n                return this.getTypeInterface(name2)._encodeRaw.call(this, writer, data[key], params, typeMap);\n            }\n        }, function decodeEnum(reader, typeParams, typeMap) {\n            let orderByte = reader.readULEB();\n            let invariant = canonicalOrder[orderByte];\n            let invariantType = struct[invariant];\n            if (orderByte === -1) {\n                throw new Error(`Decoding type mismatch, expected enum \"${name}\" invariant index, received \"${orderByte}\"`);\n            }\n            if (invariantType === null) {\n                return {\n                    [invariant]: true\n                };\n            }\n            let paramIndex = canonicalTypeParams.indexOf(invariantType);\n            let typeOrParam = paramIndex === -1 ? invariantType : typeParams[paramIndex];\n            {\n                let { name: name2, params } = this.parseTypeName(typeOrParam);\n                return {\n                    [invariant]: this.getTypeInterface(name2)._decodeRaw.call(this, reader, params, typeMap)\n                };\n            }\n        });\n    }\n    /**\n   * Get a set of encoders/decoders for specific type.\n   * Mainly used to define custom type de/serialization logic.\n   *\n   * @param type\n   * @returns {TypeInterface}\n   */ getTypeInterface(type) {\n        let typeInterface = this.types.get(type);\n        if (typeof typeInterface === \"string\") {\n            let chain = [];\n            while(typeof typeInterface === \"string\"){\n                if (chain.includes(typeInterface)) {\n                    throw new Error(`Recursive definition found: ${chain.join(\" -> \")} -> ${typeInterface}`);\n                }\n                chain.push(typeInterface);\n                typeInterface = this.types.get(typeInterface);\n            }\n        }\n        if (typeInterface === void 0) {\n            throw new Error(`Type ${type} is not registered`);\n        }\n        return typeInterface;\n    }\n    /**\n   * Parse a type name and get the type's generics.\n   * @example\n   * let { typeName, typeParams } = parseTypeName('Option<Coin<SUI>>');\n   * // typeName: Option\n   * // typeParams: [ 'Coin<SUI>' ]\n   *\n   * @param name Name of the type to process\n   * @returns Object with typeName and typeParams listed as Array\n   */ parseTypeName(name) {\n        if (Array.isArray(name)) {\n            let [typeName2, ...params2] = name;\n            return {\n                name: typeName2,\n                params: params2\n            };\n        }\n        if (typeof name !== \"string\") {\n            throw new Error(`Illegal type passed as a name of the type: ${name}`);\n        }\n        let [left, right] = this.schema.genericSeparators || [\n            \"<\",\n            \">\"\n        ];\n        let l_bound = name.indexOf(left);\n        let r_bound = Array.from(name).reverse().indexOf(right);\n        if (l_bound === -1 && r_bound === -1) {\n            return {\n                name,\n                params: []\n            };\n        }\n        if (l_bound === -1 || r_bound === -1) {\n            throw new Error(`Unclosed generic in name '${name}'`);\n        }\n        let typeName = name.slice(0, l_bound);\n        let params = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.splitGenericParameters)(name.slice(l_bound + 1, name.length - r_bound - 1), this.schema.genericSeparators);\n        return {\n            name: typeName,\n            params\n        };\n    }\n};\nlet BCS = _BCS;\n// Predefined types constants\nBCS.U8 = \"u8\";\nBCS.U16 = \"u16\";\nBCS.U32 = \"u32\";\nBCS.U64 = \"u64\";\nBCS.U128 = \"u128\";\nBCS.U256 = \"u256\";\nBCS.BOOL = \"bool\";\nBCS.VECTOR = \"vector\";\nBCS.ADDRESS = \"address\";\nBCS.STRING = \"string\";\nBCS.HEX = \"hex-string\";\nBCS.BASE58 = \"base58-string\";\nBCS.BASE64 = \"base64-string\";\nfunction registerPrimitives(bcs) {\n    bcs.registerType(BCS.U8, function(writer, data) {\n        return writer.write8(data);\n    }, function(reader) {\n        return reader.read8();\n    }, (u8)=>u8 < 256);\n    bcs.registerType(BCS.U16, function(writer, data) {\n        return writer.write16(data);\n    }, function(reader) {\n        return reader.read16();\n    }, (u16)=>u16 < 65536);\n    bcs.registerType(BCS.U32, function(writer, data) {\n        return writer.write32(data);\n    }, function(reader) {\n        return reader.read32();\n    }, (u32)=>u32 <= 4294967296n);\n    bcs.registerType(BCS.U64, function(writer, data) {\n        return writer.write64(data);\n    }, function(reader) {\n        return reader.read64();\n    });\n    bcs.registerType(BCS.U128, function(writer, data) {\n        return writer.write128(data);\n    }, function(reader) {\n        return reader.read128();\n    });\n    bcs.registerType(BCS.U256, function(writer, data) {\n        return writer.write256(data);\n    }, function(reader) {\n        return reader.read256();\n    });\n    bcs.registerType(BCS.BOOL, function(writer, data) {\n        return writer.write8(data);\n    }, function(reader) {\n        return reader.read8().toString(10) === \"1\";\n    });\n    bcs.registerType(BCS.STRING, function(writer, data) {\n        return writer.writeVec(Array.from(data), (writer2, el)=>writer2.write8(el.charCodeAt(0)));\n    }, function(reader) {\n        return reader.readVec((reader2)=>reader2.read8()).map((el)=>String.fromCharCode(Number(el))).join(\"\");\n    }, (_str)=>true);\n    bcs.registerType(BCS.HEX, function(writer, data) {\n        return writer.writeVec(Array.from((0,_hex_js__WEBPACK_IMPORTED_MODULE_5__.fromHEX)(data)), (writer2, el)=>writer2.write8(el));\n    }, function(reader) {\n        let bytes = reader.readVec((reader2)=>reader2.read8());\n        return (0,_hex_js__WEBPACK_IMPORTED_MODULE_5__.toHEX)(new Uint8Array(bytes));\n    });\n    bcs.registerType(BCS.BASE58, function(writer, data) {\n        return writer.writeVec(Array.from((0,_b58_js__WEBPACK_IMPORTED_MODULE_6__.fromB58)(data)), (writer2, el)=>writer2.write8(el));\n    }, function(reader) {\n        let bytes = reader.readVec((reader2)=>reader2.read8());\n        return (0,_b58_js__WEBPACK_IMPORTED_MODULE_6__.toB58)(new Uint8Array(bytes));\n    });\n    bcs.registerType(BCS.BASE64, function(writer, data) {\n        return writer.writeVec(Array.from((0,_b64_js__WEBPACK_IMPORTED_MODULE_4__.fromB64)(data)), (writer2, el)=>writer2.write8(el));\n    }, function(reader) {\n        let bytes = reader.readVec((reader2)=>reader2.read8());\n        return (0,_b64_js__WEBPACK_IMPORTED_MODULE_4__.toB64)(new Uint8Array(bytes));\n    });\n}\nfunction getRustConfig() {\n    return {\n        genericSeparators: [\n            \"<\",\n            \">\"\n        ],\n        vectorType: \"Vec\",\n        addressLength: SUI_ADDRESS_LENGTH,\n        addressEncoding: \"hex\"\n    };\n}\nfunction getSuiMoveConfig() {\n    return {\n        genericSeparators: [\n            \"<\",\n            \">\"\n        ],\n        vectorType: \"vector\",\n        addressLength: SUI_ADDRESS_LENGTH,\n        addressEncoding: \"hex\"\n    };\n}\n //# sourceMappingURL=legacy-registry.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG15c3RlbitiY3NAMC4xMS4xL25vZGVfbW9kdWxlcy9AbXlzdGVuL2Jjcy9kaXN0L2VzbS9sZWdhY3ktcmVnaXN0cnkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBMEM7QUFDQTtBQUNGO0FBQ0U7QUFDRjtBQUN1QjtBQUN2QjtBQUN4QyxNQUFNVyxxQkFBcUI7QUFDM0IsTUFBTUMsT0FBTztJQUNYOzs7OztHQUtDLEdBQ0RDLFlBQVlDLE1BQU0sQ0FBRTtRQUNsQjs7Ozs7S0FLQyxHQUNELElBQUksQ0FBQ0MsS0FBSyxHQUFHLGFBQWEsR0FBRyxJQUFJQztRQUNqQzs7S0FFQyxHQUNELElBQUksQ0FBQ0MsT0FBTyxHQUFHO1FBQ2YsSUFBSUgsa0JBQWtCRixNQUFNO1lBQzFCLElBQUksQ0FBQ0UsTUFBTSxHQUFHQSxPQUFPQSxNQUFNO1lBQzNCLElBQUksQ0FBQ0MsS0FBSyxHQUFHLElBQUlDLElBQUlGLE9BQU9DLEtBQUs7WUFDakM7UUFDRjtRQUNBLElBQUksQ0FBQ0QsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ0ksbUJBQW1CLENBQUNOLEtBQUtPLE9BQU8sRUFBRUwsT0FBT00sYUFBYSxFQUFFTixPQUFPTyxlQUFlO1FBQ25GLElBQUksQ0FBQ0Msa0JBQWtCLENBQUNSLE9BQU9TLFVBQVU7UUFDekMsSUFBSVQsT0FBT0MsS0FBSyxJQUFJRCxPQUFPQyxLQUFLLENBQUNTLE9BQU8sRUFBRTtZQUN4QyxLQUFLLElBQUlDLFFBQVFDLE9BQU9DLElBQUksQ0FBQ2IsT0FBT0MsS0FBSyxDQUFDUyxPQUFPLEVBQUc7Z0JBQ2xELElBQUksQ0FBQ0ksa0JBQWtCLENBQUNILE1BQU1YLE9BQU9DLEtBQUssQ0FBQ1MsT0FBTyxDQUFDQyxLQUFLO1lBQzFEO1FBQ0Y7UUFDQSxJQUFJWCxPQUFPQyxLQUFLLElBQUlELE9BQU9DLEtBQUssQ0FBQ2MsS0FBSyxFQUFFO1lBQ3RDLEtBQUssSUFBSUosUUFBUUMs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LG1CQUFtQjtZQUFDO1lBQUs7U0FBSTtRQUM3QmxILFlBQVk7UUFDWkgsZUFBZVQ7UUFDZlUsaUJBQWlCO0lBQ25CO0FBQ0Y7QUFNRSxDQUNGLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL25vdGFzY2FtLXByb3RvY29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BteXN0ZW4rYmNzQDAuMTEuMS9ub2RlX21vZHVsZXMvQG15c3Rlbi9iY3MvZGlzdC9lc20vbGVnYWN5LXJlZ2lzdHJ5LmpzPzNkM2MiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZnJvbUI1OCwgdG9CNTggfSBmcm9tIFwiLi9iNTguanNcIjtcbmltcG9ydCB7IGZyb21CNjQsIHRvQjY0IH0gZnJvbSBcIi4vYjY0LmpzXCI7XG5pbXBvcnQgeyBCY3NUeXBlIH0gZnJvbSBcIi4vYmNzLXR5cGUuanNcIjtcbmltcG9ydCB7IGZyb21IRVgsIHRvSEVYIH0gZnJvbSBcIi4vaGV4LmpzXCI7XG5pbXBvcnQgeyBCY3NSZWFkZXIgfSBmcm9tIFwiLi9yZWFkZXIuanNcIjtcbmltcG9ydCB7IGRlY29kZVN0ciwgc3BsaXRHZW5lcmljUGFyYW1ldGVycyB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBCY3NXcml0ZXIgfSBmcm9tIFwiLi93cml0ZXIuanNcIjtcbmNvbnN0IFNVSV9BRERSRVNTX0xFTkdUSCA9IDMyO1xuY29uc3QgX0JDUyA9IGNsYXNzIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIEJDUyBpbnN0YW5jZSB3aXRoIGEgcHJlcGFyZWQgc2NoZW1hLlxuICAgKlxuICAgKiBAcGFyYW0gc2NoZW1hIEEgcHJlcGFyZWQgc2NoZW1hIHdpdGggdHlwZSBkZWZpbml0aW9uc1xuICAgKiBAcGFyYW0gd2l0aFByaW1pdGl2ZXMgV2hldGhlciB0byByZWdpc3RlciBwcmltaXRpdmUgdHlwZXMgYnkgZGVmYXVsdFxuICAgKi9cbiAgY29uc3RydWN0b3Ioc2NoZW1hKSB7XG4gICAgLyoqXG4gICAgICogTWFwIG9mIGtpbmQgYFR5cGVOYW1lID0+IFR5cGVJbnRlcmZhY2VgLiBIb2xkcyBhbGxcbiAgICAgKiBjYWxsYmFja3MgZm9yIChkZSlzZXJpYWxpemF0aW9uIG9mIGV2ZXJ5IHJlZ2lzdGVyZWQgdHlwZS5cbiAgICAgKlxuICAgICAqIElmIHRoZSB2YWx1ZSBzdG9yZWQgaXMgYSBzdHJpbmcsIGl0IGlzIHRyZWF0ZWQgYXMgYW4gYWxpYXMuXG4gICAgICovXG4gICAgdGhpcy50eXBlcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgLyoqXG4gICAgICogQ291bnQgdGVtcCBrZXlzIHRvIGdlbmVyYXRlIGEgbmV3IG9uZSB3aGVuIHJlcXVlc3RlZC5cbiAgICAgKi9cbiAgICB0aGlzLmNvdW50ZXIgPSAwO1xuICAgIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBfQkNTKSB7XG4gICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYS5zY2hlbWE7XG4gICAgICB0aGlzLnR5cGVzID0gbmV3IE1hcChzY2hlbWEudHlwZXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICB0aGlzLnJlZ2lzdGVyQWRkcmVzc1R5cGUoX0JDUy5BRERSRVNTLCBzY2hlbWEuYWRkcmVzc0xlbmd0aCwgc2NoZW1hLmFkZHJlc3NFbmNvZGluZyk7XG4gICAgdGhpcy5yZWdpc3RlclZlY3RvclR5cGUoc2NoZW1hLnZlY3RvclR5cGUpO1xuICAgIGlmIChzY2hlbWEudHlwZXMgJiYgc2NoZW1hLnR5cGVzLnN0cnVjdHMpIHtcbiAgICAgIGZvciAobGV0IG5hbWUgb2YgT2JqZWN0LmtleXMoc2NoZW1hLnR5cGVzLnN0cnVjdHMpKSB7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJTdHJ1Y3RUeXBlKG5hbWUsIHNjaGVtYS50eXBlcy5zdHJ1Y3RzW25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNjaGVtYS50eXBlcyAmJiBzY2hlbWEudHlwZXMuZW51bXMpIHtcbiAgICAgIGZvciAobGV0IG5hbWUgb2YgT2JqZWN0LmtleXMoc2NoZW1hLnR5cGVzLmVudW1zKSkge1xuICAgICAgICB0aGlzLnJlZ2lzdGVyRW51bVR5cGUobmFtZSwgc2NoZW1hLnR5cGVzLmVudW1zW25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNjaGVtYS50eXBlcyAmJiBzY2hlbWEudHlwZXMuYWxpYXNlcykge1xuICAgICAgZm9yIChsZXQgbmFtZSBvZiBPYmplY3Qua2V5cyhzY2hlbWEudHlwZXMuYWxpYXNlcykpIHtcbiAgICAgICAgdGhpcy5yZWdpc3RlckFsaWFzKG5hbWUsIHNjaGVtYS50eXBlcy5hbGlhc2VzW25hbWVdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNjaGVtYS53aXRoUHJpbWl0aXZlcyAhPT0gZmFsc2UpIHtcbiAgICAgIHJlZ2lzdGVyUHJpbWl0aXZlcyh0aGlzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhlIGtleSB0byB1c2UgZm9yIHRlbXBvcmFyeSBzdHJ1Y3QgZGVmaW5pdGlvbnMuXG4gICAqIFJldHVybnMgYSB0ZW1wIGtleSArIGluZGV4IChmb3IgYSBjYXNlIHdoZW4gbXVsdGlwbGUgdGVtcFxuICAgKiBzdHJ1Y3RzIGFyZSBwcm9jZXNzZWQpLlxuICAgKi9cbiAgdGVtcEtleSgpIHtcbiAgICByZXR1cm4gYGJjcy1zdHJ1Y3QtJHsrK3RoaXMuY291bnRlcn1gO1xuICB9XG4gIC8qKlxuICAgKiBTZXJpYWxpemUgZGF0YSBpbnRvIGJjcy5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYmNzLnJlZ2lzdGVyVmVjdG9yVHlwZSgndmVjdG9yPHU4PicsICd1OCcpO1xuICAgKlxuICAgKiBsZXQgc2VyaWFsaXplZCA9IEJDU1xuICAgKiAgIC5zZXQoJ3ZlY3Rvcjx1OD4nLCBbMSwyLDMsNCw1LDZdKVxuICAgKiAgIC50b0J5dGVzKCk7XG4gICAqXG4gICAqIGNvbnNvbGUuYXNzZXJ0KHRvSGV4KHNlcmlhbGl6ZWQpID09PSAnMDYwMTAyMDMwNDA1MDYnKTtcbiAgICpcbiAgICogQHBhcmFtIHR5cGUgTmFtZSBvZiB0aGUgdHlwZSB0byBzZXJpYWxpemUgKG11c3QgYmUgcmVnaXN0ZXJlZCkgb3IgYSBzdHJ1Y3QgdHlwZS5cbiAgICogQHBhcmFtIGRhdGEgRGF0YSB0byBzZXJpYWxpemUuXG4gICAqIEBwYXJhbSBzaXplIFNlcmlhbGl6YXRpb24gYnVmZmVyIHNpemUuIERlZmF1bHQgMTAyNCA9IDFLQi5cbiAgICogQHJldHVybiBBIEJDUyByZWFkZXIgaW5zdGFuY2UuIFVzdWFsbHkgeW91J2Qgd2FudCB0byBjYWxsIGAudG9CeXRlcygpYFxuICAgKi9cbiAgc2VyKHR5cGUsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIHR5cGUgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgY29uc3QgeyBuYW1lLCBwYXJhbXMgfSA9IHRoaXMucGFyc2VUeXBlTmFtZSh0eXBlKTtcbiAgICAgIHJldHVybiB0aGlzLmdldFR5cGVJbnRlcmZhY2UobmFtZSkuZW5jb2RlKHRoaXMsIGRhdGEsIG9wdGlvbnMsIHBhcmFtcyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3Qga2V5ID0gdGhpcy50ZW1wS2V5KCk7XG4gICAgICBjb25zdCB0ZW1wID0gbmV3IF9CQ1ModGhpcyk7XG4gICAgICByZXR1cm4gdGVtcC5yZWdpc3RlclN0cnVjdFR5cGUoa2V5LCB0eXBlKS5zZXIoa2V5LCBkYXRhLCBvcHRpb25zKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbmNvcnJlY3QgdHlwZSBwYXNzZWQgaW50byB0aGUgJy5zZXIoKScgZnVuY3Rpb24uIFxuJHtKU09OLnN0cmluZ2lmeSh0eXBlKX1gKTtcbiAgfVxuICAvKipcbiAgICogRGVzZXJpYWxpemUgQkNTIGludG8gYSBKUyB0eXBlLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBsZXQgbnVtID0gYmNzLnNlcigndTY0JywgJzQyOTQ5NjcyOTUnKS50b1N0cmluZygnaGV4Jyk7XG4gICAqIGxldCBkZU51bSA9IGJjcy5kZSgndTY0JywgbnVtLCAnaGV4Jyk7XG4gICAqIGNvbnNvbGUuYXNzZXJ0KGRlTnVtLnRvU3RyaW5nKDEwKSA9PT0gJzQyOTQ5NjcyOTUnKTtcbiAgICpcbiAgICogQHBhcmFtIHR5cGUgTmFtZSBvZiB0aGUgdHlwZSB0byBkZXNlcmlhbGl6ZSAobXVzdCBiZSByZWdpc3RlcmVkKSBvciBhIHN0cnVjdCB0eXBlIGRlZmluaXRpb24uXG4gICAqIEBwYXJhbSBkYXRhIERhdGEgdG8gZGVzZXJpYWxpemUuXG4gICAqIEBwYXJhbSBlbmNvZGluZyBPcHRpb25hbCAtIGVuY29kaW5nIHRvIHVzZSBpZiBkYXRhIGlzIG9mIHR5cGUgU3RyaW5nXG4gICAqIEByZXR1cm4gRGVzZXJpYWxpemVkIGRhdGEuXG4gICAqL1xuICBkZSh0eXBlLCBkYXRhLCBlbmNvZGluZykge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKGVuY29kaW5nKSB7XG4gICAgICAgIGRhdGEgPSBkZWNvZGVTdHIoZGF0YSwgZW5jb2RpbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVG8gcGFzcyBhIHN0cmluZyB0byBgYmNzLmRlYCwgc3BlY2lmeSBlbmNvZGluZ1wiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSBcInN0cmluZ1wiIHx8IEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgIGNvbnN0IHsgbmFtZSwgcGFyYW1zIH0gPSB0aGlzLnBhcnNlVHlwZU5hbWUodHlwZSk7XG4gICAgICByZXR1cm4gdGhpcy5nZXRUeXBlSW50ZXJmYWNlKG5hbWUpLmRlY29kZSh0aGlzLCBkYXRhLCBwYXJhbXMpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvbnN0IHRlbXAgPSBuZXcgX0JDUyh0aGlzKTtcbiAgICAgIGNvbnN0IGtleSA9IHRoaXMudGVtcEtleSgpO1xuICAgICAgcmV0dXJuIHRlbXAucmVnaXN0ZXJTdHJ1Y3RUeXBlKGtleSwgdHlwZSkuZGUoa2V5LCBkYXRhLCBlbmNvZGluZyk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgSW5jb3JyZWN0IHR5cGUgcGFzc2VkIGludG8gdGhlICcuZGUoKScgZnVuY3Rpb24uIFxuJHtKU09OLnN0cmluZ2lmeSh0eXBlKX1gKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgd2hldGhlciBhIGBUeXBlSW50ZXJmYWNlYCBoYXMgYmVlbiBsb2FkZWQgZm9yIGEgYHR5cGVgLlxuICAgKiBAcGFyYW0gdHlwZSBOYW1lIG9mIHRoZSB0eXBlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgaGFzVHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuIHRoaXMudHlwZXMuaGFzKHR5cGUpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gYWxpYXMgZm9yIGEgdHlwZS5cbiAgICogV0FSTklORzogdGhpcyBjYW4gcG90ZW50aWFsbHkgbGVhZCB0byByZWN1cnNpb25cbiAgICogQHBhcmFtIG5hbWUgQWxpYXMgdG8gdXNlXG4gICAqIEBwYXJhbSBmb3JUeXBlIFR5cGUgdG8gcmVmZXJlbmNlXG4gICAqIEByZXR1cm5zXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGBgYFxuICAgKiBsZXQgYmNzID0gbmV3IEJDUyhnZXRTdWlNb3ZlQ29uZmlnKCkpO1xuICAgKiBiY3MucmVnaXN0ZXJBbGlhcygnT2JqZWN0RGlnZXN0JywgQkNTLkJBU0U1OCk7XG4gICAqIGxldCBiNThfZGlnZXN0ID0gYmNzLmRlKCdPYmplY3REaWdlc3QnLCAnPGRpZ2VzdF9ieXRlcz4nLCAnYmFzZTY0Jyk7XG4gICAqIGBgYFxuICAgKi9cbiAgcmVnaXN0ZXJBbGlhcyhuYW1lLCBmb3JUeXBlKSB7XG4gICAgdGhpcy50eXBlcy5zZXQobmFtZSwgZm9yVHlwZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIE1ldGhvZCB0byByZWdpc3RlciBuZXcgdHlwZXMgZm9yIEJDUyBpbnRlcm5hbCByZXByZXNlbnRhdGlvbi5cbiAgICogRm9yIGVhY2ggcmVnaXN0ZXJlZCB0eXBlIDIgY2FsbGJhY2tzIG11c3QgYmUgc3BlY2lmaWVkIGFuZCBvbmUgaXMgb3B0aW9uYWw6XG4gICAqXG4gICAqIC0gZW5jb2RlQ2Iod3JpdGVyLCBkYXRhKSAtIHdyaXRlIGEgd2F5IHRvIHNlcmlhbGl6ZSBkYXRhIHdpdGggQmNzV3JpdGVyO1xuICAgKiAtIGRlY29kZUNiKHJlYWRlcikgLSB3cml0ZSBhIHdheSB0byBkZXNlcmlhbGl6ZSBkYXRhIHdpdGggQmNzUmVhZGVyO1xuICAgKiAtIHZhbGlkYXRlQ2IoZGF0YSkgLSB2YWxpZGF0ZSBkYXRhIC0gZWl0aGVyIHJldHVybiBib29sIG9yIHRocm93IGFuIGVycm9yXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIG91ciB0eXBlIHdvdWxkIGJlIGEgc3RyaW5nIHRoYXQgY29uc2lzdHMgb25seSBvZiBudW1iZXJzXG4gICAqIGJjcy5yZWdpc3RlclR5cGUoJ251bWJlcl9zdHJpbmcnLFxuICAgKiAgICAod3JpdGVyLCBkYXRhKSA9PiB3cml0ZXIud3JpdGVWZWMoZGF0YSwgKHcsIGVsKSA9PiB3LndyaXRlOChlbCkpLFxuICAgKiAgICAocmVhZGVyKSA9PiByZWFkZXIucmVhZFZlYygocikgPT4gci5yZWFkOCgpKS5qb2luKCcnKSwgLy8gcmVhZCBlYWNoIHZhbHVlIGFzIHU4XG4gICAqICAgICh2YWx1ZSkgPT4gL1swLTldKy8udGVzdCh2YWx1ZSkgLy8gdGVzdCB0aGF0IGl0IGhhcyBhdCBsZWFzdCBvbmUgZGlnaXRcbiAgICogKTtcbiAgICogY29uc29sZS5sb2coQXJyYXkuZnJvbShiY3Muc2VyKCdudW1iZXJfc3RyaW5nJywgJzEyMzQ1JykudG9CeXRlcygpKSA9PSBbNSwxLDIsMyw0LDVdKTtcbiAgICpcbiAgICogQHBhcmFtIG5hbWVcbiAgICogQHBhcmFtIGVuY29kZUNiIENhbGxiYWNrIHRvIGVuY29kZSBhIHZhbHVlLlxuICAgKiBAcGFyYW0gZGVjb2RlQ2IgQ2FsbGJhY2sgdG8gZGVjb2RlIGEgdmFsdWUuXG4gICAqIEBwYXJhbSB2YWxpZGF0ZUNiIE9wdGlvbmFsIHZhbGlkYXRvciBDYWxsYmFjayB0byBjaGVjayB0eXBlIGJlZm9yZSBzZXJpYWxpemF0aW9uLlxuICAgKi9cbiAgcmVnaXN0ZXJUeXBlKHR5cGVOYW1lLCBlbmNvZGVDYiwgZGVjb2RlQ2IsIHZhbGlkYXRlQ2IgPSAoKSA9PiB0cnVlKSB7XG4gICAgY29uc3QgeyBuYW1lLCBwYXJhbXM6IGdlbmVyaWNzIH0gPSB0aGlzLnBhcnNlVHlwZU5hbWUodHlwZU5hbWUpO1xuICAgIHRoaXMudHlwZXMuc2V0KG5hbWUsIHtcbiAgICAgIGVuY29kZShzZWxmLCBkYXRhLCBvcHRpb25zLCB0eXBlUGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHR5cGVNYXAgPSBnZW5lcmljcy5yZWR1Y2UoKGFjYywgdmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oYWNjLCB7IFt2YWx1ZV06IHR5cGVQYXJhbXNbaW5kZXhdIH0pO1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmNvZGVSYXcuY2FsbChzZWxmLCBuZXcgQmNzV3JpdGVyKG9wdGlvbnMpLCBkYXRhLCB0eXBlUGFyYW1zLCB0eXBlTWFwKTtcbiAgICAgIH0sXG4gICAgICBkZWNvZGUoc2VsZiwgZGF0YSwgdHlwZVBhcmFtcykge1xuICAgICAgICBjb25zdCB0eXBlTWFwID0gZ2VuZXJpY3MucmVkdWNlKChhY2MsIHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGFjYywgeyBbdmFsdWVdOiB0eXBlUGFyYW1zW2luZGV4XSB9KTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVjb2RlUmF3LmNhbGwoc2VsZiwgbmV3IEJjc1JlYWRlcihkYXRhKSwgdHlwZVBhcmFtcywgdHlwZU1hcCk7XG4gICAgICB9LFxuICAgICAgLy8gdGhlc2UgbWV0aG9kcyBzaG91bGQgYWx3YXlzIGJlIHVzZWQgd2l0aCBjYXV0aW9uIGFzIHRoZXkgcmVxdWlyZSBwcmUtZGVmaW5lZFxuICAgICAgLy8gcmVhZGVyIGFuZCB3cml0ZXIgYW5kIG1haW5seSBleGlzdCB0byBhbGxvdyBtdWx0aS1maWVsZCAoZGUpc2VyaWFsaXphdGlvbjtcbiAgICAgIF9lbmNvZGVSYXcod3JpdGVyLCBkYXRhLCB0eXBlUGFyYW1zLCB0eXBlTWFwKSB7XG4gICAgICAgIGlmICh2YWxpZGF0ZUNiKGRhdGEpKSB7XG4gICAgICAgICAgcmV0dXJuIGVuY29kZUNiLmNhbGwodGhpcywgd3JpdGVyLCBkYXRhLCB0eXBlUGFyYW1zLCB0eXBlTWFwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFZhbGlkYXRpb24gZmFpbGVkIGZvciB0eXBlICR7bmFtZX0sIGRhdGE6ICR7ZGF0YX1gKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9kZWNvZGVSYXcocmVhZGVyLCB0eXBlUGFyYW1zLCB0eXBlTWFwKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVDYi5jYWxsKHRoaXMsIHJlYWRlciwgdHlwZVBhcmFtcywgdHlwZU1hcCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gIFx0ICogTWV0aG9kIHRvIHJlZ2lzdGVyIEJjc1R5cGUgaW5zdGFuY2VzIHRvIHRoZSByZWdpc3RyeVxuICBcdCAqIFR5cGVzIGFyZSByZWdpc3RlcmVkIHdpdGggYSBjYWxsYmFjayB0aGF0IHByb3ZpZGVzIEJjc1R5cGUgaW5zdGFuY2VzIGZvciBlYWNoIGdlbmVyaWNcbiAgXHQgKiBwYXNzZWQgdG8gdGhlIHR5cGUuXG4gIFx0ICpcbiAgXHQgKiAtIGNyZWF0ZVR5cGUoLi4uZ2VuZXJpY3MpIC0gUmV0dXJuIGEgQmNzVHlwZSBpbnN0YW5jZVxuICBcdCAqXG4gIFx0ICogQGV4YW1wbGVcbiAgXHQgKiAvLyBvdXIgdHlwZSB3b3VsZCBiZSBhIHN0cmluZyB0aGF0IGNvbnNpc3RzIG9ubHkgb2YgbnVtYmVyc1xuICBcdCAqIGJjcy5yZWdpc3RlclR5cGUoJ0JveDxUPicsIChUKSA9PiB7XG4gIFx0ICogXHRcdHJldHVybiBiY3Muc3RydWN0KHtcbiAgXHQgKiBcdFx0XHR2YWx1ZTogVFxuICBcdCAqIFx0XHR9KTtcbiAgXHQgKiB9KTtcbiAgXG4gIFx0ICogY29uc29sZS5sb2coQXJyYXkuZnJvbShiY3Muc2VyKCdCb3g8c3RyaW5nPicsICcxMjM0NScpLnRvQnl0ZXMoKSkgPT0gWzUsMSwyLDMsNCw1XSk7XG4gIFx0ICpcbiAgXHQgKiBAcGFyYW0gbmFtZVxuICBcdCAqIEBwYXJhbSBjcmVhdGVUeXBlIGEgQ2FsbGJhY2sgdG8gY3JlYXRlIHRoZSBCY3NUeXBlIHdpdGggYW55IHBhc3NlZCBpbiBnZW5lcmljc1xuICBcdCAqL1xuICByZWdpc3RlckJjc1R5cGUodHlwZU5hbWUsIGNyZWF0ZVR5cGUpIHtcbiAgICB0aGlzLnJlZ2lzdGVyVHlwZShcbiAgICAgIHR5cGVOYW1lLFxuICAgICAgKHdyaXRlciwgZGF0YSwgdHlwZVBhcmFtcykgPT4ge1xuICAgICAgICBjb25zdCBnZW5lcmljcyA9IHR5cGVQYXJhbXMubWFwKFxuICAgICAgICAgIChwYXJhbSkgPT4gbmV3IEJjc1R5cGUoe1xuICAgICAgICAgICAgbmFtZTogU3RyaW5nKHBhcmFtKSxcbiAgICAgICAgICAgIHdyaXRlOiAoZGF0YTIsIHdyaXRlcjIpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgeyBuYW1lLCBwYXJhbXMgfSA9IHRoaXMucGFyc2VUeXBlTmFtZShwYXJhbSk7XG4gICAgICAgICAgICAgIGNvbnN0IHR5cGVJbnRlcmZhY2UgPSB0aGlzLmdldFR5cGVJbnRlcmZhY2UobmFtZSk7XG4gICAgICAgICAgICAgIGNvbnN0IHR5cGVNYXAgPSBwYXJhbXMucmVkdWNlKChhY2MsIHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGFjYywgeyBbdmFsdWVdOiB0eXBlUGFyYW1zW2luZGV4XSB9KTtcbiAgICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgICByZXR1cm4gdHlwZUludGVyZmFjZS5fZW5jb2RlUmF3LmNhbGwodGhpcywgd3JpdGVyMiwgZGF0YTIsIHBhcmFtcywgdHlwZU1hcCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVhZDogKCkgPT4ge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgY3JlYXRlVHlwZSguLi5nZW5lcmljcykud3JpdGUoZGF0YSwgd3JpdGVyKTtcbiAgICAgICAgcmV0dXJuIHdyaXRlcjtcbiAgICAgIH0sXG4gICAgICAocmVhZGVyLCB0eXBlUGFyYW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IGdlbmVyaWNzID0gdHlwZVBhcmFtcy5tYXAoXG4gICAgICAgICAgKHBhcmFtKSA9PiBuZXcgQmNzVHlwZSh7XG4gICAgICAgICAgICBuYW1lOiBTdHJpbmcocGFyYW0pLFxuICAgICAgICAgICAgd3JpdGU6IChfZGF0YSwgX3dyaXRlcikgPT4ge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWRcIik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVhZDogKHJlYWRlcjIpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgeyBuYW1lLCBwYXJhbXMgfSA9IHRoaXMucGFyc2VUeXBlTmFtZShwYXJhbSk7XG4gICAgICAgICAgICAgIGNvbnN0IHR5cGVJbnRlcmZhY2UgPSB0aGlzLmdldFR5cGVJbnRlcmZhY2UobmFtZSk7XG4gICAgICAgICAgICAgIGNvbnN0IHR5cGVNYXAgPSBwYXJhbXMucmVkdWNlKChhY2MsIHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGFjYywgeyBbdmFsdWVdOiB0eXBlUGFyYW1zW2luZGV4XSB9KTtcbiAgICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgICByZXR1cm4gdHlwZUludGVyZmFjZS5fZGVjb2RlUmF3LmNhbGwodGhpcywgcmVhZGVyMiwgcGFyYW1zLCB0eXBlTWFwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gY3JlYXRlVHlwZSguLi5nZW5lcmljcykucmVhZChyZWFkZXIpO1xuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGFuIGFkZHJlc3MgdHlwZSB3aGljaCBpcyBhIHNlcXVlbmNlIG9mIFU4cyBvZiBzcGVjaWZpZWQgbGVuZ3RoLlxuICAgKiBAZXhhbXBsZVxuICAgKiBiY3MucmVnaXN0ZXJBZGRyZXNzVHlwZSgnYWRkcmVzcycsIFNVSV9BRERSRVNTX0xFTkdUSCk7XG4gICAqIGxldCBhZGRyID0gYmNzLmRlKCdhZGRyZXNzJywgJ2MzYWNhNTEwYzc4NWM3MDk0YWM5OWFlYWExZTY5ZDQ5MzEyMjQ0NGRmNTBiYjhhOTlkZmE3OTBjNjU0YTc5YWYnKTtcbiAgICpcbiAgICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgYWRkcmVzcyB0eXBlLlxuICAgKiBAcGFyYW0gbGVuZ3RoIEJ5dGUgbGVuZ3RoIG9mIHRoZSBhZGRyZXNzLlxuICAgKiBAcGFyYW0gZW5jb2RpbmcgRW5jb2RpbmcgdG8gdXNlIGZvciB0aGUgYWRkcmVzcyB0eXBlXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICByZWdpc3RlckFkZHJlc3NUeXBlKG5hbWUsIGxlbmd0aCwgZW5jb2RpbmcgPSBcImhleFwiKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSBcImJhc2U2NFwiOlxuICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RlclR5cGUoXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBmdW5jdGlvbiBlbmNvZGVBZGRyZXNzKHdyaXRlciwgZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGZyb21CNjQoZGF0YSkucmVkdWNlKCh3cml0ZXIyLCBlbCkgPT4gd3JpdGVyMi53cml0ZTgoZWwpLCB3cml0ZXIpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZnVuY3Rpb24gZGVjb2RlQWRkcmVzcyhyZWFkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0b0I2NChyZWFkZXIucmVhZEJ5dGVzKGxlbmd0aCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICAgIGNhc2UgXCJoZXhcIjpcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJUeXBlKFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgZnVuY3Rpb24gZW5jb2RlQWRkcmVzcyh3cml0ZXIsIGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tSEVYKGRhdGEpLnJlZHVjZSgod3JpdGVyMiwgZWwpID0+IHdyaXRlcjIud3JpdGU4KGVsKSwgd3JpdGVyKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGZ1bmN0aW9uIGRlY29kZUFkZHJlc3MocmVhZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9IRVgocmVhZGVyLnJlYWRCeXRlcyhsZW5ndGgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBlbmNvZGluZyEgVXNlIGVpdGhlciBoZXggb3IgYmFzZTY0XCIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogUmVnaXN0ZXIgY3VzdG9tIHZlY3RvciB0eXBlIGluc2lkZSB0aGUgYmNzLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiBiY3MucmVnaXN0ZXJWZWN0b3JUeXBlKCd2ZWN0b3I8VD4nKTsgLy8gZ2VuZXJpYyByZWdpc3RyYXRpb25cbiAgICogbGV0IGFycmF5ID0gYmNzLmRlKCd2ZWN0b3I8dTg+JywgJzA2MDEwMjAzMDQwNTA2JywgJ2hleCcpOyAvLyBbMSwyLDMsNCw1LDZdO1xuICAgKiBsZXQgYWdhaW4gPSBiY3Muc2VyKCd2ZWN0b3I8dTg+JywgWzEsMiwzLDQsNSw2XSkudG9TdHJpbmcoJ2hleCcpO1xuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSB0eXBlIHRvIHJlZ2lzdGVyXG4gICAqIEBwYXJhbSBlbGVtZW50VHlwZSBPcHRpb25hbCBuYW1lIG9mIHRoZSBpbm5lciB0eXBlIG9mIHRoZSB2ZWN0b3JcbiAgICogQHJldHVybiBSZXR1cm5zIHNlbGYgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgcmVnaXN0ZXJWZWN0b3JUeXBlKHR5cGVOYW1lKSB7XG4gICAgbGV0IHsgbmFtZSwgcGFyYW1zIH0gPSB0aGlzLnBhcnNlVHlwZU5hbWUodHlwZU5hbWUpO1xuICAgIGlmIChwYXJhbXMubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmVjdG9yIGNhbiBoYXZlIG9ubHkgb25lIHR5cGUgcGFyYW1ldGVyOyBnb3QgXCIgKyBuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJUeXBlKFxuICAgICAgdHlwZU5hbWUsXG4gICAgICBmdW5jdGlvbiBlbmNvZGVWZWN0b3Iod3JpdGVyLCBkYXRhLCB0eXBlUGFyYW1zLCB0eXBlTWFwKSB7XG4gICAgICAgIHJldHVybiB3cml0ZXIud3JpdGVWZWMoZGF0YSwgKHdyaXRlcjIsIGVsKSA9PiB7XG4gICAgICAgICAgbGV0IGVsZW1lbnRUeXBlID0gdHlwZVBhcmFtc1swXTtcbiAgICAgICAgICBpZiAoIWVsZW1lbnRUeXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEluY29ycmVjdCBudW1iZXIgb2YgdHlwZSBwYXJhbWV0ZXJzIHBhc3NlZCBhIHRvIHZlY3RvciAnJHt0eXBlTmFtZX0nYCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCB7IG5hbWU6IG5hbWUyLCBwYXJhbXM6IHBhcmFtczIgfSA9IHRoaXMucGFyc2VUeXBlTmFtZShlbGVtZW50VHlwZSk7XG4gICAgICAgICAgaWYgKHRoaXMuaGFzVHlwZShuYW1lMikpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGVJbnRlcmZhY2UobmFtZTIpLl9lbmNvZGVSYXcuY2FsbCh0aGlzLCB3cml0ZXIyLCBlbCwgcGFyYW1zMiwgdHlwZU1hcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghKG5hbWUyIGluIHR5cGVNYXApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBVbmFibGUgdG8gZmluZCBhIG1hdGNoaW5nIHR5cGUgZGVmaW5pdGlvbiBmb3IgJHtuYW1lMn0gaW4gdmVjdG9yOyBtYWtlIHN1cmUgeW91IHBhc3NlZCBhIGdlbmVyaWNgXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgeyBuYW1lOiBpbm5lck5hbWUsIHBhcmFtczogaW5uZXJQYXJhbXMgfSA9IHRoaXMucGFyc2VUeXBlTmFtZSh0eXBlTWFwW25hbWUyXSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZUludGVyZmFjZShpbm5lck5hbWUpLl9lbmNvZGVSYXcuY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICB3cml0ZXIyLFxuICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICBpbm5lclBhcmFtcyxcbiAgICAgICAgICAgIHR5cGVNYXBcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbiBkZWNvZGVWZWN0b3IocmVhZGVyLCB0eXBlUGFyYW1zLCB0eXBlTWFwKSB7XG4gICAgICAgIHJldHVybiByZWFkZXIucmVhZFZlYygocmVhZGVyMikgPT4ge1xuICAgICAgICAgIGxldCBlbGVtZW50VHlwZSA9IHR5cGVQYXJhbXNbMF07XG4gICAgICAgICAgaWYgKCFlbGVtZW50VHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbmNvcnJlY3QgbnVtYmVyIG9mIHR5cGUgcGFyYW1ldGVycyBwYXNzZWQgdG8gYSB2ZWN0b3IgJyR7dHlwZU5hbWV9J2ApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgeyBuYW1lOiBuYW1lMiwgcGFyYW1zOiBwYXJhbXMyIH0gPSB0aGlzLnBhcnNlVHlwZU5hbWUoZWxlbWVudFR5cGUpO1xuICAgICAgICAgIGlmICh0aGlzLmhhc1R5cGUobmFtZTIpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUeXBlSW50ZXJmYWNlKG5hbWUyKS5fZGVjb2RlUmF3LmNhbGwodGhpcywgcmVhZGVyMiwgcGFyYW1zMiwgdHlwZU1hcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghKG5hbWUyIGluIHR5cGVNYXApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBVbmFibGUgdG8gZmluZCBhIG1hdGNoaW5nIHR5cGUgZGVmaW5pdGlvbiBmb3IgJHtuYW1lMn0gaW4gdmVjdG9yOyBtYWtlIHN1cmUgeW91IHBhc3NlZCBhIGdlbmVyaWNgXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgeyBuYW1lOiBpbm5lck5hbWUsIHBhcmFtczogaW5uZXJQYXJhbXMgfSA9IHRoaXMucGFyc2VUeXBlTmFtZSh0eXBlTWFwW25hbWUyXSk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHlwZUludGVyZmFjZShpbm5lck5hbWUpLl9kZWNvZGVSYXcuY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICByZWFkZXIyLFxuICAgICAgICAgICAgaW5uZXJQYXJhbXMsXG4gICAgICAgICAgICB0eXBlTWFwXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogU2FmZSBtZXRob2QgdG8gcmVnaXN0ZXIgYSBjdXN0b20gTW92ZSBzdHJ1Y3QuIFRoZSBmaXJzdCBhcmd1bWVudCBpcyBhIG5hbWUgb2YgdGhlXG4gICAqIHN0cnVjdCB3aGljaCBpcyBvbmx5IHVzZWQgb24gdGhlIEZyb250RW5kIGFuZCBoYXMgbm8gYWZmZWN0IG9uIHNlcmlhbGl6YXRpb24gcmVzdWx0cyxcbiAgICogYW5kIHRoZSBzZWNvbmQgaXMgYSBzdHJ1Y3QgZGVzY3JpcHRpb24gcGFzc2VkIGFzIGFuIE9iamVjdC5cbiAgICpcbiAgICogVGhlIGRlc2NyaXB0aW9uIG9iamVjdCBNVVNUIGhhdmUgdGhlIHNhbWUgb3JkZXIgb24gYWxsIG9mIHRoZSBwbGF0Zm9ybXMgKGllIGluIE1vdmVcbiAgICogb3IgaW4gUnVzdCkuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIC8vIE1vdmUgLyBSdXN0IHN0cnVjdFxuICAgKiAvLyBzdHJ1Y3QgQ29pbiB7XG4gICAqIC8vICAgdmFsdWU6IHU2NCxcbiAgICogLy8gICBvd25lcjogdmVjdG9yPHU4PiwgLy8gbmFtZSAvLyBWZWM8dTg+IGluIFJ1c3RcbiAgICogLy8gICBpc19sb2NrZWQ6IGJvb2wsXG4gICAqIC8vIH1cbiAgICpcbiAgICogYmNzLnJlZ2lzdGVyU3RydWN0VHlwZSgnQ29pbicsIHtcbiAgICogICB2YWx1ZTogYmNzLlU2NCxcbiAgICogICBvd25lcjogYmNzLlNUUklORyxcbiAgICogICBpc19sb2NrZWQ6IGJjcy5CT09MXG4gICAqIH0pO1xuICAgKlxuICAgKiAvLyBDcmVhdGVkIGluIFJ1c3Qgd2l0aCBkaWVtL2Jjc1xuICAgKiAvLyBsZXQgcnVzdF9iY3Nfc3RyID0gJzgwZDFiMTA1NjAwMDAwMDAwZTQyNjk2NzIwNTc2MTZjNmM2NTc0MjA0Nzc1NzkwMCc7XG4gICAqIGxldCBydXN0X2Jjc19zdHIgPSBbIC8vIHVzaW5nIGFuIEFycmF5IGhlcmUgYXMgQkNTIHdvcmtzIHdpdGggVWludDhBcnJheVxuICAgKiAgMTI4LCAyMDksIDE3NywgICA1LCAgOTYsICAwLCAgMCxcbiAgICogICAgMCwgIDE0LCAgNjYsIDEwNSwgMTAzLCAzMiwgODcsXG4gICAqICAgOTcsIDEwOCwgMTA4LCAxMDEsIDExNiwgMzIsIDcxLFxuICAgKiAgMTE3LCAxMjEsICAgMFxuICAgKiBdO1xuICAgKlxuICAgKiAvLyBMZXQncyBlbmNvZGUgdGhlIHZhbHVlIGFzIHdlbGxcbiAgICogbGV0IHRlc3Rfc2V0ID0gYmNzLnNlcignQ29pbicsIHtcbiAgICogICBvd25lcjogJ0JpZyBXYWxsZXQgR3V5JyxcbiAgICogICB2YWx1ZTogJzQxMjQxMjQwMDAwMCcsXG4gICAqICAgaXNfbG9ja2VkOiBmYWxzZSxcbiAgICogfSk7XG4gICAqXG4gICAqIGNvbnNvbGUuYXNzZXJ0KEFycmF5LmZyb20odGVzdF9zZXQudG9CeXRlcygpKSA9PT0gcnVzdF9iY3Nfc3RyLCAnV2hvb3BzaWUsIHJlc3VsdCBtaXNtYXRjaCcpO1xuICAgKlxuICAgKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSB0eXBlIHRvIHJlZ2lzdGVyLlxuICAgKiBAcGFyYW0gZmllbGRzIEZpZWxkcyBvZiB0aGUgc3RydWN0LiBNdXN0IGJlIGluIHRoZSBjb3JyZWN0IG9yZGVyLlxuICAgKiBAcmV0dXJuIFJldHVybnMgQkNTIGZvciBjaGFpbmluZy5cbiAgICovXG4gIHJlZ2lzdGVyU3RydWN0VHlwZSh0eXBlTmFtZSwgZmllbGRzKSB7XG4gICAgZm9yIChsZXQga2V5IGluIGZpZWxkcykge1xuICAgICAgbGV0IGludGVybmFsTmFtZSA9IHRoaXMudGVtcEtleSgpO1xuICAgICAgbGV0IHZhbHVlID0gZmllbGRzW2tleV07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBmaWVsZHNba2V5XSA9IGludGVybmFsTmFtZTtcbiAgICAgICAgdGhpcy5yZWdpc3RlclN0cnVjdFR5cGUoaW50ZXJuYWxOYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBzdHJ1Y3QgPSBPYmplY3QuZnJlZXplKGZpZWxkcyk7XG4gICAgbGV0IGNhbm9uaWNhbE9yZGVyID0gT2JqZWN0LmtleXMoc3RydWN0KTtcbiAgICBsZXQgeyBuYW1lOiBzdHJ1Y3ROYW1lLCBwYXJhbXM6IGdlbmVyaWNzIH0gPSB0aGlzLnBhcnNlVHlwZU5hbWUodHlwZU5hbWUpO1xuICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyVHlwZShcbiAgICAgIHR5cGVOYW1lLFxuICAgICAgZnVuY3Rpb24gZW5jb2RlU3RydWN0KHdyaXRlciwgZGF0YSwgdHlwZVBhcmFtcywgdHlwZU1hcCkge1xuICAgICAgICBpZiAoIWRhdGEgfHwgZGF0YS5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCAke3N0cnVjdE5hbWV9IHRvIGJlIGFuIE9iamVjdCwgZ290OiAke2RhdGF9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVQYXJhbXMubGVuZ3RoICE9PSBnZW5lcmljcy5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSW5jb3JyZWN0IG51bWJlciBvZiBnZW5lcmljIHBhcmFtZXRlcnMgcGFzc2VkOyBleHBlY3RlZDogJHtnZW5lcmljcy5sZW5ndGh9LCBnb3Q6ICR7dHlwZVBhcmFtcy5sZW5ndGh9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQga2V5IG9mIGNhbm9uaWNhbE9yZGVyKSB7XG4gICAgICAgICAgaWYgKCEoa2V5IGluIGRhdGEpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN0cnVjdCAke3N0cnVjdE5hbWV9IHJlcXVpcmVzIGZpZWxkICR7a2V5fToke3N0cnVjdFtrZXldfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7IG5hbWU6IGZpZWxkVHlwZSwgcGFyYW1zOiBmaWVsZFBhcmFtcyB9ID0gdGhpcy5wYXJzZVR5cGVOYW1lKFxuICAgICAgICAgICAgc3RydWN0W2tleV1cbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICghZ2VuZXJpY3MuaW5jbHVkZXMoZmllbGRUeXBlKSkge1xuICAgICAgICAgICAgdGhpcy5nZXRUeXBlSW50ZXJmYWNlKGZpZWxkVHlwZSkuX2VuY29kZVJhdy5jYWxsKFxuICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICB3cml0ZXIsXG4gICAgICAgICAgICAgIGRhdGFba2V5XSxcbiAgICAgICAgICAgICAgZmllbGRQYXJhbXMsXG4gICAgICAgICAgICAgIHR5cGVNYXBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtSWR4ID0gZ2VuZXJpY3MuaW5kZXhPZihmaWVsZFR5cGUpO1xuICAgICAgICAgICAgbGV0IHsgbmFtZSwgcGFyYW1zIH0gPSB0aGlzLnBhcnNlVHlwZU5hbWUodHlwZVBhcmFtc1twYXJhbUlkeF0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzVHlwZShuYW1lKSkge1xuICAgICAgICAgICAgICB0aGlzLmdldFR5cGVJbnRlcmZhY2UobmFtZSkuX2VuY29kZVJhdy5jYWxsKFxuICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgd3JpdGVyLFxuICAgICAgICAgICAgICAgIGRhdGFba2V5XSxcbiAgICAgICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICAgICAgdHlwZU1hcFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghKG5hbWUgaW4gdHlwZU1hcCkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIGBVbmFibGUgdG8gZmluZCBhIG1hdGNoaW5nIHR5cGUgZGVmaW5pdGlvbiBmb3IgJHtuYW1lfSBpbiAke3N0cnVjdE5hbWV9OyBtYWtlIHN1cmUgeW91IHBhc3NlZCBhIGdlbmVyaWNgXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgeyBuYW1lOiBpbm5lck5hbWUsIHBhcmFtczogaW5uZXJQYXJhbXMgfSA9IHRoaXMucGFyc2VUeXBlTmFtZSh0eXBlTWFwW25hbWVdKTtcbiAgICAgICAgICAgIHRoaXMuZ2V0VHlwZUludGVyZmFjZShpbm5lck5hbWUpLl9lbmNvZGVSYXcuY2FsbChcbiAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgd3JpdGVyLFxuICAgICAgICAgICAgICBkYXRhW2tleV0sXG4gICAgICAgICAgICAgIGlubmVyUGFyYW1zLFxuICAgICAgICAgICAgICB0eXBlTWFwXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyO1xuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uIGRlY29kZVN0cnVjdChyZWFkZXIsIHR5cGVQYXJhbXMsIHR5cGVNYXApIHtcbiAgICAgICAgaWYgKHR5cGVQYXJhbXMubGVuZ3RoICE9PSBnZW5lcmljcy5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgSW5jb3JyZWN0IG51bWJlciBvZiBnZW5lcmljIHBhcmFtZXRlcnMgcGFzc2VkOyBleHBlY3RlZDogJHtnZW5lcmljcy5sZW5ndGh9LCBnb3Q6ICR7dHlwZVBhcmFtcy5sZW5ndGh9YFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBrZXkgb2YgY2Fub25pY2FsT3JkZXIpIHtcbiAgICAgICAgICBjb25zdCB7IG5hbWU6IGZpZWxkTmFtZSwgcGFyYW1zOiBmaWVsZFBhcmFtcyB9ID0gdGhpcy5wYXJzZVR5cGVOYW1lKFxuICAgICAgICAgICAgc3RydWN0W2tleV1cbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICghZ2VuZXJpY3MuaW5jbHVkZXMoZmllbGROYW1lKSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB0aGlzLmdldFR5cGVJbnRlcmZhY2UoZmllbGROYW1lKS5fZGVjb2RlUmF3LmNhbGwoXG4gICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgIHJlYWRlcixcbiAgICAgICAgICAgICAgZmllbGRQYXJhbXMsXG4gICAgICAgICAgICAgIHR5cGVNYXBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtSWR4ID0gZ2VuZXJpY3MuaW5kZXhPZihmaWVsZE5hbWUpO1xuICAgICAgICAgICAgbGV0IHsgbmFtZSwgcGFyYW1zIH0gPSB0aGlzLnBhcnNlVHlwZU5hbWUodHlwZVBhcmFtc1twYXJhbUlkeF0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzVHlwZShuYW1lKSkge1xuICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHRoaXMuZ2V0VHlwZUludGVyZmFjZShuYW1lKS5fZGVjb2RlUmF3LmNhbGwoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICByZWFkZXIsXG4gICAgICAgICAgICAgICAgcGFyYW1zLFxuICAgICAgICAgICAgICAgIHR5cGVNYXBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIShuYW1lIGluIHR5cGVNYXApKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgVW5hYmxlIHRvIGZpbmQgYSBtYXRjaGluZyB0eXBlIGRlZmluaXRpb24gZm9yICR7bmFtZX0gaW4gJHtzdHJ1Y3ROYW1lfTsgbWFrZSBzdXJlIHlvdSBwYXNzZWQgYSBnZW5lcmljYFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHsgbmFtZTogaW5uZXJOYW1lLCBwYXJhbXM6IGlubmVyUGFyYW1zIH0gPSB0aGlzLnBhcnNlVHlwZU5hbWUodHlwZU1hcFtuYW1lXSk7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IHRoaXMuZ2V0VHlwZUludGVyZmFjZShpbm5lck5hbWUpLl9kZWNvZGVSYXcuY2FsbChcbiAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgcmVhZGVyLFxuICAgICAgICAgICAgICBpbm5lclBhcmFtcyxcbiAgICAgICAgICAgICAgdHlwZU1hcFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBTYWZlIG1ldGhvZCB0byByZWdpc3RlciBjdXN0b20gZW51bSB0eXBlIHdoZXJlIGVhY2ggaW52YXJpYW50IGhvbGRzIHRoZSB2YWx1ZSBvZiBhbm90aGVyIHR5cGUuXG4gICAqIEBleGFtcGxlXG4gICAqIGJjcy5yZWdpc3RlclN0cnVjdFR5cGUoJ0NvaW4nLCB7IHZhbHVlOiAndTY0JyB9KTtcbiAgICogYmNzLnJlZ2lzdGVyRW51bVR5cGUoJ015RW51bScsIHtcbiAgICogIHNpbmdsZTogJ0NvaW4nLFxuICAgKiAgbXVsdGk6ICd2ZWN0b3I8Q29pbj4nLFxuICAgKiAgZW1wdHk6IG51bGxcbiAgICogfSk7XG4gICAqXG4gICAqIGNvbnNvbGUubG9nKFxuICAgKiAgYmNzLmRlKCdNeUVudW0nLCAnQUlDV21BQUFBQUFBJywgJ2Jhc2U2NCcpLCAvLyB7IHNpbmdsZTogeyB2YWx1ZTogMTAwMDAwMDAgfSB9XG4gICAqICBiY3MuZGUoJ015RW51bScsICdBUUlCQUFBQUFBQUFBQUlBQUFBQUFBQUEnLCAnYmFzZTY0JykgIC8vIHsgbXVsdGk6IFsgeyB2YWx1ZTogMSB9LCB7IHZhbHVlOiAyIH0gXSB9XG4gICAqIClcbiAgICpcbiAgICogLy8gYW5kIHNlcmlhbGl6YXRpb25cbiAgICogYmNzLnNlcignTXlFbnVtJywgeyBzaW5nbGU6IHsgdmFsdWU6IDEwMDAwMDAwIH0gfSkudG9CeXRlcygpO1xuICAgKiBiY3Muc2VyKCdNeUVudW0nLCB7IG11bHRpOiBbIHsgdmFsdWU6IDEgfSwgeyB2YWx1ZTogMiB9IF0gfSk7XG4gICAqXG4gICAqIEBwYXJhbSBuYW1lXG4gICAqIEBwYXJhbSB2YXJpYW50c1xuICAgKi9cbiAgcmVnaXN0ZXJFbnVtVHlwZSh0eXBlTmFtZSwgdmFyaWFudHMpIHtcbiAgICBmb3IgKGxldCBrZXkgaW4gdmFyaWFudHMpIHtcbiAgICAgIGxldCBpbnRlcm5hbE5hbWUgPSB0aGlzLnRlbXBLZXkoKTtcbiAgICAgIGxldCB2YWx1ZSA9IHZhcmlhbnRzW2tleV07XG4gICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpICYmIHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YXJpYW50c1trZXldID0gaW50ZXJuYWxOYW1lO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyU3RydWN0VHlwZShpbnRlcm5hbE5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHN0cnVjdCA9IE9iamVjdC5mcmVlemUodmFyaWFudHMpO1xuICAgIGxldCBjYW5vbmljYWxPcmRlciA9IE9iamVjdC5rZXlzKHN0cnVjdCk7XG4gICAgbGV0IHsgbmFtZSwgcGFyYW1zOiBjYW5vbmljYWxUeXBlUGFyYW1zIH0gPSB0aGlzLnBhcnNlVHlwZU5hbWUodHlwZU5hbWUpO1xuICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyVHlwZShcbiAgICAgIHR5cGVOYW1lLFxuICAgICAgZnVuY3Rpb24gZW5jb2RlRW51bSh3cml0ZXIsIGRhdGEsIHR5cGVQYXJhbXMsIHR5cGVNYXApIHtcbiAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gd3JpdGUgZW51bSBcIiR7bmFtZX1cIiwgbWlzc2luZyBkYXRhLlxuUmVjZWl2ZWQ6IFwiJHtkYXRhfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYEluY29ycmVjdCBkYXRhIHBhc3NlZCBpbnRvIGVudW0gXCIke25hbWV9XCIsIGV4cGVjdGVkIG9iamVjdCB3aXRoIHByb3BlcnRpZXM6IFwiJHtjYW5vbmljYWxPcmRlci5qb2luKFxuICAgICAgICAgICAgICBcIiB8IFwiXG4gICAgICAgICAgICApfVwiLlxuUmVjZWl2ZWQ6IFwiJHtKU09OLnN0cmluZ2lmeShkYXRhKX1cImBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBrZXkgPSBPYmplY3Qua2V5cyhkYXRhKVswXTtcbiAgICAgICAgaWYgKGtleSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFbXB0eSBvYmplY3QgcGFzc2VkIGFzIGludmFyaWFudCBvZiB0aGUgZW51bSBcIiR7bmFtZX1cImApO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvcmRlckJ5dGUgPSBjYW5vbmljYWxPcmRlci5pbmRleE9mKGtleSk7XG4gICAgICAgIGlmIChvcmRlckJ5dGUgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFVua25vd24gaW52YXJpYW50IG9mIHRoZSBlbnVtIFwiJHtuYW1lfVwiLCBhbGxvd2VkIHZhbHVlczogXCIke2Nhbm9uaWNhbE9yZGVyLmpvaW4oXG4gICAgICAgICAgICAgIFwiIHwgXCJcbiAgICAgICAgICAgICl9XCI7IHJlY2VpdmVkIFwiJHtrZXl9XCJgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW52YXJpYW50ID0gY2Fub25pY2FsT3JkZXJbb3JkZXJCeXRlXTtcbiAgICAgICAgbGV0IGludmFyaWFudFR5cGUgPSBzdHJ1Y3RbaW52YXJpYW50XTtcbiAgICAgICAgd3JpdGVyLndyaXRlOChvcmRlckJ5dGUpO1xuICAgICAgICBpZiAoaW52YXJpYW50VHlwZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhcmFtSW5kZXggPSBjYW5vbmljYWxUeXBlUGFyYW1zLmluZGV4T2YoaW52YXJpYW50VHlwZSk7XG4gICAgICAgIGxldCB0eXBlT3JQYXJhbSA9IHBhcmFtSW5kZXggPT09IC0xID8gaW52YXJpYW50VHlwZSA6IHR5cGVQYXJhbXNbcGFyYW1JbmRleF07XG4gICAgICAgIHtcbiAgICAgICAgICBsZXQgeyBuYW1lOiBuYW1lMiwgcGFyYW1zIH0gPSB0aGlzLnBhcnNlVHlwZU5hbWUodHlwZU9yUGFyYW0pO1xuICAgICAgICAgIHJldHVybiB0aGlzLmdldFR5cGVJbnRlcmZhY2UobmFtZTIpLl9lbmNvZGVSYXcuY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICB3cml0ZXIsXG4gICAgICAgICAgICBkYXRhW2tleV0sXG4gICAgICAgICAgICBwYXJhbXMsXG4gICAgICAgICAgICB0eXBlTWFwXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGZ1bmN0aW9uIGRlY29kZUVudW0ocmVhZGVyLCB0eXBlUGFyYW1zLCB0eXBlTWFwKSB7XG4gICAgICAgIGxldCBvcmRlckJ5dGUgPSByZWFkZXIucmVhZFVMRUIoKTtcbiAgICAgICAgbGV0IGludmFyaWFudCA9IGNhbm9uaWNhbE9yZGVyW29yZGVyQnl0ZV07XG4gICAgICAgIGxldCBpbnZhcmlhbnRUeXBlID0gc3RydWN0W2ludmFyaWFudF07XG4gICAgICAgIGlmIChvcmRlckJ5dGUgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYERlY29kaW5nIHR5cGUgbWlzbWF0Y2gsIGV4cGVjdGVkIGVudW0gXCIke25hbWV9XCIgaW52YXJpYW50IGluZGV4LCByZWNlaXZlZCBcIiR7b3JkZXJCeXRlfVwiYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludmFyaWFudFR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4geyBbaW52YXJpYW50XTogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJhbUluZGV4ID0gY2Fub25pY2FsVHlwZVBhcmFtcy5pbmRleE9mKGludmFyaWFudFR5cGUpO1xuICAgICAgICBsZXQgdHlwZU9yUGFyYW0gPSBwYXJhbUluZGV4ID09PSAtMSA/IGludmFyaWFudFR5cGUgOiB0eXBlUGFyYW1zW3BhcmFtSW5kZXhdO1xuICAgICAgICB7XG4gICAgICAgICAgbGV0IHsgbmFtZTogbmFtZTIsIHBhcmFtcyB9ID0gdGhpcy5wYXJzZVR5cGVOYW1lKHR5cGVPclBhcmFtKTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW2ludmFyaWFudF06IHRoaXMuZ2V0VHlwZUludGVyZmFjZShuYW1lMikuX2RlY29kZVJhdy5jYWxsKHRoaXMsIHJlYWRlciwgcGFyYW1zLCB0eXBlTWFwKVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgYSBzZXQgb2YgZW5jb2RlcnMvZGVjb2RlcnMgZm9yIHNwZWNpZmljIHR5cGUuXG4gICAqIE1haW5seSB1c2VkIHRvIGRlZmluZSBjdXN0b20gdHlwZSBkZS9zZXJpYWxpemF0aW9uIGxvZ2ljLlxuICAgKlxuICAgKiBAcGFyYW0gdHlwZVxuICAgKiBAcmV0dXJucyB7VHlwZUludGVyZmFjZX1cbiAgICovXG4gIGdldFR5cGVJbnRlcmZhY2UodHlwZSkge1xuICAgIGxldCB0eXBlSW50ZXJmYWNlID0gdGhpcy50eXBlcy5nZXQodHlwZSk7XG4gICAgaWYgKHR5cGVvZiB0eXBlSW50ZXJmYWNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBsZXQgY2hhaW4gPSBbXTtcbiAgICAgIHdoaWxlICh0eXBlb2YgdHlwZUludGVyZmFjZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoY2hhaW4uaW5jbHVkZXModHlwZUludGVyZmFjZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlY3Vyc2l2ZSBkZWZpbml0aW9uIGZvdW5kOiAke2NoYWluLmpvaW4oXCIgLT4gXCIpfSAtPiAke3R5cGVJbnRlcmZhY2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY2hhaW4ucHVzaCh0eXBlSW50ZXJmYWNlKTtcbiAgICAgICAgdHlwZUludGVyZmFjZSA9IHRoaXMudHlwZXMuZ2V0KHR5cGVJbnRlcmZhY2UpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZUludGVyZmFjZSA9PT0gdm9pZCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFR5cGUgJHt0eXBlfSBpcyBub3QgcmVnaXN0ZXJlZGApO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZUludGVyZmFjZTtcbiAgfVxuICAvKipcbiAgICogUGFyc2UgYSB0eXBlIG5hbWUgYW5kIGdldCB0aGUgdHlwZSdzIGdlbmVyaWNzLlxuICAgKiBAZXhhbXBsZVxuICAgKiBsZXQgeyB0eXBlTmFtZSwgdHlwZVBhcmFtcyB9ID0gcGFyc2VUeXBlTmFtZSgnT3B0aW9uPENvaW48U1VJPj4nKTtcbiAgICogLy8gdHlwZU5hbWU6IE9wdGlvblxuICAgKiAvLyB0eXBlUGFyYW1zOiBbICdDb2luPFNVST4nIF1cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgdHlwZSB0byBwcm9jZXNzXG4gICAqIEByZXR1cm5zIE9iamVjdCB3aXRoIHR5cGVOYW1lIGFuZCB0eXBlUGFyYW1zIGxpc3RlZCBhcyBBcnJheVxuICAgKi9cbiAgcGFyc2VUeXBlTmFtZShuYW1lKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobmFtZSkpIHtcbiAgICAgIGxldCBbdHlwZU5hbWUyLCAuLi5wYXJhbXMyXSA9IG5hbWU7XG4gICAgICByZXR1cm4geyBuYW1lOiB0eXBlTmFtZTIsIHBhcmFtczogcGFyYW1zMiB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG5hbWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSWxsZWdhbCB0eXBlIHBhc3NlZCBhcyBhIG5hbWUgb2YgdGhlIHR5cGU6ICR7bmFtZX1gKTtcbiAgICB9XG4gICAgbGV0IFtsZWZ0LCByaWdodF0gPSB0aGlzLnNjaGVtYS5nZW5lcmljU2VwYXJhdG9ycyB8fCBbXCI8XCIsIFwiPlwiXTtcbiAgICBsZXQgbF9ib3VuZCA9IG5hbWUuaW5kZXhPZihsZWZ0KTtcbiAgICBsZXQgcl9ib3VuZCA9IEFycmF5LmZyb20obmFtZSkucmV2ZXJzZSgpLmluZGV4T2YocmlnaHQpO1xuICAgIGlmIChsX2JvdW5kID09PSAtMSAmJiByX2JvdW5kID09PSAtMSkge1xuICAgICAgcmV0dXJuIHsgbmFtZSwgcGFyYW1zOiBbXSB9O1xuICAgIH1cbiAgICBpZiAobF9ib3VuZCA9PT0gLTEgfHwgcl9ib3VuZCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5jbG9zZWQgZ2VuZXJpYyBpbiBuYW1lICcke25hbWV9J2ApO1xuICAgIH1cbiAgICBsZXQgdHlwZU5hbWUgPSBuYW1lLnNsaWNlKDAsIGxfYm91bmQpO1xuICAgIGxldCBwYXJhbXMgPSBzcGxpdEdlbmVyaWNQYXJhbWV0ZXJzKFxuICAgICAgbmFtZS5zbGljZShsX2JvdW5kICsgMSwgbmFtZS5sZW5ndGggLSByX2JvdW5kIC0gMSksXG4gICAgICB0aGlzLnNjaGVtYS5nZW5lcmljU2VwYXJhdG9yc1xuICAgICk7XG4gICAgcmV0dXJuIHsgbmFtZTogdHlwZU5hbWUsIHBhcmFtcyB9O1xuICB9XG59O1xubGV0IEJDUyA9IF9CQ1M7XG4vLyBQcmVkZWZpbmVkIHR5cGVzIGNvbnN0YW50c1xuQkNTLlU4ID0gXCJ1OFwiO1xuQkNTLlUxNiA9IFwidTE2XCI7XG5CQ1MuVTMyID0gXCJ1MzJcIjtcbkJDUy5VNjQgPSBcInU2NFwiO1xuQkNTLlUxMjggPSBcInUxMjhcIjtcbkJDUy5VMjU2ID0gXCJ1MjU2XCI7XG5CQ1MuQk9PTCA9IFwiYm9vbFwiO1xuQkNTLlZFQ1RPUiA9IFwidmVjdG9yXCI7XG5CQ1MuQUREUkVTUyA9IFwiYWRkcmVzc1wiO1xuQkNTLlNUUklORyA9IFwic3RyaW5nXCI7XG5CQ1MuSEVYID0gXCJoZXgtc3RyaW5nXCI7XG5CQ1MuQkFTRTU4ID0gXCJiYXNlNTgtc3RyaW5nXCI7XG5CQ1MuQkFTRTY0ID0gXCJiYXNlNjQtc3RyaW5nXCI7XG5mdW5jdGlvbiByZWdpc3RlclByaW1pdGl2ZXMoYmNzKSB7XG4gIGJjcy5yZWdpc3RlclR5cGUoXG4gICAgQkNTLlU4LFxuICAgIGZ1bmN0aW9uKHdyaXRlciwgZGF0YSkge1xuICAgICAgcmV0dXJuIHdyaXRlci53cml0ZTgoZGF0YSk7XG4gICAgfSxcbiAgICBmdW5jdGlvbihyZWFkZXIpIHtcbiAgICAgIHJldHVybiByZWFkZXIucmVhZDgoKTtcbiAgICB9LFxuICAgICh1OCkgPT4gdTggPCAyNTZcbiAgKTtcbiAgYmNzLnJlZ2lzdGVyVHlwZShcbiAgICBCQ1MuVTE2LFxuICAgIGZ1bmN0aW9uKHdyaXRlciwgZGF0YSkge1xuICAgICAgcmV0dXJuIHdyaXRlci53cml0ZTE2KGRhdGEpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24ocmVhZGVyKSB7XG4gICAgICByZXR1cm4gcmVhZGVyLnJlYWQxNigpO1xuICAgIH0sXG4gICAgKHUxNikgPT4gdTE2IDwgNjU1MzZcbiAgKTtcbiAgYmNzLnJlZ2lzdGVyVHlwZShcbiAgICBCQ1MuVTMyLFxuICAgIGZ1bmN0aW9uKHdyaXRlciwgZGF0YSkge1xuICAgICAgcmV0dXJuIHdyaXRlci53cml0ZTMyKGRhdGEpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24ocmVhZGVyKSB7XG4gICAgICByZXR1cm4gcmVhZGVyLnJlYWQzMigpO1xuICAgIH0sXG4gICAgKHUzMikgPT4gdTMyIDw9IDQyOTQ5NjcyOTZuXG4gICk7XG4gIGJjcy5yZWdpc3RlclR5cGUoXG4gICAgQkNTLlU2NCxcbiAgICBmdW5jdGlvbih3cml0ZXIsIGRhdGEpIHtcbiAgICAgIHJldHVybiB3cml0ZXIud3JpdGU2NChkYXRhKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uKHJlYWRlcikge1xuICAgICAgcmV0dXJuIHJlYWRlci5yZWFkNjQoKTtcbiAgICB9XG4gICk7XG4gIGJjcy5yZWdpc3RlclR5cGUoXG4gICAgQkNTLlUxMjgsXG4gICAgZnVuY3Rpb24od3JpdGVyLCBkYXRhKSB7XG4gICAgICByZXR1cm4gd3JpdGVyLndyaXRlMTI4KGRhdGEpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24ocmVhZGVyKSB7XG4gICAgICByZXR1cm4gcmVhZGVyLnJlYWQxMjgoKTtcbiAgICB9XG4gICk7XG4gIGJjcy5yZWdpc3RlclR5cGUoXG4gICAgQkNTLlUyNTYsXG4gICAgZnVuY3Rpb24od3JpdGVyLCBkYXRhKSB7XG4gICAgICByZXR1cm4gd3JpdGVyLndyaXRlMjU2KGRhdGEpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24ocmVhZGVyKSB7XG4gICAgICByZXR1cm4gcmVhZGVyLnJlYWQyNTYoKTtcbiAgICB9XG4gICk7XG4gIGJjcy5yZWdpc3RlclR5cGUoXG4gICAgQkNTLkJPT0wsXG4gICAgZnVuY3Rpb24od3JpdGVyLCBkYXRhKSB7XG4gICAgICByZXR1cm4gd3JpdGVyLndyaXRlOChkYXRhKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uKHJlYWRlcikge1xuICAgICAgcmV0dXJuIHJlYWRlci5yZWFkOCgpLnRvU3RyaW5nKDEwKSA9PT0gXCIxXCI7XG4gICAgfVxuICApO1xuICBiY3MucmVnaXN0ZXJUeXBlKFxuICAgIEJDUy5TVFJJTkcsXG4gICAgZnVuY3Rpb24od3JpdGVyLCBkYXRhKSB7XG4gICAgICByZXR1cm4gd3JpdGVyLndyaXRlVmVjKEFycmF5LmZyb20oZGF0YSksICh3cml0ZXIyLCBlbCkgPT4gd3JpdGVyMi53cml0ZTgoZWwuY2hhckNvZGVBdCgwKSkpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24ocmVhZGVyKSB7XG4gICAgICByZXR1cm4gcmVhZGVyLnJlYWRWZWMoKHJlYWRlcjIpID0+IHJlYWRlcjIucmVhZDgoKSkubWFwKChlbCkgPT4gU3RyaW5nLmZyb21DaGFyQ29kZShOdW1iZXIoZWwpKSkuam9pbihcIlwiKTtcbiAgICB9LFxuICAgIChfc3RyKSA9PiB0cnVlXG4gICk7XG4gIGJjcy5yZWdpc3RlclR5cGUoXG4gICAgQkNTLkhFWCxcbiAgICBmdW5jdGlvbih3cml0ZXIsIGRhdGEpIHtcbiAgICAgIHJldHVybiB3cml0ZXIud3JpdGVWZWMoQXJyYXkuZnJvbShmcm9tSEVYKGRhdGEpKSwgKHdyaXRlcjIsIGVsKSA9PiB3cml0ZXIyLndyaXRlOChlbCkpO1xuICAgIH0sXG4gICAgZnVuY3Rpb24ocmVhZGVyKSB7XG4gICAgICBsZXQgYnl0ZXMgPSByZWFkZXIucmVhZFZlYygocmVhZGVyMikgPT4gcmVhZGVyMi5yZWFkOCgpKTtcbiAgICAgIHJldHVybiB0b0hFWChuZXcgVWludDhBcnJheShieXRlcykpO1xuICAgIH1cbiAgKTtcbiAgYmNzLnJlZ2lzdGVyVHlwZShcbiAgICBCQ1MuQkFTRTU4LFxuICAgIGZ1bmN0aW9uKHdyaXRlciwgZGF0YSkge1xuICAgICAgcmV0dXJuIHdyaXRlci53cml0ZVZlYyhBcnJheS5mcm9tKGZyb21CNTgoZGF0YSkpLCAod3JpdGVyMiwgZWwpID0+IHdyaXRlcjIud3JpdGU4KGVsKSk7XG4gICAgfSxcbiAgICBmdW5jdGlvbihyZWFkZXIpIHtcbiAgICAgIGxldCBieXRlcyA9IHJlYWRlci5yZWFkVmVjKChyZWFkZXIyKSA9PiByZWFkZXIyLnJlYWQ4KCkpO1xuICAgICAgcmV0dXJuIHRvQjU4KG5ldyBVaW50OEFycmF5KGJ5dGVzKSk7XG4gICAgfVxuICApO1xuICBiY3MucmVnaXN0ZXJUeXBlKFxuICAgIEJDUy5CQVNFNjQsXG4gICAgZnVuY3Rpb24od3JpdGVyLCBkYXRhKSB7XG4gICAgICByZXR1cm4gd3JpdGVyLndyaXRlVmVjKEFycmF5LmZyb20oZnJvbUI2NChkYXRhKSksICh3cml0ZXIyLCBlbCkgPT4gd3JpdGVyMi53cml0ZTgoZWwpKTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uKHJlYWRlcikge1xuICAgICAgbGV0IGJ5dGVzID0gcmVhZGVyLnJlYWRWZWMoKHJlYWRlcjIpID0+IHJlYWRlcjIucmVhZDgoKSk7XG4gICAgICByZXR1cm4gdG9CNjQobmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKTtcbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBnZXRSdXN0Q29uZmlnKCkge1xuICByZXR1cm4ge1xuICAgIGdlbmVyaWNTZXBhcmF0b3JzOiBbXCI8XCIsIFwiPlwiXSxcbiAgICB2ZWN0b3JUeXBlOiBcIlZlY1wiLFxuICAgIGFkZHJlc3NMZW5ndGg6IFNVSV9BRERSRVNTX0xFTkdUSCxcbiAgICBhZGRyZXNzRW5jb2Rpbmc6IFwiaGV4XCJcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFN1aU1vdmVDb25maWcoKSB7XG4gIHJldHVybiB7XG4gICAgZ2VuZXJpY1NlcGFyYXRvcnM6IFtcIjxcIiwgXCI+XCJdLFxuICAgIHZlY3RvclR5cGU6IFwidmVjdG9yXCIsXG4gICAgYWRkcmVzc0xlbmd0aDogU1VJX0FERFJFU1NfTEVOR1RILFxuICAgIGFkZHJlc3NFbmNvZGluZzogXCJoZXhcIlxuICB9O1xufVxuZXhwb3J0IHtcbiAgQkNTLFxuICBnZXRSdXN0Q29uZmlnLFxuICBnZXRTdWlNb3ZlQ29uZmlnLFxuICByZWdpc3RlclByaW1pdGl2ZXNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZWdhY3ktcmVnaXN0cnkuanMubWFwXG4iXSwibmFtZXMiOlsiZnJvbUI1OCIsInRvQjU4IiwiZnJvbUI2NCIsInRvQjY0IiwiQmNzVHlwZSIsImZyb21IRVgiLCJ0b0hFWCIsIkJjc1JlYWRlciIsImRlY29kZVN0ciIsInNwbGl0R2VuZXJpY1BhcmFtZXRlcnMiLCJCY3NXcml0ZXIiLCJTVUlfQUREUkVTU19MRU5HVEgiLCJfQkNTIiwiY29uc3RydWN0b3IiLCJzY2hlbWEiLCJ0eXBlcyIsIk1hcCIsImNvdW50ZXIiLCJyZWdpc3RlckFkZHJlc3NUeXBlIiwiQUREUkVTUyIsImFkZHJlc3NMZW5ndGgiLCJhZGRyZXNzRW5jb2RpbmciLCJyZWdpc3RlclZlY3RvclR5cGUiLCJ2ZWN0b3JUeXBlIiwic3RydWN0cyIsIm5hbWUiLCJPYmplY3QiLCJrZXlzIiwicmVnaXN0ZXJTdHJ1Y3RUeXBlIiwiZW51bXMiLCJyZWdpc3RlckVudW1UeXBlIiwiYWxpYXNlcyIsInJlZ2lzdGVyQWxpYXMiLCJ3aXRoUHJpbWl0aXZlcyIsInJlZ2lzdGVyUHJpbWl0aXZlcyIsInRlbXBLZXkiLCJzZXIiLCJ0eXBlIiwiZGF0YSIsIm9wdGlvbnMiLCJBcnJheSIsImlzQXJyYXkiLCJwYXJhbXMiLCJwYXJzZVR5cGVOYW1lIiwiZ2V0VHlwZUludGVyZmFjZSIsImVuY29kZSIsImtleSIsInRlbXAiLCJFcnJvciIsIkpTT04iLCJzdHJpbmdpZnkiLCJkZSIsImVuY29kaW5nIiwiZGVjb2RlIiwiaGFzVHlwZSIsImhhcyIsImZvclR5cGUiLCJzZXQiLCJyZWdpc3RlclR5cGUiLCJ0eXBlTmFtZSIsImVuY29kZUNiIiwiZGVjb2RlQ2IiLCJ2YWxpZGF0ZUNiIiwiZ2VuZXJpY3MiLCJzZWxmIiwidHlwZVBhcmFtcyIsInR5cGVNYXAiLCJyZWR1Y2UiLCJhY2MiLCJ2YWx1ZSIsImluZGV4IiwiYXNzaWduIiwiX2VuY29kZVJhdyIsImNhbGwiLCJfZGVjb2RlUmF3Iiwid3JpdGVyIiwicmVhZGVyIiwicmVnaXN0ZXJCY3NUeXBlIiwiY3JlYXRlVHlwZSIsIm1hcCIsInBhcmFtIiwiU3RyaW5nIiwid3JpdGUiLCJkYXRhMiIsIndyaXRlcjIiLCJ0eXBlSW50ZXJmYWNlIiwicmVhZCIsIl9kYXRhIiwiX3dyaXRlciIsInJlYWRlcjIiLCJsZW5ndGgiLCJlbmNvZGVBZGRyZXNzIiwiZWwiLCJ3cml0ZTgiLCJkZWNvZGVBZGRyZXNzIiwicmVhZEJ5dGVzIiwiZW5jb2RlVmVjdG9yIiwid3JpdGVWZWMiLCJlbGVtZW50VHlwZSIsIm5hbWUyIiwicGFyYW1zMiIsImlubmVyTmFtZSIsImlubmVyUGFyYW1zIiwiZGVjb2RlVmVjdG9yIiwicmVhZFZlYyIsImZpZWxkcyIsImludGVybmFsTmFtZSIsInN0cnVjdCIsImZyZWV6ZSIsImNhbm9uaWNhbE9yZGVyIiwic3RydWN0TmFtZSIsImVuY29kZVN0cnVjdCIsImZpZWxkVHlwZSIsImZpZWxkUGFyYW1zIiwiaW5jbHVkZXMiLCJwYXJhbUlkeCIsImluZGV4T2YiLCJkZWNvZGVTdHJ1Y3QiLCJyZXN1bHQiLCJmaWVsZE5hbWUiLCJ2YXJpYW50cyIsImNhbm9uaWNhbFR5cGVQYXJhbXMiLCJlbmNvZGVFbnVtIiwiam9pbiIsIm9yZGVyQnl0ZSIsImludmFyaWFudCIsImludmFyaWFudFR5cGUiLCJwYXJhbUluZGV4IiwidHlwZU9yUGFyYW0iLCJkZWNvZGVFbnVtIiwicmVhZFVMRUIiLCJnZXQiLCJjaGFpbiIsInB1c2giLCJ0eXBlTmFtZTIiLCJsZWZ0IiwicmlnaHQiLCJnZW5lcmljU2VwYXJhdG9ycyIsImxfYm91bmQiLCJyX2JvdW5kIiwiZnJvbSIsInJldmVyc2UiLCJzbGljZSIsIkJDUyIsIlU4IiwiVTE2IiwiVTMyIiwiVTY0IiwiVTEyOCIsIlUyNTYiLCJCT09MIiwiVkVDVE9SIiwiU1RSSU5HIiwiSEVYIiwiQkFTRTU4IiwiQkFTRTY0IiwiYmNzIiwicmVhZDgiLCJ1OCIsIndyaXRlMTYiLCJyZWFkMTYiLCJ1MTYiLCJ3cml0ZTMyIiwicmVhZDMyIiwidTMyIiwid3JpdGU2NCIsInJlYWQ2NCIsIndyaXRlMTI4IiwicmVhZDEyOCIsIndyaXRlMjU2IiwicmVhZDI1NiIsInRvU3RyaW5nIiwiY2hhckNvZGVBdCIsImZyb21DaGFyQ29kZSIsIk51bWJlciIsIl9zdHIiLCJieXRlcyIsIlVpbnQ4QXJyYXkiLCJnZXRSdXN0Q29uZmlnIiwiZ2V0U3VpTW92ZUNvbmZpZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/legacy-registry.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/reader.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/reader.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BcsReader: () => (/* binding */ BcsReader)\n/* harmony export */ });\n/* harmony import */ var _uleb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./uleb.js */ \"(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/uleb.js\");\n\nclass BcsReader {\n    /**\n   * @param {Uint8Array} data Data to use as a buffer.\n   */ constructor(data){\n        this.bytePosition = 0;\n        this.dataView = new DataView(data.buffer);\n    }\n    /**\n   * Shift current cursor position by `bytes`.\n   *\n   * @param {Number} bytes Number of bytes to\n   * @returns {this} Self for possible chaining.\n   */ shift(bytes) {\n        this.bytePosition += bytes;\n        return this;\n    }\n    /**\n   * Read U8 value from the buffer and shift cursor by 1.\n   * @returns\n   */ read8() {\n        let value = this.dataView.getUint8(this.bytePosition);\n        this.shift(1);\n        return value;\n    }\n    /**\n   * Read U16 value from the buffer and shift cursor by 2.\n   * @returns\n   */ read16() {\n        let value = this.dataView.getUint16(this.bytePosition, true);\n        this.shift(2);\n        return value;\n    }\n    /**\n   * Read U32 value from the buffer and shift cursor by 4.\n   * @returns\n   */ read32() {\n        let value = this.dataView.getUint32(this.bytePosition, true);\n        this.shift(4);\n        return value;\n    }\n    /**\n   * Read U64 value from the buffer and shift cursor by 8.\n   * @returns\n   */ read64() {\n        let value1 = this.read32();\n        let value2 = this.read32();\n        let result = value2.toString(16) + value1.toString(16).padStart(8, \"0\");\n        return BigInt(\"0x\" + result).toString(10);\n    }\n    /**\n   * Read U128 value from the buffer and shift cursor by 16.\n   */ read128() {\n        let value1 = BigInt(this.read64());\n        let value2 = BigInt(this.read64());\n        let result = value2.toString(16) + value1.toString(16).padStart(16, \"0\");\n        return BigInt(\"0x\" + result).toString(10);\n    }\n    /**\n   * Read U128 value from the buffer and shift cursor by 32.\n   * @returns\n   */ read256() {\n        let value1 = BigInt(this.read128());\n        let value2 = BigInt(this.read128());\n        let result = value2.toString(16) + value1.toString(16).padStart(32, \"0\");\n        return BigInt(\"0x\" + result).toString(10);\n    }\n    /**\n   * Read `num` number of bytes from the buffer and shift cursor by `num`.\n   * @param num Number of bytes to read.\n   */ readBytes(num) {\n        let start = this.bytePosition + this.dataView.byteOffset;\n        let value = new Uint8Array(this.dataView.buffer, start, num);\n        this.shift(num);\n        return value;\n    }\n    /**\n   * Read ULEB value - an integer of varying size. Used for enum indexes and\n   * vector lengths.\n   * @returns {Number} The ULEB value.\n   */ readULEB() {\n        let start = this.bytePosition + this.dataView.byteOffset;\n        let buffer = new Uint8Array(this.dataView.buffer, start);\n        let { value, length } = (0,_uleb_js__WEBPACK_IMPORTED_MODULE_0__.ulebDecode)(buffer);\n        this.shift(length);\n        return value;\n    }\n    /**\n   * Read a BCS vector: read a length and then apply function `cb` X times\n   * where X is the length of the vector, defined as ULEB in BCS bytes.\n   * @param cb Callback to process elements of vector.\n   * @returns {Array<Any>} Array of the resulting values, returned by callback.\n   */ readVec(cb) {\n        let length = this.readULEB();\n        let result = [];\n        for(let i = 0; i < length; i++){\n            result.push(cb(this, i, length));\n        }\n        return result;\n    }\n}\n //# sourceMappingURL=reader.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG15c3RlbitiY3NAMC4xMS4xL25vZGVfbW9kdWxlcy9AbXlzdGVuL2Jjcy9kaXN0L2VzbS9yZWFkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBdUM7QUFDdkMsTUFBTUM7SUFDSjs7R0FFQyxHQUNEQyxZQUFZQyxJQUFJLENBQUU7UUFDaEIsSUFBSSxDQUFDQyxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDQyxRQUFRLEdBQUcsSUFBSUMsU0FBU0gsS0FBS0ksTUFBTTtJQUMxQztJQUNBOzs7OztHQUtDLEdBQ0RDLE1BQU1DLEtBQUssRUFBRTtRQUNYLElBQUksQ0FBQ0wsWUFBWSxJQUFJSztRQUNyQixPQUFPLElBQUk7SUFDYjtJQUNBOzs7R0FHQyxHQUNEQyxRQUFRO1FBQ04sSUFBSUMsUUFBUSxJQUFJLENBQUNOLFFBQVEsQ0FBQ08sUUFBUSxDQUFDLElBQUksQ0FBQ1IsWUFBWTtRQUNwRCxJQUFJLENBQUNJLEtBQUssQ0FBQztRQUNYLE9BQU9HO0lBQ1Q7SUFDQTs7O0dBR0MsR0FDREUsU0FBUztRQUNQLElBQUlGLFFBQVEsSUFBSSxDQUFDTixRQUFRLENBQUNTLFNBQVMsQ0FBQyxJQUFJLENBQUNWLFlBQVksRUFBRTtRQUN2RCxJQUFJLENBQUNJLEtBQUssQ0FBQztRQUNYLE9BQU9HO0lBQ1Q7SUFDQTs7O0dBR0MsR0FDREksU0FBUztRQUNQLElBQUlKLFFBQVEsSUFBSSxDQUFDTixRQUFRLENBQUNXLFNBQVMsQ0FBQyxJQUFJLENBQUNaLFlBQVksRUFBRTtRQUN2RCxJQUFJLENBQUNJLEtBQUssQ0FBQztRQUNYLE9BQU9HO0lBQ1Q7SUFDQTs7O0dBR0MsR0FDRE0sU0FBUztRQUNQLElBQUlDLFNBQVMsSUFBSSxDQUFDSCxNQUFNO1FBQ3hCLElBQUlJLFNBQVMsSUFBSSxDQUFDSixNQUFNO1FBQ3hCLElBQUlLLFNBQVNELE9BQU9FLFFBQVEsQ0FBQyxNQUFNSCxPQUFPRyxRQUFRLENBQUMsSUFBSUMsUUFBUSxDQUFDLEdBQUc7UUFDbkUsT0FBT0MsT0FBTyxPQUFPSCxRQUFRQyxRQUFRLENBQUM7SUFDeEM7SUFDQTs7R0FFQyxHQUNERyxVQUFVO1FBQ1IsSUFBSU4sU0FBU0ssT0FBTyxJQUFJLENBQUNOLE1BQU07UUFDL0IsSUFBSUUsU0FBU0ksT0FBTyxJQUFJLENBQUNOLE1BQU07UUFDL0IsSUFBSUcsU0FBU0QsT0FBT0UsUUFBUSxDQUFDLE1BQU1ILE9BQU9HLFFBQVEsQ0FBQyxJQUFJQyxRQUFRLENBQUMsSUFBSTtRQUNwRSxPQUFPQyxPQUFPLE9BQU9ILFFBQVFDLFFBQVEsQ0FBQztJQUN4QztJQUNBOzs7R0FHQyxHQUNESSxVQUFVO1FBQ1IsSUFBSVAsU0FBU0ssT0FBTyxJQUFJLENBQUNDLE9BQU87UUFDaEMsSUFBSUwsU0FBU0ksT0FBTyxJQUFJLENBQUNDLE9BQU87UUFDaEMsSUFBSUosU0FBU0QsT0FBT0UsUUFBUSxDQUFDLE1BQU1ILE9BQU9HLFFBQVEsQ0FBQyxJQUFJQyxRQUFRLENBQUMsSUFBSTtRQUNwRSxPQUFPQyxPQUFPLE9BQU9ILFFBQVFDLFFBQVEsQ0FBQztJQUN4QztJQUNBOzs7R0FHQyxHQUNESyxVQUFVQyxHQUFHLEVBQUU7UUFDYixJQUFJQyxRQUFRLElBQUksQ0FBQ3hCLFlBQVksR0FBRyxJQUFJLENBQUNDLFFBQVEsQ0FBQ3dCLFVBQVU7UUFDeEQsSUFBSWxCLFFBQVEsSUFBSW1CLFdBQVcsSUFBSSxDQUFDekIsUUFBUSxDQUFDRSxNQUFNLEVBQUVxQixPQUFPRDtRQUN4RCxJQUFJLENBQUNuQixLQUFLLENBQUNtQjtRQUNYLE9BQU9oQjtJQUNUO0lBQ0E7Ozs7R0FJQyxHQUNEb0IsV0FBVztRQUNULElBQUlILFFBQVEsSUFBSSxDQUFDeEIsWUFBWSxHQUFHLElBQUksQ0FBQ0MsUUFBUSxDQUFDd0IsVUFBVTtRQUN4RCxJQUFJdEIsU0FBUyxJQUFJdUIsV0FBVyxJQUFJLENBQUN6QixRQUFRLENBQUNFLE1BQU0sRUFBRXFCO1FBQ2xELElBQUksRUFBRWpCLEtBQUssRUFBRXFCLE1BQU0sRUFBRSxHQUFHaEMsb0RBQVVBLENBQUNPO1FBQ25DLElBQUksQ0FBQ0MsS0FBSyxDQUFDd0I7UUFDWCxPQUFPckI7SUFDVDtJQUNBOzs7OztHQUtDLEdBQ0RzQixRQUFRQyxFQUFFLEVBQUU7UUFDVixJQUFJRixTQUFTLElBQUksQ0FBQ0QsUUFBUTtRQUMxQixJQUFJWCxTQUFTLEVBQUU7UUFDZixJQUFLLElBQUllLElBQUksR0FBR0EsSUFBSUgsUUFBUUcsSUFBSztZQUMvQmYsT0FBT2dCLElBQUksQ0FBQ0YsR0FBRyxJQUFJLEVBQUVDLEdBQUdIO1FBQzFCO1FBQ0EsT0FBT1o7SUFDVDtBQUNGO0FBR0UsQ0FDRixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3Rhc2NhbS1wcm90b2NvbC8uL25vZGVfbW9kdWxlcy8ucG5wbS9AbXlzdGVuK2Jjc0AwLjExLjEvbm9kZV9tb2R1bGVzL0BteXN0ZW4vYmNzL2Rpc3QvZXNtL3JlYWRlci5qcz9jYzc3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVsZWJEZWNvZGUgfSBmcm9tIFwiLi91bGViLmpzXCI7XG5jbGFzcyBCY3NSZWFkZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhIERhdGEgdG8gdXNlIGFzIGEgYnVmZmVyLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHRoaXMuYnl0ZVBvc2l0aW9uID0gMDtcbiAgICB0aGlzLmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KGRhdGEuYnVmZmVyKTtcbiAgfVxuICAvKipcbiAgICogU2hpZnQgY3VycmVudCBjdXJzb3IgcG9zaXRpb24gYnkgYGJ5dGVzYC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGJ5dGVzIE51bWJlciBvZiBieXRlcyB0b1xuICAgKiBAcmV0dXJucyB7dGhpc30gU2VsZiBmb3IgcG9zc2libGUgY2hhaW5pbmcuXG4gICAqL1xuICBzaGlmdChieXRlcykge1xuICAgIHRoaXMuYnl0ZVBvc2l0aW9uICs9IGJ5dGVzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIFU4IHZhbHVlIGZyb20gdGhlIGJ1ZmZlciBhbmQgc2hpZnQgY3Vyc29yIGJ5IDEuXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICByZWFkOCgpIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLmRhdGFWaWV3LmdldFVpbnQ4KHRoaXMuYnl0ZVBvc2l0aW9uKTtcbiAgICB0aGlzLnNoaWZ0KDEpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBVMTYgdmFsdWUgZnJvbSB0aGUgYnVmZmVyIGFuZCBzaGlmdCBjdXJzb3IgYnkgMi5cbiAgICogQHJldHVybnNcbiAgICovXG4gIHJlYWQxNigpIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLmRhdGFWaWV3LmdldFVpbnQxNih0aGlzLmJ5dGVQb3NpdGlvbiwgdHJ1ZSk7XG4gICAgdGhpcy5zaGlmdCgyKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgVTMyIHZhbHVlIGZyb20gdGhlIGJ1ZmZlciBhbmQgc2hpZnQgY3Vyc29yIGJ5IDQuXG4gICAqIEByZXR1cm5zXG4gICAqL1xuICByZWFkMzIoKSB7XG4gICAgbGV0IHZhbHVlID0gdGhpcy5kYXRhVmlldy5nZXRVaW50MzIodGhpcy5ieXRlUG9zaXRpb24sIHRydWUpO1xuICAgIHRoaXMuc2hpZnQoNCk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIFU2NCB2YWx1ZSBmcm9tIHRoZSBidWZmZXIgYW5kIHNoaWZ0IGN1cnNvciBieSA4LlxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgcmVhZDY0KCkge1xuICAgIGxldCB2YWx1ZTEgPSB0aGlzLnJlYWQzMigpO1xuICAgIGxldCB2YWx1ZTIgPSB0aGlzLnJlYWQzMigpO1xuICAgIGxldCByZXN1bHQgPSB2YWx1ZTIudG9TdHJpbmcoMTYpICsgdmFsdWUxLnRvU3RyaW5nKDE2KS5wYWRTdGFydCg4LCBcIjBcIik7XG4gICAgcmV0dXJuIEJpZ0ludChcIjB4XCIgKyByZXN1bHQpLnRvU3RyaW5nKDEwKTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBVMTI4IHZhbHVlIGZyb20gdGhlIGJ1ZmZlciBhbmQgc2hpZnQgY3Vyc29yIGJ5IDE2LlxuICAgKi9cbiAgcmVhZDEyOCgpIHtcbiAgICBsZXQgdmFsdWUxID0gQmlnSW50KHRoaXMucmVhZDY0KCkpO1xuICAgIGxldCB2YWx1ZTIgPSBCaWdJbnQodGhpcy5yZWFkNjQoKSk7XG4gICAgbGV0IHJlc3VsdCA9IHZhbHVlMi50b1N0cmluZygxNikgKyB2YWx1ZTEudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDE2LCBcIjBcIik7XG4gICAgcmV0dXJuIEJpZ0ludChcIjB4XCIgKyByZXN1bHQpLnRvU3RyaW5nKDEwKTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBVMTI4IHZhbHVlIGZyb20gdGhlIGJ1ZmZlciBhbmQgc2hpZnQgY3Vyc29yIGJ5IDMyLlxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgcmVhZDI1NigpIHtcbiAgICBsZXQgdmFsdWUxID0gQmlnSW50KHRoaXMucmVhZDEyOCgpKTtcbiAgICBsZXQgdmFsdWUyID0gQmlnSW50KHRoaXMucmVhZDEyOCgpKTtcbiAgICBsZXQgcmVzdWx0ID0gdmFsdWUyLnRvU3RyaW5nKDE2KSArIHZhbHVlMS50b1N0cmluZygxNikucGFkU3RhcnQoMzIsIFwiMFwiKTtcbiAgICByZXR1cm4gQmlnSW50KFwiMHhcIiArIHJlc3VsdCkudG9TdHJpbmcoMTApO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGBudW1gIG51bWJlciBvZiBieXRlcyBmcm9tIHRoZSBidWZmZXIgYW5kIHNoaWZ0IGN1cnNvciBieSBgbnVtYC5cbiAgICogQHBhcmFtIG51bSBOdW1iZXIgb2YgYnl0ZXMgdG8gcmVhZC5cbiAgICovXG4gIHJlYWRCeXRlcyhudW0pIHtcbiAgICBsZXQgc3RhcnQgPSB0aGlzLmJ5dGVQb3NpdGlvbiArIHRoaXMuZGF0YVZpZXcuYnl0ZU9mZnNldDtcbiAgICBsZXQgdmFsdWUgPSBuZXcgVWludDhBcnJheSh0aGlzLmRhdGFWaWV3LmJ1ZmZlciwgc3RhcnQsIG51bSk7XG4gICAgdGhpcy5zaGlmdChudW0pO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBVTEVCIHZhbHVlIC0gYW4gaW50ZWdlciBvZiB2YXJ5aW5nIHNpemUuIFVzZWQgZm9yIGVudW0gaW5kZXhlcyBhbmRcbiAgICogdmVjdG9yIGxlbmd0aHMuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBVTEVCIHZhbHVlLlxuICAgKi9cbiAgcmVhZFVMRUIoKSB7XG4gICAgbGV0IHN0YXJ0ID0gdGhpcy5ieXRlUG9zaXRpb24gKyB0aGlzLmRhdGFWaWV3LmJ5dGVPZmZzZXQ7XG4gICAgbGV0IGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YVZpZXcuYnVmZmVyLCBzdGFydCk7XG4gICAgbGV0IHsgdmFsdWUsIGxlbmd0aCB9ID0gdWxlYkRlY29kZShidWZmZXIpO1xuICAgIHRoaXMuc2hpZnQobGVuZ3RoKTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBCQ1MgdmVjdG9yOiByZWFkIGEgbGVuZ3RoIGFuZCB0aGVuIGFwcGx5IGZ1bmN0aW9uIGBjYmAgWCB0aW1lc1xuICAgKiB3aGVyZSBYIGlzIHRoZSBsZW5ndGggb2YgdGhlIHZlY3RvciwgZGVmaW5lZCBhcyBVTEVCIGluIEJDUyBieXRlcy5cbiAgICogQHBhcmFtIGNiIENhbGxiYWNrIHRvIHByb2Nlc3MgZWxlbWVudHMgb2YgdmVjdG9yLlxuICAgKiBAcmV0dXJucyB7QXJyYXk8QW55Pn0gQXJyYXkgb2YgdGhlIHJlc3VsdGluZyB2YWx1ZXMsIHJldHVybmVkIGJ5IGNhbGxiYWNrLlxuICAgKi9cbiAgcmVhZFZlYyhjYikge1xuICAgIGxldCBsZW5ndGggPSB0aGlzLnJlYWRVTEVCKCk7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3VsdC5wdXNoKGNiKHRoaXMsIGksIGxlbmd0aCkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5leHBvcnQge1xuICBCY3NSZWFkZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFkZXIuanMubWFwXG4iXSwibmFtZXMiOlsidWxlYkRlY29kZSIsIkJjc1JlYWRlciIsImNvbnN0cnVjdG9yIiwiZGF0YSIsImJ5dGVQb3NpdGlvbiIsImRhdGFWaWV3IiwiRGF0YVZpZXciLCJidWZmZXIiLCJzaGlmdCIsImJ5dGVzIiwicmVhZDgiLCJ2YWx1ZSIsImdldFVpbnQ4IiwicmVhZDE2IiwiZ2V0VWludDE2IiwicmVhZDMyIiwiZ2V0VWludDMyIiwicmVhZDY0IiwidmFsdWUxIiwidmFsdWUyIiwicmVzdWx0IiwidG9TdHJpbmciLCJwYWRTdGFydCIsIkJpZ0ludCIsInJlYWQxMjgiLCJyZWFkMjU2IiwicmVhZEJ5dGVzIiwibnVtIiwic3RhcnQiLCJieXRlT2Zmc2V0IiwiVWludDhBcnJheSIsInJlYWRVTEVCIiwibGVuZ3RoIiwicmVhZFZlYyIsImNiIiwiaSIsInB1c2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/reader.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/uleb.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/uleb.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ulebDecode: () => (/* binding */ ulebDecode),\n/* harmony export */   ulebEncode: () => (/* binding */ ulebEncode)\n/* harmony export */ });\nfunction ulebEncode(num) {\n    let arr = [];\n    let len = 0;\n    if (num === 0) {\n        return [\n            0\n        ];\n    }\n    while(num > 0){\n        arr[len] = num & 127;\n        if (num >>= 7) {\n            arr[len] |= 128;\n        }\n        len += 1;\n    }\n    return arr;\n}\nfunction ulebDecode(arr) {\n    let total = 0;\n    let shift = 0;\n    let len = 0;\n    while(true){\n        let byte = arr[len];\n        len += 1;\n        total |= (byte & 127) << shift;\n        if ((byte & 128) === 0) {\n            break;\n        }\n        shift += 7;\n    }\n    return {\n        value: total,\n        length: len\n    };\n}\n //# sourceMappingURL=uleb.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG15c3RlbitiY3NAMC4xMS4xL25vZGVfbW9kdWxlcy9AbXlzdGVuL2Jjcy9kaXN0L2VzbS91bGViLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsU0FBU0EsV0FBV0MsR0FBRztJQUNyQixJQUFJQyxNQUFNLEVBQUU7SUFDWixJQUFJQyxNQUFNO0lBQ1YsSUFBSUYsUUFBUSxHQUFHO1FBQ2IsT0FBTztZQUFDO1NBQUU7SUFDWjtJQUNBLE1BQU9BLE1BQU0sRUFBRztRQUNkQyxHQUFHLENBQUNDLElBQUksR0FBR0YsTUFBTTtRQUNqQixJQUFJQSxRQUFRLEdBQUc7WUFDYkMsR0FBRyxDQUFDQyxJQUFJLElBQUk7UUFDZDtRQUNBQSxPQUFPO0lBQ1Q7SUFDQSxPQUFPRDtBQUNUO0FBQ0EsU0FBU0UsV0FBV0YsR0FBRztJQUNyQixJQUFJRyxRQUFRO0lBQ1osSUFBSUMsUUFBUTtJQUNaLElBQUlILE1BQU07SUFDVixNQUFPLEtBQU07UUFDWCxJQUFJSSxPQUFPTCxHQUFHLENBQUNDLElBQUk7UUFDbkJBLE9BQU87UUFDUEUsU0FBUyxDQUFDRSxPQUFPLEdBQUUsS0FBTUQ7UUFDekIsSUFBSSxDQUFDQyxPQUFPLEdBQUUsTUFBTyxHQUFHO1lBQ3RCO1FBQ0Y7UUFDQUQsU0FBUztJQUNYO0lBQ0EsT0FBTztRQUNMRSxPQUFPSDtRQUNQSSxRQUFRTjtJQUNWO0FBQ0Y7QUFJRSxDQUNGLGdDQUFnQyIsInNvdXJjZXMiOlsid2VicGFjazovL25vdGFzY2FtLXByb3RvY29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0BteXN0ZW4rYmNzQDAuMTEuMS9ub2RlX21vZHVsZXMvQG15c3Rlbi9iY3MvZGlzdC9lc20vdWxlYi5qcz8wNDI3Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIHVsZWJFbmNvZGUobnVtKSB7XG4gIGxldCBhcnIgPSBbXTtcbiAgbGV0IGxlbiA9IDA7XG4gIGlmIChudW0gPT09IDApIHtcbiAgICByZXR1cm4gWzBdO1xuICB9XG4gIHdoaWxlIChudW0gPiAwKSB7XG4gICAgYXJyW2xlbl0gPSBudW0gJiAxMjc7XG4gICAgaWYgKG51bSA+Pj0gNykge1xuICAgICAgYXJyW2xlbl0gfD0gMTI4O1xuICAgIH1cbiAgICBsZW4gKz0gMTtcbiAgfVxuICByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gdWxlYkRlY29kZShhcnIpIHtcbiAgbGV0IHRvdGFsID0gMDtcbiAgbGV0IHNoaWZ0ID0gMDtcbiAgbGV0IGxlbiA9IDA7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgbGV0IGJ5dGUgPSBhcnJbbGVuXTtcbiAgICBsZW4gKz0gMTtcbiAgICB0b3RhbCB8PSAoYnl0ZSAmIDEyNykgPDwgc2hpZnQ7XG4gICAgaWYgKChieXRlICYgMTI4KSA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHNoaWZ0ICs9IDc7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdG90YWwsXG4gICAgbGVuZ3RoOiBsZW5cbiAgfTtcbn1cbmV4cG9ydCB7XG4gIHVsZWJEZWNvZGUsXG4gIHVsZWJFbmNvZGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11bGViLmpzLm1hcFxuIl0sIm5hbWVzIjpbInVsZWJFbmNvZGUiLCJudW0iLCJhcnIiLCJsZW4iLCJ1bGViRGVjb2RlIiwidG90YWwiLCJzaGlmdCIsImJ5dGUiLCJ2YWx1ZSIsImxlbmd0aCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/uleb.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/utils.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/utils.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeStr: () => (/* binding */ decodeStr),\n/* harmony export */   encodeStr: () => (/* binding */ encodeStr),\n/* harmony export */   splitGenericParameters: () => (/* binding */ splitGenericParameters)\n/* harmony export */ });\n/* harmony import */ var _b58_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./b58.js */ \"(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/b58.js\");\n/* harmony import */ var _b64_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./b64.js */ \"(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/b64.js\");\n/* harmony import */ var _hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hex.js */ \"(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/hex.js\");\n\n\n\nfunction encodeStr(data, encoding) {\n    switch(encoding){\n        case \"base58\":\n            return (0,_b58_js__WEBPACK_IMPORTED_MODULE_0__.toB58)(data);\n        case \"base64\":\n            return (0,_b64_js__WEBPACK_IMPORTED_MODULE_1__.toB64)(data);\n        case \"hex\":\n            return (0,_hex_js__WEBPACK_IMPORTED_MODULE_2__.toHEX)(data);\n        default:\n            throw new Error(\"Unsupported encoding, supported values are: base64, hex\");\n    }\n}\nfunction decodeStr(data, encoding) {\n    switch(encoding){\n        case \"base58\":\n            return (0,_b58_js__WEBPACK_IMPORTED_MODULE_0__.fromB58)(data);\n        case \"base64\":\n            return (0,_b64_js__WEBPACK_IMPORTED_MODULE_1__.fromB64)(data);\n        case \"hex\":\n            return (0,_hex_js__WEBPACK_IMPORTED_MODULE_2__.fromHEX)(data);\n        default:\n            throw new Error(\"Unsupported encoding, supported values are: base64, hex\");\n    }\n}\nfunction splitGenericParameters(str, genericSeparators = [\n    \"<\",\n    \">\"\n]) {\n    const [left, right] = genericSeparators;\n    const tok = [];\n    let word = \"\";\n    let nestedAngleBrackets = 0;\n    for(let i = 0; i < str.length; i++){\n        const char = str[i];\n        if (char === left) {\n            nestedAngleBrackets++;\n        }\n        if (char === right) {\n            nestedAngleBrackets--;\n        }\n        if (nestedAngleBrackets === 0 && char === \",\") {\n            tok.push(word.trim());\n            word = \"\";\n            continue;\n        }\n        word += char;\n    }\n    tok.push(word.trim());\n    return tok;\n}\n //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG15c3RlbitiY3NAMC4xMS4xL25vZGVfbW9kdWxlcy9AbXlzdGVuL2Jjcy9kaXN0L2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBMEM7QUFDQTtBQUNBO0FBQzFDLFNBQVNNLFVBQVVDLElBQUksRUFBRUMsUUFBUTtJQUMvQixPQUFRQTtRQUNOLEtBQUs7WUFDSCxPQUFPUCw4Q0FBS0EsQ0FBQ007UUFDZixLQUFLO1lBQ0gsT0FBT0osOENBQUtBLENBQUNJO1FBQ2YsS0FBSztZQUNILE9BQU9GLDhDQUFLQSxDQUFDRTtRQUNmO1lBQ0UsTUFBTSxJQUFJRSxNQUFNO0lBQ3BCO0FBQ0Y7QUFDQSxTQUFTQyxVQUFVSCxJQUFJLEVBQUVDLFFBQVE7SUFDL0IsT0FBUUE7UUFDTixLQUFLO1lBQ0gsT0FBT1IsZ0RBQU9BLENBQUNPO1FBQ2pCLEtBQUs7WUFDSCxPQUFPTCxnREFBT0EsQ0FBQ0s7UUFDakIsS0FBSztZQUNILE9BQU9ILGdEQUFPQSxDQUFDRztRQUNqQjtZQUNFLE1BQU0sSUFBSUUsTUFBTTtJQUNwQjtBQUNGO0FBQ0EsU0FBU0UsdUJBQXVCQyxHQUFHLEVBQUVDLG9CQUFvQjtJQUFDO0lBQUs7Q0FBSTtJQUNqRSxNQUFNLENBQUNDLE1BQU1DLE1BQU0sR0FBR0Y7SUFDdEIsTUFBTUcsTUFBTSxFQUFFO0lBQ2QsSUFBSUMsT0FBTztJQUNYLElBQUlDLHNCQUFzQjtJQUMxQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSVAsSUFBSVEsTUFBTSxFQUFFRCxJQUFLO1FBQ25DLE1BQU1FLE9BQU9ULEdBQUcsQ0FBQ08sRUFBRTtRQUNuQixJQUFJRSxTQUFTUCxNQUFNO1lBQ2pCSTtRQUNGO1FBQ0EsSUFBSUcsU0FBU04sT0FBTztZQUNsQkc7UUFDRjtRQUNBLElBQUlBLHdCQUF3QixLQUFLRyxTQUFTLEtBQUs7WUFDN0NMLElBQUlNLElBQUksQ0FBQ0wsS0FBS00sSUFBSTtZQUNsQk4sT0FBTztZQUNQO1FBQ0Y7UUFDQUEsUUFBUUk7SUFDVjtJQUNBTCxJQUFJTSxJQUFJLENBQUNMLEtBQUtNLElBQUk7SUFDbEIsT0FBT1A7QUFDVDtBQUtFLENBQ0YsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbm90YXNjYW0tcHJvdG9jb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vQG15c3RlbitiY3NAMC4xMS4xL25vZGVfbW9kdWxlcy9AbXlzdGVuL2Jjcy9kaXN0L2VzbS91dGlscy5qcz8yNDliIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGZyb21CNTgsIHRvQjU4IH0gZnJvbSBcIi4vYjU4LmpzXCI7XG5pbXBvcnQgeyBmcm9tQjY0LCB0b0I2NCB9IGZyb20gXCIuL2I2NC5qc1wiO1xuaW1wb3J0IHsgZnJvbUhFWCwgdG9IRVggfSBmcm9tIFwiLi9oZXguanNcIjtcbmZ1bmN0aW9uIGVuY29kZVN0cihkYXRhLCBlbmNvZGluZykge1xuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSBcImJhc2U1OFwiOlxuICAgICAgcmV0dXJuIHRvQjU4KGRhdGEpO1xuICAgIGNhc2UgXCJiYXNlNjRcIjpcbiAgICAgIHJldHVybiB0b0I2NChkYXRhKTtcbiAgICBjYXNlIFwiaGV4XCI6XG4gICAgICByZXR1cm4gdG9IRVgoZGF0YSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGVuY29kaW5nLCBzdXBwb3J0ZWQgdmFsdWVzIGFyZTogYmFzZTY0LCBoZXhcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlY29kZVN0cihkYXRhLCBlbmNvZGluZykge1xuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSBcImJhc2U1OFwiOlxuICAgICAgcmV0dXJuIGZyb21CNTgoZGF0YSk7XG4gICAgY2FzZSBcImJhc2U2NFwiOlxuICAgICAgcmV0dXJuIGZyb21CNjQoZGF0YSk7XG4gICAgY2FzZSBcImhleFwiOlxuICAgICAgcmV0dXJuIGZyb21IRVgoZGF0YSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGVuY29kaW5nLCBzdXBwb3J0ZWQgdmFsdWVzIGFyZTogYmFzZTY0LCBoZXhcIik7XG4gIH1cbn1cbmZ1bmN0aW9uIHNwbGl0R2VuZXJpY1BhcmFtZXRlcnMoc3RyLCBnZW5lcmljU2VwYXJhdG9ycyA9IFtcIjxcIiwgXCI+XCJdKSB7XG4gIGNvbnN0IFtsZWZ0LCByaWdodF0gPSBnZW5lcmljU2VwYXJhdG9ycztcbiAgY29uc3QgdG9rID0gW107XG4gIGxldCB3b3JkID0gXCJcIjtcbiAgbGV0IG5lc3RlZEFuZ2xlQnJhY2tldHMgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoYXIgPSBzdHJbaV07XG4gICAgaWYgKGNoYXIgPT09IGxlZnQpIHtcbiAgICAgIG5lc3RlZEFuZ2xlQnJhY2tldHMrKztcbiAgICB9XG4gICAgaWYgKGNoYXIgPT09IHJpZ2h0KSB7XG4gICAgICBuZXN0ZWRBbmdsZUJyYWNrZXRzLS07XG4gICAgfVxuICAgIGlmIChuZXN0ZWRBbmdsZUJyYWNrZXRzID09PSAwICYmIGNoYXIgPT09IFwiLFwiKSB7XG4gICAgICB0b2sucHVzaCh3b3JkLnRyaW0oKSk7XG4gICAgICB3b3JkID0gXCJcIjtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB3b3JkICs9IGNoYXI7XG4gIH1cbiAgdG9rLnB1c2god29yZC50cmltKCkpO1xuICByZXR1cm4gdG9rO1xufVxuZXhwb3J0IHtcbiAgZGVjb2RlU3RyLFxuICBlbmNvZGVTdHIsXG4gIHNwbGl0R2VuZXJpY1BhcmFtZXRlcnNcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJmcm9tQjU4IiwidG9CNTgiLCJmcm9tQjY0IiwidG9CNjQiLCJmcm9tSEVYIiwidG9IRVgiLCJlbmNvZGVTdHIiLCJkYXRhIiwiZW5jb2RpbmciLCJFcnJvciIsImRlY29kZVN0ciIsInNwbGl0R2VuZXJpY1BhcmFtZXRlcnMiLCJzdHIiLCJnZW5lcmljU2VwYXJhdG9ycyIsImxlZnQiLCJyaWdodCIsInRvayIsIndvcmQiLCJuZXN0ZWRBbmdsZUJyYWNrZXRzIiwiaSIsImxlbmd0aCIsImNoYXIiLCJwdXNoIiwidHJpbSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/writer.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/writer.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BcsWriter: () => (/* binding */ BcsWriter)\n/* harmony export */ });\n/* harmony import */ var _uleb_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./uleb.js */ \"(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/uleb.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/utils.js\");\n\n\nclass BcsWriter {\n    constructor({ size = 1024, maxSize, allocateSize = 1024 } = {}){\n        this.bytePosition = 0;\n        this.size = size;\n        this.maxSize = maxSize || size;\n        this.allocateSize = allocateSize;\n        this.dataView = new DataView(new ArrayBuffer(size));\n    }\n    ensureSizeOrGrow(bytes) {\n        const requiredSize = this.bytePosition + bytes;\n        if (requiredSize > this.size) {\n            const nextSize = Math.min(this.maxSize, this.size + this.allocateSize);\n            if (requiredSize > nextSize) {\n                throw new Error(`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${requiredSize}`);\n            }\n            this.size = nextSize;\n            const nextBuffer = new ArrayBuffer(this.size);\n            new Uint8Array(nextBuffer).set(new Uint8Array(this.dataView.buffer));\n            this.dataView = new DataView(nextBuffer);\n        }\n    }\n    /**\n   * Shift current cursor position by `bytes`.\n   *\n   * @param {Number} bytes Number of bytes to\n   * @returns {this} Self for possible chaining.\n   */ shift(bytes) {\n        this.bytePosition += bytes;\n        return this;\n    }\n    /**\n   * Write a U8 value into a buffer and shift cursor position by 1.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */ write8(value) {\n        this.ensureSizeOrGrow(1);\n        this.dataView.setUint8(this.bytePosition, Number(value));\n        return this.shift(1);\n    }\n    /**\n   * Write a U16 value into a buffer and shift cursor position by 2.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */ write16(value) {\n        this.ensureSizeOrGrow(2);\n        this.dataView.setUint16(this.bytePosition, Number(value), true);\n        return this.shift(2);\n    }\n    /**\n   * Write a U32 value into a buffer and shift cursor position by 4.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */ write32(value) {\n        this.ensureSizeOrGrow(4);\n        this.dataView.setUint32(this.bytePosition, Number(value), true);\n        return this.shift(4);\n    }\n    /**\n   * Write a U64 value into a buffer and shift cursor position by 8.\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */ write64(value) {\n        toLittleEndian(BigInt(value), 8).forEach((el)=>this.write8(el));\n        return this;\n    }\n    /**\n   * Write a U128 value into a buffer and shift cursor position by 16.\n   *\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */ write128(value) {\n        toLittleEndian(BigInt(value), 16).forEach((el)=>this.write8(el));\n        return this;\n    }\n    /**\n   * Write a U256 value into a buffer and shift cursor position by 16.\n   *\n   * @param {bigint} value Value to write.\n   * @returns {this}\n   */ write256(value) {\n        toLittleEndian(BigInt(value), 32).forEach((el)=>this.write8(el));\n        return this;\n    }\n    /**\n   * Write a ULEB value into a buffer and shift cursor position by number of bytes\n   * written.\n   * @param {Number} value Value to write.\n   * @returns {this}\n   */ writeULEB(value) {\n        (0,_uleb_js__WEBPACK_IMPORTED_MODULE_0__.ulebEncode)(value).forEach((el)=>this.write8(el));\n        return this;\n    }\n    /**\n   * Write a vector into a buffer by first writing the vector length and then calling\n   * a callback on each passed value.\n   *\n   * @param {Array<Any>} vector Array of elements to write.\n   * @param {WriteVecCb} cb Callback to call on each element of the vector.\n   * @returns {this}\n   */ writeVec(vector, cb) {\n        this.writeULEB(vector.length);\n        Array.from(vector).forEach((el, i)=>cb(this, el, i, vector.length));\n        return this;\n    }\n    /**\n   * Adds support for iterations over the object.\n   * @returns {Uint8Array}\n   */ *[Symbol.iterator]() {\n        for(let i = 0; i < this.bytePosition; i++){\n            yield this.dataView.getUint8(i);\n        }\n        return this.toBytes();\n    }\n    /**\n   * Get underlying buffer taking only value bytes (in case initial buffer size was bigger).\n   * @returns {Uint8Array} Resulting bcs.\n   */ toBytes() {\n        return new Uint8Array(this.dataView.buffer.slice(0, this.bytePosition));\n    }\n    /**\n   * Represent data as 'hex' or 'base64'\n   * @param encoding Encoding to use: 'base64' or 'hex'\n   */ toString(encoding) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.encodeStr)(this.toBytes(), encoding);\n    }\n}\nfunction toLittleEndian(bigint, size) {\n    let result = new Uint8Array(size);\n    let i = 0;\n    while(bigint > 0){\n        result[i] = Number(bigint % BigInt(256));\n        bigint = bigint / BigInt(256);\n        i += 1;\n    }\n    return result;\n}\n //# sourceMappingURL=writer.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG15c3RlbitiY3NAMC4xMS4xL25vZGVfbW9kdWxlcy9AbXlzdGVuL2Jjcy9kaXN0L2VzbS93cml0ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXVDO0FBQ0E7QUFDdkMsTUFBTUU7SUFDSkMsWUFBWSxFQUFFQyxPQUFPLElBQUksRUFBRUMsT0FBTyxFQUFFQyxlQUFlLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFFO1FBQzlELElBQUksQ0FBQ0MsWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0gsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ0MsT0FBTyxHQUFHQSxXQUFXRDtRQUMxQixJQUFJLENBQUNFLFlBQVksR0FBR0E7UUFDcEIsSUFBSSxDQUFDRSxRQUFRLEdBQUcsSUFBSUMsU0FBUyxJQUFJQyxZQUFZTjtJQUMvQztJQUNBTyxpQkFBaUJDLEtBQUssRUFBRTtRQUN0QixNQUFNQyxlQUFlLElBQUksQ0FBQ04sWUFBWSxHQUFHSztRQUN6QyxJQUFJQyxlQUFlLElBQUksQ0FBQ1QsSUFBSSxFQUFFO1lBQzVCLE1BQU1VLFdBQVdDLEtBQUtDLEdBQUcsQ0FBQyxJQUFJLENBQUNYLE9BQU8sRUFBRSxJQUFJLENBQUNELElBQUksR0FBRyxJQUFJLENBQUNFLFlBQVk7WUFDckUsSUFBSU8sZUFBZUMsVUFBVTtnQkFDM0IsTUFBTSxJQUFJRyxNQUNSLENBQUMsc0ZBQXNGLEVBQUUsSUFBSSxDQUFDYixJQUFJLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQ0MsT0FBTyxDQUFDLGlCQUFpQixFQUFFUSxhQUFhLENBQUM7WUFFbks7WUFDQSxJQUFJLENBQUNULElBQUksR0FBR1U7WUFDWixNQUFNSSxhQUFhLElBQUlSLFlBQVksSUFBSSxDQUFDTixJQUFJO1lBQzVDLElBQUllLFdBQVdELFlBQVlFLEdBQUcsQ0FBQyxJQUFJRCxXQUFXLElBQUksQ0FBQ1gsUUFBUSxDQUFDYSxNQUFNO1lBQ2xFLElBQUksQ0FBQ2Is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Q2xDLElBQUlrRCxTQUFTLElBQUluQyxXQUFXZjtJQUM1QixJQUFJeUMsSUFBSTtJQUNSLE1BQU9RLFNBQVMsRUFBRztRQUNqQkMsTUFBTSxDQUFDVCxFQUFFLEdBQUduQixPQUFPMkIsU0FBU3BCLE9BQU87UUFDbkNvQixTQUFTQSxTQUFTcEIsT0FBTztRQUN6QlksS0FBSztJQUNQO0lBQ0EsT0FBT1M7QUFDVDtBQUdFLENBQ0Ysa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbm90YXNjYW0tcHJvdG9jb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vQG15c3RlbitiY3NAMC4xMS4xL25vZGVfbW9kdWxlcy9AbXlzdGVuL2Jjcy9kaXN0L2VzbS93cml0ZXIuanM/OWZhNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1bGViRW5jb2RlIH0gZnJvbSBcIi4vdWxlYi5qc1wiO1xuaW1wb3J0IHsgZW5jb2RlU3RyIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmNsYXNzIEJjc1dyaXRlciB7XG4gIGNvbnN0cnVjdG9yKHsgc2l6ZSA9IDEwMjQsIG1heFNpemUsIGFsbG9jYXRlU2l6ZSA9IDEwMjQgfSA9IHt9KSB7XG4gICAgdGhpcy5ieXRlUG9zaXRpb24gPSAwO1xuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgdGhpcy5tYXhTaXplID0gbWF4U2l6ZSB8fCBzaXplO1xuICAgIHRoaXMuYWxsb2NhdGVTaXplID0gYWxsb2NhdGVTaXplO1xuICAgIHRoaXMuZGF0YVZpZXcgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKHNpemUpKTtcbiAgfVxuICBlbnN1cmVTaXplT3JHcm93KGJ5dGVzKSB7XG4gICAgY29uc3QgcmVxdWlyZWRTaXplID0gdGhpcy5ieXRlUG9zaXRpb24gKyBieXRlcztcbiAgICBpZiAocmVxdWlyZWRTaXplID4gdGhpcy5zaXplKSB7XG4gICAgICBjb25zdCBuZXh0U2l6ZSA9IE1hdGgubWluKHRoaXMubWF4U2l6ZSwgdGhpcy5zaXplICsgdGhpcy5hbGxvY2F0ZVNpemUpO1xuICAgICAgaWYgKHJlcXVpcmVkU2l6ZSA+IG5leHRTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQXR0ZW1wdGluZyB0byBzZXJpYWxpemUgdG8gQkNTLCBidXQgYnVmZmVyIGRvZXMgbm90IGhhdmUgZW5vdWdoIHNpemUuIEFsbG9jYXRlZCBzaXplOiAke3RoaXMuc2l6ZX0sIE1heCBzaXplOiAke3RoaXMubWF4U2l6ZX0sIFJlcXVpcmVkIHNpemU6ICR7cmVxdWlyZWRTaXplfWBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2l6ZSA9IG5leHRTaXplO1xuICAgICAgY29uc3QgbmV4dEJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcih0aGlzLnNpemUpO1xuICAgICAgbmV3IFVpbnQ4QXJyYXkobmV4dEJ1ZmZlcikuc2V0KG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YVZpZXcuYnVmZmVyKSk7XG4gICAgICB0aGlzLmRhdGFWaWV3ID0gbmV3IERhdGFWaWV3KG5leHRCdWZmZXIpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2hpZnQgY3VycmVudCBjdXJzb3IgcG9zaXRpb24gYnkgYGJ5dGVzYC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGJ5dGVzIE51bWJlciBvZiBieXRlcyB0b1xuICAgKiBAcmV0dXJucyB7dGhpc30gU2VsZiBmb3IgcG9zc2libGUgY2hhaW5pbmcuXG4gICAqL1xuICBzaGlmdChieXRlcykge1xuICAgIHRoaXMuYnl0ZVBvc2l0aW9uICs9IGJ5dGVzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIFU4IHZhbHVlIGludG8gYSBidWZmZXIgYW5kIHNoaWZ0IGN1cnNvciBwb3NpdGlvbiBieSAxLlxuICAgKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgVmFsdWUgdG8gd3JpdGUuXG4gICAqIEByZXR1cm5zIHt0aGlzfVxuICAgKi9cbiAgd3JpdGU4KHZhbHVlKSB7XG4gICAgdGhpcy5lbnN1cmVTaXplT3JHcm93KDEpO1xuICAgIHRoaXMuZGF0YVZpZXcuc2V0VWludDgodGhpcy5ieXRlUG9zaXRpb24sIE51bWJlcih2YWx1ZSkpO1xuICAgIHJldHVybiB0aGlzLnNoaWZ0KDEpO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIFUxNiB2YWx1ZSBpbnRvIGEgYnVmZmVyIGFuZCBzaGlmdCBjdXJzb3IgcG9zaXRpb24gYnkgMi5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlLlxuICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICovXG4gIHdyaXRlMTYodmFsdWUpIHtcbiAgICB0aGlzLmVuc3VyZVNpemVPckdyb3coMik7XG4gICAgdGhpcy5kYXRhVmlldy5zZXRVaW50MTYodGhpcy5ieXRlUG9zaXRpb24sIE51bWJlcih2YWx1ZSksIHRydWUpO1xuICAgIHJldHVybiB0aGlzLnNoaWZ0KDIpO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIFUzMiB2YWx1ZSBpbnRvIGEgYnVmZmVyIGFuZCBzaGlmdCBjdXJzb3IgcG9zaXRpb24gYnkgNC5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbHVlIFZhbHVlIHRvIHdyaXRlLlxuICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICovXG4gIHdyaXRlMzIodmFsdWUpIHtcbiAgICB0aGlzLmVuc3VyZVNpemVPckdyb3coNCk7XG4gICAgdGhpcy5kYXRhVmlldy5zZXRVaW50MzIodGhpcy5ieXRlUG9zaXRpb24sIE51bWJlcih2YWx1ZSksIHRydWUpO1xuICAgIHJldHVybiB0aGlzLnNoaWZ0KDQpO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIFU2NCB2YWx1ZSBpbnRvIGEgYnVmZmVyIGFuZCBzaGlmdCBjdXJzb3IgcG9zaXRpb24gYnkgOC5cbiAgICogQHBhcmFtIHtiaWdpbnR9IHZhbHVlIFZhbHVlIHRvIHdyaXRlLlxuICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICovXG4gIHdyaXRlNjQodmFsdWUpIHtcbiAgICB0b0xpdHRsZUVuZGlhbihCaWdJbnQodmFsdWUpLCA4KS5mb3JFYWNoKChlbCkgPT4gdGhpcy53cml0ZTgoZWwpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBVMTI4IHZhbHVlIGludG8gYSBidWZmZXIgYW5kIHNoaWZ0IGN1cnNvciBwb3NpdGlvbiBieSAxNi5cbiAgICpcbiAgICogQHBhcmFtIHtiaWdpbnR9IHZhbHVlIFZhbHVlIHRvIHdyaXRlLlxuICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICovXG4gIHdyaXRlMTI4KHZhbHVlKSB7XG4gICAgdG9MaXR0bGVFbmRpYW4oQmlnSW50KHZhbHVlKSwgMTYpLmZvckVhY2goKGVsKSA9PiB0aGlzLndyaXRlOChlbCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIFUyNTYgdmFsdWUgaW50byBhIGJ1ZmZlciBhbmQgc2hpZnQgY3Vyc29yIHBvc2l0aW9uIGJ5IDE2LlxuICAgKlxuICAgKiBAcGFyYW0ge2JpZ2ludH0gdmFsdWUgVmFsdWUgdG8gd3JpdGUuXG4gICAqIEByZXR1cm5zIHt0aGlzfVxuICAgKi9cbiAgd3JpdGUyNTYodmFsdWUpIHtcbiAgICB0b0xpdHRsZUVuZGlhbihCaWdJbnQodmFsdWUpLCAzMikuZm9yRWFjaCgoZWwpID0+IHRoaXMud3JpdGU4KGVsKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgVUxFQiB2YWx1ZSBpbnRvIGEgYnVmZmVyIGFuZCBzaGlmdCBjdXJzb3IgcG9zaXRpb24gYnkgbnVtYmVyIG9mIGJ5dGVzXG4gICAqIHdyaXR0ZW4uXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSBWYWx1ZSB0byB3cml0ZS5cbiAgICogQHJldHVybnMge3RoaXN9XG4gICAqL1xuICB3cml0ZVVMRUIodmFsdWUpIHtcbiAgICB1bGViRW5jb2RlKHZhbHVlKS5mb3JFYWNoKChlbCkgPT4gdGhpcy53cml0ZTgoZWwpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSB2ZWN0b3IgaW50byBhIGJ1ZmZlciBieSBmaXJzdCB3cml0aW5nIHRoZSB2ZWN0b3IgbGVuZ3RoIGFuZCB0aGVuIGNhbGxpbmdcbiAgICogYSBjYWxsYmFjayBvbiBlYWNoIHBhc3NlZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxBbnk+fSB2ZWN0b3IgQXJyYXkgb2YgZWxlbWVudHMgdG8gd3JpdGUuXG4gICAqIEBwYXJhbSB7V3JpdGVWZWNDYn0gY2IgQ2FsbGJhY2sgdG8gY2FsbCBvbiBlYWNoIGVsZW1lbnQgb2YgdGhlIHZlY3Rvci5cbiAgICogQHJldHVybnMge3RoaXN9XG4gICAqL1xuICB3cml0ZVZlYyh2ZWN0b3IsIGNiKSB7XG4gICAgdGhpcy53cml0ZVVMRUIodmVjdG9yLmxlbmd0aCk7XG4gICAgQXJyYXkuZnJvbSh2ZWN0b3IpLmZvckVhY2goKGVsLCBpKSA9PiBjYih0aGlzLCBlbCwgaSwgdmVjdG9yLmxlbmd0aCkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBBZGRzIHN1cHBvcnQgZm9yIGl0ZXJhdGlvbnMgb3ZlciB0aGUgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7VWludDhBcnJheX1cbiAgICovXG4gICpbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYnl0ZVBvc2l0aW9uOyBpKyspIHtcbiAgICAgIHlpZWxkIHRoaXMuZGF0YVZpZXcuZ2V0VWludDgoaSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRvQnl0ZXMoKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHVuZGVybHlpbmcgYnVmZmVyIHRha2luZyBvbmx5IHZhbHVlIGJ5dGVzIChpbiBjYXNlIGluaXRpYWwgYnVmZmVyIHNpemUgd2FzIGJpZ2dlcikuXG4gICAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBSZXN1bHRpbmcgYmNzLlxuICAgKi9cbiAgdG9CeXRlcygpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy5kYXRhVmlldy5idWZmZXIuc2xpY2UoMCwgdGhpcy5ieXRlUG9zaXRpb24pKTtcbiAgfVxuICAvKipcbiAgICogUmVwcmVzZW50IGRhdGEgYXMgJ2hleCcgb3IgJ2Jhc2U2NCdcbiAgICogQHBhcmFtIGVuY29kaW5nIEVuY29kaW5nIHRvIHVzZTogJ2Jhc2U2NCcgb3IgJ2hleCdcbiAgICovXG4gIHRvU3RyaW5nKGVuY29kaW5nKSB7XG4gICAgcmV0dXJuIGVuY29kZVN0cih0aGlzLnRvQnl0ZXMoKSwgZW5jb2RpbmcpO1xuICB9XG59XG5mdW5jdGlvbiB0b0xpdHRsZUVuZGlhbihiaWdpbnQsIHNpemUpIHtcbiAgbGV0IHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICBsZXQgaSA9IDA7XG4gIHdoaWxlIChiaWdpbnQgPiAwKSB7XG4gICAgcmVzdWx0W2ldID0gTnVtYmVyKGJpZ2ludCAlIEJpZ0ludCgyNTYpKTtcbiAgICBiaWdpbnQgPSBiaWdpbnQgLyBCaWdJbnQoMjU2KTtcbiAgICBpICs9IDE7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCB7XG4gIEJjc1dyaXRlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdyaXRlci5qcy5tYXBcbiJdLCJuYW1lcyI6WyJ1bGViRW5jb2RlIiwiZW5jb2RlU3RyIiwiQmNzV3JpdGVyIiwiY29uc3RydWN0b3IiLCJzaXplIiwibWF4U2l6ZSIsImFsbG9jYXRlU2l6ZSIsImJ5dGVQb3NpdGlvbiIsImRhdGFWaWV3IiwiRGF0YVZpZXciLCJBcnJheUJ1ZmZlciIsImVuc3VyZVNpemVPckdyb3ciLCJieXRlcyIsInJlcXVpcmVkU2l6ZSIsIm5leHRTaXplIiwiTWF0aCIsIm1pbiIsIkVycm9yIiwibmV4dEJ1ZmZlciIsIlVpbnQ4QXJyYXkiLCJzZXQiLCJidWZmZXIiLCJzaGlmdCIsIndyaXRlOCIsInZhbHVlIiwic2V0VWludDgiLCJOdW1iZXIiLCJ3cml0ZTE2Iiwic2V0VWludDE2Iiwid3JpdGUzMiIsInNldFVpbnQzMiIsIndyaXRlNjQiLCJ0b0xpdHRsZUVuZGlhbiIsIkJpZ0ludCIsImZvckVhY2giLCJlbCIsIndyaXRlMTI4Iiwid3JpdGUyNTYiLCJ3cml0ZVVMRUIiLCJ3cml0ZVZlYyIsInZlY3RvciIsImNiIiwibGVuZ3RoIiwiQXJyYXkiLCJmcm9tIiwiaSIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiZ2V0VWludDgiLCJ0b0J5dGVzIiwic2xpY2UiLCJ0b1N0cmluZyIsImVuY29kaW5nIiwiYmlnaW50IiwicmVzdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@mysten+bcs@0.11.1/node_modules/@mysten/bcs/dist/esm/writer.js\n");

/***/ })

};
;