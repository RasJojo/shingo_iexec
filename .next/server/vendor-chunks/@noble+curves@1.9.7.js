"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@noble+curves@1.9.7";
exports.ids = ["vendor-chunks/@noble+curves@1.9.7"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/_shortw_utils.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: () => (/* binding */ createCurve),\n/* harmony export */   getHash: () => (/* binding */ getHash)\n/* harmony export */ });\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/**\n * Utilities for short weierstrass curves, combined with noble-hashes.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n/** connects noble-curves to noble-hashes */ function getHash(hash) {\n    return {\n        hash\n    };\n}\n/** @deprecated use new `weierstrass()` and `ecdsa()` methods */ function createCurve(curveDef, defHash) {\n    const create = (hash)=>(0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_0__.weierstrass)({\n            ...curveDef,\n            hash: hash\n        });\n    return {\n        ...create(defHash),\n        create\n    };\n} //# sourceMappingURL=_shortw_utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjkuNy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vX3Nob3J0d191dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTs7O0NBR0MsR0FDRCxvRUFBb0UsR0FDWjtBQUN4RCwwQ0FBMEMsR0FDbkMsU0FBU0MsUUFBUUMsSUFBSTtJQUN4QixPQUFPO1FBQUVBO0lBQUs7QUFDbEI7QUFDQSw4REFBOEQsR0FDdkQsU0FBU0MsWUFBWUMsUUFBUSxFQUFFQyxPQUFPO0lBQ3pDLE1BQU1DLFNBQVMsQ0FBQ0osT0FBU0YscUVBQVdBLENBQUM7WUFBRSxHQUFHSSxRQUFRO1lBQUVGLE1BQU1BO1FBQUs7SUFDL0QsT0FBTztRQUFFLEdBQUdJLE9BQU9ELFFBQVE7UUFBRUM7SUFBTztBQUN4QyxFQUNBLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL25vdGFzY2FtLXByb3RvY29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bub2JsZStjdXJ2ZXNAMS45Ljcvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL19zaG9ydHdfdXRpbHMuanM/MTdjMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFV0aWxpdGllcyBmb3Igc2hvcnQgd2VpZXJzdHJhc3MgY3VydmVzLCBjb21iaW5lZCB3aXRoIG5vYmxlLWhhc2hlcy5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgd2VpZXJzdHJhc3MgfSBmcm9tIFwiLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qc1wiO1xuLyoqIGNvbm5lY3RzIG5vYmxlLWN1cnZlcyB0byBub2JsZS1oYXNoZXMgKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRIYXNoKGhhc2gpIHtcbiAgICByZXR1cm4geyBoYXNoIH07XG59XG4vKiogQGRlcHJlY2F0ZWQgdXNlIG5ldyBgd2VpZXJzdHJhc3MoKWAgYW5kIGBlY2RzYSgpYCBtZXRob2RzICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ3VydmUoY3VydmVEZWYsIGRlZkhhc2gpIHtcbiAgICBjb25zdCBjcmVhdGUgPSAoaGFzaCkgPT4gd2VpZXJzdHJhc3MoeyAuLi5jdXJ2ZURlZiwgaGFzaDogaGFzaCB9KTtcbiAgICByZXR1cm4geyAuLi5jcmVhdGUoZGVmSGFzaCksIGNyZWF0ZSB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3Nob3J0d191dGlscy5qcy5tYXAiXSwibmFtZXMiOlsid2VpZXJzdHJhc3MiLCJnZXRIYXNoIiwiaGFzaCIsImNyZWF0ZUN1cnZlIiwiY3VydmVEZWYiLCJkZWZIYXNoIiwiY3JlYXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/_shortw_utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/bls.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/bls.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bls: () => (/* binding */ bls)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/utils.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/curve.js\");\n/* harmony import */ var _hash_to_curve_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./hash-to-curve.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./weierstrass.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/**\n * BLS != BLS.\n * The file implements BLS (Boneh-Lynn-Shacham) signatures.\n * Used in both BLS (Barreto-Lynn-Scott) and BN (Barreto-Naehrig)\n * families of pairing-friendly curves.\n * Consists of two curves: G1 and G2:\n * - G1 is a subgroup of (x, y) E(Fq) over y² = x³ + 4.\n * - G2 is a subgroup of ((x₁, x₂+i), (y₁, y₂+i)) E(Fq²) over y² = x³ + 4(1 + i) where i is √-1\n * - Gt, created by bilinear (ate) pairing e(G1, G2), consists of p-th roots of unity in\n *   Fq^k where k is embedding degree. Only degree 12 is currently supported, 24 is not.\n * Pairing is used to aggregate and verify signatures.\n * There are two modes of operation:\n * - Long signatures:  X-byte keys + 2X-byte sigs (G1 keys + G2 sigs).\n * - Short signatures: 2X-byte keys + X-byte sigs (G2 keys + G1 sigs).\n * @module\n **/ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// Not used with BLS12-381 (no sequential `11` in X). Useful for other curves.\nfunction NAfDecomposition(a) {\n    const res = [];\n    // a>1 because of marker bit\n    for(; a > _1n; a >>= _1n){\n        if ((a & _1n) === _0n) res.unshift(0);\n        else if ((a & _3n) === _3n) {\n            res.unshift(-1);\n            a += _1n;\n        } else res.unshift(1);\n    }\n    return res;\n}\nfunction aNonEmpty(arr) {\n    if (!Array.isArray(arr) || arr.length === 0) throw new Error(\"expected non-empty array\");\n}\n// This should be enough for bn254, no need to export full stuff?\nfunction createBlsPairing(fields, G1, G2, params) {\n    const { Fp2, Fp12 } = fields;\n    const { twistType, ateLoopSize, xNegative, postPrecompute } = params;\n    // Applies sparse multiplication as line function\n    let lineFunction;\n    if (twistType === \"multiplicative\") {\n        lineFunction = (c0, c1, c2, f, Px, Py)=>Fp12.mul014(f, c0, Fp2.mul(c1, Px), Fp2.mul(c2, Py));\n    } else if (twistType === \"divisive\") {\n        // NOTE: it should be [c0, c1, c2], but we use different order here to reduce complexity of\n        // precompute calculations.\n        lineFunction = (c0, c1, c2, f, Px, Py)=>Fp12.mul034(f, Fp2.mul(c2, Py), Fp2.mul(c1, Px), c0);\n    } else throw new Error(\"bls: unknown twist type\");\n    const Fp2div2 = Fp2.div(Fp2.ONE, Fp2.mul(Fp2.ONE, _2n));\n    function pointDouble(ell, Rx, Ry, Rz) {\n        const t0 = Fp2.sqr(Ry); // Ry²\n        const t1 = Fp2.sqr(Rz); // Rz²\n        const t2 = Fp2.mulByB(Fp2.mul(t1, _3n)); // 3 * T1 * B\n        const t3 = Fp2.mul(t2, _3n); // 3 * T2\n        const t4 = Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(Ry, Rz)), t1), t0); // (Ry + Rz)² - T1 - T0\n        const c0 = Fp2.sub(t2, t0); // T2 - T0 (i)\n        const c1 = Fp2.mul(Fp2.sqr(Rx), _3n); // 3 * Rx²\n        const c2 = Fp2.neg(t4); // -T4 (-h)\n        ell.push([\n            c0,\n            c1,\n            c2\n        ]);\n        Rx = Fp2.mul(Fp2.mul(Fp2.mul(Fp2.sub(t0, t3), Rx), Ry), Fp2div2); // ((T0 - T3) * Rx * Ry) / 2\n        Ry = Fp2.sub(Fp2.sqr(Fp2.mul(Fp2.add(t0, t3), Fp2div2)), Fp2.mul(Fp2.sqr(t2), _3n)); // ((T0 + T3) / 2)² - 3 * T2²\n        Rz = Fp2.mul(t0, t4); // T0 * T4\n        return {\n            Rx,\n            Ry,\n            Rz\n        };\n    }\n    function pointAdd(ell, Rx, Ry, Rz, Qx, Qy) {\n        // Addition\n        const t0 = Fp2.sub(Ry, Fp2.mul(Qy, Rz)); // Ry - Qy * Rz\n        const t1 = Fp2.sub(Rx, Fp2.mul(Qx, Rz)); // Rx - Qx * Rz\n        const c0 = Fp2.sub(Fp2.mul(t0, Qx), Fp2.mul(t1, Qy)); // T0 * Qx - T1 * Qy == Ry * Qx  - Rx * Qy\n        const c1 = Fp2.neg(t0); // -T0 == Qy * Rz - Ry\n        const c2 = t1; // == Rx - Qx * Rz\n        ell.push([\n            c0,\n            c1,\n            c2\n        ]);\n        const t2 = Fp2.sqr(t1); // T1²\n        const t3 = Fp2.mul(t2, t1); // T2 * T1\n        const t4 = Fp2.mul(t2, Rx); // T2 * Rx\n        const t5 = Fp2.add(Fp2.sub(t3, Fp2.mul(t4, _2n)), Fp2.mul(Fp2.sqr(t0), Rz)); // T3 - 2 * T4 + T0² * Rz\n        Rx = Fp2.mul(t1, t5); // T1 * T5\n        Ry = Fp2.sub(Fp2.mul(Fp2.sub(t4, t5), t0), Fp2.mul(t3, Ry)); // (T4 - T5) * T0 - T3 * Ry\n        Rz = Fp2.mul(Rz, t3); // Rz * T3\n        return {\n            Rx,\n            Ry,\n            Rz\n        };\n    }\n    // Pre-compute coefficients for sparse multiplication\n    // Point addition and point double calculations is reused for coefficients\n    // pointAdd happens only if bit set, so wNAF is reasonable. Unfortunately we cannot combine\n    // add + double in windowed precomputes here, otherwise it would be single op (since X is static)\n    const ATE_NAF = NAfDecomposition(ateLoopSize);\n    const calcPairingPrecomputes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memoized)((point)=>{\n        const p = point;\n        const { x, y } = p.toAffine();\n        // prettier-ignore\n        const Qx = x, Qy = y, negQy = Fp2.neg(y);\n        // prettier-ignore\n        let Rx = Qx, Ry = Qy, Rz = Fp2.ONE;\n        const ell = [];\n        for (const bit of ATE_NAF){\n            const cur = [];\n            ({ Rx, Ry, Rz } = pointDouble(cur, Rx, Ry, Rz));\n            if (bit) ({ Rx, Ry, Rz } = pointAdd(cur, Rx, Ry, Rz, Qx, bit === -1 ? negQy : Qy));\n            ell.push(cur);\n        }\n        if (postPrecompute) {\n            const last = ell[ell.length - 1];\n            postPrecompute(Rx, Ry, Rz, Qx, Qy, pointAdd.bind(null, last));\n        }\n        return ell;\n    });\n    function millerLoopBatch(pairs, withFinalExponent = false) {\n        let f12 = Fp12.ONE;\n        if (pairs.length) {\n            const ellLen = pairs[0][0].length;\n            for(let i = 0; i < ellLen; i++){\n                f12 = Fp12.sqr(f12); // This allows us to do sqr only one time for all pairings\n                // NOTE: we apply multiple pairings in parallel here\n                for (const [ell, Px, Py] of pairs){\n                    for (const [c0, c1, c2] of ell[i])f12 = lineFunction(c0, c1, c2, f12, Px, Py);\n                }\n            }\n        }\n        if (xNegative) f12 = Fp12.conjugate(f12);\n        return withFinalExponent ? Fp12.finalExponentiate(f12) : f12;\n    }\n    // Calculates product of multiple pairings\n    // This up to x2 faster than just `map(({g1, g2})=>pairing({g1,g2}))`\n    function pairingBatch(pairs, withFinalExponent = true) {\n        const res = [];\n        // Cache precomputed toAffine for all points\n        (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.normalizeZ)(G1, pairs.map(({ g1 })=>g1));\n        (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.normalizeZ)(G2, pairs.map(({ g2 })=>g2));\n        for (const { g1, g2 } of pairs){\n            if (g1.is0() || g2.is0()) throw new Error(\"pairing is not available for ZERO point\");\n            // This uses toAffine inside\n            g1.assertValidity();\n            g2.assertValidity();\n            const Qa = g1.toAffine();\n            res.push([\n                calcPairingPrecomputes(g2),\n                Qa.x,\n                Qa.y\n            ]);\n        }\n        return millerLoopBatch(res, withFinalExponent);\n    }\n    // Calculates bilinear pairing\n    function pairing(Q, P, withFinalExponent = true) {\n        return pairingBatch([\n            {\n                g1: Q,\n                g2: P\n            }\n        ], withFinalExponent);\n    }\n    return {\n        Fp12,\n        millerLoopBatch,\n        pairing,\n        pairingBatch,\n        calcPairingPrecomputes\n    };\n}\nfunction createBlsSig(blsPairing, PubCurve, SigCurve, SignatureCoder, isSigG1) {\n    const { Fp12, pairingBatch } = blsPairing;\n    function normPub(point) {\n        return point instanceof PubCurve.Point ? point : PubCurve.Point.fromHex(point);\n    }\n    function normSig(point) {\n        return point instanceof SigCurve.Point ? point : SigCurve.Point.fromHex(point);\n    }\n    function amsg(m) {\n        if (!(m instanceof SigCurve.Point)) throw new Error(`expected valid message hashed to ${!isSigG1 ? \"G2\" : \"G1\"} curve`);\n        return m;\n    }\n    // What matters here is what point pairing API accepts as G1 or G2, not actual size or names\n    const pair = !isSigG1 ? (a, b)=>({\n            g1: a,\n            g2: b\n        }) : (a, b)=>({\n            g1: b,\n            g2: a\n        });\n    return {\n        // P = pk x G\n        getPublicKey (secretKey) {\n            // TODO: replace with\n            // const sec = PubCurve.Point.Fn.fromBytes(secretKey);\n            const sec = (0,_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__._normFnElement)(PubCurve.Point.Fn, secretKey);\n            return PubCurve.Point.BASE.multiply(sec);\n        },\n        // S = pk x H(m)\n        sign (message, secretKey, unusedArg) {\n            if (unusedArg != null) throw new Error(\"sign() expects 2 arguments\");\n            // TODO: replace with\n            // PubCurve.Point.Fn.fromBytes(secretKey)\n            const sec = (0,_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__._normFnElement)(PubCurve.Point.Fn, secretKey);\n            amsg(message).assertValidity();\n            return message.multiply(sec);\n        },\n        // Checks if pairing of public key & hash is equal to pairing of generator & signature.\n        // e(P, H(m)) == e(G, S)\n        // e(S, G) == e(H(m), P)\n        verify (signature, message, publicKey, unusedArg) {\n            if (unusedArg != null) throw new Error(\"verify() expects 3 arguments\");\n            signature = normSig(signature);\n            publicKey = normPub(publicKey);\n            const P = publicKey.negate();\n            const G = PubCurve.Point.BASE;\n            const Hm = amsg(message);\n            const S = signature;\n            // This code was changed in 1.9.x:\n            // Before it was G.negate() in G2, now it's always pubKey.negate\n            // e(P, -Q)===e(-P, Q)==e(P, Q)^-1. Negate can be done anywhere (as long it is done once per pair).\n            // We just moving sign, but since pairing is multiplicative, we doing X * X^-1 = 1\n            const exp = pairingBatch([\n                pair(P, Hm),\n                pair(G, S)\n            ]);\n            return Fp12.eql(exp, Fp12.ONE);\n        },\n        // https://ethresear.ch/t/fast-verification-of-multiple-bls-signatures/5407\n        // e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))\n        // TODO: maybe `{message: G2Hex, publicKey: G1Hex}[]` instead?\n        verifyBatch (signature, messages, publicKeys) {\n            aNonEmpty(messages);\n            if (publicKeys.length !== messages.length) throw new Error(\"amount of public keys and messages should be equal\");\n            const sig = normSig(signature);\n            const nMessages = messages;\n            const nPublicKeys = publicKeys.map(normPub);\n            // NOTE: this works only for exact same object\n            const messagePubKeyMap = new Map();\n            for(let i = 0; i < nPublicKeys.length; i++){\n                const pub = nPublicKeys[i];\n                const msg = nMessages[i];\n                let keys = messagePubKeyMap.get(msg);\n                if (keys === undefined) {\n                    keys = [];\n                    messagePubKeyMap.set(msg, keys);\n                }\n                keys.push(pub);\n            }\n            const paired = [];\n            const G = PubCurve.Point.BASE;\n            try {\n                for (const [msg, keys] of messagePubKeyMap){\n                    const groupPublicKey = keys.reduce((acc, msg)=>acc.add(msg));\n                    paired.push(pair(groupPublicKey, msg));\n                }\n                paired.push(pair(G.negate(), sig));\n                return Fp12.eql(pairingBatch(paired), Fp12.ONE);\n            } catch  {\n                return false;\n            }\n        },\n        // Adds a bunch of public key points together.\n        // pk1 + pk2 + pk3 = pkA\n        aggregatePublicKeys (publicKeys) {\n            aNonEmpty(publicKeys);\n            publicKeys = publicKeys.map((pub)=>normPub(pub));\n            const agg = publicKeys.reduce((sum, p)=>sum.add(p), PubCurve.Point.ZERO);\n            agg.assertValidity();\n            return agg;\n        },\n        // Adds a bunch of signature points together.\n        // pk1 + pk2 + pk3 = pkA\n        aggregateSignatures (signatures) {\n            aNonEmpty(signatures);\n            signatures = signatures.map((sig)=>normSig(sig));\n            const agg = signatures.reduce((sum, s)=>sum.add(s), SigCurve.Point.ZERO);\n            agg.assertValidity();\n            return agg;\n        },\n        hash (messageBytes, DST) {\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.abytes)(messageBytes);\n            const opts = DST ? {\n                DST\n            } : undefined;\n            return SigCurve.hashToCurve(messageBytes, opts);\n        },\n        Signature: SignatureCoder\n    };\n}\n// G1_Point: ProjConstructor<bigint>, G2_Point: ProjConstructor<Fp2>,\nfunction bls(CURVE) {\n    // Fields are specific for curve, so for now we'll need to pass them with opts\n    const { Fp, Fr, Fp2, Fp6, Fp12 } = CURVE.fields;\n    // Point on G1 curve: (x, y)\n    const G1_ = (0,_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrassPoints)(CURVE.G1);\n    const G1 = Object.assign(G1_, (0,_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_4__.createHasher)(G1_.Point, CURVE.G1.mapToCurve, {\n        ...CURVE.htfDefaults,\n        ...CURVE.G1.htfDefaults\n    }));\n    // Point on G2 curve (complex numbers): (x₁, x₂+i), (y₁, y₂+i)\n    const G2_ = (0,_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrassPoints)(CURVE.G2);\n    const G2 = Object.assign(G2_, (0,_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_4__.createHasher)(G2_.Point, CURVE.G2.mapToCurve, {\n        ...CURVE.htfDefaults,\n        ...CURVE.G2.htfDefaults\n    }));\n    const pairingRes = createBlsPairing(CURVE.fields, G1.Point, G2.Point, {\n        ...CURVE.params,\n        postPrecompute: CURVE.postPrecompute\n    });\n    const { millerLoopBatch, pairing, pairingBatch, calcPairingPrecomputes } = pairingRes;\n    const longSignatures = createBlsSig(pairingRes, G1, G2, CURVE.G2.Signature, false);\n    const shortSignatures = createBlsSig(pairingRes, G2, G1, CURVE.G1.ShortSignature, true);\n    const rand = CURVE.randomBytes || _utils_js__WEBPACK_IMPORTED_MODULE_3__.randomBytes;\n    const randomSecretKey = ()=>{\n        const length = (0,_modular_js__WEBPACK_IMPORTED_MODULE_5__.getMinHashLength)(Fr.ORDER);\n        return (0,_modular_js__WEBPACK_IMPORTED_MODULE_5__.mapHashToField)(rand(length), Fr.ORDER);\n    };\n    const utils = {\n        randomSecretKey,\n        randomPrivateKey: randomSecretKey,\n        calcPairingPrecomputes\n    };\n    const { ShortSignature } = CURVE.G1;\n    const { Signature } = CURVE.G2;\n    function normP1Hash(point, htfOpts) {\n        return point instanceof G1.Point ? point : shortSignatures.hash((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"point\", point), htfOpts?.DST);\n    }\n    function normP2Hash(point, htfOpts) {\n        return point instanceof G2.Point ? point : longSignatures.hash((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"point\", point), htfOpts?.DST);\n    }\n    function getPublicKey(privateKey) {\n        return longSignatures.getPublicKey(privateKey).toBytes(true);\n    }\n    function getPublicKeyForShortSignatures(privateKey) {\n        return shortSignatures.getPublicKey(privateKey).toBytes(true);\n    }\n    function sign(message, privateKey, htfOpts) {\n        const Hm = normP2Hash(message, htfOpts);\n        const S = longSignatures.sign(Hm, privateKey);\n        return message instanceof G2.Point ? S : Signature.toBytes(S);\n    }\n    function signShortSignature(message, privateKey, htfOpts) {\n        const Hm = normP1Hash(message, htfOpts);\n        const S = shortSignatures.sign(Hm, privateKey);\n        return message instanceof G1.Point ? S : ShortSignature.toBytes(S);\n    }\n    function verify(signature, message, publicKey, htfOpts) {\n        const Hm = normP2Hash(message, htfOpts);\n        return longSignatures.verify(signature, Hm, publicKey);\n    }\n    function verifyShortSignature(signature, message, publicKey, htfOpts) {\n        const Hm = normP1Hash(message, htfOpts);\n        return shortSignatures.verify(signature, Hm, publicKey);\n    }\n    function aggregatePublicKeys(publicKeys) {\n        const agg = longSignatures.aggregatePublicKeys(publicKeys);\n        return publicKeys[0] instanceof G1.Point ? agg : agg.toBytes(true);\n    }\n    function aggregateSignatures(signatures) {\n        const agg = longSignatures.aggregateSignatures(signatures);\n        return signatures[0] instanceof G2.Point ? agg : Signature.toBytes(agg);\n    }\n    function aggregateShortSignatures(signatures) {\n        const agg = shortSignatures.aggregateSignatures(signatures);\n        return signatures[0] instanceof G1.Point ? agg : ShortSignature.toBytes(agg);\n    }\n    function verifyBatch(signature, messages, publicKeys, htfOpts) {\n        const Hm = messages.map((m)=>normP2Hash(m, htfOpts));\n        return longSignatures.verifyBatch(signature, Hm, publicKeys);\n    }\n    G1.Point.BASE.precompute(4);\n    return {\n        longSignatures,\n        shortSignatures,\n        millerLoopBatch,\n        pairing,\n        pairingBatch,\n        verifyBatch,\n        fields: {\n            Fr,\n            Fp,\n            Fp2,\n            Fp6,\n            Fp12\n        },\n        params: {\n            ateLoopSize: CURVE.params.ateLoopSize,\n            twistType: CURVE.params.twistType,\n            // deprecated\n            r: CURVE.params.r,\n            G1b: CURVE.G1.b,\n            G2b: CURVE.G2.b\n        },\n        utils,\n        // deprecated\n        getPublicKey,\n        getPublicKeyForShortSignatures,\n        sign,\n        signShortSignature,\n        verify,\n        verifyShortSignature,\n        aggregatePublicKeys,\n        aggregateSignatures,\n        aggregateShortSignatures,\n        G1,\n        G2,\n        Signature,\n        ShortSignature\n    };\n} //# sourceMappingURL=bls.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjkuNy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvYmxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7O0VBZUUsR0FDRixvRUFBb0UsR0FDTTtBQUNsQztBQUNXO0FBQ2E7QUFDTTtBQUN0RSxrQkFBa0I7QUFDbEIsTUFBTVUsTUFBTUMsT0FBTyxJQUFJQyxNQUFNRCxPQUFPLElBQUlFLE1BQU1GLE9BQU8sSUFBSUcsTUFBTUgsT0FBTztBQUN0RSw4RUFBOEU7QUFDOUUsU0FBU0ksaUJBQWlCQyxDQUFDO0lBQ3ZCLE1BQU1DLE1BQU0sRUFBRTtJQUNkLDRCQUE0QjtJQUM1QixNQUFPRCxJQUFJSixLQUFLSSxNQUFNSixJQUFLO1FBQ3ZCLElBQUksQ0FBQ0ksSUFBSUosR0FBRSxNQUFPRixLQUNkTyxJQUFJQyxPQUFPLENBQUM7YUFDWCxJQUFJLENBQUNGLElBQUlGLEdBQUUsTUFBT0EsS0FBSztZQUN4QkcsSUFBSUMsT0FBTyxDQUFDLENBQUM7WUFDYkYsS0FBS0o7UUFDVCxPQUVJSyxJQUFJQyxPQUFPLENBQUM7SUFDcEI7SUFDQSxPQUFPRDtBQUNYO0FBQ0EsU0FBU0UsVUFBVUMsR0FBRztJQUNsQixJQUFJLENBQUNDLE1BQU1DLE9BQU8sQ0FBQ0YsUUFBUUEsSUFBSUcsTUFBTSxLQUFLLEdBQ3RDLE1BQU0sSUFBSUMsTUFBTTtBQUN4QjtBQUNBLGlFQUFpRTtBQUNqRSxTQUFTQyxpQkFBaUJDLE1BQU0sRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLE1BQU07SUFDNUMsTUFBTSxFQUFFQyxHQUFHLEVBQUVDLElBQUksRUFBRSxHQUFHTDtJQUN0QixNQUFNLEVBQUVNLFNBQVMsRUFBRUMsV0FBVyxFQUFFQyxTQUFTLEVBQUVDLGNBQWMsRUFBRSxHQUFHTjtJQUM5RCxpREFBaUQ7SUFDakQsSUFBSU87SUFDSixJQUFJSixj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QUNBMEM7UUFDQXpHLFFBQVE7WUFDSjJJO1lBQ0FEO1lBQ0F0STtZQUNBd0k7WUFDQXZJO1FBQ0o7UUFDQUYsUUFBUTtZQUNKSSxhQUFha0ksTUFBTXRJLE1BQU0sQ0FBQ0ksV0FBVztZQUNyQ0QsV0FBV21JLE1BQU10SSxNQUFNLENBQUNHLFNBQVM7WUFDakMsYUFBYTtZQUNiZ0ssR0FBRzdCLE1BQU10SSxNQUFNLENBQUNtSyxDQUFDO1lBQ2pCQyxLQUFLOUIsTUFBTXhJLEVBQUUsQ0FBQ3FGLENBQUM7WUFDZmtGLEtBQUsvQixNQUFNdkksRUFBRSxDQUFDb0YsQ0FBQztRQUNuQjtRQUNBb0U7UUFDQSxhQUFhO1FBQ2JuRTtRQUNBMEU7UUFDQXBFO1FBQ0FxRTtRQUNBbEU7UUFDQW1FO1FBQ0F4QztRQUNBSTtRQUNBcUM7UUFDQW5LO1FBQ0FDO1FBQ0FxSTtRQUNBZTtJQUNKO0FBQ0osRUFDQSwrQkFBK0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3Rhc2NhbS1wcm90b2NvbC8uL25vZGVfbW9kdWxlcy8ucG5wbS9Abm9ibGUrY3VydmVzQDEuOS43L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9ibHMuanM/ODRjZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEJMUyAhPSBCTFMuXG4gKiBUaGUgZmlsZSBpbXBsZW1lbnRzIEJMUyAoQm9uZWgtTHlubi1TaGFjaGFtKSBzaWduYXR1cmVzLlxuICogVXNlZCBpbiBib3RoIEJMUyAoQmFycmV0by1MeW5uLVNjb3R0KSBhbmQgQk4gKEJhcnJldG8tTmFlaHJpZylcbiAqIGZhbWlsaWVzIG9mIHBhaXJpbmctZnJpZW5kbHkgY3VydmVzLlxuICogQ29uc2lzdHMgb2YgdHdvIGN1cnZlczogRzEgYW5kIEcyOlxuICogLSBHMSBpcyBhIHN1Ymdyb3VwIG9mICh4LCB5KSBFKEZxKSBvdmVyIHnCsiA9IHjCsyArIDQuXG4gKiAtIEcyIGlzIGEgc3ViZ3JvdXAgb2YgKCh44oKBLCB44oKCK2kpLCAoeeKCgSwgeeKCgitpKSkgRShGccKyKSBvdmVyIHnCsiA9IHjCsyArIDQoMSArIGkpIHdoZXJlIGkgaXMg4oiaLTFcbiAqIC0gR3QsIGNyZWF0ZWQgYnkgYmlsaW5lYXIgKGF0ZSkgcGFpcmluZyBlKEcxLCBHMiksIGNvbnNpc3RzIG9mIHAtdGggcm9vdHMgb2YgdW5pdHkgaW5cbiAqICAgRnFeayB3aGVyZSBrIGlzIGVtYmVkZGluZyBkZWdyZWUuIE9ubHkgZGVncmVlIDEyIGlzIGN1cnJlbnRseSBzdXBwb3J0ZWQsIDI0IGlzIG5vdC5cbiAqIFBhaXJpbmcgaXMgdXNlZCB0byBhZ2dyZWdhdGUgYW5kIHZlcmlmeSBzaWduYXR1cmVzLlxuICogVGhlcmUgYXJlIHR3byBtb2RlcyBvZiBvcGVyYXRpb246XG4gKiAtIExvbmcgc2lnbmF0dXJlczogIFgtYnl0ZSBrZXlzICsgMlgtYnl0ZSBzaWdzIChHMSBrZXlzICsgRzIgc2lncykuXG4gKiAtIFNob3J0IHNpZ25hdHVyZXM6IDJYLWJ5dGUga2V5cyArIFgtYnl0ZSBzaWdzIChHMiBrZXlzICsgRzEgc2lncykuXG4gKiBAbW9kdWxlXG4gKiovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBhYnl0ZXMsIGVuc3VyZUJ5dGVzLCBtZW1vaXplZCwgcmFuZG9tQnl0ZXMsIH0gZnJvbSBcIi4uL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBub3JtYWxpemVaIH0gZnJvbSBcIi4vY3VydmUuanNcIjtcbmltcG9ydCB7IGNyZWF0ZUhhc2hlciwgfSBmcm9tIFwiLi9oYXNoLXRvLWN1cnZlLmpzXCI7XG5pbXBvcnQgeyBnZXRNaW5IYXNoTGVuZ3RoLCBtYXBIYXNoVG9GaWVsZCB9IGZyb20gXCIuL21vZHVsYXIuanNcIjtcbmltcG9ydCB7IF9ub3JtRm5FbGVtZW50LCB3ZWllcnN0cmFzc1BvaW50cywgfSBmcm9tIFwiLi93ZWllcnN0cmFzcy5qc1wiO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gQmlnSW50KDIpLCBfM24gPSBCaWdJbnQoMyk7XG4vLyBOb3QgdXNlZCB3aXRoIEJMUzEyLTM4MSAobm8gc2VxdWVudGlhbCBgMTFgIGluIFgpLiBVc2VmdWwgZm9yIG90aGVyIGN1cnZlcy5cbmZ1bmN0aW9uIE5BZkRlY29tcG9zaXRpb24oYSkge1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIC8vIGE+MSBiZWNhdXNlIG9mIG1hcmtlciBiaXRcbiAgICBmb3IgKDsgYSA+IF8xbjsgYSA+Pj0gXzFuKSB7XG4gICAgICAgIGlmICgoYSAmIF8xbikgPT09IF8wbilcbiAgICAgICAgICAgIHJlcy51bnNoaWZ0KDApO1xuICAgICAgICBlbHNlIGlmICgoYSAmIF8zbikgPT09IF8zbikge1xuICAgICAgICAgICAgcmVzLnVuc2hpZnQoLTEpO1xuICAgICAgICAgICAgYSArPSBfMW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmVzLnVuc2hpZnQoMSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBhTm9uRW1wdHkoYXJyKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycikgfHwgYXJyLmxlbmd0aCA9PT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBub24tZW1wdHkgYXJyYXknKTtcbn1cbi8vIFRoaXMgc2hvdWxkIGJlIGVub3VnaCBmb3IgYm4yNTQsIG5vIG5lZWQgdG8gZXhwb3J0IGZ1bGwgc3R1ZmY/XG5mdW5jdGlvbiBjcmVhdGVCbHNQYWlyaW5nKGZpZWxkcywgRzEsIEcyLCBwYXJhbXMpIHtcbiAgICBjb25zdCB7IEZwMiwgRnAxMiB9ID0gZmllbGRzO1xuICAgIGNvbnN0IHsgdHdpc3RUeXBlLCBhdGVMb29wU2l6ZSwgeE5lZ2F0aXZlLCBwb3N0UHJlY29tcHV0ZSB9ID0gcGFyYW1zO1xuICAgIC8vIEFwcGxpZXMgc3BhcnNlIG11bHRpcGxpY2F0aW9uIGFzIGxpbmUgZnVuY3Rpb25cbiAgICBsZXQgbGluZUZ1bmN0aW9uO1xuICAgIGlmICh0d2lzdFR5cGUgPT09ICdtdWx0aXBsaWNhdGl2ZScpIHtcbiAgICAgICAgbGluZUZ1bmN0aW9uID0gKGMwLCBjMSwgYzIsIGYsIFB4LCBQeSkgPT4gRnAxMi5tdWwwMTQoZiwgYzAsIEZwMi5tdWwoYzEsIFB4KSwgRnAyLm11bChjMiwgUHkpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHdpc3RUeXBlID09PSAnZGl2aXNpdmUnKSB7XG4gICAgICAgIC8vIE5PVEU6IGl0IHNob3VsZCBiZSBbYzAsIGMxLCBjMl0sIGJ1dCB3ZSB1c2UgZGlmZmVyZW50IG9yZGVyIGhlcmUgdG8gcmVkdWNlIGNvbXBsZXhpdHkgb2ZcbiAgICAgICAgLy8gcHJlY29tcHV0ZSBjYWxjdWxhdGlvbnMuXG4gICAgICAgIGxpbmVGdW5jdGlvbiA9IChjMCwgYzEsIGMyLCBmLCBQeCwgUHkpID0+IEZwMTIubXVsMDM0KGYsIEZwMi5tdWwoYzIsIFB5KSwgRnAyLm11bChjMSwgUHgpLCBjMCk7XG4gICAgfVxuICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdibHM6IHVua25vd24gdHdpc3QgdHlwZScpO1xuICAgIGNvbnN0IEZwMmRpdjIgPSBGcDIuZGl2KEZwMi5PTkUsIEZwMi5tdWwoRnAyLk9ORSwgXzJuKSk7XG4gICAgZnVuY3Rpb24gcG9pbnREb3VibGUoZWxsLCBSeCwgUnksIFJ6KSB7XG4gICAgICAgIGNvbnN0IHQwID0gRnAyLnNxcihSeSk7IC8vIFJ5wrJcbiAgICAgICAgY29uc3QgdDEgPSBGcDIuc3FyKFJ6KTsgLy8gUnrCslxuICAgICAgICBjb25zdCB0MiA9IEZwMi5tdWxCeUIoRnAyLm11bCh0MSwgXzNuKSk7IC8vIDMgKiBUMSAqIEJcbiAgICAgICAgY29uc3QgdDMgPSBGcDIubXVsKHQyLCBfM24pOyAvLyAzICogVDJcbiAgICAgICAgY29uc3QgdDQgPSBGcDIuc3ViKEZwMi5zdWIoRnAyLnNxcihGcDIuYWRkKFJ5LCBSeikpLCB0MSksIHQwKTsgLy8gKFJ5ICsgUnopwrIgLSBUMSAtIFQwXG4gICAgICAgIGNvbnN0IGMwID0gRnAyLnN1Yih0MiwgdDApOyAvLyBUMiAtIFQwIChpKVxuICAgICAgICBjb25zdCBjMSA9IEZwMi5tdWwoRnAyLnNxcihSeCksIF8zbik7IC8vIDMgKiBSeMKyXG4gICAgICAgIGNvbnN0IGMyID0gRnAyLm5lZyh0NCk7IC8vIC1UNCAoLWgpXG4gICAgICAgIGVsbC5wdXNoKFtjMCwgYzEsIGMyXSk7XG4gICAgICAgIFJ4ID0gRnAyLm11bChGcDIubXVsKEZwMi5tdWwoRnAyLnN1Yih0MCwgdDMpLCBSeCksIFJ5KSwgRnAyZGl2Mik7IC8vICgoVDAgLSBUMykgKiBSeCAqIFJ5KSAvIDJcbiAgICAgICAgUnkgPSBGcDIuc3ViKEZwMi5zcXIoRnAyLm11bChGcDIuYWRkKHQwLCB0MyksIEZwMmRpdjIpKSwgRnAyLm11bChGcDIuc3FyKHQyKSwgXzNuKSk7IC8vICgoVDAgKyBUMykgLyAyKcKyIC0gMyAqIFQywrJcbiAgICAgICAgUnogPSBGcDIubXVsKHQwLCB0NCk7IC8vIFQwICogVDRcbiAgICAgICAgcmV0dXJuIHsgUngsIFJ5LCBSeiB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwb2ludEFkZChlbGwsIFJ4LCBSeSwgUnosIFF4LCBReSkge1xuICAgICAgICAvLyBBZGRpdGlvblxuICAgICAgICBjb25zdCB0MCA9IEZwMi5zdWIoUnksIEZwMi5tdWwoUXksIFJ6KSk7IC8vIFJ5IC0gUXkgKiBSelxuICAgICAgICBjb25zdCB0MSA9IEZwMi5zdWIoUngsIEZwMi5tdWwoUXgsIFJ6KSk7IC8vIFJ4IC0gUXggKiBSelxuICAgICAgICBjb25zdCBjMCA9IEZwMi5zdWIoRnAyLm11bCh0MCwgUXgpLCBGcDIubXVsKHQxLCBReSkpOyAvLyBUMCAqIFF4IC0gVDEgKiBReSA9PSBSeSAqIFF4ICAtIFJ4ICogUXlcbiAgICAgICAgY29uc3QgYzEgPSBGcDIubmVnKHQwKTsgLy8gLVQwID09IFF5ICogUnogLSBSeVxuICAgICAgICBjb25zdCBjMiA9IHQxOyAvLyA9PSBSeCAtIFF4ICogUnpcbiAgICAgICAgZWxsLnB1c2goW2MwLCBjMSwgYzJdKTtcbiAgICAgICAgY29uc3QgdDIgPSBGcDIuc3FyKHQxKTsgLy8gVDHCslxuICAgICAgICBjb25zdCB0MyA9IEZwMi5tdWwodDIsIHQxKTsgLy8gVDIgKiBUMVxuICAgICAgICBjb25zdCB0NCA9IEZwMi5tdWwodDIsIFJ4KTsgLy8gVDIgKiBSeFxuICAgICAgICBjb25zdCB0NSA9IEZwMi5hZGQoRnAyLnN1Yih0MywgRnAyLm11bCh0NCwgXzJuKSksIEZwMi5tdWwoRnAyLnNxcih0MCksIFJ6KSk7IC8vIFQzIC0gMiAqIFQ0ICsgVDDCsiAqIFJ6XG4gICAgICAgIFJ4ID0gRnAyLm11bCh0MSwgdDUpOyAvLyBUMSAqIFQ1XG4gICAgICAgIFJ5ID0gRnAyLnN1YihGcDIubXVsKEZwMi5zdWIodDQsIHQ1KSwgdDApLCBGcDIubXVsKHQzLCBSeSkpOyAvLyAoVDQgLSBUNSkgKiBUMCAtIFQzICogUnlcbiAgICAgICAgUnogPSBGcDIubXVsKFJ6LCB0Myk7IC8vIFJ6ICogVDNcbiAgICAgICAgcmV0dXJuIHsgUngsIFJ5LCBSeiB9O1xuICAgIH1cbiAgICAvLyBQcmUtY29tcHV0ZSBjb2VmZmljaWVudHMgZm9yIHNwYXJzZSBtdWx0aXBsaWNhdGlvblxuICAgIC8vIFBvaW50IGFkZGl0aW9uIGFuZCBwb2ludCBkb3VibGUgY2FsY3VsYXRpb25zIGlzIHJldXNlZCBmb3IgY29lZmZpY2llbnRzXG4gICAgLy8gcG9pbnRBZGQgaGFwcGVucyBvbmx5IGlmIGJpdCBzZXQsIHNvIHdOQUYgaXMgcmVhc29uYWJsZS4gVW5mb3J0dW5hdGVseSB3ZSBjYW5ub3QgY29tYmluZVxuICAgIC8vIGFkZCArIGRvdWJsZSBpbiB3aW5kb3dlZCBwcmVjb21wdXRlcyBoZXJlLCBvdGhlcndpc2UgaXQgd291bGQgYmUgc2luZ2xlIG9wIChzaW5jZSBYIGlzIHN0YXRpYylcbiAgICBjb25zdCBBVEVfTkFGID0gTkFmRGVjb21wb3NpdGlvbihhdGVMb29wU2l6ZSk7XG4gICAgY29uc3QgY2FsY1BhaXJpbmdQcmVjb21wdXRlcyA9IG1lbW9pemVkKChwb2ludCkgPT4ge1xuICAgICAgICBjb25zdCBwID0gcG9pbnQ7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcC50b0FmZmluZSgpO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgY29uc3QgUXggPSB4LCBReSA9IHksIG5lZ1F5ID0gRnAyLm5lZyh5KTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGxldCBSeCA9IFF4LCBSeSA9IFF5LCBSeiA9IEZwMi5PTkU7XG4gICAgICAgIGNvbnN0IGVsbCA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGJpdCBvZiBBVEVfTkFGKSB7XG4gICAgICAgICAgICBjb25zdCBjdXIgPSBbXTtcbiAgICAgICAgICAgICh7IFJ4LCBSeSwgUnogfSA9IHBvaW50RG91YmxlKGN1ciwgUngsIFJ5LCBSeikpO1xuICAgICAgICAgICAgaWYgKGJpdClcbiAgICAgICAgICAgICAgICAoeyBSeCwgUnksIFJ6IH0gPSBwb2ludEFkZChjdXIsIFJ4LCBSeSwgUnosIFF4LCBiaXQgPT09IC0xID8gbmVnUXkgOiBReSkpO1xuICAgICAgICAgICAgZWxsLnB1c2goY3VyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zdFByZWNvbXB1dGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3QgPSBlbGxbZWxsLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgcG9zdFByZWNvbXB1dGUoUngsIFJ5LCBSeiwgUXgsIFF5LCBwb2ludEFkZC5iaW5kKG51bGwsIGxhc3QpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxsO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIG1pbGxlckxvb3BCYXRjaChwYWlycywgd2l0aEZpbmFsRXhwb25lbnQgPSBmYWxzZSkge1xuICAgICAgICBsZXQgZjEyID0gRnAxMi5PTkU7XG4gICAgICAgIGlmIChwYWlycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsbExlbiA9IHBhaXJzWzBdWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxsTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmMTIgPSBGcDEyLnNxcihmMTIpOyAvLyBUaGlzIGFsbG93cyB1cyB0byBkbyBzcXIgb25seSBvbmUgdGltZSBmb3IgYWxsIHBhaXJpbmdzXG4gICAgICAgICAgICAgICAgLy8gTk9URTogd2UgYXBwbHkgbXVsdGlwbGUgcGFpcmluZ3MgaW4gcGFyYWxsZWwgaGVyZVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2VsbCwgUHgsIFB5XSBvZiBwYWlycykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtjMCwgYzEsIGMyXSBvZiBlbGxbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICBmMTIgPSBsaW5lRnVuY3Rpb24oYzAsIGMxLCBjMiwgZjEyLCBQeCwgUHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoeE5lZ2F0aXZlKVxuICAgICAgICAgICAgZjEyID0gRnAxMi5jb25qdWdhdGUoZjEyKTtcbiAgICAgICAgcmV0dXJuIHdpdGhGaW5hbEV4cG9uZW50ID8gRnAxMi5maW5hbEV4cG9uZW50aWF0ZShmMTIpIDogZjEyO1xuICAgIH1cbiAgICAvLyBDYWxjdWxhdGVzIHByb2R1Y3Qgb2YgbXVsdGlwbGUgcGFpcmluZ3NcbiAgICAvLyBUaGlzIHVwIHRvIHgyIGZhc3RlciB0aGFuIGp1c3QgYG1hcCgoe2cxLCBnMn0pPT5wYWlyaW5nKHtnMSxnMn0pKWBcbiAgICBmdW5jdGlvbiBwYWlyaW5nQmF0Y2gocGFpcnMsIHdpdGhGaW5hbEV4cG9uZW50ID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgLy8gQ2FjaGUgcHJlY29tcHV0ZWQgdG9BZmZpbmUgZm9yIGFsbCBwb2ludHNcbiAgICAgICAgbm9ybWFsaXplWihHMSwgcGFpcnMubWFwKCh7IGcxIH0pID0+IGcxKSk7XG4gICAgICAgIG5vcm1hbGl6ZVooRzIsIHBhaXJzLm1hcCgoeyBnMiB9KSA9PiBnMikpO1xuICAgICAgICBmb3IgKGNvbnN0IHsgZzEsIGcyIH0gb2YgcGFpcnMpIHtcbiAgICAgICAgICAgIGlmIChnMS5pczAoKSB8fCBnMi5pczAoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhaXJpbmcgaXMgbm90IGF2YWlsYWJsZSBmb3IgWkVSTyBwb2ludCcpO1xuICAgICAgICAgICAgLy8gVGhpcyB1c2VzIHRvQWZmaW5lIGluc2lkZVxuICAgICAgICAgICAgZzEuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIGcyLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICBjb25zdCBRYSA9IGcxLnRvQWZmaW5lKCk7XG4gICAgICAgICAgICByZXMucHVzaChbY2FsY1BhaXJpbmdQcmVjb21wdXRlcyhnMiksIFFhLngsIFFhLnldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWlsbGVyTG9vcEJhdGNoKHJlcywgd2l0aEZpbmFsRXhwb25lbnQpO1xuICAgIH1cbiAgICAvLyBDYWxjdWxhdGVzIGJpbGluZWFyIHBhaXJpbmdcbiAgICBmdW5jdGlvbiBwYWlyaW5nKFEsIFAsIHdpdGhGaW5hbEV4cG9uZW50ID0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gcGFpcmluZ0JhdGNoKFt7IGcxOiBRLCBnMjogUCB9XSwgd2l0aEZpbmFsRXhwb25lbnQpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBGcDEyLCAvLyBOT1RFOiB3ZSByZS1leHBvcnQgRnAxMiBoZXJlIGJlY2F1c2UgcGFpcmluZyByZXN1bHRzIGFyZSBGcDEyIVxuICAgICAgICBtaWxsZXJMb29wQmF0Y2gsXG4gICAgICAgIHBhaXJpbmcsXG4gICAgICAgIHBhaXJpbmdCYXRjaCxcbiAgICAgICAgY2FsY1BhaXJpbmdQcmVjb21wdXRlcyxcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQmxzU2lnKGJsc1BhaXJpbmcsIFB1YkN1cnZlLCBTaWdDdXJ2ZSwgU2lnbmF0dXJlQ29kZXIsIGlzU2lnRzEpIHtcbiAgICBjb25zdCB7IEZwMTIsIHBhaXJpbmdCYXRjaCB9ID0gYmxzUGFpcmluZztcbiAgICBmdW5jdGlvbiBub3JtUHViKHBvaW50KSB7XG4gICAgICAgIHJldHVybiBwb2ludCBpbnN0YW5jZW9mIFB1YkN1cnZlLlBvaW50ID8gcG9pbnQgOiBQdWJDdXJ2ZS5Qb2ludC5mcm9tSGV4KHBvaW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbm9ybVNpZyhwb2ludCkge1xuICAgICAgICByZXR1cm4gcG9pbnQgaW5zdGFuY2VvZiBTaWdDdXJ2ZS5Qb2ludCA/IHBvaW50IDogU2lnQ3VydmUuUG9pbnQuZnJvbUhleChwb2ludCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFtc2cobSkge1xuICAgICAgICBpZiAoIShtIGluc3RhbmNlb2YgU2lnQ3VydmUuUG9pbnQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBleHBlY3RlZCB2YWxpZCBtZXNzYWdlIGhhc2hlZCB0byAkeyFpc1NpZ0cxID8gJ0cyJyA6ICdHMSd9IGN1cnZlYCk7XG4gICAgICAgIHJldHVybiBtO1xuICAgIH1cbiAgICAvLyBXaGF0IG1hdHRlcnMgaGVyZSBpcyB3aGF0IHBvaW50IHBhaXJpbmcgQVBJIGFjY2VwdHMgYXMgRzEgb3IgRzIsIG5vdCBhY3R1YWwgc2l6ZSBvciBuYW1lc1xuICAgIGNvbnN0IHBhaXIgPSAhaXNTaWdHMVxuICAgICAgICA/IChhLCBiKSA9PiAoeyBnMTogYSwgZzI6IGIgfSlcbiAgICAgICAgOiAoYSwgYikgPT4gKHsgZzE6IGIsIGcyOiBhIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8vIFAgPSBwayB4IEdcbiAgICAgICAgZ2V0UHVibGljS2V5KHNlY3JldEtleSkge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVwbGFjZSB3aXRoXG4gICAgICAgICAgICAvLyBjb25zdCBzZWMgPSBQdWJDdXJ2ZS5Qb2ludC5Gbi5mcm9tQnl0ZXMoc2VjcmV0S2V5KTtcbiAgICAgICAgICAgIGNvbnN0IHNlYyA9IF9ub3JtRm5FbGVtZW50KFB1YkN1cnZlLlBvaW50LkZuLCBzZWNyZXRLZXkpO1xuICAgICAgICAgICAgcmV0dXJuIFB1YkN1cnZlLlBvaW50LkJBU0UubXVsdGlwbHkoc2VjKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gUyA9IHBrIHggSChtKVxuICAgICAgICBzaWduKG1lc3NhZ2UsIHNlY3JldEtleSwgdW51c2VkQXJnKSB7XG4gICAgICAgICAgICBpZiAodW51c2VkQXJnICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduKCkgZXhwZWN0cyAyIGFyZ3VtZW50cycpO1xuICAgICAgICAgICAgLy8gVE9ETzogcmVwbGFjZSB3aXRoXG4gICAgICAgICAgICAvLyBQdWJDdXJ2ZS5Qb2ludC5Gbi5mcm9tQnl0ZXMoc2VjcmV0S2V5KVxuICAgICAgICAgICAgY29uc3Qgc2VjID0gX25vcm1GbkVsZW1lbnQoUHViQ3VydmUuUG9pbnQuRm4sIHNlY3JldEtleSk7XG4gICAgICAgICAgICBhbXNnKG1lc3NhZ2UpLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZS5tdWx0aXBseShzZWMpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBDaGVja3MgaWYgcGFpcmluZyBvZiBwdWJsaWMga2V5ICYgaGFzaCBpcyBlcXVhbCB0byBwYWlyaW5nIG9mIGdlbmVyYXRvciAmIHNpZ25hdHVyZS5cbiAgICAgICAgLy8gZShQLCBIKG0pKSA9PSBlKEcsIFMpXG4gICAgICAgIC8vIGUoUywgRykgPT0gZShIKG0pLCBQKVxuICAgICAgICB2ZXJpZnkoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXksIHVudXNlZEFyZykge1xuICAgICAgICAgICAgaWYgKHVudXNlZEFyZyAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndmVyaWZ5KCkgZXhwZWN0cyAzIGFyZ3VtZW50cycpO1xuICAgICAgICAgICAgc2lnbmF0dXJlID0gbm9ybVNpZyhzaWduYXR1cmUpO1xuICAgICAgICAgICAgcHVibGljS2V5ID0gbm9ybVB1YihwdWJsaWNLZXkpO1xuICAgICAgICAgICAgY29uc3QgUCA9IHB1YmxpY0tleS5uZWdhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IEcgPSBQdWJDdXJ2ZS5Qb2ludC5CQVNFO1xuICAgICAgICAgICAgY29uc3QgSG0gPSBhbXNnKG1lc3NhZ2UpO1xuICAgICAgICAgICAgY29uc3QgUyA9IHNpZ25hdHVyZTtcbiAgICAgICAgICAgIC8vIFRoaXMgY29kZSB3YXMgY2hhbmdlZCBpbiAxLjkueDpcbiAgICAgICAgICAgIC8vIEJlZm9yZSBpdCB3YXMgRy5uZWdhdGUoKSBpbiBHMiwgbm93IGl0J3MgYWx3YXlzIHB1YktleS5uZWdhdGVcbiAgICAgICAgICAgIC8vIGUoUCwgLVEpPT09ZSgtUCwgUSk9PWUoUCwgUSleLTEuIE5lZ2F0ZSBjYW4gYmUgZG9uZSBhbnl3aGVyZSAoYXMgbG9uZyBpdCBpcyBkb25lIG9uY2UgcGVyIHBhaXIpLlxuICAgICAgICAgICAgLy8gV2UganVzdCBtb3Zpbmcgc2lnbiwgYnV0IHNpbmNlIHBhaXJpbmcgaXMgbXVsdGlwbGljYXRpdmUsIHdlIGRvaW5nIFggKiBYXi0xID0gMVxuICAgICAgICAgICAgY29uc3QgZXhwID0gcGFpcmluZ0JhdGNoKFtwYWlyKFAsIEhtKSwgcGFpcihHLCBTKV0pO1xuICAgICAgICAgICAgcmV0dXJuIEZwMTIuZXFsKGV4cCwgRnAxMi5PTkUpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBodHRwczovL2V0aHJlc2Vhci5jaC90L2Zhc3QtdmVyaWZpY2F0aW9uLW9mLW11bHRpcGxlLWJscy1zaWduYXR1cmVzLzU0MDdcbiAgICAgICAgLy8gZShHLCBTKSA9IGUoRywgU1VNKG4pKFNpKSkgPSBNVUwobikoZShHLCBTaSkpXG4gICAgICAgIC8vIFRPRE86IG1heWJlIGB7bWVzc2FnZTogRzJIZXgsIHB1YmxpY0tleTogRzFIZXh9W11gIGluc3RlYWQ/XG4gICAgICAgIHZlcmlmeUJhdGNoKHNpZ25hdHVyZSwgbWVzc2FnZXMsIHB1YmxpY0tleXMpIHtcbiAgICAgICAgICAgIGFOb25FbXB0eShtZXNzYWdlcyk7XG4gICAgICAgICAgICBpZiAocHVibGljS2V5cy5sZW5ndGggIT09IG1lc3NhZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Ftb3VudCBvZiBwdWJsaWMga2V5cyBhbmQgbWVzc2FnZXMgc2hvdWxkIGJlIGVxdWFsJyk7XG4gICAgICAgICAgICBjb25zdCBzaWcgPSBub3JtU2lnKHNpZ25hdHVyZSk7XG4gICAgICAgICAgICBjb25zdCBuTWVzc2FnZXMgPSBtZXNzYWdlcztcbiAgICAgICAgICAgIGNvbnN0IG5QdWJsaWNLZXlzID0gcHVibGljS2V5cy5tYXAobm9ybVB1Yik7XG4gICAgICAgICAgICAvLyBOT1RFOiB0aGlzIHdvcmtzIG9ubHkgZm9yIGV4YWN0IHNhbWUgb2JqZWN0XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlUHViS2V5TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuUHVibGljS2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHB1YiA9IG5QdWJsaWNLZXlzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1zZyA9IG5NZXNzYWdlc1tpXTtcbiAgICAgICAgICAgICAgICBsZXQga2V5cyA9IG1lc3NhZ2VQdWJLZXlNYXAuZ2V0KG1zZyk7XG4gICAgICAgICAgICAgICAgaWYgKGtleXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBrZXlzID0gW107XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VQdWJLZXlNYXAuc2V0KG1zZywga2V5cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGtleXMucHVzaChwdWIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFpcmVkID0gW107XG4gICAgICAgICAgICBjb25zdCBHID0gUHViQ3VydmUuUG9pbnQuQkFTRTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBbbXNnLCBrZXlzXSBvZiBtZXNzYWdlUHViS2V5TWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGdyb3VwUHVibGljS2V5ID0ga2V5cy5yZWR1Y2UoKGFjYywgbXNnKSA9PiBhY2MuYWRkKG1zZykpO1xuICAgICAgICAgICAgICAgICAgICBwYWlyZWQucHVzaChwYWlyKGdyb3VwUHVibGljS2V5LCBtc2cpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFpcmVkLnB1c2gocGFpcihHLm5lZ2F0ZSgpLCBzaWcpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gRnAxMi5lcWwocGFpcmluZ0JhdGNoKHBhaXJlZCksIEZwMTIuT05FKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEFkZHMgYSBidW5jaCBvZiBwdWJsaWMga2V5IHBvaW50cyB0b2dldGhlci5cbiAgICAgICAgLy8gcGsxICsgcGsyICsgcGszID0gcGtBXG4gICAgICAgIGFnZ3JlZ2F0ZVB1YmxpY0tleXMocHVibGljS2V5cykge1xuICAgICAgICAgICAgYU5vbkVtcHR5KHB1YmxpY0tleXMpO1xuICAgICAgICAgICAgcHVibGljS2V5cyA9IHB1YmxpY0tleXMubWFwKChwdWIpID0+IG5vcm1QdWIocHViKSk7XG4gICAgICAgICAgICBjb25zdCBhZ2cgPSBwdWJsaWNLZXlzLnJlZHVjZSgoc3VtLCBwKSA9PiBzdW0uYWRkKHApLCBQdWJDdXJ2ZS5Qb2ludC5aRVJPKTtcbiAgICAgICAgICAgIGFnZy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIGFnZztcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQWRkcyBhIGJ1bmNoIG9mIHNpZ25hdHVyZSBwb2ludHMgdG9nZXRoZXIuXG4gICAgICAgIC8vIHBrMSArIHBrMiArIHBrMyA9IHBrQVxuICAgICAgICBhZ2dyZWdhdGVTaWduYXR1cmVzKHNpZ25hdHVyZXMpIHtcbiAgICAgICAgICAgIGFOb25FbXB0eShzaWduYXR1cmVzKTtcbiAgICAgICAgICAgIHNpZ25hdHVyZXMgPSBzaWduYXR1cmVzLm1hcCgoc2lnKSA9PiBub3JtU2lnKHNpZykpO1xuICAgICAgICAgICAgY29uc3QgYWdnID0gc2lnbmF0dXJlcy5yZWR1Y2UoKHN1bSwgcykgPT4gc3VtLmFkZChzKSwgU2lnQ3VydmUuUG9pbnQuWkVSTyk7XG4gICAgICAgICAgICBhZ2cuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBhZ2c7XG4gICAgICAgIH0sXG4gICAgICAgIGhhc2gobWVzc2FnZUJ5dGVzLCBEU1QpIHtcbiAgICAgICAgICAgIGFieXRlcyhtZXNzYWdlQnl0ZXMpO1xuICAgICAgICAgICAgY29uc3Qgb3B0cyA9IERTVCA/IHsgRFNUIH0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXR1cm4gU2lnQ3VydmUuaGFzaFRvQ3VydmUobWVzc2FnZUJ5dGVzLCBvcHRzKTtcbiAgICAgICAgfSxcbiAgICAgICAgU2lnbmF0dXJlOiBTaWduYXR1cmVDb2RlcixcbiAgICB9O1xufVxuLy8gRzFfUG9pbnQ6IFByb2pDb25zdHJ1Y3RvcjxiaWdpbnQ+LCBHMl9Qb2ludDogUHJvakNvbnN0cnVjdG9yPEZwMj4sXG5leHBvcnQgZnVuY3Rpb24gYmxzKENVUlZFKSB7XG4gICAgLy8gRmllbGRzIGFyZSBzcGVjaWZpYyBmb3IgY3VydmUsIHNvIGZvciBub3cgd2UnbGwgbmVlZCB0byBwYXNzIHRoZW0gd2l0aCBvcHRzXG4gICAgY29uc3QgeyBGcCwgRnIsIEZwMiwgRnA2LCBGcDEyIH0gPSBDVVJWRS5maWVsZHM7XG4gICAgLy8gUG9pbnQgb24gRzEgY3VydmU6ICh4LCB5KVxuICAgIGNvbnN0IEcxXyA9IHdlaWVyc3RyYXNzUG9pbnRzKENVUlZFLkcxKTtcbiAgICBjb25zdCBHMSA9IE9iamVjdC5hc3NpZ24oRzFfLCBjcmVhdGVIYXNoZXIoRzFfLlBvaW50LCBDVVJWRS5HMS5tYXBUb0N1cnZlLCB7XG4gICAgICAgIC4uLkNVUlZFLmh0ZkRlZmF1bHRzLFxuICAgICAgICAuLi5DVVJWRS5HMS5odGZEZWZhdWx0cyxcbiAgICB9KSk7XG4gICAgLy8gUG9pbnQgb24gRzIgY3VydmUgKGNvbXBsZXggbnVtYmVycyk6ICh44oKBLCB44oKCK2kpLCAoeeKCgSwgeeKCgitpKVxuICAgIGNvbnN0IEcyXyA9IHdlaWVyc3RyYXNzUG9pbnRzKENVUlZFLkcyKTtcbiAgICBjb25zdCBHMiA9IE9iamVjdC5hc3NpZ24oRzJfLCBjcmVhdGVIYXNoZXIoRzJfLlBvaW50LCBDVVJWRS5HMi5tYXBUb0N1cnZlLCB7XG4gICAgICAgIC4uLkNVUlZFLmh0ZkRlZmF1bHRzLFxuICAgICAgICAuLi5DVVJWRS5HMi5odGZEZWZhdWx0cyxcbiAgICB9KSk7XG4gICAgY29uc3QgcGFpcmluZ1JlcyA9IGNyZWF0ZUJsc1BhaXJpbmcoQ1VSVkUuZmllbGRzLCBHMS5Qb2ludCwgRzIuUG9pbnQsIHtcbiAgICAgICAgLi4uQ1VSVkUucGFyYW1zLFxuICAgICAgICBwb3N0UHJlY29tcHV0ZTogQ1VSVkUucG9zdFByZWNvbXB1dGUsXG4gICAgfSk7XG4gICAgY29uc3QgeyBtaWxsZXJMb29wQmF0Y2gsIHBhaXJpbmcsIHBhaXJpbmdCYXRjaCwgY2FsY1BhaXJpbmdQcmVjb21wdXRlcyB9ID0gcGFpcmluZ1JlcztcbiAgICBjb25zdCBsb25nU2lnbmF0dXJlcyA9IGNyZWF0ZUJsc1NpZyhwYWlyaW5nUmVzLCBHMSwgRzIsIENVUlZFLkcyLlNpZ25hdHVyZSwgZmFsc2UpO1xuICAgIGNvbnN0IHNob3J0U2lnbmF0dXJlcyA9IGNyZWF0ZUJsc1NpZyhwYWlyaW5nUmVzLCBHMiwgRzEsIENVUlZFLkcxLlNob3J0U2lnbmF0dXJlLCB0cnVlKTtcbiAgICBjb25zdCByYW5kID0gQ1VSVkUucmFuZG9tQnl0ZXMgfHwgcmFuZG9tQnl0ZXM7XG4gICAgY29uc3QgcmFuZG9tU2VjcmV0S2V5ID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBsZW5ndGggPSBnZXRNaW5IYXNoTGVuZ3RoKEZyLk9SREVSKTtcbiAgICAgICAgcmV0dXJuIG1hcEhhc2hUb0ZpZWxkKHJhbmQobGVuZ3RoKSwgRnIuT1JERVIpO1xuICAgIH07XG4gICAgY29uc3QgdXRpbHMgPSB7XG4gICAgICAgIHJhbmRvbVNlY3JldEtleSxcbiAgICAgICAgcmFuZG9tUHJpdmF0ZUtleTogcmFuZG9tU2VjcmV0S2V5LFxuICAgICAgICBjYWxjUGFpcmluZ1ByZWNvbXB1dGVzLFxuICAgIH07XG4gICAgY29uc3QgeyBTaG9ydFNpZ25hdHVyZSB9ID0gQ1VSVkUuRzE7XG4gICAgY29uc3QgeyBTaWduYXR1cmUgfSA9IENVUlZFLkcyO1xuICAgIGZ1bmN0aW9uIG5vcm1QMUhhc2gocG9pbnQsIGh0Zk9wdHMpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50IGluc3RhbmNlb2YgRzEuUG9pbnRcbiAgICAgICAgICAgID8gcG9pbnRcbiAgICAgICAgICAgIDogc2hvcnRTaWduYXR1cmVzLmhhc2goZW5zdXJlQnl0ZXMoJ3BvaW50JywgcG9pbnQpLCBodGZPcHRzPy5EU1QpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtUDJIYXNoKHBvaW50LCBodGZPcHRzKSB7XG4gICAgICAgIHJldHVybiBwb2ludCBpbnN0YW5jZW9mIEcyLlBvaW50XG4gICAgICAgICAgICA/IHBvaW50XG4gICAgICAgICAgICA6IGxvbmdTaWduYXR1cmVzLmhhc2goZW5zdXJlQnl0ZXMoJ3BvaW50JywgcG9pbnQpLCBodGZPcHRzPy5EU1QpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRQdWJsaWNLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICByZXR1cm4gbG9uZ1NpZ25hdHVyZXMuZ2V0UHVibGljS2V5KHByaXZhdGVLZXkpLnRvQnl0ZXModHJ1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFB1YmxpY0tleUZvclNob3J0U2lnbmF0dXJlcyhwcml2YXRlS2V5KSB7XG4gICAgICAgIHJldHVybiBzaG9ydFNpZ25hdHVyZXMuZ2V0UHVibGljS2V5KHByaXZhdGVLZXkpLnRvQnl0ZXModHJ1ZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNpZ24obWVzc2FnZSwgcHJpdmF0ZUtleSwgaHRmT3B0cykge1xuICAgICAgICBjb25zdCBIbSA9IG5vcm1QMkhhc2gobWVzc2FnZSwgaHRmT3B0cyk7XG4gICAgICAgIGNvbnN0IFMgPSBsb25nU2lnbmF0dXJlcy5zaWduKEhtLCBwcml2YXRlS2V5KTtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2UgaW5zdGFuY2VvZiBHMi5Qb2ludCA/IFMgOiBTaWduYXR1cmUudG9CeXRlcyhTKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2lnblNob3J0U2lnbmF0dXJlKG1lc3NhZ2UsIHByaXZhdGVLZXksIGh0Zk9wdHMpIHtcbiAgICAgICAgY29uc3QgSG0gPSBub3JtUDFIYXNoKG1lc3NhZ2UsIGh0Zk9wdHMpO1xuICAgICAgICBjb25zdCBTID0gc2hvcnRTaWduYXR1cmVzLnNpZ24oSG0sIHByaXZhdGVLZXkpO1xuICAgICAgICByZXR1cm4gbWVzc2FnZSBpbnN0YW5jZW9mIEcxLlBvaW50ID8gUyA6IFNob3J0U2lnbmF0dXJlLnRvQnl0ZXMoUyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSwgaHRmT3B0cykge1xuICAgICAgICBjb25zdCBIbSA9IG5vcm1QMkhhc2gobWVzc2FnZSwgaHRmT3B0cyk7XG4gICAgICAgIHJldHVybiBsb25nU2lnbmF0dXJlcy52ZXJpZnkoc2lnbmF0dXJlLCBIbSwgcHVibGljS2V5KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmVyaWZ5U2hvcnRTaWduYXR1cmUoc2lnbmF0dXJlLCBtZXNzYWdlLCBwdWJsaWNLZXksIGh0Zk9wdHMpIHtcbiAgICAgICAgY29uc3QgSG0gPSBub3JtUDFIYXNoKG1lc3NhZ2UsIGh0Zk9wdHMpO1xuICAgICAgICByZXR1cm4gc2hvcnRTaWduYXR1cmVzLnZlcmlmeShzaWduYXR1cmUsIEhtLCBwdWJsaWNLZXkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZ2dyZWdhdGVQdWJsaWNLZXlzKHB1YmxpY0tleXMpIHtcbiAgICAgICAgY29uc3QgYWdnID0gbG9uZ1NpZ25hdHVyZXMuYWdncmVnYXRlUHVibGljS2V5cyhwdWJsaWNLZXlzKTtcbiAgICAgICAgcmV0dXJuIHB1YmxpY0tleXNbMF0gaW5zdGFuY2VvZiBHMS5Qb2ludCA/IGFnZyA6IGFnZy50b0J5dGVzKHRydWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZ2dyZWdhdGVTaWduYXR1cmVzKHNpZ25hdHVyZXMpIHtcbiAgICAgICAgY29uc3QgYWdnID0gbG9uZ1NpZ25hdHVyZXMuYWdncmVnYXRlU2lnbmF0dXJlcyhzaWduYXR1cmVzKTtcbiAgICAgICAgcmV0dXJuIHNpZ25hdHVyZXNbMF0gaW5zdGFuY2VvZiBHMi5Qb2ludCA/IGFnZyA6IFNpZ25hdHVyZS50b0J5dGVzKGFnZyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFnZ3JlZ2F0ZVNob3J0U2lnbmF0dXJlcyhzaWduYXR1cmVzKSB7XG4gICAgICAgIGNvbnN0IGFnZyA9IHNob3J0U2lnbmF0dXJlcy5hZ2dyZWdhdGVTaWduYXR1cmVzKHNpZ25hdHVyZXMpO1xuICAgICAgICByZXR1cm4gc2lnbmF0dXJlc1swXSBpbnN0YW5jZW9mIEcxLlBvaW50ID8gYWdnIDogU2hvcnRTaWduYXR1cmUudG9CeXRlcyhhZ2cpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2ZXJpZnlCYXRjaChzaWduYXR1cmUsIG1lc3NhZ2VzLCBwdWJsaWNLZXlzLCBodGZPcHRzKSB7XG4gICAgICAgIGNvbnN0IEhtID0gbWVzc2FnZXMubWFwKChtKSA9PiBub3JtUDJIYXNoKG0sIGh0Zk9wdHMpKTtcbiAgICAgICAgcmV0dXJuIGxvbmdTaWduYXR1cmVzLnZlcmlmeUJhdGNoKHNpZ25hdHVyZSwgSG0sIHB1YmxpY0tleXMpO1xuICAgIH1cbiAgICBHMS5Qb2ludC5CQVNFLnByZWNvbXB1dGUoNCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbG9uZ1NpZ25hdHVyZXMsXG4gICAgICAgIHNob3J0U2lnbmF0dXJlcyxcbiAgICAgICAgbWlsbGVyTG9vcEJhdGNoLFxuICAgICAgICBwYWlyaW5nLFxuICAgICAgICBwYWlyaW5nQmF0Y2gsXG4gICAgICAgIHZlcmlmeUJhdGNoLFxuICAgICAgICBmaWVsZHM6IHtcbiAgICAgICAgICAgIEZyLFxuICAgICAgICAgICAgRnAsXG4gICAgICAgICAgICBGcDIsXG4gICAgICAgICAgICBGcDYsXG4gICAgICAgICAgICBGcDEyLFxuICAgICAgICB9LFxuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIGF0ZUxvb3BTaXplOiBDVVJWRS5wYXJhbXMuYXRlTG9vcFNpemUsXG4gICAgICAgICAgICB0d2lzdFR5cGU6IENVUlZFLnBhcmFtcy50d2lzdFR5cGUsXG4gICAgICAgICAgICAvLyBkZXByZWNhdGVkXG4gICAgICAgICAgICByOiBDVVJWRS5wYXJhbXMucixcbiAgICAgICAgICAgIEcxYjogQ1VSVkUuRzEuYixcbiAgICAgICAgICAgIEcyYjogQ1VSVkUuRzIuYixcbiAgICAgICAgfSxcbiAgICAgICAgdXRpbHMsXG4gICAgICAgIC8vIGRlcHJlY2F0ZWRcbiAgICAgICAgZ2V0UHVibGljS2V5LFxuICAgICAgICBnZXRQdWJsaWNLZXlGb3JTaG9ydFNpZ25hdHVyZXMsXG4gICAgICAgIHNpZ24sXG4gICAgICAgIHNpZ25TaG9ydFNpZ25hdHVyZSxcbiAgICAgICAgdmVyaWZ5LFxuICAgICAgICB2ZXJpZnlTaG9ydFNpZ25hdHVyZSxcbiAgICAgICAgYWdncmVnYXRlUHVibGljS2V5cyxcbiAgICAgICAgYWdncmVnYXRlU2lnbmF0dXJlcyxcbiAgICAgICAgYWdncmVnYXRlU2hvcnRTaWduYXR1cmVzLFxuICAgICAgICBHMSxcbiAgICAgICAgRzIsXG4gICAgICAgIFNpZ25hdHVyZSxcbiAgICAgICAgU2hvcnRTaWduYXR1cmUsXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJscy5qcy5tYXAiXSwibmFtZXMiOlsiYWJ5dGVzIiwiZW5zdXJlQnl0ZXMiLCJtZW1vaXplZCIsInJhbmRvbUJ5dGVzIiwibm9ybWFsaXplWiIsImNyZWF0ZUhhc2hlciIsImdldE1pbkhhc2hMZW5ndGgiLCJtYXBIYXNoVG9GaWVsZCIsIl9ub3JtRm5FbGVtZW50Iiwid2VpZXJzdHJhc3NQb2ludHMiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJfM24iLCJOQWZEZWNvbXBvc2l0aW9uIiwiYSIsInJlcyIsInVuc2hpZnQiLCJhTm9uRW1wdHkiLCJhcnIiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJFcnJvciIsImNyZWF0ZUJsc1BhaXJpbmciLCJmaWVsZHMiLCJHMSIsIkcyIiwicGFyYW1zIiwiRnAyIiwiRnAxMiIsInR3aXN0VHlwZSIsImF0ZUxvb3BTaXplIiwieE5lZ2F0aXZlIiwicG9zdFByZWNvbXB1dGUiLCJsaW5lRnVuY3Rpb24iLCJjMCIsImMxIiwiYzIiLCJmIiwiUHgiLCJQeSIsIm11bDAxNCIsIm11bCIsIm11bDAzNCIsIkZwMmRpdjIiLCJkaXYiLCJPTkUiLCJwb2ludERvdWJsZSIsImVsbCIsIlJ4IiwiUnkiLCJSeiIsInQwIiwic3FyIiwidDEiLCJ0MiIsIm11bEJ5QiIsInQzIiwidDQiLCJzdWIiLCJhZGQiLCJuZWciLCJwdXNoIiwicG9pbnRBZGQiLCJReCIsIlF5IiwidDUiLCJBVEVfTkFGIiwiY2FsY1BhaXJpbmdQcmVjb21wdXRlcyIsInBvaW50IiwicCIsIngiLCJ5IiwidG9BZmZpbmUiLCJuZWdReSIsImJpdCIsImN1ciIsImxhc3QiLCJiaW5kIiwibWlsbGVyTG9vcEJhdGNoIiwicGFpcnMiLCJ3aXRoRmluYWxFeHBvbmVudCIsImYxMiIsImVsbExlbiIsImkiLCJjb25qdWdhdGUiLCJmaW5hbEV4cG9uZW50aWF0ZSIsInBhaXJpbmdCYXRjaCIsIm1hcCIsImcxIiwiZzIiLCJpczAiLCJhc3NlcnRWYWxpZGl0eSIsIlFhIiwicGFpcmluZyIsIlEiLCJQIiwiY3JlYXRlQmxzU2lnIiwiYmxzUGFpcmluZyIsIlB1YkN1cnZlIiwiU2lnQ3VydmUiLCJTaWduYXR1cmVDb2RlciIsImlzU2lnRzEiLCJub3JtUHViIiwiUG9pbnQiLCJmcm9tSGV4Iiwibm9ybVNpZyIsImFtc2ciLCJtIiwicGFpciIsImIiLCJnZXRQdWJsaWNLZXkiLCJzZWNyZXRLZXkiLCJzZWMiLCJGbiIsIkJBU0UiLCJtdWx0aXBseSIsInNpZ24iLCJtZXNzYWdlIiwidW51c2VkQXJnIiwidmVyaWZ5Iiwic2lnbmF0dXJlIiwicHVibGljS2V5IiwibmVnYXRlIiwiRyIsIkhtIiwiUyIsImV4cCIsImVxbCIsInZlcmlmeUJhdGNoIiwibWVzc2FnZXMiLCJwdWJsaWNLZXlzIiwic2lnIiwibk1lc3NhZ2VzIiwiblB1YmxpY0tleXMiLCJtZXNzYWdlUHViS2V5TWFwIiwiTWFwIiwicHViIiwibXNnIiwia2V5cyIsImdldCIsInVuZGVmaW5lZCIsInNldCIsInBhaXJlZCIsImdyb3VwUHVibGljS2V5IiwicmVkdWNlIiwiYWNjIiwiYWdncmVnYXRlUHVibGljS2V5cyIsImFnZyIsInN1bSIsIlpFUk8iLCJhZ2dyZWdhdGVTaWduYXR1cmVzIiwic2lnbmF0dXJlcyIsInMiLCJoYXNoIiwibWVzc2FnZUJ5dGVzIiwiRFNUIiwib3B0cyIsImhhc2hUb0N1cnZlIiwiU2lnbmF0dXJlIiwiYmxzIiwiQ1VSVkUiLCJGcCIsIkZyIiwiRnA2IiwiRzFfIiwiT2JqZWN0IiwiYXNzaWduIiwibWFwVG9DdXJ2ZSIsImh0ZkRlZmF1bHRzIiwiRzJfIiwicGFpcmluZ1JlcyIsImxvbmdTaWduYXR1cmVzIiwic2hvcnRTaWduYXR1cmVzIiwiU2hvcnRTaWduYXR1cmUiLCJyYW5kIiwicmFuZG9tU2VjcmV0S2V5IiwiT1JERVIiLCJ1dGlscyIsInJhbmRvbVByaXZhdGVLZXkiLCJub3JtUDFIYXNoIiwiaHRmT3B0cyIsIm5vcm1QMkhhc2giLCJwcml2YXRlS2V5IiwidG9CeXRlcyIsImdldFB1YmxpY0tleUZvclNob3J0U2lnbmF0dXJlcyIsInNpZ25TaG9ydFNpZ25hdHVyZSIsInZlcmlmeVNob3J0U2lnbmF0dXJlIiwiYWdncmVnYXRlU2hvcnRTaWduYXR1cmVzIiwicHJlY29tcHV0ZSIsInIiLCJHMWIiLCJHMmIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/bls.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/curve.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/curve.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _createCurveFields: () => (/* binding */ _createCurveFields),\n/* harmony export */   mulEndoUnsafe: () => (/* binding */ mulEndoUnsafe),\n/* harmony export */   negateCt: () => (/* binding */ negateCt),\n/* harmony export */   normalizeZ: () => (/* binding */ normalizeZ),\n/* harmony export */   pippenger: () => (/* binding */ pippenger),\n/* harmony export */   precomputeMSMUnsafe: () => (/* binding */ precomputeMSMUnsafe),\n/* harmony export */   validateBasic: () => (/* binding */ validateBasic),\n/* harmony export */   wNAF: () => (/* binding */ wNAF)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/utils.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/modular.js\");\n/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction negateCt(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\n/**\n * Takes a bunch of Projective Points but executes only one\n * inversion on all of them. Inversion is very slow operation,\n * so this improves performance massively.\n * Optimization: converts a list of projective points to a list of identical points with Z=1.\n */ function normalizeZ(c, points) {\n    const invertedZs = (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpInvertBatch)(c.Fp, points.map((p)=>p.Z));\n    return points.map((p, i)=>c.fromAffine(p.toAffine(invertedZs[i])));\n}\nfunction validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits) throw new Error(\"invalid window size, expected [1..\" + bits + \"], got W=\" + W);\n}\nfunction calcWOpts(W, scalarBits) {\n    validateW(W, scalarBits);\n    const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero\n    const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero\n    const maxNumber = 2 ** W; // W=8 256\n    const mask = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask)(W); // W=8 255 == mask 0b11111111\n    const shiftBy = BigInt(W); // W=8 8\n    return {\n        windows,\n        windowSize,\n        mask,\n        maxNumber,\n        shiftBy\n    };\n}\nfunction calcOffsets(n, window, wOpts) {\n    const { windowSize, mask, maxNumber, shiftBy } = wOpts;\n    let wbits = Number(n & mask); // extract W bits.\n    let nextN = n >> shiftBy; // shift number by W bits.\n    // What actually happens here:\n    // const highestBit = Number(mask ^ (mask >> 1n));\n    // let wbits2 = wbits - 1; // skip zero\n    // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);\n    // split if bits > max: +224 => 256-32\n    if (wbits > windowSize) {\n        // we skip zero, which means instead of `>= size-1`, we do `> size`\n        wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.\n        nextN += _1n; // +256 (carry)\n    }\n    const offsetStart = window * windowSize;\n    const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero\n    const isZero = wbits === 0; // is current window slice a 0?\n    const isNeg = wbits < 0; // is current window slice negative?\n    const isNegF = window % 2 !== 0; // fake random statement for noise\n    const offsetF = offsetStart; // fake offset for noise\n    return {\n        nextN,\n        offset,\n        isZero,\n        isNeg,\n        isNegF,\n        offsetF\n    };\n}\nfunction validateMSMPoints(points, c) {\n    if (!Array.isArray(points)) throw new Error(\"array expected\");\n    points.forEach((p, i)=>{\n        if (!(p instanceof c)) throw new Error(\"invalid point at index \" + i);\n    });\n}\nfunction validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars)) throw new Error(\"array of scalars expected\");\n    scalars.forEach((s, i)=>{\n        if (!field.isValid(s)) throw new Error(\"invalid scalar at index \" + i);\n    });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes.\n// Allows to make points frozen / immutable.\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap();\nfunction getW(P) {\n    // To disable precomputes:\n    // return 1;\n    return pointWindowSizes.get(P) || 1;\n}\nfunction assert0(n) {\n    if (n !== _0n) throw new Error(\"invalid wNAF\");\n}\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Table generation takes **30MB of ram and 10ms on high-end CPU**,\n * but may take much longer on slow devices. Actual generation will happen on\n * first call of `multiply()`. By default, `BASE` point is precomputed.\n *\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */ class wNAF {\n    // Parametrized with a given Point class (not individual point)\n    constructor(Point, bits){\n        this.BASE = Point.BASE;\n        this.ZERO = Point.ZERO;\n        this.Fn = Point.Fn;\n        this.bits = bits;\n    }\n    // non-const time multiplication ladder\n    _unsafeLadder(elm, n, p = this.ZERO) {\n        let d = elm;\n        while(n > _0n){\n            if (n & _1n) p = p.add(d);\n            d = d.double();\n            n >>= _1n;\n        }\n        return p;\n    }\n    /**\n     * Creates a wNAF precomputation window. Used for caching.\n     * Default window size is set by `utils.precompute()` and is equal to 8.\n     * Number of precomputed points depends on the curve size:\n     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n     * - 𝑊 is the window size\n     * - 𝑛 is the bitlength of the curve order.\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n     * @param point Point instance\n     * @param W window size\n     * @returns precomputed point tables flattened to a single array\n     */ precomputeWindow(point, W) {\n        const { windows, windowSize } = calcWOpts(W, this.bits);\n        const points = [];\n        let p = point;\n        let base = p;\n        for(let window = 0; window < windows; window++){\n            base = p;\n            points.push(base);\n            // i=1, bc we skip 0\n            for(let i = 1; i < windowSize; i++){\n                base = base.add(p);\n                points.push(base);\n            }\n            p = base.double();\n        }\n        return points;\n    }\n    /**\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n     * More compact implementation:\n     * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n     * @returns real and fake (for const-time) points\n     */ wNAF(W, precomputes, n) {\n        // Scalar should be smaller than field order\n        if (!this.Fn.isValid(n)) throw new Error(\"invalid scalar\");\n        // Accumulators\n        let p = this.ZERO;\n        let f = this.BASE;\n        // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n        // there is negate now: it is possible that negated element from low value\n        // would be the same as high element, which will create carry into next window.\n        // It's not obvious how this can fail, but still worth investigating later.\n        const wo = calcWOpts(W, this.bits);\n        for(let window = 0; window < wo.windows; window++){\n            // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise\n            const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);\n            n = nextN;\n            if (isZero) {\n                // bits are 0: add garbage to fake point\n                // Important part for const-time getPublicKey: add random \"noise\" point to f.\n                f = f.add(negateCt(isNegF, precomputes[offsetF]));\n            } else {\n                // bits are 1: add to result point\n                p = p.add(negateCt(isNeg, precomputes[offset]));\n            }\n        }\n        assert0(n);\n        // Return both real and fake points: JIT won't eliminate f.\n        // At this point there is a way to F be infinity-point even if p is not,\n        // which makes it less const-time: around 1 bigint multiply.\n        return {\n            p,\n            f\n        };\n    }\n    /**\n     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param acc accumulator point to add result of multiplication\n     * @returns point\n     */ wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {\n        const wo = calcWOpts(W, this.bits);\n        for(let window = 0; window < wo.windows; window++){\n            if (n === _0n) break; // Early-exit, skip 0 value\n            const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);\n            n = nextN;\n            if (isZero) {\n                continue;\n            } else {\n                const item = precomputes[offset];\n                acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM\n            }\n        }\n        assert0(n);\n        return acc;\n    }\n    getPrecomputes(W, point, transform) {\n        // Calculate precomputes on a first run, reuse them after\n        let comp = pointPrecomputes.get(point);\n        if (!comp) {\n            comp = this.precomputeWindow(point, W);\n            if (W !== 1) {\n                // Doing transform outside of if brings 15% perf hit\n                if (typeof transform === \"function\") comp = transform(comp);\n                pointPrecomputes.set(point, comp);\n            }\n        }\n        return comp;\n    }\n    cached(point, scalar, transform) {\n        const W = getW(point);\n        return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);\n    }\n    unsafe(point, scalar, transform, prev) {\n        const W = getW(point);\n        if (W === 1) return this._unsafeLadder(point, scalar, prev); // For W=1 ladder is ~x2 faster\n        return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);\n    }\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n    createCache(P, W) {\n        validateW(W, this.bits);\n        pointWindowSizes.set(P, W);\n        pointPrecomputes.delete(P);\n    }\n    hasCache(elm) {\n        return getW(elm) !== 1;\n    }\n}\n/**\n * Endomorphism-specific multiplication for Koblitz curves.\n * Cost: 128 dbl, 0-256 adds.\n */ function mulEndoUnsafe(Point, point, k1, k2) {\n    let acc = point;\n    let p1 = Point.ZERO;\n    let p2 = Point.ZERO;\n    while(k1 > _0n || k2 > _0n){\n        if (k1 & _1n) p1 = p1.add(acc);\n        if (k2 & _1n) p2 = p2.add(acc);\n        acc = acc.double();\n        k1 >>= _1n;\n        k2 >>= _1n;\n    }\n    return {\n        p1,\n        p2\n    };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster than precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka secret keys / bigints)\n */ function pippenger(c, fieldN, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    const plength = points.length;\n    const slength = scalars.length;\n    if (plength !== slength) throw new Error(\"arrays of points and scalars must have equal length\");\n    // if (plength === 0) throw new Error('array must be of length >= 2');\n    const zero = c.ZERO;\n    const wbits = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitLen)(BigInt(plength));\n    let windowSize = 1; // bits\n    if (wbits > 12) windowSize = wbits - 3;\n    else if (wbits > 4) windowSize = wbits - 2;\n    else if (wbits > 0) windowSize = 2;\n    const MASK = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask)(windowSize);\n    const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for(let i = lastBits; i >= 0; i -= windowSize){\n        buckets.fill(zero);\n        for(let j = 0; j < slength; j++){\n            const scalar = scalars[j];\n            const wbits = Number(scalar >> BigInt(i) & MASK);\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = zero; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for(let j = buckets.length - 1, sumI = zero; j > 0; j--){\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0) for(let j = 0; j < windowSize; j++)sum = sum.double();\n    }\n    return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */ function precomputeMSMUnsafe(c, fieldN, points, windowSize) {\n    /**\n     * Performance Analysis of Window-based Precomputation\n     *\n     * Base Case (256-bit scalar, 8-bit window):\n     * - Standard precomputation requires:\n     *   - 31 additions per scalar × 256 scalars = 7,936 ops\n     *   - Plus 255 summary additions = 8,191 total ops\n     *   Note: Summary additions can be optimized via accumulator\n     *\n     * Chunked Precomputation Analysis:\n     * - Using 32 chunks requires:\n     *   - 255 additions per chunk\n     *   - 256 doublings\n     *   - Total: (255 × 32) + 256 = 8,416 ops\n     *\n     * Memory Usage Comparison:\n     * Window Size | Standard Points | Chunked Points\n     * ------------|-----------------|---------------\n     *     4-bit   |     520         |      15\n     *     8-bit   |    4,224        |     255\n     *    10-bit   |   13,824        |   1,023\n     *    16-bit   |  557,056        |  65,535\n     *\n     * Key Advantages:\n     * 1. Enables larger window sizes due to reduced memory overhead\n     * 2. More efficient for smaller scalar counts:\n     *    - 16 chunks: (16 × 255) + 256 = 4,336 ops\n     *    - ~2x faster than standard 8,191 ops\n     *\n     * Limitations:\n     * - Not suitable for plain precomputes (requires 256 constant doublings)\n     * - Performance degrades with larger scalar counts:\n     *   - Optimal for ~256 scalars\n     *   - Less efficient for 4096+ scalars (Pippenger preferred)\n     */ validateW(windowSize, fieldN.BITS);\n    validateMSMPoints(points, c);\n    const zero = c.ZERO;\n    const tableSize = 2 ** windowSize - 1; // table size (without zero)\n    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n    const MASK = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask)(windowSize);\n    const tables = points.map((p)=>{\n        const res = [];\n        for(let i = 0, acc = p; i < tableSize; i++){\n            res.push(acc);\n            acc = acc.add(p);\n        }\n        return res;\n    });\n    return (scalars)=>{\n        validateMSMScalars(scalars, fieldN);\n        if (scalars.length > points.length) throw new Error(\"array of scalars must be smaller than array of points\");\n        let res = zero;\n        for(let i = 0; i < chunks; i++){\n            // No need to double if accumulator is still zero.\n            if (res !== zero) for(let j = 0; j < windowSize; j++)res = res.double();\n            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n            for(let j = 0; j < scalars.length; j++){\n                const n = scalars[j];\n                const curr = Number(n >> shiftBy & MASK);\n                if (!curr) continue; // skip zero scalars chunks\n                res = res.add(tables[j][curr - 1]);\n            }\n        }\n        return res;\n    };\n}\n// TODO: remove\n/** @deprecated */ function validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(curve, {\n        n: \"bigint\",\n        h: \"bigint\",\n        Gx: \"field\",\n        Gy: \"field\"\n    }, {\n        nBitLength: \"isSafeInteger\",\n        nByteLength: \"isSafeInteger\"\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{\n            p: curve.Fp.ORDER\n        }\n    });\n}\nfunction createField(order, field, isLE) {\n    if (field) {\n        if (field.ORDER !== order) throw new Error(\"Field.ORDER must match order: Fp == p, Fn == n\");\n        (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(field);\n        return field;\n    } else {\n        return (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(order, {\n            isLE\n        });\n    }\n}\n/** Validates CURVE opts and creates fields */ function _createCurveFields(type, CURVE, curveOpts = {}, FpFnLE) {\n    if (FpFnLE === undefined) FpFnLE = type === \"edwards\";\n    if (!CURVE || typeof CURVE !== \"object\") throw new Error(`expected valid ${type} CURVE object`);\n    for (const p of [\n        \"p\",\n        \"n\",\n        \"h\"\n    ]){\n        const val = CURVE[p];\n        if (!(typeof val === \"bigint\" && val > _0n)) throw new Error(`CURVE.${p} must be positive bigint`);\n    }\n    const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);\n    const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);\n    const _b = type === \"weierstrass\" ? \"b\" : \"d\";\n    const params = [\n        \"Gx\",\n        \"Gy\",\n        \"a\",\n        _b\n    ];\n    for (const p of params){\n        // @ts-ignore\n        if (!Fp.isValid(CURVE[p])) throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);\n    }\n    CURVE = Object.freeze(Object.assign({}, CURVE));\n    return {\n        CURVE,\n        Fp,\n        Fn\n    };\n} //# sourceMappingURL=curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjkuNy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvY3VydmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBOzs7O0NBSUMsR0FDRCxvRUFBb0UsR0FDTjtBQUNjO0FBQzVFLE1BQU1PLE1BQU1DLE9BQU87QUFDbkIsTUFBTUMsTUFBTUQsT0FBTztBQUNaLFNBQVNFLFNBQVNDLFNBQVMsRUFBRUMsSUFBSTtJQUNwQyxNQUFNQyxNQUFNRCxLQUFLRSxNQUFNO0lBQ3ZCLE9BQU9ILFlBQVlFLE1BQU1EO0FBQzdCO0FBQ0E7Ozs7O0NBS0MsR0FDTSxTQUFTRyxXQUFXQyxDQUFDLEVBQUVDLE1BQU07SUFDaEMsTUFBTUMsYUFBYWQsMERBQWFBLENBQUNZLEVBQUVHLEVBQUUsRUFBRUYsT0FBT0csR0FBRyxDQUFDLENBQUNDLElBQU1BLEVBQUVDLENBQUM7SUFDNUQsT0FBT0wsT0FBT0csR0FBRyxDQUFDLENBQUNDLEdBQUdFLElBQU1QLEVBQUVRLFVBQVUsQ0FBQ0gsRUFBRUksUUFBUSxDQUFDUCxVQUFVLENBQUNLLEVBQUU7QUFDckU7QUFDQSxTQUFTRyxVQUFVQyxDQUFDLEVBQUVDLElBQUk7SUFDdEIsSUFBSSxDQUFDQyxPQUFPQyxhQUFhLENBQUNILE1BQU1BLEtBQUssS0FBS0EsSUFBSUMsTUFDMUMsTUFBTSxJQUFJRyxNQUFNLHVDQUF1Q0gsT0FBTyxjQUFjRDtBQUNwRjtBQUNBLFNBQVNLLFVBQVVMLENBQUMsRUFBRU0sVUFBVTtJQUM1QlAsVUFBVUMsR0FBR007SUFDYixNQUFNQyxVQUFVQyxLQUFLQyxJQUFJLENBQUNILGFBQWFOLEtBQUssR0FBRyx1Q0FBdUM7SUFDdEYsTUFBTVUsYUFBYSxLQUFNVixDQUFBQSxJQUFJLElBQUkseUNBQXlDO0lBQzFFLE1BQU1XLFlBQVksS0FBS1gsR0FBRyxVQUFVO0lBQ3BDLE1BQU1ZLE9BQU90QyxrREFB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QUFNO0lBQ2xFLElBQUlBLFdBQVdDLFdBQ1hELFNBQVNILFNBQVM7SUFDdEIsSUFBSSxDQUFDQyxTQUFTLE9BQU9BLFVBQVUsVUFDM0IsTUFBTSxJQUFJaEgsTUFBTSxDQUFDLGVBQWUsRUFBRStHLEtBQUssYUFBYSxDQUFDO0lBQ3pELEtBQUssTUFBTXpILEtBQUs7UUFBQztRQUFLO1FBQUs7S0FBSSxDQUFFO1FBQzdCLE1BQU04SCxNQUFNSixLQUFLLENBQUMxSCxFQUFFO1FBQ3BCLElBQUksQ0FBRSxRQUFPOEgsUUFBUSxZQUFZQSxNQUFNNUksR0FBRSxHQUNyQyxNQUFNLElBQUl3QixNQUFNLENBQUMsTUFBTSxFQUFFVixFQUFFLHdCQUF3QixDQUFDO0lBQzVEO0lBQ0EsTUFBTUYsS0FBS3VILFlBQVlLLE1BQU0xSCxDQUFDLEVBQUUySCxVQUFVN0gsRUFBRSxFQUFFOEg7SUFDOUMsTUFBTXRFLEtBQUsrRCxZQUFZSyxNQUFNckcsQ0FBQyxFQUFFc0csVUFBVXJFLEVBQUUsRUFBRXNFO0lBQzlDLE1BQU1HLEtBQUtOLFNBQVMsZ0JBQWdCLE1BQU07SUFDMUMsTUFBTU8sU0FBUztRQUFDO1FBQU07UUFBTTtRQUFLRDtLQUFHO0lBQ3BDLEtBQUssTUFBTS9ILEtBQUtnSSxPQUFRO1FBQ3BCLGFBQWE7UUFDYixJQUFJLENBQUNsSSxHQUFHMkMsT0FBTyxDQUFDaUYsS0FBSyxDQUFDMUgsRUFBRSxHQUNwQixNQUFNLElBQUlVLE1BQU0sQ0FBQyxNQUFNLEVBQUVWLEVBQUUsd0NBQXdDLENBQUM7SUFDNUU7SUFDQTBILFFBQVFSLE9BQU9DLE1BQU0sQ0FBQ0QsT0FBT2UsTUFBTSxDQUFDLENBQUMsR0FBR1A7SUFDeEMsT0FBTztRQUFFQTtRQUFPNUg7UUFBSXdEO0lBQUc7QUFDM0IsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3Rhc2NhbS1wcm90b2NvbC8uL25vZGVfbW9kdWxlcy8ucG5wbS9Abm9ibGUrY3VydmVzQDEuOS43L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9jdXJ2ZS5qcz9mMTg2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTWV0aG9kcyBmb3IgZWxsaXB0aWMgY3VydmUgbXVsdGlwbGljYXRpb24gYnkgc2NhbGFycy5cbiAqIENvbnRhaW5zIHdOQUYsIHBpcHBlbmdlci5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgYml0TGVuLCBiaXRNYXNrLCB2YWxpZGF0ZU9iamVjdCB9IGZyb20gXCIuLi91dGlscy5qc1wiO1xuaW1wb3J0IHsgRmllbGQsIEZwSW52ZXJ0QmF0Y2gsIG5MZW5ndGgsIHZhbGlkYXRlRmllbGQgfSBmcm9tIFwiLi9tb2R1bGFyLmpzXCI7XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5leHBvcnQgZnVuY3Rpb24gbmVnYXRlQ3QoY29uZGl0aW9uLCBpdGVtKSB7XG4gICAgY29uc3QgbmVnID0gaXRlbS5uZWdhdGUoKTtcbiAgICByZXR1cm4gY29uZGl0aW9uID8gbmVnIDogaXRlbTtcbn1cbi8qKlxuICogVGFrZXMgYSBidW5jaCBvZiBQcm9qZWN0aXZlIFBvaW50cyBidXQgZXhlY3V0ZXMgb25seSBvbmVcbiAqIGludmVyc2lvbiBvbiBhbGwgb2YgdGhlbS4gSW52ZXJzaW9uIGlzIHZlcnkgc2xvdyBvcGVyYXRpb24sXG4gKiBzbyB0aGlzIGltcHJvdmVzIHBlcmZvcm1hbmNlIG1hc3NpdmVseS5cbiAqIE9wdGltaXphdGlvbjogY29udmVydHMgYSBsaXN0IG9mIHByb2plY3RpdmUgcG9pbnRzIHRvIGEgbGlzdCBvZiBpZGVudGljYWwgcG9pbnRzIHdpdGggWj0xLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplWihjLCBwb2ludHMpIHtcbiAgICBjb25zdCBpbnZlcnRlZFpzID0gRnBJbnZlcnRCYXRjaChjLkZwLCBwb2ludHMubWFwKChwKSA9PiBwLlopKTtcbiAgICByZXR1cm4gcG9pbnRzLm1hcCgocCwgaSkgPT4gYy5mcm9tQWZmaW5lKHAudG9BZmZpbmUoaW52ZXJ0ZWRac1tpXSkpKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlVyhXLCBiaXRzKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihXKSB8fCBXIDw9IDAgfHwgVyA+IGJpdHMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB3aW5kb3cgc2l6ZSwgZXhwZWN0ZWQgWzEuLicgKyBiaXRzICsgJ10sIGdvdCBXPScgKyBXKTtcbn1cbmZ1bmN0aW9uIGNhbGNXT3B0cyhXLCBzY2FsYXJCaXRzKSB7XG4gICAgdmFsaWRhdGVXKFcsIHNjYWxhckJpdHMpO1xuICAgIGNvbnN0IHdpbmRvd3MgPSBNYXRoLmNlaWwoc2NhbGFyQml0cyAvIFcpICsgMTsgLy8gVz04IDMzLiBOb3QgMzIsIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgY29uc3Qgd2luZG93U2l6ZSA9IDIgKiogKFcgLSAxKTsgLy8gVz04IDEyOC4gTm90IDI1NiwgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICBjb25zdCBtYXhOdW1iZXIgPSAyICoqIFc7IC8vIFc9OCAyNTZcbiAgICBjb25zdCBtYXNrID0gYml0TWFzayhXKTsgLy8gVz04IDI1NSA9PSBtYXNrIDBiMTExMTExMTFcbiAgICBjb25zdCBzaGlmdEJ5ID0gQmlnSW50KFcpOyAvLyBXPTggOFxuICAgIHJldHVybiB7IHdpbmRvd3MsIHdpbmRvd1NpemUsIG1hc2ssIG1heE51bWJlciwgc2hpZnRCeSB9O1xufVxuZnVuY3Rpb24gY2FsY09mZnNldHMobiwgd2luZG93LCB3T3B0cykge1xuICAgIGNvbnN0IHsgd2luZG93U2l6ZSwgbWFzaywgbWF4TnVtYmVyLCBzaGlmdEJ5IH0gPSB3T3B0cztcbiAgICBsZXQgd2JpdHMgPSBOdW1iZXIobiAmIG1hc2spOyAvLyBleHRyYWN0IFcgYml0cy5cbiAgICBsZXQgbmV4dE4gPSBuID4+IHNoaWZ0Qnk7IC8vIHNoaWZ0IG51bWJlciBieSBXIGJpdHMuXG4gICAgLy8gV2hhdCBhY3R1YWxseSBoYXBwZW5zIGhlcmU6XG4gICAgLy8gY29uc3QgaGlnaGVzdEJpdCA9IE51bWJlcihtYXNrIF4gKG1hc2sgPj4gMW4pKTtcbiAgICAvLyBsZXQgd2JpdHMyID0gd2JpdHMgLSAxOyAvLyBza2lwIHplcm9cbiAgICAvLyBpZiAod2JpdHMyICYgaGlnaGVzdEJpdCkgeyB3Yml0czIgXj0gTnVtYmVyKG1hc2spOyAvLyAofik7XG4gICAgLy8gc3BsaXQgaWYgYml0cyA+IG1heDogKzIyNCA9PiAyNTYtMzJcbiAgICBpZiAod2JpdHMgPiB3aW5kb3dTaXplKSB7XG4gICAgICAgIC8vIHdlIHNraXAgemVybywgd2hpY2ggbWVhbnMgaW5zdGVhZCBvZiBgPj0gc2l6ZS0xYCwgd2UgZG8gYD4gc2l6ZWBcbiAgICAgICAgd2JpdHMgLT0gbWF4TnVtYmVyOyAvLyAtMzIsIGNhbiBiZSBtYXhOdW1iZXIgLSB3Yml0cywgYnV0IHRoZW4gd2UgbmVlZCB0byBzZXQgaXNOZWcgaGVyZS5cbiAgICAgICAgbmV4dE4gKz0gXzFuOyAvLyArMjU2IChjYXJyeSlcbiAgICB9XG4gICAgY29uc3Qgb2Zmc2V0U3RhcnQgPSB3aW5kb3cgKiB3aW5kb3dTaXplO1xuICAgIGNvbnN0IG9mZnNldCA9IG9mZnNldFN0YXJ0ICsgTWF0aC5hYnMod2JpdHMpIC0gMTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICBjb25zdCBpc1plcm8gPSB3Yml0cyA9PT0gMDsgLy8gaXMgY3VycmVudCB3aW5kb3cgc2xpY2UgYSAwP1xuICAgIGNvbnN0IGlzTmVnID0gd2JpdHMgPCAwOyAvLyBpcyBjdXJyZW50IHdpbmRvdyBzbGljZSBuZWdhdGl2ZT9cbiAgICBjb25zdCBpc05lZ0YgPSB3aW5kb3cgJSAyICE9PSAwOyAvLyBmYWtlIHJhbmRvbSBzdGF0ZW1lbnQgZm9yIG5vaXNlXG4gICAgY29uc3Qgb2Zmc2V0RiA9IG9mZnNldFN0YXJ0OyAvLyBmYWtlIG9mZnNldCBmb3Igbm9pc2VcbiAgICByZXR1cm4geyBuZXh0Tiwgb2Zmc2V0LCBpc1plcm8sIGlzTmVnLCBpc05lZ0YsIG9mZnNldEYgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTVNNUG9pbnRzKHBvaW50cywgYykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwb2ludHMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FycmF5IGV4cGVjdGVkJyk7XG4gICAgcG9pbnRzLmZvckVhY2goKHAsIGkpID0+IHtcbiAgICAgICAgaWYgKCEocCBpbnN0YW5jZW9mIGMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvaW50IGF0IGluZGV4ICcgKyBpKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTVNNU2NhbGFycyhzY2FsYXJzLCBmaWVsZCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzY2FsYXJzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBvZiBzY2FsYXJzIGV4cGVjdGVkJyk7XG4gICAgc2NhbGFycy5mb3JFYWNoKChzLCBpKSA9PiB7XG4gICAgICAgIGlmICghZmllbGQuaXNWYWxpZChzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzY2FsYXIgYXQgaW5kZXggJyArIGkpO1xuICAgIH0pO1xufVxuLy8gU2luY2UgcG9pbnRzIGluIGRpZmZlcmVudCBncm91cHMgY2Fubm90IGJlIGVxdWFsIChkaWZmZXJlbnQgb2JqZWN0IGNvbnN0cnVjdG9yKSxcbi8vIHdlIGNhbiBoYXZlIHNpbmdsZSBwbGFjZSB0byBzdG9yZSBwcmVjb21wdXRlcy5cbi8vIEFsbG93cyB0byBtYWtlIHBvaW50cyBmcm96ZW4gLyBpbW11dGFibGUuXG5jb25zdCBwb2ludFByZWNvbXB1dGVzID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHBvaW50V2luZG93U2l6ZXMgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gZ2V0VyhQKSB7XG4gICAgLy8gVG8gZGlzYWJsZSBwcmVjb21wdXRlczpcbiAgICAvLyByZXR1cm4gMTtcbiAgICByZXR1cm4gcG9pbnRXaW5kb3dTaXplcy5nZXQoUCkgfHwgMTtcbn1cbmZ1bmN0aW9uIGFzc2VydDAobikge1xuICAgIGlmIChuICE9PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB3TkFGJyk7XG59XG4vKipcbiAqIEVsbGlwdGljIGN1cnZlIG11bHRpcGxpY2F0aW9uIG9mIFBvaW50IGJ5IHNjYWxhci4gRnJhZ2lsZS5cbiAqIFRhYmxlIGdlbmVyYXRpb24gdGFrZXMgKiozME1CIG9mIHJhbSBhbmQgMTBtcyBvbiBoaWdoLWVuZCBDUFUqKixcbiAqIGJ1dCBtYXkgdGFrZSBtdWNoIGxvbmdlciBvbiBzbG93IGRldmljZXMuIEFjdHVhbCBnZW5lcmF0aW9uIHdpbGwgaGFwcGVuIG9uXG4gKiBmaXJzdCBjYWxsIG9mIGBtdWx0aXBseSgpYC4gQnkgZGVmYXVsdCwgYEJBU0VgIHBvaW50IGlzIHByZWNvbXB1dGVkLlxuICpcbiAqIFNjYWxhcnMgc2hvdWxkIGFsd2F5cyBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXI6IHRoaXMgc2hvdWxkIGJlIGNoZWNrZWQgaW5zaWRlIG9mIGEgY3VydmUgaXRzZWxmLlxuICogQ3JlYXRlcyBwcmVjb21wdXRhdGlvbiB0YWJsZXMgZm9yIGZhc3QgbXVsdGlwbGljYXRpb246XG4gKiAtIHByaXZhdGUgc2NhbGFyIGlzIHNwbGl0IGJ5IGZpeGVkIHNpemUgd2luZG93cyBvZiBXIGJpdHNcbiAqIC0gZXZlcnkgd2luZG93IHBvaW50IGlzIGNvbGxlY3RlZCBmcm9tIHdpbmRvdydzIHRhYmxlICYgYWRkZWQgdG8gYWNjdW11bGF0b3JcbiAqIC0gc2luY2Ugd2luZG93cyBhcmUgZGlmZmVyZW50LCBzYW1lIHBvaW50IGluc2lkZSB0YWJsZXMgd29uJ3QgYmUgYWNjZXNzZWQgbW9yZSB0aGFuIG9uY2UgcGVyIGNhbGNcbiAqIC0gZWFjaCBtdWx0aXBsaWNhdGlvbiBpcyAnTWF0aC5jZWlsKENVUlZFX09SREVSIC8g8J2RiikgKyAxJyBwb2ludCBhZGRpdGlvbnMgKGZpeGVkIGZvciBhbnkgc2NhbGFyKVxuICogLSArMSB3aW5kb3cgaXMgbmVjY2Vzc2FyeSBmb3Igd05BRlxuICogLSB3TkFGIHJlZHVjZXMgdGFibGUgc2l6ZTogMnggbGVzcyBtZW1vcnkgKyAyeCBmYXN0ZXIgZ2VuZXJhdGlvbiwgYnV0IDEwJSBzbG93ZXIgbXVsdGlwbGljYXRpb25cbiAqXG4gKiBAdG9kbyBSZXNlYXJjaCByZXR1cm5pbmcgMmQgSlMgYXJyYXkgb2Ygd2luZG93cywgaW5zdGVhZCBvZiBhIHNpbmdsZSB3aW5kb3cuXG4gKiBUaGlzIHdvdWxkIGFsbG93IHdpbmRvd3MgdG8gYmUgaW4gZGlmZmVyZW50IG1lbW9yeSBsb2NhdGlvbnNcbiAqL1xuZXhwb3J0IGNsYXNzIHdOQUYge1xuICAgIC8vIFBhcmFtZXRyaXplZCB3aXRoIGEgZ2l2ZW4gUG9pbnQgY2xhc3MgKG5vdCBpbmRpdmlkdWFsIHBvaW50KVxuICAgIGNvbnN0cnVjdG9yKFBvaW50LCBiaXRzKSB7XG4gICAgICAgIHRoaXMuQkFTRSA9IFBvaW50LkJBU0U7XG4gICAgICAgIHRoaXMuWkVSTyA9IFBvaW50LlpFUk87XG4gICAgICAgIHRoaXMuRm4gPSBQb2ludC5GbjtcbiAgICAgICAgdGhpcy5iaXRzID0gYml0cztcbiAgICB9XG4gICAgLy8gbm9uLWNvbnN0IHRpbWUgbXVsdGlwbGljYXRpb24gbGFkZGVyXG4gICAgX3Vuc2FmZUxhZGRlcihlbG0sIG4sIHAgPSB0aGlzLlpFUk8pIHtcbiAgICAgICAgbGV0IGQgPSBlbG07XG4gICAgICAgIHdoaWxlIChuID4gXzBuKSB7XG4gICAgICAgICAgICBpZiAobiAmIF8xbilcbiAgICAgICAgICAgICAgICBwID0gcC5hZGQoZCk7XG4gICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgIG4gPj49IF8xbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHdOQUYgcHJlY29tcHV0YXRpb24gd2luZG93LiBVc2VkIGZvciBjYWNoaW5nLlxuICAgICAqIERlZmF1bHQgd2luZG93IHNpemUgaXMgc2V0IGJ5IGB1dGlscy5wcmVjb21wdXRlKClgIGFuZCBpcyBlcXVhbCB0byA4LlxuICAgICAqIE51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgZGVwZW5kcyBvbiB0aGUgY3VydmUgc2l6ZTpcbiAgICAgKiAyXijwnZGK4oiSMSkgKiAoTWF0aC5jZWlsKPCdkZsgLyDwnZGKKSArIDEpLCB3aGVyZTpcbiAgICAgKiAtIPCdkYogaXMgdGhlIHdpbmRvdyBzaXplXG4gICAgICogLSDwnZGbIGlzIHRoZSBiaXRsZW5ndGggb2YgdGhlIGN1cnZlIG9yZGVyLlxuICAgICAqIEZvciBhIDI1Ni1iaXQgY3VydmUgYW5kIHdpbmRvdyBzaXplIDgsIHRoZSBudW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGlzIDEyOCAqIDMzID0gNDIyNC5cbiAgICAgKiBAcGFyYW0gcG9pbnQgUG9pbnQgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gVyB3aW5kb3cgc2l6ZVxuICAgICAqIEByZXR1cm5zIHByZWNvbXB1dGVkIHBvaW50IHRhYmxlcyBmbGF0dGVuZWQgdG8gYSBzaW5nbGUgYXJyYXlcbiAgICAgKi9cbiAgICBwcmVjb21wdXRlV2luZG93KHBvaW50LCBXKSB7XG4gICAgICAgIGNvbnN0IHsgd2luZG93cywgd2luZG93U2l6ZSB9ID0gY2FsY1dPcHRzKFcsIHRoaXMuYml0cyk7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICBsZXQgcCA9IHBvaW50O1xuICAgICAgICBsZXQgYmFzZSA9IHA7XG4gICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICBiYXNlID0gcDtcbiAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgLy8gaT0xLCBiYyB3ZSBza2lwIDBcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgd2luZG93U2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYmFzZSA9IGJhc2UuYWRkKHApO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcCA9IGJhc2UuZG91YmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50cyBlYyBtdWx0aXBsaWNhdGlvbiB1c2luZyBwcmVjb21wdXRlZCB0YWJsZXMgYW5kIHctYXJ5IG5vbi1hZGphY2VudCBmb3JtLlxuICAgICAqIE1vcmUgY29tcGFjdCBpbXBsZW1lbnRhdGlvbjpcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL25vYmxlLXNlY3AyNTZrMS9ibG9iLzQ3Y2IxNjY5YjZlNTA2YWQ2NmIzNWZlN2Q3NjEzMmFlOTc0NjVkYTIvaW5kZXgudHMjTDUwMi1MNTQxXG4gICAgICogQHJldHVybnMgcmVhbCBhbmQgZmFrZSAoZm9yIGNvbnN0LXRpbWUpIHBvaW50c1xuICAgICAqL1xuICAgIHdOQUYoVywgcHJlY29tcHV0ZXMsIG4pIHtcbiAgICAgICAgLy8gU2NhbGFyIHNob3VsZCBiZSBzbWFsbGVyIHRoYW4gZmllbGQgb3JkZXJcbiAgICAgICAgaWYgKCF0aGlzLkZuLmlzVmFsaWQobikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2NhbGFyJyk7XG4gICAgICAgIC8vIEFjY3VtdWxhdG9yc1xuICAgICAgICBsZXQgcCA9IHRoaXMuWkVSTztcbiAgICAgICAgbGV0IGYgPSB0aGlzLkJBU0U7XG4gICAgICAgIC8vIFRoaXMgY29kZSB3YXMgZmlyc3Qgd3JpdHRlbiB3aXRoIGFzc3VtcHRpb24gdGhhdCAnZicgYW5kICdwJyB3aWxsIG5ldmVyIGJlIGluZmluaXR5IHBvaW50OlxuICAgICAgICAvLyBzaW5jZSBlYWNoIGFkZGl0aW9uIGlzIG11bHRpcGxpZWQgYnkgMiAqKiBXLCBpdCBjYW5ub3QgY2FuY2VsIGVhY2ggb3RoZXIuIEhvd2V2ZXIsXG4gICAgICAgIC8vIHRoZXJlIGlzIG5lZ2F0ZSBub3c6IGl0IGlzIHBvc3NpYmxlIHRoYXQgbmVnYXRlZCBlbGVtZW50IGZyb20gbG93IHZhbHVlXG4gICAgICAgIC8vIHdvdWxkIGJlIHRoZSBzYW1lIGFzIGhpZ2ggZWxlbWVudCwgd2hpY2ggd2lsbCBjcmVhdGUgY2FycnkgaW50byBuZXh0IHdpbmRvdy5cbiAgICAgICAgLy8gSXQncyBub3Qgb2J2aW91cyBob3cgdGhpcyBjYW4gZmFpbCwgYnV0IHN0aWxsIHdvcnRoIGludmVzdGlnYXRpbmcgbGF0ZXIuXG4gICAgICAgIGNvbnN0IHdvID0gY2FsY1dPcHRzKFcsIHRoaXMuYml0cyk7XG4gICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdvLndpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAvLyAobiA9PT0gXzBuKSBpcyBoYW5kbGVkIGFuZCBub3QgZWFybHktZXhpdGVkLiBpc0V2ZW4gYW5kIG9mZnNldEYgYXJlIHVzZWQgZm9yIG5vaXNlXG4gICAgICAgICAgICBjb25zdCB7IG5leHROLCBvZmZzZXQsIGlzWmVybywgaXNOZWcsIGlzTmVnRiwgb2Zmc2V0RiB9ID0gY2FsY09mZnNldHMobiwgd2luZG93LCB3byk7XG4gICAgICAgICAgICBuID0gbmV4dE47XG4gICAgICAgICAgICBpZiAoaXNaZXJvKSB7XG4gICAgICAgICAgICAgICAgLy8gYml0cyBhcmUgMDogYWRkIGdhcmJhZ2UgdG8gZmFrZSBwb2ludFxuICAgICAgICAgICAgICAgIC8vIEltcG9ydGFudCBwYXJ0IGZvciBjb25zdC10aW1lIGdldFB1YmxpY0tleTogYWRkIHJhbmRvbSBcIm5vaXNlXCIgcG9pbnQgdG8gZi5cbiAgICAgICAgICAgICAgICBmID0gZi5hZGQobmVnYXRlQ3QoaXNOZWdGLCBwcmVjb21wdXRlc1tvZmZzZXRGXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gYml0cyBhcmUgMTogYWRkIHRvIHJlc3VsdCBwb2ludFxuICAgICAgICAgICAgICAgIHAgPSBwLmFkZChuZWdhdGVDdChpc05lZywgcHJlY29tcHV0ZXNbb2Zmc2V0XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFzc2VydDAobik7XG4gICAgICAgIC8vIFJldHVybiBib3RoIHJlYWwgYW5kIGZha2UgcG9pbnRzOiBKSVQgd29uJ3QgZWxpbWluYXRlIGYuXG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQgdGhlcmUgaXMgYSB3YXkgdG8gRiBiZSBpbmZpbml0eS1wb2ludCBldmVuIGlmIHAgaXMgbm90LFxuICAgICAgICAvLyB3aGljaCBtYWtlcyBpdCBsZXNzIGNvbnN0LXRpbWU6IGFyb3VuZCAxIGJpZ2ludCBtdWx0aXBseS5cbiAgICAgICAgcmV0dXJuIHsgcCwgZiB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIGVjIHVuc2FmZSAobm9uIGNvbnN0LXRpbWUpIG11bHRpcGxpY2F0aW9uIHVzaW5nIHByZWNvbXB1dGVkIHRhYmxlcyBhbmQgdy1hcnkgbm9uLWFkamFjZW50IGZvcm0uXG4gICAgICogQHBhcmFtIGFjYyBhY2N1bXVsYXRvciBwb2ludCB0byBhZGQgcmVzdWx0IG9mIG11bHRpcGxpY2F0aW9uXG4gICAgICogQHJldHVybnMgcG9pbnRcbiAgICAgKi9cbiAgICB3TkFGVW5zYWZlKFcsIHByZWNvbXB1dGVzLCBuLCBhY2MgPSB0aGlzLlpFUk8pIHtcbiAgICAgICAgY29uc3Qgd28gPSBjYWxjV09wdHMoVywgdGhpcy5iaXRzKTtcbiAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd28ud2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgIGlmIChuID09PSBfMG4pXG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIEVhcmx5LWV4aXQsIHNraXAgMCB2YWx1ZVxuICAgICAgICAgICAgY29uc3QgeyBuZXh0Tiwgb2Zmc2V0LCBpc1plcm8sIGlzTmVnIH0gPSBjYWxjT2Zmc2V0cyhuLCB3aW5kb3csIHdvKTtcbiAgICAgICAgICAgIG4gPSBuZXh0TjtcbiAgICAgICAgICAgIGlmIChpc1plcm8pIHtcbiAgICAgICAgICAgICAgICAvLyBXaW5kb3cgYml0cyBhcmUgMDogc2tpcCBwcm9jZXNzaW5nLlxuICAgICAgICAgICAgICAgIC8vIE1vdmUgdG8gbmV4dCB3aW5kb3cuXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gcHJlY29tcHV0ZXNbb2Zmc2V0XTtcbiAgICAgICAgICAgICAgICBhY2MgPSBhY2MuYWRkKGlzTmVnID8gaXRlbS5uZWdhdGUoKSA6IGl0ZW0pOyAvLyBSZS11c2luZyBhY2MgYWxsb3dzIHRvIHNhdmUgYWRkcyBpbiBNU01cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQwKG4pO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH1cbiAgICBnZXRQcmVjb21wdXRlcyhXLCBwb2ludCwgdHJhbnNmb3JtKSB7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBwcmVjb21wdXRlcyBvbiBhIGZpcnN0IHJ1biwgcmV1c2UgdGhlbSBhZnRlclxuICAgICAgICBsZXQgY29tcCA9IHBvaW50UHJlY29tcHV0ZXMuZ2V0KHBvaW50KTtcbiAgICAgICAgaWYgKCFjb21wKSB7XG4gICAgICAgICAgICBjb21wID0gdGhpcy5wcmVjb21wdXRlV2luZG93KHBvaW50LCBXKTtcbiAgICAgICAgICAgIGlmIChXICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gRG9pbmcgdHJhbnNmb3JtIG91dHNpZGUgb2YgaWYgYnJpbmdzIDE1JSBwZXJmIGhpdFxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgICAgICAgICBjb21wID0gdHJhbnNmb3JtKGNvbXApO1xuICAgICAgICAgICAgICAgIHBvaW50UHJlY29tcHV0ZXMuc2V0KHBvaW50LCBjb21wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcDtcbiAgICB9XG4gICAgY2FjaGVkKHBvaW50LCBzY2FsYXIsIHRyYW5zZm9ybSkge1xuICAgICAgICBjb25zdCBXID0gZ2V0Vyhwb2ludCk7XG4gICAgICAgIHJldHVybiB0aGlzLndOQUYoVywgdGhpcy5nZXRQcmVjb21wdXRlcyhXLCBwb2ludCwgdHJhbnNmb3JtKSwgc2NhbGFyKTtcbiAgICB9XG4gICAgdW5zYWZlKHBvaW50LCBzY2FsYXIsIHRyYW5zZm9ybSwgcHJldikge1xuICAgICAgICBjb25zdCBXID0gZ2V0Vyhwb2ludCk7XG4gICAgICAgIGlmIChXID09PSAxKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Vuc2FmZUxhZGRlcihwb2ludCwgc2NhbGFyLCBwcmV2KTsgLy8gRm9yIFc9MSBsYWRkZXIgaXMgfngyIGZhc3RlclxuICAgICAgICByZXR1cm4gdGhpcy53TkFGVW5zYWZlKFcsIHRoaXMuZ2V0UHJlY29tcHV0ZXMoVywgcG9pbnQsIHRyYW5zZm9ybSksIHNjYWxhciwgcHJldik7XG4gICAgfVxuICAgIC8vIFdlIGNhbGN1bGF0ZSBwcmVjb21wdXRlcyBmb3IgZWxsaXB0aWMgY3VydmUgcG9pbnQgbXVsdGlwbGljYXRpb25cbiAgICAvLyB1c2luZyB3aW5kb3dlZCBtZXRob2QuIFRoaXMgc3BlY2lmaWVzIHdpbmRvdyBzaXplIGFuZFxuICAgIC8vIHN0b3JlcyBwcmVjb21wdXRlZCB2YWx1ZXMuIFVzdWFsbHkgb25seSBiYXNlIHBvaW50IHdvdWxkIGJlIHByZWNvbXB1dGVkLlxuICAgIGNyZWF0ZUNhY2hlKFAsIFcpIHtcbiAgICAgICAgdmFsaWRhdGVXKFcsIHRoaXMuYml0cyk7XG4gICAgICAgIHBvaW50V2luZG93U2l6ZXMuc2V0KFAsIFcpO1xuICAgICAgICBwb2ludFByZWNvbXB1dGVzLmRlbGV0ZShQKTtcbiAgICB9XG4gICAgaGFzQ2FjaGUoZWxtKSB7XG4gICAgICAgIHJldHVybiBnZXRXKGVsbSkgIT09IDE7XG4gICAgfVxufVxuLyoqXG4gKiBFbmRvbW9ycGhpc20tc3BlY2lmaWMgbXVsdGlwbGljYXRpb24gZm9yIEtvYmxpdHogY3VydmVzLlxuICogQ29zdDogMTI4IGRibCwgMC0yNTYgYWRkcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bEVuZG9VbnNhZmUoUG9pbnQsIHBvaW50LCBrMSwgazIpIHtcbiAgICBsZXQgYWNjID0gcG9pbnQ7XG4gICAgbGV0IHAxID0gUG9pbnQuWkVSTztcbiAgICBsZXQgcDIgPSBQb2ludC5aRVJPO1xuICAgIHdoaWxlIChrMSA+IF8wbiB8fCBrMiA+IF8wbikge1xuICAgICAgICBpZiAoazEgJiBfMW4pXG4gICAgICAgICAgICBwMSA9IHAxLmFkZChhY2MpO1xuICAgICAgICBpZiAoazIgJiBfMW4pXG4gICAgICAgICAgICBwMiA9IHAyLmFkZChhY2MpO1xuICAgICAgICBhY2MgPSBhY2MuZG91YmxlKCk7XG4gICAgICAgIGsxID4+PSBfMW47XG4gICAgICAgIGsyID4+PSBfMW47XG4gICAgfVxuICAgIHJldHVybiB7IHAxLCBwMiB9O1xufVxuLyoqXG4gKiBQaXBwZW5nZXIgYWxnb3JpdGhtIGZvciBtdWx0aS1zY2FsYXIgbXVsdGlwbGljYXRpb24gKE1TTSwgUGEgKyBRYiArIFJjICsgLi4uKS5cbiAqIDMweCBmYXN0ZXIgdnMgbmFpdmUgYWRkaXRpb24gb24gTD00MDk2LCAxMHggZmFzdGVyIHRoYW4gcHJlY29tcHV0ZXMuXG4gKiBGb3IgTj0yNTRiaXQsIEw9MSwgaXQgZG9lczogMTAyNCBBREQgKyAyNTQgREJMLiBGb3IgTD01OiAxNTM2IEFERCArIDI1NCBEQkwuXG4gKiBBbGdvcml0aG1pY2FsbHkgY29uc3RhbnQtdGltZSAoZm9yIHNhbWUgTCksIGV2ZW4gd2hlbiAxIHBvaW50ICsgc2NhbGFyLCBvciB3aGVuIHNjYWxhciA9IDAuXG4gKiBAcGFyYW0gYyBDdXJ2ZSBQb2ludCBjb25zdHJ1Y3RvclxuICogQHBhcmFtIGZpZWxkTiBmaWVsZCBvdmVyIENVUlZFLk4gLSBpbXBvcnRhbnQgdGhhdCBpdCdzIG5vdCBvdmVyIENVUlZFLlBcbiAqIEBwYXJhbSBwb2ludHMgYXJyYXkgb2YgTCBjdXJ2ZSBwb2ludHNcbiAqIEBwYXJhbSBzY2FsYXJzIGFycmF5IG9mIEwgc2NhbGFycyAoYWthIHNlY3JldCBrZXlzIC8gYmlnaW50cylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBpcHBlbmdlcihjLCBmaWVsZE4sIHBvaW50cywgc2NhbGFycykge1xuICAgIC8vIElmIHdlIHNwbGl0IHNjYWxhcnMgYnkgc29tZSB3aW5kb3cgKGxldCdzIHNheSA4IGJpdHMpLCBldmVyeSBjaHVuayB3aWxsIG9ubHlcbiAgICAvLyB0YWtlIDI1NiBidWNrZXRzIGV2ZW4gaWYgdGhlcmUgYXJlIDQwOTYgc2NhbGFycywgYWxzbyByZS11c2VzIGRvdWJsZS5cbiAgICAvLyBUT0RPOlxuICAgIC8vIC0gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAyNC83NTAucGRmXG4gICAgLy8gLSBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvMTAyODdcbiAgICAvLyAwIGlzIGFjY2VwdGVkIGluIHNjYWxhcnNcbiAgICB2YWxpZGF0ZU1TTVBvaW50cyhwb2ludHMsIGMpO1xuICAgIHZhbGlkYXRlTVNNU2NhbGFycyhzY2FsYXJzLCBmaWVsZE4pO1xuICAgIGNvbnN0IHBsZW5ndGggPSBwb2ludHMubGVuZ3RoO1xuICAgIGNvbnN0IHNsZW5ndGggPSBzY2FsYXJzLmxlbmd0aDtcbiAgICBpZiAocGxlbmd0aCAhPT0gc2xlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheXMgb2YgcG9pbnRzIGFuZCBzY2FsYXJzIG11c3QgaGF2ZSBlcXVhbCBsZW5ndGgnKTtcbiAgICAvLyBpZiAocGxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBtdXN0IGJlIG9mIGxlbmd0aCA+PSAyJyk7XG4gICAgY29uc3QgemVybyA9IGMuWkVSTztcbiAgICBjb25zdCB3Yml0cyA9IGJpdExlbihCaWdJbnQocGxlbmd0aCkpO1xuICAgIGxldCB3aW5kb3dTaXplID0gMTsgLy8gYml0c1xuICAgIGlmICh3Yml0cyA+IDEyKVxuICAgICAgICB3aW5kb3dTaXplID0gd2JpdHMgLSAzO1xuICAgIGVsc2UgaWYgKHdiaXRzID4gNClcbiAgICAgICAgd2luZG93U2l6ZSA9IHdiaXRzIC0gMjtcbiAgICBlbHNlIGlmICh3Yml0cyA+IDApXG4gICAgICAgIHdpbmRvd1NpemUgPSAyO1xuICAgIGNvbnN0IE1BU0sgPSBiaXRNYXNrKHdpbmRvd1NpemUpO1xuICAgIGNvbnN0IGJ1Y2tldHMgPSBuZXcgQXJyYXkoTnVtYmVyKE1BU0spICsgMSkuZmlsbCh6ZXJvKTsgLy8gKzEgZm9yIHplcm8gYXJyYXlcbiAgICBjb25zdCBsYXN0Qml0cyA9IE1hdGguZmxvb3IoKGZpZWxkTi5CSVRTIC0gMSkgLyB3aW5kb3dTaXplKSAqIHdpbmRvd1NpemU7XG4gICAgbGV0IHN1bSA9IHplcm87XG4gICAgZm9yIChsZXQgaSA9IGxhc3RCaXRzOyBpID49IDA7IGkgLT0gd2luZG93U2l6ZSkge1xuICAgICAgICBidWNrZXRzLmZpbGwoemVybyk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2xlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBzY2FsYXIgPSBzY2FsYXJzW2pdO1xuICAgICAgICAgICAgY29uc3Qgd2JpdHMgPSBOdW1iZXIoKHNjYWxhciA+PiBCaWdJbnQoaSkpICYgTUFTSyk7XG4gICAgICAgICAgICBidWNrZXRzW3diaXRzXSA9IGJ1Y2tldHNbd2JpdHNdLmFkZChwb2ludHNbal0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNJID0gemVybzsgLy8gbm90IHVzaW5nIHRoaXMgd2lsbCBkbyBzbWFsbCBzcGVlZC11cCwgYnV0IHdpbGwgbG9zZSBjdFxuICAgICAgICAvLyBTa2lwIGZpcnN0IGJ1Y2tldCwgYmVjYXVzZSBpdCBpcyB6ZXJvXG4gICAgICAgIGZvciAobGV0IGogPSBidWNrZXRzLmxlbmd0aCAtIDEsIHN1bUkgPSB6ZXJvOyBqID4gMDsgai0tKSB7XG4gICAgICAgICAgICBzdW1JID0gc3VtSS5hZGQoYnVja2V0c1tqXSk7XG4gICAgICAgICAgICByZXNJID0gcmVzSS5hZGQoc3VtSSk7XG4gICAgICAgIH1cbiAgICAgICAgc3VtID0gc3VtLmFkZChyZXNJKTtcbiAgICAgICAgaWYgKGkgIT09IDApXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpbmRvd1NpemU7IGorKylcbiAgICAgICAgICAgICAgICBzdW0gPSBzdW0uZG91YmxlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59XG4vKipcbiAqIFByZWNvbXB1dGVkIG11bHRpLXNjYWxhciBtdWx0aXBsaWNhdGlvbiAoTVNNLCBQYSArIFFiICsgUmMgKyAuLi4pLlxuICogQHBhcmFtIGMgQ3VydmUgUG9pbnQgY29uc3RydWN0b3JcbiAqIEBwYXJhbSBmaWVsZE4gZmllbGQgb3ZlciBDVVJWRS5OIC0gaW1wb3J0YW50IHRoYXQgaXQncyBub3Qgb3ZlciBDVVJWRS5QXG4gKiBAcGFyYW0gcG9pbnRzIGFycmF5IG9mIEwgY3VydmUgcG9pbnRzXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB3aGljaCBtdWx0aXBsaWVzIHBvaW50cyB3aXRoIHNjYWFyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJlY29tcHV0ZU1TTVVuc2FmZShjLCBmaWVsZE4sIHBvaW50cywgd2luZG93U2l6ZSkge1xuICAgIC8qKlxuICAgICAqIFBlcmZvcm1hbmNlIEFuYWx5c2lzIG9mIFdpbmRvdy1iYXNlZCBQcmVjb21wdXRhdGlvblxuICAgICAqXG4gICAgICogQmFzZSBDYXNlICgyNTYtYml0IHNjYWxhciwgOC1iaXQgd2luZG93KTpcbiAgICAgKiAtIFN0YW5kYXJkIHByZWNvbXB1dGF0aW9uIHJlcXVpcmVzOlxuICAgICAqICAgLSAzMSBhZGRpdGlvbnMgcGVyIHNjYWxhciDDlyAyNTYgc2NhbGFycyA9IDcsOTM2IG9wc1xuICAgICAqICAgLSBQbHVzIDI1NSBzdW1tYXJ5IGFkZGl0aW9ucyA9IDgsMTkxIHRvdGFsIG9wc1xuICAgICAqICAgTm90ZTogU3VtbWFyeSBhZGRpdGlvbnMgY2FuIGJlIG9wdGltaXplZCB2aWEgYWNjdW11bGF0b3JcbiAgICAgKlxuICAgICAqIENodW5rZWQgUHJlY29tcHV0YXRpb24gQW5hbHlzaXM6XG4gICAgICogLSBVc2luZyAzMiBjaHVua3MgcmVxdWlyZXM6XG4gICAgICogICAtIDI1NSBhZGRpdGlvbnMgcGVyIGNodW5rXG4gICAgICogICAtIDI1NiBkb3VibGluZ3NcbiAgICAgKiAgIC0gVG90YWw6ICgyNTUgw5cgMzIpICsgMjU2ID0gOCw0MTYgb3BzXG4gICAgICpcbiAgICAgKiBNZW1vcnkgVXNhZ2UgQ29tcGFyaXNvbjpcbiAgICAgKiBXaW5kb3cgU2l6ZSB8IFN0YW5kYXJkIFBvaW50cyB8IENodW5rZWQgUG9pbnRzXG4gICAgICogLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLVxuICAgICAqICAgICA0LWJpdCAgIHwgICAgIDUyMCAgICAgICAgIHwgICAgICAxNVxuICAgICAqICAgICA4LWJpdCAgIHwgICAgNCwyMjQgICAgICAgIHwgICAgIDI1NVxuICAgICAqICAgIDEwLWJpdCAgIHwgICAxMyw4MjQgICAgICAgIHwgICAxLDAyM1xuICAgICAqICAgIDE2LWJpdCAgIHwgIDU1NywwNTYgICAgICAgIHwgIDY1LDUzNVxuICAgICAqXG4gICAgICogS2V5IEFkdmFudGFnZXM6XG4gICAgICogMS4gRW5hYmxlcyBsYXJnZXIgd2luZG93IHNpemVzIGR1ZSB0byByZWR1Y2VkIG1lbW9yeSBvdmVyaGVhZFxuICAgICAqIDIuIE1vcmUgZWZmaWNpZW50IGZvciBzbWFsbGVyIHNjYWxhciBjb3VudHM6XG4gICAgICogICAgLSAxNiBjaHVua3M6ICgxNiDDlyAyNTUpICsgMjU2ID0gNCwzMzYgb3BzXG4gICAgICogICAgLSB+MnggZmFzdGVyIHRoYW4gc3RhbmRhcmQgOCwxOTEgb3BzXG4gICAgICpcbiAgICAgKiBMaW1pdGF0aW9uczpcbiAgICAgKiAtIE5vdCBzdWl0YWJsZSBmb3IgcGxhaW4gcHJlY29tcHV0ZXMgKHJlcXVpcmVzIDI1NiBjb25zdGFudCBkb3VibGluZ3MpXG4gICAgICogLSBQZXJmb3JtYW5jZSBkZWdyYWRlcyB3aXRoIGxhcmdlciBzY2FsYXIgY291bnRzOlxuICAgICAqICAgLSBPcHRpbWFsIGZvciB+MjU2IHNjYWxhcnNcbiAgICAgKiAgIC0gTGVzcyBlZmZpY2llbnQgZm9yIDQwOTYrIHNjYWxhcnMgKFBpcHBlbmdlciBwcmVmZXJyZWQpXG4gICAgICovXG4gICAgdmFsaWRhdGVXKHdpbmRvd1NpemUsIGZpZWxkTi5CSVRTKTtcbiAgICB2YWxpZGF0ZU1TTVBvaW50cyhwb2ludHMsIGMpO1xuICAgIGNvbnN0IHplcm8gPSBjLlpFUk87XG4gICAgY29uc3QgdGFibGVTaXplID0gMiAqKiB3aW5kb3dTaXplIC0gMTsgLy8gdGFibGUgc2l6ZSAod2l0aG91dCB6ZXJvKVxuICAgIGNvbnN0IGNodW5rcyA9IE1hdGguY2VpbChmaWVsZE4uQklUUyAvIHdpbmRvd1NpemUpOyAvLyBjaHVua3Mgb2YgaXRlbVxuICAgIGNvbnN0IE1BU0sgPSBiaXRNYXNrKHdpbmRvd1NpemUpO1xuICAgIGNvbnN0IHRhYmxlcyA9IHBvaW50cy5tYXAoKHApID0+IHtcbiAgICAgICAgY29uc3QgcmVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBhY2MgPSBwOyBpIDwgdGFibGVTaXplOyBpKyspIHtcbiAgICAgICAgICAgIHJlcy5wdXNoKGFjYyk7XG4gICAgICAgICAgICBhY2MgPSBhY2MuYWRkKHApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSk7XG4gICAgcmV0dXJuIChzY2FsYXJzKSA9PiB7XG4gICAgICAgIHZhbGlkYXRlTVNNU2NhbGFycyhzY2FsYXJzLCBmaWVsZE4pO1xuICAgICAgICBpZiAoc2NhbGFycy5sZW5ndGggPiBwb2ludHMubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBvZiBzY2FsYXJzIG11c3QgYmUgc21hbGxlciB0aGFuIGFycmF5IG9mIHBvaW50cycpO1xuICAgICAgICBsZXQgcmVzID0gemVybztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaHVua3M7IGkrKykge1xuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBkb3VibGUgaWYgYWNjdW11bGF0b3IgaXMgc3RpbGwgemVyby5cbiAgICAgICAgICAgIGlmIChyZXMgIT09IHplcm8pXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB3aW5kb3dTaXplOyBqKyspXG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5kb3VibGUoKTtcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoY2h1bmtzICogd2luZG93U2l6ZSAtIChpICsgMSkgKiB3aW5kb3dTaXplKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2NhbGFycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG4gPSBzY2FsYXJzW2pdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnIgPSBOdW1iZXIoKG4gPj4gc2hpZnRCeSkgJiBNQVNLKTtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnIpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBza2lwIHplcm8gc2NhbGFycyBjaHVua3NcbiAgICAgICAgICAgICAgICByZXMgPSByZXMuYWRkKHRhYmxlc1tqXVtjdXJyIC0gMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbn1cbi8vIFRPRE86IHJlbW92ZVxuLyoqIEBkZXByZWNhdGVkICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVCYXNpYyhjdXJ2ZSkge1xuICAgIHZhbGlkYXRlRmllbGQoY3VydmUuRnApO1xuICAgIHZhbGlkYXRlT2JqZWN0KGN1cnZlLCB7XG4gICAgICAgIG46ICdiaWdpbnQnLFxuICAgICAgICBoOiAnYmlnaW50JyxcbiAgICAgICAgR3g6ICdmaWVsZCcsXG4gICAgICAgIEd5OiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgbkJpdExlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBuQnl0ZUxlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgIH0pO1xuICAgIC8vIFNldCBkZWZhdWx0c1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgLi4ubkxlbmd0aChjdXJ2ZS5uLCBjdXJ2ZS5uQml0TGVuZ3RoKSxcbiAgICAgICAgLi4uY3VydmUsXG4gICAgICAgIC4uLnsgcDogY3VydmUuRnAuT1JERVIgfSxcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpZWxkKG9yZGVyLCBmaWVsZCwgaXNMRSkge1xuICAgIGlmIChmaWVsZCkge1xuICAgICAgICBpZiAoZmllbGQuT1JERVIgIT09IG9yZGVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWVsZC5PUkRFUiBtdXN0IG1hdGNoIG9yZGVyOiBGcCA9PSBwLCBGbiA9PSBuJyk7XG4gICAgICAgIHZhbGlkYXRlRmllbGQoZmllbGQpO1xuICAgICAgICByZXR1cm4gZmllbGQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gRmllbGQob3JkZXIsIHsgaXNMRSB9KTtcbiAgICB9XG59XG4vKiogVmFsaWRhdGVzIENVUlZFIG9wdHMgYW5kIGNyZWF0ZXMgZmllbGRzICovXG5leHBvcnQgZnVuY3Rpb24gX2NyZWF0ZUN1cnZlRmllbGRzKHR5cGUsIENVUlZFLCBjdXJ2ZU9wdHMgPSB7fSwgRnBGbkxFKSB7XG4gICAgaWYgKEZwRm5MRSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICBGcEZuTEUgPSB0eXBlID09PSAnZWR3YXJkcyc7XG4gICAgaWYgKCFDVVJWRSB8fCB0eXBlb2YgQ1VSVkUgIT09ICdvYmplY3QnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGV4cGVjdGVkIHZhbGlkICR7dHlwZX0gQ1VSVkUgb2JqZWN0YCk7XG4gICAgZm9yIChjb25zdCBwIG9mIFsncCcsICduJywgJ2gnXSkge1xuICAgICAgICBjb25zdCB2YWwgPSBDVVJWRVtwXTtcbiAgICAgICAgaWYgKCEodHlwZW9mIHZhbCA9PT0gJ2JpZ2ludCcgJiYgdmFsID4gXzBuKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ1VSVkUuJHtwfSBtdXN0IGJlIHBvc2l0aXZlIGJpZ2ludGApO1xuICAgIH1cbiAgICBjb25zdCBGcCA9IGNyZWF0ZUZpZWxkKENVUlZFLnAsIGN1cnZlT3B0cy5GcCwgRnBGbkxFKTtcbiAgICBjb25zdCBGbiA9IGNyZWF0ZUZpZWxkKENVUlZFLm4sIGN1cnZlT3B0cy5GbiwgRnBGbkxFKTtcbiAgICBjb25zdCBfYiA9IHR5cGUgPT09ICd3ZWllcnN0cmFzcycgPyAnYicgOiAnZCc7XG4gICAgY29uc3QgcGFyYW1zID0gWydHeCcsICdHeScsICdhJywgX2JdO1xuICAgIGZvciAoY29uc3QgcCBvZiBwYXJhbXMpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoIUZwLmlzVmFsaWQoQ1VSVkVbcF0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDVVJWRS4ke3B9IG11c3QgYmUgdmFsaWQgZmllbGQgZWxlbWVudCBvZiBDVVJWRS5GcGApO1xuICAgIH1cbiAgICBDVVJWRSA9IE9iamVjdC5mcmVlemUoT2JqZWN0LmFzc2lnbih7fSwgQ1VSVkUpKTtcbiAgICByZXR1cm4geyBDVVJWRSwgRnAsIEZuIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXJ2ZS5qcy5tYXAiXSwibmFtZXMiOlsiYml0TGVuIiwiYml0TWFzayIsInZhbGlkYXRlT2JqZWN0IiwiRmllbGQiLCJGcEludmVydEJhdGNoIiwibkxlbmd0aCIsInZhbGlkYXRlRmllbGQiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJuZWdhdGVDdCIsImNvbmRpdGlvbiIsIml0ZW0iLCJuZWciLCJuZWdhdGUiLCJub3JtYWxpemVaIiwiYyIsInBvaW50cyIsImludmVydGVkWnMiLCJGcCIsIm1hcCIsInAiLCJaIiwiaSIsImZyb21BZmZpbmUiLCJ0b0FmZmluZSIsInZhbGlkYXRlVyIsIlciLCJiaXRzIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsIkVycm9yIiwiY2FsY1dPcHRzIiwic2NhbGFyQml0cyIsIndpbmRvd3MiLCJNYXRoIiwiY2VpbCIsIndpbmRvd1NpemUiLCJtYXhOdW1iZXIiLCJtYXNrIiwic2hpZnRCeSIsImNhbGNPZmZzZXRzIiwibiIsIndpbmRvdyIsIndPcHRzIiwid2JpdHMiLCJuZXh0TiIsIm9mZnNldFN0YXJ0Iiwib2Zmc2V0IiwiYWJzIiwiaXNaZXJvIiwiaXNOZWciLCJpc05lZ0YiLCJvZmZzZXRGIiwidmFsaWRhdGVNU01Qb2ludHMiLCJBcnJheSIsImlzQXJyYXkiLCJmb3JFYWNoIiwidmFsaWRhdGVNU01TY2FsYXJzIiwic2NhbGFycyIsImZpZWxkIiwicyIsImlzVmFsaWQiLCJwb2ludFByZWNvbXB1dGVzIiwiV2Vha01hcCIsInBvaW50V2luZG93U2l6ZXMiLCJnZXRXIiwiUCIsImdldCIsImFzc2VydDAiLCJ3TkFGIiwiY29uc3RydWN0b3IiLCJQb2ludCIsIkJBU0UiLCJaRVJPIiwiRm4iLCJfdW5zYWZlTGFkZGVyIiwiZWxtIiwiZCIsImFkZCIsImRvdWJsZSIsInByZWNvbXB1dGVXaW5kb3ciLCJwb2ludCIsImJhc2UiLCJwdXNoIiwicHJlY29tcHV0ZXMiLCJmIiwid28iLCJ3TkFGVW5zYWZlIiwiYWNjIiwiZ2V0UHJlY29tcHV0ZXMiLCJ0cmFuc2Zvcm0iLCJjb21wIiwic2V0IiwiY2FjaGVkIiwic2NhbGFyIiwidW5zYWZlIiwicHJldiIsImNyZWF0ZUNhY2hlIiwiZGVsZXRlIiwiaGFzQ2FjaGUiLCJtdWxFbmRvVW5zYWZlIiwiazEiLCJrMiIsInAxIiwicDIiLCJwaXBwZW5nZXIiLCJmaWVsZE4iLCJwbGVuZ3RoIiwibGVuZ3RoIiwic2xlbmd0aCIsInplcm8iLCJNQVNLIiwiYnVja2V0cyIsImZpbGwiLCJsYXN0Qml0cyIsImZsb29yIiwiQklUUyIsInN1bSIsImoiLCJyZXNJIiwic3VtSSIsInByZWNvbXB1dGVNU01VbnNhZmUiLCJ0YWJsZVNpemUiLCJjaHVua3MiLCJ0YWJsZXMiLCJyZXMiLCJjdXJyIiwidmFsaWRhdGVCYXNpYyIsImN1cnZlIiwiaCIsIkd4IiwiR3kiLCJuQml0TGVuZ3RoIiwibkJ5dGVMZW5ndGgiLCJPYmplY3QiLCJmcmVlemUiLCJPUkRFUiIsImNyZWF0ZUZpZWxkIiwib3JkZXIiLCJpc0xFIiwiX2NyZWF0ZUN1cnZlRmllbGRzIiwidHlwZSIsIkNVUlZFIiwiY3VydmVPcHRzIiwiRnBGbkxFIiwidW5kZWZpbmVkIiwidmFsIiwiX2IiLCJwYXJhbXMiLCJhc3NpZ24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/edwards.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/edwards.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PrimeEdwardsPoint: () => (/* binding */ PrimeEdwardsPoint),\n/* harmony export */   eddsa: () => (/* binding */ eddsa),\n/* harmony export */   edwards: () => (/* binding */ edwards),\n/* harmony export */   twistedEdwards: () => (/* binding */ twistedEdwards)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/utils.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/curve.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/modular.js\");\n/**\n * Twisted Edwards curve. The formula is: ax² + y² = 1 + dx²y².\n * For design rationale of types / exports, see weierstrass module documentation.\n * Untwisted Edwards curves exist, but they aren't used in real-world protocols.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\nfunction isEdValidXY(Fp, CURVE, x, y) {\n    const x2 = Fp.sqr(x);\n    const y2 = Fp.sqr(y);\n    const left = Fp.add(Fp.mul(CURVE.a, x2), y2);\n    const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));\n    return Fp.eql(left, right);\n}\nfunction edwards(params, extraOpts = {}) {\n    const validated = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__._createCurveFields)(\"edwards\", params, extraOpts, extraOpts.FpFnLE);\n    const { Fp, Fn } = validated;\n    let CURVE = validated.CURVE;\n    const { h: cofactor } = CURVE;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__._validateObject)(extraOpts, {}, {\n        uvRatio: \"function\"\n    });\n    // Important:\n    // There are some places where Fp.BYTES is used instead of nByteLength.\n    // So far, everything has been tested with curves of Fp.BYTES == nByteLength.\n    // TODO: test and find curves which behave otherwise.\n    const MASK = _2n << BigInt(Fn.BYTES * 8) - _1n;\n    const modP = (n)=>Fp.create(n); // Function overrides\n    // sqrt(u/v)\n    const uvRatio = extraOpts.uvRatio || ((u, v)=>{\n        try {\n            return {\n                isValid: true,\n                value: Fp.sqrt(Fp.div(u, v))\n            };\n        } catch (e) {\n            return {\n                isValid: false,\n                value: _0n\n            };\n        }\n    });\n    // Validate whether the passed curve params are valid.\n    // equation ax² + y² = 1 + dx²y² should work for generator point.\n    if (!isEdValidXY(Fp, CURVE, CURVE.Gx, CURVE.Gy)) throw new Error(\"bad curve params: generator point\");\n    /**\n     * Asserts coordinate is valid: 0 <= n < MASK.\n     * Coordinates >= Fp.ORDER are allowed for zip215.\n     */ function acoord(title, n, banZero = false) {\n        const min = banZero ? _1n : _0n;\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.aInRange)(\"coordinate \" + title, n, min, MASK);\n        return n;\n    }\n    function aextpoint(other) {\n        if (!(other instanceof Point)) throw new Error(\"ExtendedPoint expected\");\n    }\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    const toAffineMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.memoized)((p, iz)=>{\n        const { X, Y, Z } = p;\n        const is0 = p.is0();\n        if (iz == null) iz = is0 ? _8n : Fp.inv(Z); // 8 was chosen arbitrarily\n        const x = modP(X * iz);\n        const y = modP(Y * iz);\n        const zz = Fp.mul(Z, iz);\n        if (is0) return {\n            x: _0n,\n            y: _1n\n        };\n        if (zz !== _1n) throw new Error(\"invZ was invalid\");\n        return {\n            x,\n            y\n        };\n    });\n    const assertValidMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.memoized)((p)=>{\n        const { a, d } = CURVE;\n        if (p.is0()) throw new Error(\"bad point: ZERO\"); // TODO: optimize, with vars below?\n        // Equation in affine coordinates: ax² + y² = 1 + dx²y²\n        // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX² + Y²)Z² = Z⁴ + dX²Y²\n        const { X, Y, Z, T } = p;\n        const X2 = modP(X * X); // X²\n        const Y2 = modP(Y * Y); // Y²\n        const Z2 = modP(Z * Z); // Z²\n        const Z4 = modP(Z2 * Z2); // Z⁴\n        const aX2 = modP(X2 * a); // aX²\n        const left = modP(Z2 * modP(aX2 + Y2)); // (aX² + Y²)Z²\n        const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z⁴ + dX²Y²\n        if (left !== right) throw new Error(\"bad point: equation left != right (1)\");\n        // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n        const XY = modP(X * Y);\n        const ZT = modP(Z * T);\n        if (XY !== ZT) throw new Error(\"bad point: equation left != right (2)\");\n        return true;\n    });\n    // Extended Point works in extended coordinates: (X, Y, Z, T) ∋ (x=X/Z, y=Y/Z, T=xy).\n    // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n    class Point {\n        constructor(X, Y, Z, T){\n            this.X = acoord(\"x\", X);\n            this.Y = acoord(\"y\", Y);\n            this.Z = acoord(\"z\", Z, true);\n            this.T = acoord(\"t\", T);\n            Object.freeze(this);\n        }\n        static CURVE() {\n            return CURVE;\n        }\n        static fromAffine(p) {\n            if (p instanceof Point) throw new Error(\"extended point not allowed\");\n            const { x, y } = p || {};\n            acoord(\"x\", x);\n            acoord(\"y\", y);\n            return new Point(x, y, _1n, modP(x * y));\n        }\n        // Uses algo from RFC8032 5.1.3.\n        static fromBytes(bytes, zip215 = false) {\n            const len = Fp.BYTES;\n            const { a, d } = CURVE;\n            bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.copyBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__._abytes2)(bytes, len, \"point\"));\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__._abool2)(zip215, \"zip215\");\n            const normed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.copyBytes)(bytes); // copy again, we'll manipulate it\n            const lastByte = bytes[len - 1]; // select last byte\n            normed[len - 1] = lastByte & ~0x80; // clear last bit\n            const y = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE)(normed);\n            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n            // RFC8032 prohibits >= p, but ZIP215 doesn't\n            // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n            // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n            const max = zip215 ? MASK : Fp.ORDER;\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.aInRange)(\"point.y\", y, _0n, max);\n            // Ed25519: x² = (y²-1)/(dy²+1) mod p. Ed448: x² = (y²-1)/(dy²-1) mod p. Generic case:\n            // ax²+y²=1+dx²y² => y²-1=dx²y²-ax² => y²-1=x²(dy²-a) => x²=(y²-1)/(dy²-a)\n            const y2 = modP(y * y); // denominator is always non-0 mod p.\n            const u = modP(y2 - _1n); // u = y² - 1\n            const v = modP(d * y2 - a); // v = d y² + 1.\n            let { isValid, value: x } = uvRatio(u, v); // √(u/v)\n            if (!isValid) throw new Error(\"bad point: invalid y coordinate\");\n            const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n            const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n            if (!zip215 && x === _0n && isLastByteOdd) // if x=0 and x_0 = 1, fail\n            throw new Error(\"bad point: x=0 and x_0=1\");\n            if (isLastByteOdd !== isXOdd) x = modP(-x); // if x_0 != x mod 2, set x = p-x\n            return Point.fromAffine({\n                x,\n                y\n            });\n        }\n        static fromHex(bytes, zip215 = false) {\n            return Point.fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"point\", bytes), zip215);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        precompute(windowSize = 8, isLazy = true) {\n            wnaf.createCache(this, windowSize);\n            if (!isLazy) this.multiply(_2n); // random number\n            return this;\n        }\n        // Useful in fromAffine() - not for fromBytes(), which always created valid points.\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        // Compare one point to another.\n        equals(other) {\n            aextpoint(other);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            const { X: X2, Y: Y2, Z: Z2 } = other;\n            const X1Z2 = modP(X1 * Z2);\n            const X2Z1 = modP(X2 * Z1);\n            const Y1Z2 = modP(Y1 * Z2);\n            const Y2Z1 = modP(Y2 * Z1);\n            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        negate() {\n            // Flips point sign to a negative one (-x, y in affine coords)\n            return new Point(modP(-this.X), this.Y, this.Z, modP(-this.T));\n        }\n        // Fast algo for doubling Extended Point.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n        // Cost: 4M + 4S + 1*a + 6add + 1*2.\n        double() {\n            const { a } = CURVE;\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            const A = modP(X1 * X1); // A = X12\n            const B = modP(Y1 * Y1); // B = Y12\n            const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n            const D = modP(a * A); // D = a*A\n            const x1y1 = X1 + Y1;\n            const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n            const G = D + B; // G = D+B\n            const F = G - C; // F = G-C\n            const H = D - B; // H = D-B\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        // Fast algo for adding 2 Extended Points.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n        // Cost: 9M + 1*a + 1*d + 7add.\n        add(other) {\n            aextpoint(other);\n            const { a, d } = CURVE;\n            const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;\n            const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;\n            const A = modP(X1 * X2); // A = X1*X2\n            const B = modP(Y1 * Y2); // B = Y1*Y2\n            const C = modP(T1 * d * T2); // C = T1*d*T2\n            const D = modP(Z1 * Z2); // D = Z1*Z2\n            const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n            const F = D - C; // F = D-C\n            const G = D + C; // G = D+C\n            const H = modP(B - a * A); // H = B-a*A\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        // Constant-time multiplication.\n        multiply(scalar) {\n            // 1 <= scalar < L\n            if (!Fn.isValidNot0(scalar)) throw new Error(\"invalid scalar: expected 1 <= sc < curve.n\");\n            const { p, f } = wnaf.cached(this, scalar, (p)=>(0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.normalizeZ)(Point, p));\n            return (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.normalizeZ)(Point, [\n                p,\n                f\n            ])[0];\n        }\n        // Non-constant-time multiplication. Uses double-and-add algorithm.\n        // It's faster, but should only be used when you don't care about\n        // an exposed private key e.g. sig verification.\n        // Does NOT allow scalars higher than CURVE.n.\n        // Accepts optional accumulator to merge with multiply (important for sparse scalars)\n        multiplyUnsafe(scalar, acc = Point.ZERO) {\n            // 0 <= scalar < L\n            if (!Fn.isValid(scalar)) throw new Error(\"invalid scalar: expected 0 <= sc < curve.n\");\n            if (scalar === _0n) return Point.ZERO;\n            if (this.is0() || scalar === _1n) return this;\n            return wnaf.unsafe(this, scalar, (p)=>(0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.normalizeZ)(Point, p), acc);\n        }\n        // Checks if point is of small order.\n        // If you add something to small order point, you will have \"dirty\"\n        // point with torsion component.\n        // Multiplies point by cofactor and checks if the result is 0.\n        isSmallOrder() {\n            return this.multiplyUnsafe(cofactor).is0();\n        }\n        // Multiplies point by curve order and checks if the result is 0.\n        // Returns `false` is the point is dirty.\n        isTorsionFree() {\n            return wnaf.unsafe(this, CURVE.n).is0();\n        }\n        // Converts Extended point to default (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        toAffine(invertedZ) {\n            return toAffineMemo(this, invertedZ);\n        }\n        clearCofactor() {\n            if (cofactor === _1n) return this;\n            return this.multiplyUnsafe(cofactor);\n        }\n        toBytes() {\n            const { x, y } = this.toAffine();\n            // Fp.toBytes() allows non-canonical encoding of y (>= p).\n            const bytes = Fp.toBytes(y);\n            // Each y has 2 valid points: (x, y), (x,-y).\n            // When compressing, it's enough to store y and use the last byte to encode sign of x\n            bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0;\n            return bytes;\n        }\n        toHex() {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.bytesToHex)(this.toBytes());\n        }\n        toString() {\n            return `<Point ${this.is0() ? \"ZERO\" : this.toHex()}>`;\n        }\n        // TODO: remove\n        get ex() {\n            return this.X;\n        }\n        get ey() {\n            return this.Y;\n        }\n        get ez() {\n            return this.Z;\n        }\n        get et() {\n            return this.T;\n        }\n        static normalizeZ(points) {\n            return (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.normalizeZ)(Point, points);\n        }\n        static msm(points, scalars) {\n            return (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.pippenger)(Point, Fn, points, scalars);\n        }\n        _setWindowSize(windowSize) {\n            this.precompute(windowSize);\n        }\n        toRawBytes() {\n            return this.toBytes();\n        }\n    }\n    // base / generator point\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    // zero / infinity / identity point\n    Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n    // math field\n    Point.Fp = Fp;\n    // scalar field\n    Point.Fn = Fn;\n    const wnaf = new _curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF(Point, Fn.BITS);\n    Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n    return Point;\n}\n/**\n * Base class for prime-order points like Ristretto255 and Decaf448.\n * These points eliminate cofactor issues by representing equivalence classes\n * of Edwards curve points.\n */ class PrimeEdwardsPoint {\n    constructor(ep){\n        this.ep = ep;\n    }\n    // Static methods that must be implemented by subclasses\n    static fromBytes(_bytes) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.notImplemented)();\n    }\n    static fromHex(_hex) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.notImplemented)();\n    }\n    get x() {\n        return this.toAffine().x;\n    }\n    get y() {\n        return this.toAffine().y;\n    }\n    // Common implementations\n    clearCofactor() {\n        // no-op for prime-order groups\n        return this;\n    }\n    assertValidity() {\n        this.ep.assertValidity();\n    }\n    toAffine(invertedZ) {\n        return this.ep.toAffine(invertedZ);\n    }\n    toHex() {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.bytesToHex)(this.toBytes());\n    }\n    toString() {\n        return this.toHex();\n    }\n    isTorsionFree() {\n        return true;\n    }\n    isSmallOrder() {\n        return false;\n    }\n    add(other) {\n        this.assertSame(other);\n        return this.init(this.ep.add(other.ep));\n    }\n    subtract(other) {\n        this.assertSame(other);\n        return this.init(this.ep.subtract(other.ep));\n    }\n    multiply(scalar) {\n        return this.init(this.ep.multiply(scalar));\n    }\n    multiplyUnsafe(scalar) {\n        return this.init(this.ep.multiplyUnsafe(scalar));\n    }\n    double() {\n        return this.init(this.ep.double());\n    }\n    negate() {\n        return this.init(this.ep.negate());\n    }\n    precompute(windowSize, isLazy) {\n        return this.init(this.ep.precompute(windowSize, isLazy));\n    }\n    /** @deprecated use `toBytes` */ toRawBytes() {\n        return this.toBytes();\n    }\n}\n/**\n * Initializes EdDSA signatures over given Edwards curve.\n */ function eddsa(Point, cHash, eddsaOpts = {}) {\n    if (typeof cHash !== \"function\") throw new Error('\"hash\" function param is required');\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__._validateObject)(eddsaOpts, {}, {\n        adjustScalarBytes: \"function\",\n        randomBytes: \"function\",\n        domain: \"function\",\n        prehash: \"function\",\n        mapToCurve: \"function\"\n    });\n    const { prehash } = eddsaOpts;\n    const { BASE, Fp, Fn } = Point;\n    const randomBytes = eddsaOpts.randomBytes || _utils_js__WEBPACK_IMPORTED_MODULE_2__.randomBytes;\n    const adjustScalarBytes = eddsaOpts.adjustScalarBytes || ((bytes)=>bytes);\n    const domain = eddsaOpts.domain || ((data, ctx, phflag)=>{\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__._abool2)(phflag, \"phflag\");\n        if (ctx.length || phflag) throw new Error(\"Contexts/pre-hash are not supported\");\n        return data;\n    }); // NOOP\n    // Little-endian SHA512 with modulo n\n    function modN_LE(hash) {\n        return Fn.create((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE)(hash)); // Not Fn.fromBytes: it has length limit\n    }\n    // Get the hashed private scalar per RFC8032 5.1.5\n    function getPrivateScalar(key) {\n        const len = lengths.secretKey;\n        key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"private key\", key, len);\n        // Hash private key with curve's hash function to produce uniformingly random input\n        // Check byte lengths: ensure(64, h(ensure(32, key)))\n        const hashed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"hashed private key\", cHash(key), 2 * len);\n        const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n        const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n        const scalar = modN_LE(head); // The actual private scalar\n        return {\n            head,\n            prefix,\n            scalar\n        };\n    }\n    /** Convenience method that creates public key from scalar. RFC8032 5.1.5 */ function getExtendedPublicKey(secretKey) {\n        const { head, prefix, scalar } = getPrivateScalar(secretKey);\n        const point = BASE.multiply(scalar); // Point on Edwards curve aka public key\n        const pointBytes = point.toBytes();\n        return {\n            head,\n            prefix,\n            scalar,\n            point,\n            pointBytes\n        };\n    }\n    /** Calculates EdDSA pub key. RFC8032 5.1.5. */ function getPublicKey(secretKey) {\n        return getExtendedPublicKey(secretKey).pointBytes;\n    }\n    // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n    function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {\n        const msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.concatBytes)(...msgs);\n        return modN_LE(cHash(domain(msg, (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"context\", context), !!prehash)));\n    }\n    /** Signs message with privateKey. RFC8032 5.1.6 */ function sign(msg, secretKey, options = {}) {\n        msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"message\", msg);\n        if (prehash) msg = prehash(msg); // for ed25519ph etc.\n        const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);\n        const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n        const R = BASE.multiply(r).toBytes(); // R = rG\n        const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n        const s = Fn.create(r + k * scalar); // S = (r + k * s) mod L\n        if (!Fn.isValid(s)) throw new Error(\"sign failed: invalid s\"); // 0 <= s < L\n        const rs = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.concatBytes)(R, Fn.toBytes(s));\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__._abytes2)(rs, lengths.signature, \"result\");\n    }\n    // verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\n    const verifyOpts = {\n        zip215: true\n    };\n    /**\n     * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n     * An extended group equation is checked.\n     */ function verify(sig, msg, publicKey, options = verifyOpts) {\n        const { context, zip215 } = options;\n        const len = lengths.signature;\n        sig = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"signature\", sig, len);\n        msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"message\", msg);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)(\"publicKey\", publicKey, lengths.publicKey);\n        if (zip215 !== undefined) (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__._abool2)(zip215, \"zip215\");\n        if (prehash) msg = prehash(msg); // for ed25519ph, etc\n        const mid = len / 2;\n        const r = sig.subarray(0, mid);\n        const s = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE)(sig.subarray(mid, len));\n        let A, R, SB;\n        try {\n            // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n            // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n            // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n            A = Point.fromBytes(publicKey, zip215);\n            R = Point.fromBytes(r, zip215);\n            SB = BASE.multiplyUnsafe(s); // 0 <= s < l is done inside\n        } catch (error) {\n            return false;\n        }\n        if (!zip215 && A.isSmallOrder()) return false; // zip215 allows public keys of small order\n        const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);\n        const RkA = R.add(A.multiplyUnsafe(k));\n        // Extended group equation\n        // [8][S]B = [8]R + [8][k]A'\n        return RkA.subtract(SB).clearCofactor().is0();\n    }\n    const _size = Fp.BYTES; // 32 for ed25519, 57 for ed448\n    const lengths = {\n        secretKey: _size,\n        publicKey: _size,\n        signature: 2 * _size,\n        seed: _size\n    };\n    function randomSecretKey(seed = randomBytes(lengths.seed)) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__._abytes2)(seed, lengths.seed, \"seed\");\n    }\n    function keygen(seed) {\n        const secretKey = utils.randomSecretKey(seed);\n        return {\n            secretKey,\n            publicKey: getPublicKey(secretKey)\n        };\n    }\n    function isValidSecretKey(key) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.isBytes)(key) && key.length === Fn.BYTES;\n    }\n    function isValidPublicKey(key, zip215) {\n        try {\n            return !!Point.fromBytes(key, zip215);\n        } catch (error) {\n            return false;\n        }\n    }\n    const utils = {\n        getExtendedPublicKey,\n        randomSecretKey,\n        isValidSecretKey,\n        isValidPublicKey,\n        /**\n         * Converts ed public key to x public key. Uses formula:\n         * - ed25519:\n         *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n         *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n         * - ed448:\n         *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`\n         *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`\n         */ toMontgomery (publicKey) {\n            const { y } = Point.fromBytes(publicKey);\n            const size = lengths.publicKey;\n            const is25519 = size === 32;\n            if (!is25519 && size !== 57) throw new Error(\"only defined for 25519 and 448\");\n            const u = is25519 ? Fp.div(_1n + y, _1n - y) : Fp.div(y - _1n, y + _1n);\n            return Fp.toBytes(u);\n        },\n        toMontgomerySecret (secretKey) {\n            const size = lengths.secretKey;\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__._abytes2)(secretKey, size);\n            const hashed = cHash(secretKey.subarray(0, size));\n            return adjustScalarBytes(hashed).subarray(0, size);\n        },\n        /** @deprecated */ randomPrivateKey: randomSecretKey,\n        /** @deprecated */ precompute (windowSize = 8, point = Point.BASE) {\n            return point.precompute(windowSize, false);\n        }\n    };\n    return Object.freeze({\n        keygen,\n        getPublicKey,\n        sign,\n        verify,\n        utils,\n        Point,\n        lengths\n    });\n}\nfunction _eddsa_legacy_opts_to_new(c) {\n    const CURVE = {\n        a: c.a,\n        d: c.d,\n        p: c.Fp.ORDER,\n        n: c.n,\n        h: c.h,\n        Gx: c.Gx,\n        Gy: c.Gy\n    };\n    const Fp = c.Fp;\n    const Fn = (0,_modular_js__WEBPACK_IMPORTED_MODULE_3__.Field)(CURVE.n, c.nBitLength, true);\n    const curveOpts = {\n        Fp,\n        Fn,\n        uvRatio: c.uvRatio\n    };\n    const eddsaOpts = {\n        randomBytes: c.randomBytes,\n        adjustScalarBytes: c.adjustScalarBytes,\n        domain: c.domain,\n        prehash: c.prehash,\n        mapToCurve: c.mapToCurve\n    };\n    return {\n        CURVE,\n        curveOpts,\n        hash: c.hash,\n        eddsaOpts\n    };\n}\nfunction _eddsa_new_output_to_legacy(c, eddsa) {\n    const Point = eddsa.Point;\n    const legacy = Object.assign({}, eddsa, {\n        ExtendedPoint: Point,\n        CURVE: c,\n        nBitLength: Point.Fn.BITS,\n        nByteLength: Point.Fn.BYTES\n    });\n    return legacy;\n}\n// TODO: remove. Use eddsa\nfunction twistedEdwards(c) {\n    const { CURVE, curveOpts, hash, eddsaOpts } = _eddsa_legacy_opts_to_new(c);\n    const Point = edwards(CURVE, curveOpts);\n    const EDDSA = eddsa(Point, hash, eddsaOpts);\n    return _eddsa_new_output_to_legacy(c, EDDSA);\n} //# sourceMappingURL=edwards.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjkuNy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvZWR3YXJkcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOzs7OztDQUtDLEdBQ0Qsb0VBQW9FLEdBQytKO0FBQ3JKO0FBQ3pDO0FBQ3JDLHFFQUFxRTtBQUNyRSxrQkFBa0I7QUFDbEIsTUFBTXFCLE1BQU1DLE9BQU8sSUFBSUMsTUFBTUQsT0FBTyxJQUFJRSxNQUFNRixPQUFPLElBQUlHLE1BQU1ILE9BQU87QUFDdEUsU0FBU0ksWUFBWUMsRUFBRSxFQUFFQyxLQUFLLEVBQUVDLENBQUMsRUFBRUMsQ0FBQztJQUNoQyxNQUFNQyxLQUFLSixHQUFHSyxHQUFHLENBQUNIO0lBQ2xCLE1BQU1JLEtBQUtOLEdBQUdLLEdBQUcsQ0FBQ0Y7SUFDbEIsTUFBTUksT0FBT1AsR0FBR1EsR0FBRyxDQUFDUixHQUFHUyxHQUFHLENBQUNSLE1BQU1TLENBQUMsRUFBRU4sS0FBS0U7SUFDekMsTUFBTUssUUFBUVgsR0FBR1EsR0FBRyxDQUFDUixHQUFHWSxHQUFHLEVBQUVaLEdBQUdTLEdBQUcsQ0FBQ1IsTUFBTVksQ0FBQyxFQUFFYixHQUFHUyxHQUFHLENBQUNMLElBQUlFO0lBQ3hELE9BQU9OLEdBQUdjLEdBQUcsQ0FBQ1AsTUFBTUk7QUFDeEI7QUFDTyxTQUFTSSxRQUFRQyxNQUFNLEVBQUVDLFlBQVksQ0FBQyxDQUFDO0lBQzFDLE1BQU1DLFlBQVk3Qiw2REFBa0JBLENBQUMsV0FBVzJCLFFBQVFDLFdBQVdBLFVBQVVFLE1BQU07SUFDbkYsTUFBTSxFQUFFbkIsRUFBRSxFQUFFb0IsRUFBRSxFQUFFLEdBQUdGO0lBQ25CLElBQUlqQixRQUFRaUIsVUFBVWpCLEtBQUs7SUFDM0IsTUFBTSxFQUFFb0IsR0FBR0MsUUFBUSxFQUFFLEdBQUdyQjtJQUN4QjVCLDBEQUFlQSxDQUFDNEMsV0FBVyxDQUFDLEdBQUc7UUFBRU0sU0FBUztJQUFXO0lBQ3JELGFBQWE7SUFDYix1RUFBdUU7SUFDdkUsNkVBQTZFO0lBQzdFLHFEQUFxRDtJQUNyRCxNQUFNQyxPQUFPM0IsT0FBUUYsT0FBT3lCLEdBQUdLLEtBQUssR0FBRyxLQUFLN0I7SUFDNUMsTUFBTThCLE9BQU8sQ0FBQ0MsSUFBTTNCLEdBQUc0QixNQUFNLENBQUNELElBQUkscUJBQXFCO0lBQ3ZELFlBQVk7SUFDWixNQUFNSixVQUFVTixVQUFVTSxPQUFPLElBQzVCLEVBQUNNLEdBQUdDO1FBQ0QsSUFBSTtZQUNBLE9BQU87Z0JBQUVDLFNBQVM7Z0JBQU1DLE9BQU9oQyxHQUFHaUMsSUFBSSxDQUFDakMsR0FBR2tDLEdBQUcsQ0FBQ0wsR0FBR0M7WUFBSTtRQUN6RCxFQUNBLE9BQU9LLEdBQUc7WUFDTixPQUFPO2dCQUFFSixTQUFTO2dCQUFPQyxPQUFPdEM7WUFBSTtRQUN4QztJQUNKO0lBQ0osc0RBQXNEO0lBQ3RELGlFQUFpRTtJQUNqRSxJQUFJLENBQUNLLFlBQVlDLElBQUlDLE9BQU9BLE1BQU1tQyxFQUFFLEVBQUVuQyxNQUFNb0MsRUFBRSxHQUMxQyxNQUFNLElBQUlDLE1BQU07SUFDcEI7OztLQUdDLEdBQ0QsU0FBU0MsT0FBT0MsS0FBSyxFQUFFYixDQUFDLEVBQUVjLFVBQVUsS0FBSztRQUNyQyxNQUFNQyxNQUFNRCxVQUFVN0MsTUFBTUY7UUFDNUJoQixtREFBUUEsQ0FBQyxnQkFBZ0I4RCxPQUFPYixHQUFHZSxLQUFLbEI7UUFDeEMsT0FBT0c7SUFDWDtJQUNBLFNBQVNnQixVQUFVQyxLQUFLO1FBQ3BCLElBQUksQ0FBRUEsQ0FBQUEsaUJBQWlCQyxLQUFJLEdBQ3ZCLE1BQU0sSUFBSVAsTUFBTTtJQUN4QjtJQUNBLHlEQUF5RDtJQUN6RCwrREFBK0Q7SUFDL0QsTUFBTVEsZUFBZTdELG1EQUFRQSxDQUFDLENBQUM4RCxHQUFHQztRQUM5QixNQUFNLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUUsR0FBR0o7UUFDcEIsTUFBTUssTUFBTUwsRUFBRUssR0FBRztRQUNqQixJQUFJSixNQUFNLE1BQ05BLEtBQUtJLE1BQU10RCxNQUFNRSxHQUFHcUQsR0FBRyxDQUFDRixJQUFJLDJCQUEyQjtRQUMzRCxNQUFNakQsSUFBSXdCLEtBQUt1QixJQUFJRDtRQUNuQixNQUFNN0MsSUFBSXVCLEtBQUt3QixJQUFJRjtRQUNuQixNQUFNTSxLQUFLdEQsR0FBR1MsR0FBRyxDQUFDMEMsR0FBR0g7UUFDckIsSUFBSUksS0FDQSxPQUFPO1lBQUVsRCxHQUFHUjtZQUFLUyxHQUFHUDtRQUFJO1FBQzVCLElBQUkwRCxPQUFPMUQsS0FDUCxNQUFNLElBQUkwQyxNQUFNO1FBQ3BCLE9BQU87WUFBRXBDO1lBQUdDO1FBQUU7SUFDbEI7SUFDQSxNQUFNb0Qsa0JBQWtCdEUsbURBQVFBLENBQUMsQ0FBQzhEO1FBQzlCLE1BQU0sRUFBRXJDLENBQUMsRUFBRUcsQ0FBQyxFQUFFLEdBQUdaO1FBQ2pCLElBQUk4QyxFQUFFSyxHQUFHLElBQ0wsTUFBTSxJQUFJZCxNQUFNLG9CQUFvQixtQ0FBbUM7UUFDM0UsdURBQXVEO1FBQ3ZELCtFQUErRTtRQUMvRSxNQUFNLEVBQUVXLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVLLENBQUMsRUFBRSxHQUFHVDtRQUN2QixNQUFNVSxLQUFLL0IsS0FBS3VCLElBQUlBLElBQUksS0FBSztRQUM3QixNQUFNUyxLQUFLaEMsS0FBS3dCLElBQUlBLElBQUksS0FBSztRQUM3QixNQUFNUyxLQUFLakMsS0FBS3lCLElBQUlBLElBQUksS0FBSztRQUM3QixNQUFNUyxLQUFLbEMsS0FBS2lDLEtBQUtBLEtBQUssS0FBSztRQUMvQixNQUFNRSxNQUFNbkMsS0FBSytCLEtBQUsvQyxJQUFJLE1BQU07UUFDaEMsTUFBTUgsT0FBT21CLEtBQUtpQyxLQUFLakMsS0FBS21DLE1BQU1ILE1BQU0sZUFBZTtRQUN2RCxNQUFNL0MsUUFBUWUsS0FBS2tDLEtBQUtsQyxLQUFLYixJQUFJYSxLQUFLK0IsS0FBS0MsT0FBTyxhQUFhO1FBQy9ELElBQUluRCxTQUFTSSxPQUNULE1BQU0sSUFBSTJCLE1BQU07UUFDcEIsNkVBQTZFO1FBQzdFLE1BQU13QixLQUFLcEMsS0FBS3VCLElBQUlDO1FBQ3BCLE1BQU1hLEtBQUtyQyxLQUFLeUIsSUFBSUs7UUFDcEIsSUFBSU0sT0FBT0MsSUFDUCxNQUFNLElBQUl6QixNQUFNO1FBQ3BCLE9BQU87SUFDWDtJQUNBLHFGQUFxRjtJQUNyRiwyRUFBMkU7SUFDM0UsTUFBTU87UUFDRm1CLFlBQVlmLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVLLENBQUMsQ0FBRTtZQUNwQixJQUFJLENBQUNQLENBQUMsR0FBR1YsT0FBTyxLQUFLVTtZQUNyQixJQUFJLENBQUNDLENBQUMsR0FBR1gsT0FBTyxLQUFLVztZQUNyQixJQUFJLENBQUNDLENBQUMsR0FBR1osT0FBTyxLQUFLWSxHQUFHO1lBQ3hCLElBQUksQ0FBQ0ssQ0FBQyxHQUFHakIsT0FBTyxLQUFLaUI7WUFDckJTLE9BQU9DLE1BQU0sQ0FBQyxJQUFJO1FBQ3RCO1FBQ0EsT0FBT2pFLFFBQVE7WUFDWCxPQUFPQTtRQUNYO1FBQ0EsT0FBT2tFLFdBQVdwQixDQUFDLEVBQUU7WUFDakIsSUFBSUEsYUFBYUYsT0FDYixNQUFNLElBQUlQLE1BQU07WUFDcEIsTUFBTSxFQUFFcEMsQ0FBQyxFQUFFQyxDQUFDLEVBQUUsR0FBRzRDLEtBQUssQ0FBQztZQUN2QlIsT0FBTyxLQUFLckM7WUFDWnFDLE9BQU8sS0FBS3BDO1lBQ1osT0FBTyxJQUFJMEMsTUFBTTNDLEdBQUdDLEdBQUdQLEtBQUs4QixLQUFLeEIsSUFBSUM7UUFDekM7UUFDQSxnQ0FBZ0M7UUFDaEMsT0FBT2lFLFVBQVVDLEtBQUssRUFBRUMsU0FBUyxLQUFLLEVBQUU7WUFDcEMsTUFBTUMsTUFBTXZFLEdBQUd5QixLQUFLO1lBQ3BCLE1BQU0sRUFBRWYsQ0FBQyxFQUFFRyxDQUFDLEVBQUUsR0FBR1o7WUFDakJvRSxRQUFRdkYsb0RBQVNBLENBQUNMLG1EQUFNQSxDQUFDNEYsT0FBT0UsS0FBSztZQUNyQ2hHLGtEQUFLQSxDQUFDK0YsUUFBUTtZQUNkLE1BQU1FLFNBQVMxRixvREFBU0EsQ0FBQ3VGLFFBQVEsa0NBQWtDO1lBQ25FLE1BQU1JLFdBQVdKLEtBQUssQ0FBQ0UsTUFBTSxFQUFFLEVBQUUsbUJBQW1CO1lBQ3BEQyxNQUFNLENBQUNELE1BQU0sRUFBRSxHQUFHRSxXQUFXLENBQUMsTUFBTSxpQkFBaUI7WUFDckQsTUFBTXRFLElBQUl2QiwwREFBZUEsQ0FBQzRGO1lBQzFCLHVGQUF1RjtZQUN2Riw2Q0FBNkM7WUFDN0Msa0RBQWtEO1lBQ2xELGtEQUFrRDtZQUNsRCxNQUFNRSxNQUFNSixTQUFTOUMsT0FBT3hCLEdBQUcyRSxLQUFLO1lBQ3BDakcsbURBQVFBLENBQUMsV0FBV3lCLEdBQUdULEtBQUtnRjtZQUM1QixzRkFBc0Y7WUFDdEYsMEVBQTBFO1lBQzFFLE1BQU1wRSxLQUFLb0IsS0FBS3ZCLElBQUlBLElBQUkscUNBQXFDO1lBQzdELE1BQU0wQixJQUFJSCxLQUFLcEIsS0FBS1YsTUFBTSxhQUFhO1lBQ3ZDLE1BQU1rQyxJQUFJSixLQUFLYixJQUFJUCxLQUFLSSxJQUFJLGdCQUFnQjtZQUM1QyxJQUFJLEVBQUVxQixPQUFPLEVBQUVDLE9BQU85QixDQUFDLEVBQUUsR0FBR3FCLFFBQVFNLEdBQUdDLElBQUksU0FBUztZQUNwRCxJQUFJLENBQUNDLFNBQ0QsTUFBTSxJQUFJTyxNQUFNO1lBQ3BCLE1BQU1zQyxTQUFTLENBQUMxRSxJQUFJTixHQUFFLE1BQU9BLEtBQUsseURBQXlEO1lBQzNGLE1BQU1pRixnQkFBZ0IsQ0FBQ0osV0FBVyxJQUFHLE1BQU8sR0FBRyxnQkFBZ0I7WUFDL0QsSUFBSSxDQUFDSCxVQUFVcEUsTUFBTVIsT0FBT21GLGVBQ3hCLDJCQUEyQjtZQUMzQixNQUFNLElBQUl2QyxNQUFNO1lBQ3BCLElBQUl1QyxrQkFBa0JELFFBQ2xCMUUsSUFBSXdCLEtBQUssQ0FBQ3hCLElBQUksaUNBQWlDO1lBQ25ELE9BQU8yQyxNQUFNc0IsVUFBVSxDQUFDO2dCQUFFakU7Z0JBQUdDO1lBQUU7UUFDbkM7UUFDQSxPQUFPMkUsUUFBUVQsS0FBSyxFQUFFQyxTQUFTLEtBQUssRUFBRTtZQUNsQyxPQUFPekIsTUFBTXVCLFNBQVMsQ0FBQ3JGLHNEQUFXQSxDQUFDLFNBQVNzRixRQUFRQztRQUN4RDtRQUNBLElBQUlwRSxJQUFJO1lBQ0osT0FBTyxJQUFJLENBQUM2RSxRQUFRLEdBQUc3RSxDQUFDO1FBQzVCO1FBQ0EsSUFBSUMsSUFBSTtZQUNKLE9BQU8sSUFBSSxDQUFDNEUsUUFBUSxHQUFHNUUsQ0FBQztRQUM1QjtRQUNBNkUsV0FBV0MsYUFBYSxDQUFDLEVBQUVDLFNBQVMsSUFBSSxFQUFFO1lBQ3RDQyxLQUFLQyxXQUFXLENBQUMsSUFBSSxFQUFFSDtZQUN2QixJQUFJLENBQUNDLFFBQ0QsSUFBSSxDQUFDRyxRQUFRLENBQUN4RixNQUFNLGdCQUFnQjtZQUN4QyxPQUFPLElBQUk7UUFDZjtRQUNBLG1GQUFtRjtRQUNuRnlGLGlCQUFpQjtZQUNiL0IsZ0JBQWdCLElBQUk7UUFDeEI7UUFDQSxnQ0FBZ0M7UUFDaENnQyxPQUFPM0MsS0FBSyxFQUFFO1lBQ1ZELFVBQVVDO1lBQ1YsTUFBTSxFQUFFSyxHQUFHdUMsRUFBRSxFQUFFdEMsR0FBR3VDLEVBQUUsRUFBRXRDLEdBQUd1QyxFQUFFLEVBQUUsR0FBRyxJQUFJO1lBQ3BDLE1BQU0sRUFBRXpDLEdBQUdRLEVBQUUsRUFBRVAsR0FBR1EsRUFBRSxFQUFFUCxHQUFHUSxFQUFFLEVBQUUsR0FBR2Y7WUFDaEMsTUFBTStDLE9BQU9qRSxLQUFLOEQsS0FBSzdCO1lBQ3ZCLE1BQU1pQyxPQUFPbEUsS0FBSytCLEtBQUtpQztZQUN2QixNQUFNRyxPQUFPbkUsS0FBSytELEtBQUs5QjtZQUN2QixNQUFNbUMsT0FBT3BFLEtBQUtnQyxLQUFLZ0M7WUFDdkIsT0FBT0MsU0FBU0MsUUFBUUMsU0FBU0M7UUFDckM7UUFDQTFDLE1BQU07WUFDRixPQUFPLElBQUksQ0FBQ21DLE1BQU0sQ0FBQzFDLE1BQU1rRCxJQUFJO1FBQ2pDO1FBQ0FDLFNBQVM7WUFDTCw4REFBOEQ7WUFDOUQsT0FBTyxJQUFJbkQsTUFBTW5CLEtBQUssQ0FBQyxJQUFJLENBQUN1QixDQUFDLEdBQUcsSUFBSSxDQUFDQyxDQUFDLEVBQUUsSUFBSSxDQUFDQyxDQUFDLEVBQUV6QixLQUFLLENBQUMsSUFBSSxDQUFDOEIsQ0FBQztRQUNoRTtRQUNBLHlDQUF5QztRQUN6QyxzRkFBc0Y7UUFDdEYsb0NBQW9DO1FBQ3BDeUMsU0FBUztZQUNMLE1BQU0sRUFBRXZGLENBQUMsRUFBRSxHQUFHVDtZQUNkLE1BQU0sRUFBRWdELEdBQUd1QyxFQUFFLEVBQUV0QyxHQUFHdUMsRUFBRSxFQUFFdEMsR0FBR3VDLEVBQUUsRUFBRSxHQUFHLElBQUk7WUFDcEMsTUFBTVEsSUFBSXhFLEtBQUs4RCxLQUFLQSxLQUFLLFVBQVU7WUFDbkMsTUFBTVcsSUFBSXpFLEtBQUsrRCxLQUFLQSxLQUFLLFVBQVU7WUFDbkMsTUFBTVcsSUFBSTFFLEtBQUs3QixNQUFNNkIsS0FBS2dFLEtBQUtBLE1BQU0sWUFBWTtZQUNqRCxNQUFNVyxJQUFJM0UsS0FBS2hCLElBQUl3RixJQUFJLFVBQVU7WUFDakMsTUFBTUksT0FBT2QsS0FBS0M7WUFDbEIsTUFBTWMsSUFBSTdFLEtBQUtBLEtBQUs0RSxPQUFPQSxRQUFRSixJQUFJQyxJQUFJLG1CQUFtQjtZQUM5RCxNQUFNSyxJQUFJSCxJQUFJRixHQUFHLFVBQVU7WUFDM0IsTUFBTU0sSUFBSUQsSUFBSUosR0FBRyxVQUFVO1lBQzNCLE1BQU1NLElBQUlMLElBQUlGLEdBQUcsVUFBVTtZQUMzQixNQUFNUSxLQUFLakYsS0FBSzZFLElBQUlFLElBQUksV0FBVztZQUNuQyxNQUFNRyxLQUFLbEYsS0FBSzhFLElBQUlFLElBQUksV0FBVztZQUNuQyxNQUFNRyxLQUFLbkYsS0FBSzZFLElBQUlHLElBQUksV0FBVztZQUNuQyxNQUFNSSxLQUFLcEYsS0FBSytFLElBQUlELElBQUksV0FBVztZQUNuQyxPQUFPLElBQUkzRCxNQUFNOEQsSUFBSUMsSUFBSUUsSUFBSUQ7UUFDakM7UUFDQSwwQ0FBMEM7UUFDMUMsc0ZBQXNGO1FBQ3RGLCtCQUErQjtRQUMvQnJHLElBQUlvQyxLQUFLLEVBQUU7WUFDUEQsVUFBVUM7WUFDVixNQUFNLEVBQUVsQyxDQUFDLEVBQUVHLENBQUMsRUFBRSxHQUFHWjtZQUNqQixNQUFNLEVBQUVnRCxHQUFHdUMsRUFBRSxFQUFFdEMsR0FBR3VDLEVBQUUsRUFBRXRDLEdBQUd1QyxFQUFFLEVBQUVsQyxHQUFHdUQsRUFBRSxFQUFFLEdBQUcsSUFBSTtZQUMzQyxNQUFNLEVBQUU5RCxHQUFHUSxFQUFFLEVBQUVQLEdBQUdRLEVBQUUsRUFBRVAsR0FBR1EsRUFBRSxFQUFFSCxHQUFHd0QsRUFBRSxFQUFFLEdBQUdwRTtZQUN2QyxNQUFNc0QsSUFBSXhFLEtBQUs4RCxLQUFLL0IsS0FBSyxZQUFZO1lBQ3JDLE1BQU0wQyxJQUFJekUsS0FBSytELEtBQUsvQixLQUFLLFlBQVk7WUFDckMsTUFBTTBDLElBQUkxRSxLQUFLcUYsS0FBS2xHLElBQUltRyxLQUFLLGNBQWM7WUFDM0MsTUFBTVgsSUFBSTNFLEtBQUtnRSxLQUFLL0IsS0FBSyxZQUFZO1lBQ3JDLE1BQU00QyxJQUFJN0UsS0FBSyxDQUFDOEQsS0FBS0MsRUFBQyxJQUFNaEMsQ0FBQUEsS0FBS0MsRUFBQyxJQUFLd0MsSUFBSUMsSUFBSSwwQkFBMEI7WUFDekUsTUFBTU0sSUFBSUosSUFBSUQsR0FBRyxVQUFVO1lBQzNCLE1BQU1JLElBQUlILElBQUlELEdBQUcsVUFBVTtZQUMzQixNQUFNTSxJQUFJaEYsS0FBS3lFLElBQUl6RixJQUFJd0YsSUFBSSxZQUFZO1lBQ3ZDLE1BQU1TLEtBQUtqRixLQUFLNkUsSUFBSUUsSUFBSSxXQUFXO1lBQ25DLE1BQU1HLEtBQUtsRixLQUFLOEUsSUFBSUUsSUFBSSxXQUFXO1lBQ25DLE1BQU1HLEtBQUtuRixLQUFLNkUsSUFBSUcsSUFBSSxXQUFXO1lBQ25DLE1BQU1JLEtBQUtwRixLQUFLK0UsSUFBSUQsSUFBSSxXQUFXO1lBQ25DLE9BQU8sSUFBSTNELE1BQU04RCxJQUFJQyxJQUFJRSxJQUFJRDtRQUNqQztRQUNBSSxTQUFTckUsS0FBSyxFQUFFO1lBQ1osT0FBTyxJQUFJLENBQUNwQyxHQUFHLENBQUNvQyxNQUFNb0QsTUFBTTtRQUNoQztRQUNBLGdDQUFnQztRQUNoQ1gsU0FBUzZCLE1BQU0sRUFBRTtZQUNiLGtCQUFrQjtZQUNsQixJQUFJLENBQUM5RixHQUFHK0YsV0FBVyxDQUFDRCxTQUNoQixNQUFNLElBQUk1RSxNQUFNO1lBQ3BCLE1BQU0sRUFBRVMsQ0FBQyxFQUFFcUUsQ0FBQyxFQUFFLEdBQUdqQyxLQUFLa0MsTUFBTSxDQUFDLElBQUksRUFBRUgsUUFBUSxDQUFDbkUsSUFBTXpELHFEQUFVQSxDQUFDdUQsT0FBT0U7WUFDcEUsT0FBT3pELHFEQUFVQSxDQUFDdUQsT0FBTztnQkFBQ0U7Z0JBQUdxRTthQUFFLENBQUMsQ0FBQyxFQUFFO1FBQ3ZDO1FBQ0EsbUVBQW1FO1FBQ25FLGlFQUFpRTtRQUNqRSxnREFBZ0Q7UUFDaEQsOENBQThDO1FBQzlDLHFGQUFxRjtRQUNyRkUsZUFBZUosTUFBTSxFQUFFSyxNQUFNMUUsTUFBTWtELElBQUksRUFBRTtZQUNyQyxrQkFBa0I7WUFDbEIsSUFBSSxDQUFDM0UsR0FBR1csT0FBTyxDQUFDbUYsU0FDWixNQUFNLElBQUk1RSxNQUFNO1lBQ3BCLElBQUk0RSxXQUFXeEgsS0FDWCxPQUFPbUQsTUFBTWtELElBQUk7WUFDckIsSUFBSSxJQUFJLENBQUMzQyxHQUFHLE1BQU04RCxXQUFXdEgsS0FDekIsT0FBTyxJQUFJO1lBQ2YsT0FBT3VGLEtBQUtxQyxNQUFNLENBQUMsSUFBSSxFQUFFTixRQUFRLENBQUNuRSxJQUFNekQscURBQVVBLENBQUN1RCxPQUFPRSxJQUFJd0U7UUFDbEU7UUFDQSxxQ0FBcUM7UUFDckMsbUVBQW1FO1FBQ25FLGdDQUFnQztRQUNoQyw4REFBOEQ7UUFDOURFLGVBQWU7WUFDWCxPQUFPLElBQUksQ0FBQ0gsY0FBYyxDQUFDaEcsVUFBVThCLEdBQUc7UUFDNUM7UUFDQSxpRUFBaUU7UUFDakUseUNBQXlDO1FBQ3pDc0UsZ0JBQWdCO1lBQ1osT0FBT3ZDLEtBQUtxQyxNQUFNLENBQUMsSUFBSSxFQUFFdkgsTUFBTTBCLENBQUMsRUFBRXlCLEdBQUc7UUFDekM7UUFDQSx5REFBeUQ7UUFDekQsK0RBQStEO1FBQy9EMkIsU0FBUzRDLFNBQVMsRUFBRTtZQUNoQixPQUFPN0UsYUFBYSxJQUFJLEVBQUU2RTtRQUM5QjtRQUNBQyxnQkFBZ0I7WUFDWixJQUFJdEcsYUFBYTFCLEtBQ2IsT0FBTyxJQUFJO1lBQ2YsT0FBTyxJQUFJLENBQUMwSCxjQUFjLENBQUNoRztRQUMvQjtRQUNBdUcsVUFBVTtZQUNOLE1BQU0sRUFBRTNILENBQUMsRUFBRUMsQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDNEUsUUFBUTtZQUM5QiwwREFBMEQ7WUFDMUQsTUFBTVYsUUFBUXJFLEdBQUc2SCxPQUFPLENBQUMxSDtZQUN6Qiw2Q0FBNkM7WUFDN0MscUZBQXFGO1lBQ3JGa0UsS0FBSyxDQUFDQSxNQUFNeUQsTUFBTSxHQUFHLEVBQUUsSUFBSTVILElBQUlOLE1BQU0sT0FBTztZQUM1QyxPQUFPeUU7UUFDWDtRQUNBMEQsUUFBUTtZQUNKLE9BQU9wSixxREFBVUEsQ0FBQyxJQUFJLENBQUNrSixPQUFPO1FBQ2xDO1FBQ0FHLFdBQVc7WUFDUCxPQUFPLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQzVFLEdBQUcsS0FBSyxTQUFTLElBQUksQ0FBQzJFLEtBQUssR0FBRyxDQUFDLENBQUM7UUFDMUQ7UUFDQSxlQUFlO1FBQ2YsSUFBSUUsS0FBSztZQUNMLE9BQU8sSUFBSSxDQUFDaEYsQ0FBQztRQUNqQjtRQUNBLElBQUlpRixLQUFLO1lBQ0wsT0FBTyxJQUFJLENBQUNoRixDQUFDO1FBQ2pCO1FBQ0EsSUFBSWlGLEtBQUs7WUFDTCxPQUFPLElBQUksQ0FBQ2hGLENBQUM7UUFDakI7UUFDQSxJQUFJaUYsS0FBSztZQUNMLE9BQU8sSUFBSSxDQUFDNUUsQ0FBQztRQUNqQjtRQUNBLE9BQU9sRSxXQUFXK0ksTUFBTSxFQUFFO1lBQ3RCLE9BQU8vSSxxREFBVUEsQ0FBQ3VELE9BQU93RjtRQUM3QjtRQUNBLE9BQU9DLElBQUlELE1BQU0sRUFBRUUsT0FBTyxFQUFFO1lBQ3hCLE9BQU9oSixvREFBU0EsQ0FBQ3NELE9BQU96QixJQUFJaUgsUUFBUUU7UUFDeEM7UUFDQUMsZUFBZXZELFVBQVUsRUFBRTtZQUN2QixJQUFJLENBQUNELFVBQVUsQ0FBQ0M7UUFDcEI7UUFDQXdELGFBQWE7WUFDVCxPQUFPLElBQUksQ0FBQ1osT0FBTztRQUN2QjtJQUNKO0lBQ0EseUJBQXlCO0lBQ3pCaEYsTUFBTTZGLElBQUksR0FBRyxJQUFJN0YsTUFBTTVDLE1BQU1tQyxFQUFFLEVBQUVuQyxNQUFNb0MsRUFBRSxFQUFFekMsS0FBSzhCLEtBQUt6QixNQUFNbUMsRUFBRSxHQUFHbkMsTUFBTW9DLEVBQUU7SUFDeEUsbUNBQW1DO0lBQ25DUSxNQUFNa0QsSUFBSSxHQUFHLElBQUlsRCxNQUFNbkQsS0FBS0UsS0FBS0EsS0FBS0YsTUFBTSxhQUFhO0lBQ3pELGFBQWE7SUFDYm1ELE1BQU03QyxFQUFFLEdBQUdBO0lBQ1gsZUFBZTtJQUNmNkMsTUFBTXpCLEVBQUUsR0FBR0E7SUFDWCxNQUFNK0QsT0FBTyxJQUFJM0YsMkNBQUlBLENBQUNxRCxPQUFPekIsR0FBR3VILElBQUk7SUFDcEM5RixNQUFNNkYsSUFBSSxDQUFDMUQsVUFBVSxDQUFDLElBQUksc0VBQXNFO0lBQ2hHLE9BQU9uQztBQUNYO0FBQ0E7Ozs7Q0FJQyxHQUNNLE1BQU0rRjtJQUNUNUUsWUFBWTZFLEVBQUUsQ0FBRTtRQUNaLElBQUksQ0FBQ0EsRUFBRSxHQUFHQTtJQUNkO0lBQ0Esd0RBQXdEO0lBQ3hELE9BQU96RSxVQUFVMEUsTUFBTSxFQUFFO1FBQ3JCNUoseURBQWNBO0lBQ2xCO0lBQ0EsT0FBTzRGLFFBQVFpRSxJQUFJLEVBQUU7UUFDakI3Six5REFBY0E7SUFDbEI7SUFDQSxJQUFJZ0IsSUFBSTtRQUNKLE9BQU8sSUFBSSxDQUFDNkUsUUFBUSxHQUFHN0UsQ0FBQztJQUM1QjtJQUNBLElBQUlDLElBQUk7UUFDSixPQUFPLElBQUksQ0FBQzRFLFFBQVEsR0FBRzVFLENBQUM7SUFDNUI7SUFDQSx5QkFBeUI7SUFDekJ5SCxnQkFBZ0I7UUFDWiwrQkFBK0I7UUFDL0IsT0FBTyxJQUFJO0lBQ2Y7SUFDQXRDLGlCQUFpQjtRQUNiLElBQUksQ0FBQ3VELEVBQUUsQ0FBQ3ZELGNBQWM7SUFDMUI7SUFDQVAsU0FBUzRDLFNBQVMsRUFBRTtRQUNoQixPQUFPLElBQUksQ0FBQ2tCLEVBQUUsQ0FBQzlELFFBQVEsQ0FBQzRDO0lBQzVCO0lBQ0FJLFFBQVE7UUFDSixPQUFPcEoscURBQVVBLENBQUMsSUFBSSxDQUFDa0osT0FBTztJQUNsQztJQUNBRyxXQUFXO1FBQ1AsT0FBTyxJQUFJLENBQUNELEtBQUs7SUFDckI7SUFDQUwsZ0JBQWdCO1FBQ1osT0FBTztJQUNYO0lBQ0FELGVBQWU7UUFDWCxPQUFPO0lBQ1g7SUFDQWpILElBQUlvQyxLQUFLLEVBQUU7UUFDUCxJQUFJLENBQUNvRyxVQUFVLENBQUNwRztRQUNoQixPQUFPLElBQUksQ0FBQ3FHLElBQUksQ0FBQyxJQUFJLENBQUNKLEVBQUUsQ0FBQ3JJLEdBQUcsQ0FBQ29DLE1BQU1pRyxFQUFFO0lBQ3pDO0lBQ0E1QixTQUFTckUsS0FBSyxFQUFFO1FBQ1osSUFBSSxDQUFDb0csVUFBVSxDQUFDcEc7UUFDaEIsT0FBTyxJQUFJLENBQUNxRyxJQUFJLENBQUMsSUFBSSxDQUFDSixFQUFFLENBQUM1QixRQUFRLENBQUNyRSxNQUFNaUcsRUFBRTtJQUM5QztJQUNBeEQsU0FBUzZCLE1BQU0sRUFBRTtRQUNiLE9BQU8sSUFBSSxDQUFDK0IsSUFBSSxDQUFDLElBQUksQ0FBQ0osRUFBRSxDQUFDeEQsUUFBUSxDQUFDNkI7SUFDdEM7SUFDQUksZUFBZUosTUFBTSxFQUFFO1FBQ25CLE9BQU8sSUFBSSxDQUFDK0IsSUFBSSxDQUFDLElBQUksQ0FBQ0osRUFBRSxDQUFDdkIsY0FBYyxDQUFDSjtJQUM1QztJQUNBakIsU0FBUztRQUNMLE9BQU8sSUFBSSxDQUFDZ0QsSUFBSSxDQUFDLElBQUksQ0FBQ0osRUFBRSxDQUFDNUMsTUFBTTtJQUNuQztJQUNBRCxTQUFTO1FBQ0wsT0FBTyxJQUFJLENBQUNpRCxJQUFJLENBQUMsSUFBSSxDQUFDSixFQUFFLENBQUM3QyxNQUFNO0lBQ25DO0lBQ0FoQixXQUFXQyxVQUFVLEVBQUVDLE1BQU0sRUFBRTtRQUMzQixPQUFPLElBQUksQ0FBQytELElBQUksQ0FBQyxJQUFJLENBQUNKLEVBQUUsQ0FBQzdELFVBQVUsQ0FBQ0MsWUFBWUM7SUFDcEQ7SUFDQSw4QkFBOEIsR0FDOUJ1RCxhQUFhO1FBQ1QsT0FBTyxJQUFJLENBQUNaLE9BQU87SUFDdkI7QUFDSjtBQUNBOztDQUVDLEdBQ00sU0FBU3FCLE1BQU1yRyxLQUFLLEVBQUVzRyxLQUFLLEVBQUVDLFlBQVksQ0FBQyxDQUFDO0lBQzlDLElBQUksT0FBT0QsVUFBVSxZQUNqQixNQUFNLElBQUk3RyxNQUFNO0lBQ3BCakUsMERBQWVBLENBQUMrSyxXQUFXLENBQUMsR0FBRztRQUMzQkMsbUJBQW1CO1FBQ25CbEssYUFBYTtRQUNibUssUUFBUTtRQUNSQyxTQUFTO1FBQ1RDLFlBQVk7SUFDaEI7SUFDQSxNQUFNLEVBQUVELE9BQU8sRUFBRSxHQUFHSDtJQUNwQixNQUFNLEVBQUVWLElBQUksRUFBRTFJLEVBQUUsRUFBRW9CLEVBQUUsRUFBRSxHQUFHeUI7SUFDekIsTUFBTTFELGNBQWNpSyxVQUFVakssV0FBVyxJQUFJQyxrREFBY0E7SUFDM0QsTUFBTWlLLG9CQUFvQkQsVUFBVUMsaUJBQWlCLElBQUssRUFBQ2hGLFFBQVVBLEtBQUk7SUFDekUsTUFBTWlGLFNBQVNGLFVBQVVFLE1BQU0sSUFDMUIsRUFBQ0csTUFBTUMsS0FBS0M7UUFDVHBMLGtEQUFLQSxDQUFDb0wsUUFBUTtRQUNkLElBQUlELElBQUk1QixNQUFNLElBQUk2QixRQUNkLE1BQU0sSUFBSXJILE1BQU07UUFDcEIsT0FBT21IO0lBQ1gsSUFBSSxPQUFPO0lBQ2YscUNBQXFDO0lBQ3JDLFNBQVNHLFFBQVFDLElBQUk7UUFDakIsT0FBT3pJLEdBQUdRLE1BQU0sQ0FBQ2hELDBEQUFlQSxDQUFDaUwsUUFBUSx3Q0FBd0M7SUFDckY7SUFDQSxrREFBa0Q7SUFDbEQsU0FBU0MsaUJBQWlCQyxHQUFHO1FBQ3pCLE1BQU14RixNQUFNeUYsUUFBUUMsU0FBUztRQUM3QkYsTUFBTWhMLHNEQUFXQSxDQUFDLGVBQWVnTCxLQUFLeEY7UUFDdEMsbUZBQW1GO1FBQ25GLHFEQUFxRDtRQUNyRCxNQUFNMkYsU0FBU25MLHNEQUFXQSxDQUFDLHNCQUFzQm9LLE1BQU1ZLE1BQU0sSUFBSXhGO1FBQ2pFLE1BQU00RixPQUFPZCxrQkFBa0JhLE9BQU9FLEtBQUssQ0FBQyxHQUFHN0YsT0FBTyxvQ0FBb0M7UUFDMUYsTUFBTThGLFNBQVNILE9BQU9FLEtBQUssQ0FBQzdGLEtBQUssSUFBSUEsTUFBTSwyQ0FBMkM7UUFDdEYsTUFBTTJDLFNBQVMwQyxRQUFRTyxPQUFPLDRCQUE0QjtRQUMxRCxPQUFPO1lBQUVBO1lBQU1FO1lBQVFuRDtRQUFPO0lBQ2xDO0lBQ0EsMEVBQTBFLEdBQzFFLFNBQVNvRCxxQkFBcUJMLFNBQVM7UUFDbkMsTUFBTSxFQUFFRSxJQUFJLEVBQUVFLE1BQU0sRUFBRW5ELE1BQU0sRUFBRSxHQUFHNEMsaUJBQWlCRztRQUNsRCxNQUFNTSxRQUFRN0IsS0FBS3JELFFBQVEsQ0FBQzZCLFNBQVMsd0NBQXdDO1FBQzdFLE1BQU1zRCxhQUFhRCxNQUFNMUMsT0FBTztRQUNoQyxPQUFPO1lBQUVzQztZQUFNRTtZQUFRbkQ7WUFBUXFEO1lBQU9DO1FBQVc7SUFDckQ7SUFDQSw2Q0FBNkMsR0FDN0MsU0FBU0MsYUFBYVIsU0FBUztRQUMzQixPQUFPSyxxQkFBcUJMLFdBQVdPLFVBQVU7SUFDckQ7SUFDQSw4Q0FBOEM7SUFDOUMsU0FBU0UsbUJBQW1CQyxVQUFVQyxXQUFXQyxFQUFFLEVBQUUsRUFBRSxHQUFHQyxJQUFJO1FBQzFELE1BQU1DLE1BQU1sTSxzREFBV0EsSUFBSWlNO1FBQzNCLE9BQU9sQixRQUFRVCxNQUFNRyxPQUFPeUIsS0FBS2hNLHNEQUFXQSxDQUFDLFdBQVc0TCxVQUFVLENBQUMsQ0FBQ3BCO0lBQ3hFO0lBQ0EsaURBQWlELEdBQ2pELFNBQVN5QixLQUFLRCxHQUFHLEVBQUVkLFNBQVMsRUFBRWdCLFVBQVUsQ0FBQyxDQUFDO1FBQ3RDRixNQUFNaE0sc0RBQVdBLENBQUMsV0FBV2dNO1FBQzdCLElBQUl4QixTQUNBd0IsTUFBTXhCLFFBQVF3QixNQUFNLHFCQUFxQjtRQUM3QyxNQUFNLEVBQUVWLE1BQU0sRUFBRW5ELE1BQU0sRUFBRXNELFVBQVUsRUFBRSxHQUFHRixxQkFBcUJMO1FBQzVELE1BQU1pQixJQUFJUixtQkFBbUJPLFFBQVFOLE9BQU8sRUFBRU4sUUFBUVUsTUFBTSxvQ0FBb0M7UUFDaEcsTUFBTUksSUFBSXpDLEtBQUtyRCxRQUFRLENBQUM2RixHQUFHckQsT0FBTyxJQUFJLFNBQVM7UUFDL0MsTUFBTXVELElBQUlWLG1CQUFtQk8sUUFBUU4sT0FBTyxFQUFFUSxHQUFHWCxZQUFZTyxNQUFNLGtCQUFrQjtRQUNyRixNQUFNTSxJQUFJakssR0FBR1EsTUFBTSxDQUFDc0osSUFBSUUsSUFBSWxFLFNBQVMsd0JBQXdCO1FBQzdELElBQUksQ0FBQzlGLEdBQUdXLE9BQU8sQ0FBQ3NKLElBQ1osTUFBTSxJQUFJL0ksTUFBTSwyQkFBMkIsYUFBYTtRQUM1RCxNQUFNZ0osS0FBS3pNLHNEQUFXQSxDQUFDc00sR0FBRy9KLEdBQUd5RyxPQUFPLENBQUN3RDtRQUNyQyxPQUFPNU0sbURBQU1BLENBQUM2TSxJQUFJdEIsUUFBUXVCLFNBQVMsRUFBRTtJQUN6QztJQUNBLDhFQUE4RTtJQUM5RSxNQUFNQyxhQUFhO1FBQUVsSCxRQUFRO0lBQUs7SUFDbEM7OztLQUdDLEdBQ0QsU0FBU21ILE9BQU9DLEdBQUcsRUFBRVgsR0FBRyxFQUFFWSxTQUFTLEVBQUVWLFVBQVVPLFVBQVU7UUFDckQsTUFBTSxFQUFFYixPQUFPLEVBQUVyRyxNQUFNLEVBQUUsR0FBRzJHO1FBQzVCLE1BQU0xRyxNQUFNeUYsUUFBUXVCLFNBQVM7UUFDN0JHLE1BQU0zTSxzREFBV0EsQ0FBQyxhQUFhMk0sS0FBS25IO1FBQ3BDd0csTUFBTWhNLHNEQUFXQSxDQUFDLFdBQVdnTTtRQUM3QlksWUFBWTVNLHNEQUFXQSxDQUFDLGFBQWE0TSxXQUFXM0IsUUFBUTJCLFNBQVM7UUFDakUsSUFBSXJILFdBQVdzSCxXQUNYck4sa0RBQUtBLENBQUMrRixRQUFRO1FBQ2xCLElBQUlpRixTQUNBd0IsTUFBTXhCLFFBQVF3QixNQUFNLHFCQUFxQjtRQUM3QyxNQUFNYyxNQUFNdEgsTUFBTTtRQUNsQixNQUFNMkcsSUFBSVEsSUFBSUksUUFBUSxDQUFDLEdBQUdEO1FBQzFCLE1BQU1SLElBQUl6TSwwREFBZUEsQ0FBQzhNLElBQUlJLFFBQVEsQ0FBQ0QsS0FBS3RIO1FBQzVDLElBQUkyQixHQUFHaUYsR0FBR1k7UUFDVixJQUFJO1lBQ0EsdUZBQXVGO1lBQ3ZGLGtEQUFrRDtZQUNsRCxrREFBa0Q7WUFDbEQ3RixJQUFJckQsTUFBTXVCLFNBQVMsQ0FBQ3VILFdBQVdySDtZQUMvQjZHLElBQUl0SSxNQUFNdUIsU0FBUyxDQUFDOEcsR0FBRzVHO1lBQ3ZCeUgsS0FBS3JELEtBQUtwQixjQUFjLENBQUMrRCxJQUFJLDRCQUE0QjtRQUM3RCxFQUNBLE9BQU9XLE9BQU87WUFDVixPQUFPO1FBQ1g7UUFDQSxJQUFJLENBQUMxSCxVQUFVNEIsRUFBRXVCLFlBQVksSUFDekIsT0FBTyxPQUFPLDJDQUEyQztRQUM3RCxNQUFNMkQsSUFBSVYsbUJBQW1CQyxTQUFTUSxFQUFFdEQsT0FBTyxJQUFJM0IsRUFBRTJCLE9BQU8sSUFBSWtEO1FBQ2hFLE1BQU1rQixNQUFNZCxFQUFFM0ssR0FBRyxDQUFDMEYsRUFBRW9CLGNBQWMsQ0FBQzhEO1FBQ25DLDBCQUEwQjtRQUMxQiw0QkFBNEI7UUFDNUIsT0FBT2EsSUFBSWhGLFFBQVEsQ0FBQzhFLElBQUluRSxhQUFhLEdBQUd4RSxHQUFHO0lBQy9DO0lBQ0EsTUFBTThJLFFBQVFsTSxHQUFHeUIsS0FBSyxFQUFFLCtCQUErQjtJQUN2RCxNQUFNdUksVUFBVTtRQUNaQyxXQUFXaUM7UUFDWFAsV0FBV087UUFDWFgsV0FBVyxJQUFJVztRQUNmQyxNQUFNRDtJQUNWO0lBQ0EsU0FBU0UsZ0JBQWdCRCxPQUFPaE4sWUFBWTZLLFFBQVFtQyxJQUFJLENBQUM7UUFDckQsT0FBTzFOLG1EQUFNQSxDQUFDME4sTUFBTW5DLFFBQVFtQyxJQUFJLEVBQUU7SUFDdEM7SUFDQSxTQUFTRSxPQUFPRixJQUFJO1FBQ2hCLE1BQU1sQyxZQUFZcUMsTUFBTUYsZUFBZSxDQUFDRDtRQUN4QyxPQUFPO1lBQUVsQztZQUFXMEIsV0FBV2xCLGFBQWFSO1FBQVc7SUFDM0Q7SUFDQSxTQUFTc0MsaUJBQWlCeEMsR0FBRztRQUN6QixPQUFPL0ssa0RBQU9BLENBQUMrSyxRQUFRQSxJQUFJakMsTUFBTSxLQUFLMUcsR0FBR0ssS0FBSztJQUNsRDtJQUNBLFNBQVMrSyxpQkFBaUJ6QyxHQUFHLEVBQUV6RixNQUFNO1FBQ2pDLElBQUk7WUFDQSxPQUFPLENBQUMsQ0FBQ3pCLE1BQU11QixTQUFTLENBQUMyRixLQUFLekY7UUFDbEMsRUFDQSxPQUFPMEgsT0FBTztZQUNWLE9BQU87UUFDWDtJQUNKO0lBQ0EsTUFBTU0sUUFBUTtRQUNWaEM7UUFDQThCO1FBQ0FHO1FBQ0FDO1FBQ0E7Ozs7Ozs7O1NBUUMsR0FDREMsY0FBYWQsU0FBUztZQUNsQixNQUFNLEVBQUV4TCxDQUFDLEVBQUUsR0FBRzBDLE1BQU11QixTQUFTLENBQUN1SDtZQUM5QixNQUFNZSxPQUFPMUMsUUFBUTJCLFNBQVM7WUFDOUIsTUFBTWdCLFVBQVVELFNBQVM7WUFDekIsSUFBSSxDQUFDQyxXQUFXRCxTQUFTLElBQ3JCLE1BQU0sSUFBSXBLLE1BQU07WUFDcEIsTUFBTVQsSUFBSThLLFVBQVUzTSxHQUFHa0MsR0FBRyxDQUFDdEMsTUFBTU8sR0FBR1AsTUFBTU8sS0FBS0gsR0FBR2tDLEdBQUcsQ0FBQy9CLElBQUlQLEtBQUtPLElBQUlQO1lBQ25FLE9BQU9JLEdBQUc2SCxPQUFPLENBQUNoRztRQUN0QjtRQUNBK0ssb0JBQW1CM0MsU0FBUztZQUN4QixNQUFNeUMsT0FBTzFDLFFBQVFDLFNBQVM7WUFDOUJ4TCxtREFBTUEsQ0FBQ3dMLFdBQVd5QztZQUNsQixNQUFNeEMsU0FBU2YsTUFBTWMsVUFBVTZCLFFBQVEsQ0FBQyxHQUFHWTtZQUMzQyxPQUFPckQsa0JBQWtCYSxRQUFRNEIsUUFBUSxDQUFDLEdBQUdZO1FBQ2pEO1FBQ0EsZ0JBQWdCLEdBQ2hCRyxrQkFBa0JUO1FBQ2xCLGdCQUFnQixHQUNoQnBILFlBQVdDLGFBQWEsQ0FBQyxFQUFFc0YsUUFBUTFILE1BQU02RixJQUFJO1lBQ3pDLE9BQU82QixNQUFNdkYsVUFBVSxDQUFDQyxZQUFZO1FBQ3hDO0lBQ0o7SUFDQSxPQUFPaEIsT0FBT0MsTUFBTSxDQUFDO1FBQ2pCbUk7UUFDQTVCO1FBQ0FPO1FBQ0FTO1FBQ0FhO1FBQ0F6SjtRQUNBbUg7SUFDSjtBQUNKO0FBQ0EsU0FBUzhDLDBCQUEwQkMsQ0FBQztJQUNoQyxNQUFNOU0sUUFBUTtRQUNWUyxHQUFHcU0sRUFBRXJNLENBQUM7UUFDTkcsR0FBR2tNLEVBQUVsTSxDQUFDO1FBQ05rQyxHQUFHZ0ssRUFBRS9NLEVBQUUsQ0FBQzJFLEtBQUs7UUFDYmhELEdBQUdvTCxFQUFFcEwsQ0FBQztRQUNOTixHQUFHMEwsRUFBRTFMLENBQUM7UUFDTmUsSUFBSTJLLEVBQUUzSyxFQUFFO1FBQ1JDLElBQUkwSyxFQUFFMUssRUFBRTtJQUNaO0lBQ0EsTUFBTXJDLEtBQUsrTSxFQUFFL00sRUFBRTtJQUNmLE1BQU1vQixLQUFLM0Isa0RBQUtBLENBQUNRLE1BQU0wQixDQUFDLEVBQUVvTCxFQUFFQyxVQUFVLEVBQUU7SUFDeEMsTUFBTUMsWUFBWTtRQUFFak47UUFBSW9CO1FBQUlHLFNBQVN3TCxFQUFFeEwsT0FBTztJQUFDO0lBQy9DLE1BQU02SCxZQUFZO1FBQ2RqSyxhQUFhNE4sRUFBRTVOLFdBQVc7UUFDMUJrSyxtQkFBbUIwRCxFQUFFMUQsaUJBQWlCO1FBQ3RDQyxRQUFReUQsRUFBRXpELE1BQU07UUFDaEJDLFNBQVN3RCxFQUFFeEQsT0FBTztRQUNsQkMsWUFBWXVELEVBQUV2RCxVQUFVO0lBQzVCO0lBQ0EsT0FBTztRQUFFdko7UUFBT2dOO1FBQVdwRCxNQUFNa0QsRUFBRWxELElBQUk7UUFBRVQ7SUFBVTtBQUN2RDtBQUNBLFNBQVM4RCw0QkFBNEJILENBQUMsRUFBRTdELEtBQUs7SUFDekMsTUFBTXJHLFFBQVFxRyxNQUFNckcsS0FBSztJQUN6QixNQUFNc0ssU0FBU2xKLE9BQU9tSixNQUFNLENBQUMsQ0FBQyxHQUFHbEUsT0FBTztRQUNwQ21FLGVBQWV4SztRQUNmNUMsT0FBTzhNO1FBQ1BDLFlBQVluSyxNQUFNekIsRUFBRSxDQUFDdUgsSUFBSTtRQUN6QjJFLGFBQWF6SyxNQUFNekIsRUFBRSxDQUFDSyxLQUFLO0lBQy9CO0lBQ0EsT0FBTzBMO0FBQ1g7QUFDQSwwQkFBMEI7QUFDbkIsU0FBU0ksZUFBZVIsQ0FBQztJQUM1QixNQUFNLEVBQUU5TSxLQUFLLEVBQUVnTixTQUFTLEVBQUVwRCxJQUFJLEVBQUVULFNBQVMsRUFBRSxHQUFHMEQsMEJBQTBCQztJQUN4RSxNQUFNbEssUUFBUTlCLFFBQVFkLE9BQU9nTjtJQUM3QixNQUFNTyxRQUFRdEUsTUFBTXJHLE9BQU9nSCxNQUFNVDtJQUNqQyxPQUFPOEQsNEJBQTRCSCxHQUFHUztBQUMxQyxFQUNBLG1DQUFtQyIsInNvdXJjZXMiOlsid2VicGFjazovL25vdGFzY2FtLXByb3RvY29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bub2JsZStjdXJ2ZXNAMS45Ljcvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2Vkd2FyZHMuanM/MjFmNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFR3aXN0ZWQgRWR3YXJkcyBjdXJ2ZS4gVGhlIGZvcm11bGEgaXM6IGF4wrIgKyB5wrIgPSAxICsgZHjCsnnCsi5cbiAqIEZvciBkZXNpZ24gcmF0aW9uYWxlIG9mIHR5cGVzIC8gZXhwb3J0cywgc2VlIHdlaWVyc3RyYXNzIG1vZHVsZSBkb2N1bWVudGF0aW9uLlxuICogVW50d2lzdGVkIEVkd2FyZHMgY3VydmVzIGV4aXN0LCBidXQgdGhleSBhcmVuJ3QgdXNlZCBpbiByZWFsLXdvcmxkIHByb3RvY29scy5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgX3ZhbGlkYXRlT2JqZWN0LCBfYWJvb2wyIGFzIGFib29sLCBfYWJ5dGVzMiBhcyBhYnl0ZXMsIGFJblJhbmdlLCBieXRlc1RvSGV4LCBieXRlc1RvTnVtYmVyTEUsIGNvbmNhdEJ5dGVzLCBjb3B5Qnl0ZXMsIGVuc3VyZUJ5dGVzLCBpc0J5dGVzLCBtZW1vaXplZCwgbm90SW1wbGVtZW50ZWQsIHJhbmRvbUJ5dGVzIGFzIHJhbmRvbUJ5dGVzV2ViLCB9IGZyb20gXCIuLi91dGlscy5qc1wiO1xuaW1wb3J0IHsgX2NyZWF0ZUN1cnZlRmllbGRzLCBub3JtYWxpemVaLCBwaXBwZW5nZXIsIHdOQUYsIH0gZnJvbSBcIi4vY3VydmUuanNcIjtcbmltcG9ydCB7IEZpZWxkIH0gZnJvbSBcIi4vbW9kdWxhci5qc1wiO1xuLy8gQmUgZnJpZW5kbHkgdG8gYmFkIEVDTUFTY3JpcHQgcGFyc2VycyBieSBub3QgdXNpbmcgYmlnaW50IGxpdGVyYWxzXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF84biA9IEJpZ0ludCg4KTtcbmZ1bmN0aW9uIGlzRWRWYWxpZFhZKEZwLCBDVVJWRSwgeCwgeSkge1xuICAgIGNvbnN0IHgyID0gRnAuc3FyKHgpO1xuICAgIGNvbnN0IHkyID0gRnAuc3FyKHkpO1xuICAgIGNvbnN0IGxlZnQgPSBGcC5hZGQoRnAubXVsKENVUlZFLmEsIHgyKSwgeTIpO1xuICAgIGNvbnN0IHJpZ2h0ID0gRnAuYWRkKEZwLk9ORSwgRnAubXVsKENVUlZFLmQsIEZwLm11bCh4MiwgeTIpKSk7XG4gICAgcmV0dXJuIEZwLmVxbChsZWZ0LCByaWdodCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZWR3YXJkcyhwYXJhbXMsIGV4dHJhT3B0cyA9IHt9KSB7XG4gICAgY29uc3QgdmFsaWRhdGVkID0gX2NyZWF0ZUN1cnZlRmllbGRzKCdlZHdhcmRzJywgcGFyYW1zLCBleHRyYU9wdHMsIGV4dHJhT3B0cy5GcEZuTEUpO1xuICAgIGNvbnN0IHsgRnAsIEZuIH0gPSB2YWxpZGF0ZWQ7XG4gICAgbGV0IENVUlZFID0gdmFsaWRhdGVkLkNVUlZFO1xuICAgIGNvbnN0IHsgaDogY29mYWN0b3IgfSA9IENVUlZFO1xuICAgIF92YWxpZGF0ZU9iamVjdChleHRyYU9wdHMsIHt9LCB7IHV2UmF0aW86ICdmdW5jdGlvbicgfSk7XG4gICAgLy8gSW1wb3J0YW50OlxuICAgIC8vIFRoZXJlIGFyZSBzb21lIHBsYWNlcyB3aGVyZSBGcC5CWVRFUyBpcyB1c2VkIGluc3RlYWQgb2YgbkJ5dGVMZW5ndGguXG4gICAgLy8gU28gZmFyLCBldmVyeXRoaW5nIGhhcyBiZWVuIHRlc3RlZCB3aXRoIGN1cnZlcyBvZiBGcC5CWVRFUyA9PSBuQnl0ZUxlbmd0aC5cbiAgICAvLyBUT0RPOiB0ZXN0IGFuZCBmaW5kIGN1cnZlcyB3aGljaCBiZWhhdmUgb3RoZXJ3aXNlLlxuICAgIGNvbnN0IE1BU0sgPSBfMm4gPDwgKEJpZ0ludChGbi5CWVRFUyAqIDgpIC0gXzFuKTtcbiAgICBjb25zdCBtb2RQID0gKG4pID0+IEZwLmNyZWF0ZShuKTsgLy8gRnVuY3Rpb24gb3ZlcnJpZGVzXG4gICAgLy8gc3FydCh1L3YpXG4gICAgY29uc3QgdXZSYXRpbyA9IGV4dHJhT3B0cy51dlJhdGlvIHx8XG4gICAgICAgICgodSwgdikgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiB0cnVlLCB2YWx1ZTogRnAuc3FydChGcC5kaXYodSwgdikpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCB2YWx1ZTogXzBuIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIC8vIFZhbGlkYXRlIHdoZXRoZXIgdGhlIHBhc3NlZCBjdXJ2ZSBwYXJhbXMgYXJlIHZhbGlkLlxuICAgIC8vIGVxdWF0aW9uIGF4wrIgKyB5wrIgPSAxICsgZHjCsnnCsiBzaG91bGQgd29yayBmb3IgZ2VuZXJhdG9yIHBvaW50LlxuICAgIGlmICghaXNFZFZhbGlkWFkoRnAsIENVUlZFLCBDVVJWRS5HeCwgQ1VSVkUuR3kpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBjdXJ2ZSBwYXJhbXM6IGdlbmVyYXRvciBwb2ludCcpO1xuICAgIC8qKlxuICAgICAqIEFzc2VydHMgY29vcmRpbmF0ZSBpcyB2YWxpZDogMCA8PSBuIDwgTUFTSy5cbiAgICAgKiBDb29yZGluYXRlcyA+PSBGcC5PUkRFUiBhcmUgYWxsb3dlZCBmb3IgemlwMjE1LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFjb29yZCh0aXRsZSwgbiwgYmFuWmVybyA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IG1pbiA9IGJhblplcm8gPyBfMW4gOiBfMG47XG4gICAgICAgIGFJblJhbmdlKCdjb29yZGluYXRlICcgKyB0aXRsZSwgbiwgbWluLCBNQVNLKTtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFleHRwb2ludChvdGhlcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFBvaW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXh0ZW5kZWRQb2ludCBleHBlY3RlZCcpO1xuICAgIH1cbiAgICAvLyBDb252ZXJ0cyBFeHRlbmRlZCBwb2ludCB0byBkZWZhdWx0ICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAvLyBDYW4gYWNjZXB0IHByZWNvbXB1dGVkIFpeLTEgLSBmb3IgZXhhbXBsZSwgZnJvbSBpbnZlcnRCYXRjaC5cbiAgICBjb25zdCB0b0FmZmluZU1lbW8gPSBtZW1vaXplZCgocCwgaXopID0+IHtcbiAgICAgICAgY29uc3QgeyBYLCBZLCBaIH0gPSBwO1xuICAgICAgICBjb25zdCBpczAgPSBwLmlzMCgpO1xuICAgICAgICBpZiAoaXogPT0gbnVsbClcbiAgICAgICAgICAgIGl6ID0gaXMwID8gXzhuIDogRnAuaW52KFopOyAvLyA4IHdhcyBjaG9zZW4gYXJiaXRyYXJpbHlcbiAgICAgICAgY29uc3QgeCA9IG1vZFAoWCAqIGl6KTtcbiAgICAgICAgY29uc3QgeSA9IG1vZFAoWSAqIGl6KTtcbiAgICAgICAgY29uc3QgenogPSBGcC5tdWwoWiwgaXopO1xuICAgICAgICBpZiAoaXMwKVxuICAgICAgICAgICAgcmV0dXJuIHsgeDogXzBuLCB5OiBfMW4gfTtcbiAgICAgICAgaWYgKHp6ICE9PSBfMW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludlogd2FzIGludmFsaWQnKTtcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH0pO1xuICAgIGNvbnN0IGFzc2VydFZhbGlkTWVtbyA9IG1lbW9pemVkKChwKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgYSwgZCB9ID0gQ1VSVkU7XG4gICAgICAgIGlmIChwLmlzMCgpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IFpFUk8nKTsgLy8gVE9ETzogb3B0aW1pemUsIHdpdGggdmFycyBiZWxvdz9cbiAgICAgICAgLy8gRXF1YXRpb24gaW4gYWZmaW5lIGNvb3JkaW5hdGVzOiBheMKyICsgecKyID0gMSArIGR4wrJ5wrJcbiAgICAgICAgLy8gRXF1YXRpb24gaW4gcHJvamVjdGl2ZSBjb29yZGluYXRlcyAoWC9aLCBZL1osIFopOiAgKGFYwrIgKyBZwrIpWsKyID0gWuKBtCArIGRYwrJZwrJcbiAgICAgICAgY29uc3QgeyBYLCBZLCBaLCBUIH0gPSBwO1xuICAgICAgICBjb25zdCBYMiA9IG1vZFAoWCAqIFgpOyAvLyBYwrJcbiAgICAgICAgY29uc3QgWTIgPSBtb2RQKFkgKiBZKTsgLy8gWcKyXG4gICAgICAgIGNvbnN0IFoyID0gbW9kUChaICogWik7IC8vIFrCslxuICAgICAgICBjb25zdCBaNCA9IG1vZFAoWjIgKiBaMik7IC8vIFrigbRcbiAgICAgICAgY29uc3QgYVgyID0gbW9kUChYMiAqIGEpOyAvLyBhWMKyXG4gICAgICAgIGNvbnN0IGxlZnQgPSBtb2RQKFoyICogbW9kUChhWDIgKyBZMikpOyAvLyAoYVjCsiArIFnCsilawrJcbiAgICAgICAgY29uc3QgcmlnaHQgPSBtb2RQKFo0ICsgbW9kUChkICogbW9kUChYMiAqIFkyKSkpOyAvLyBa4oG0ICsgZFjCslnCslxuICAgICAgICBpZiAobGVmdCAhPT0gcmlnaHQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCAoMSknKTtcbiAgICAgICAgLy8gSW4gRXh0ZW5kZWQgY29vcmRpbmF0ZXMgd2UgYWxzbyBoYXZlIFQsIHdoaWNoIGlzIHgqeT1UL1o6IGNoZWNrIFgqWSA9PSBaKlRcbiAgICAgICAgY29uc3QgWFkgPSBtb2RQKFggKiBZKTtcbiAgICAgICAgY29uc3QgWlQgPSBtb2RQKFogKiBUKTtcbiAgICAgICAgaWYgKFhZICE9PSBaVClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0ICgyKScpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICAvLyBFeHRlbmRlZCBQb2ludCB3b3JrcyBpbiBleHRlbmRlZCBjb29yZGluYXRlczogKFgsIFksIFosIFQpIOKIiyAoeD1YL1osIHk9WS9aLCBUPXh5KS5cbiAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ud2lzdGVkX0Vkd2FyZHNfY3VydmUjRXh0ZW5kZWRfY29vcmRpbmF0ZXNcbiAgICBjbGFzcyBQb2ludCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKFgsIFksIFosIFQpIHtcbiAgICAgICAgICAgIHRoaXMuWCA9IGFjb29yZCgneCcsIFgpO1xuICAgICAgICAgICAgdGhpcy5ZID0gYWNvb3JkKCd5JywgWSk7XG4gICAgICAgICAgICB0aGlzLlogPSBhY29vcmQoJ3onLCBaLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuVCA9IGFjb29yZCgndCcsIFQpO1xuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgQ1VSVkUoKSB7XG4gICAgICAgICAgICByZXR1cm4gQ1VSVkU7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGZyb21BZmZpbmUocCkge1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4dGVuZGVkIHBvaW50IG5vdCBhbGxvd2VkJyk7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAgfHwge307XG4gICAgICAgICAgICBhY29vcmQoJ3gnLCB4KTtcbiAgICAgICAgICAgIGFjb29yZCgneScsIHkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5LCBfMW4sIG1vZFAoeCAqIHkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2VzIGFsZ28gZnJvbSBSRkM4MDMyIDUuMS4zLlxuICAgICAgICBzdGF0aWMgZnJvbUJ5dGVzKGJ5dGVzLCB6aXAyMTUgPSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc3QgbGVuID0gRnAuQllURVM7XG4gICAgICAgICAgICBjb25zdCB7IGEsIGQgfSA9IENVUlZFO1xuICAgICAgICAgICAgYnl0ZXMgPSBjb3B5Qnl0ZXMoYWJ5dGVzKGJ5dGVzLCBsZW4sICdwb2ludCcpKTtcbiAgICAgICAgICAgIGFib29sKHppcDIxNSwgJ3ppcDIxNScpO1xuICAgICAgICAgICAgY29uc3Qgbm9ybWVkID0gY29weUJ5dGVzKGJ5dGVzKTsgLy8gY29weSBhZ2Fpbiwgd2UnbGwgbWFuaXB1bGF0ZSBpdFxuICAgICAgICAgICAgY29uc3QgbGFzdEJ5dGUgPSBieXRlc1tsZW4gLSAxXTsgLy8gc2VsZWN0IGxhc3QgYnl0ZVxuICAgICAgICAgICAgbm9ybWVkW2xlbiAtIDFdID0gbGFzdEJ5dGUgJiB+MHg4MDsgLy8gY2xlYXIgbGFzdCBiaXRcbiAgICAgICAgICAgIGNvbnN0IHkgPSBieXRlc1RvTnVtYmVyTEUobm9ybWVkKTtcbiAgICAgICAgICAgIC8vIHppcDIxNT10cnVlIGlzIGdvb2QgZm9yIGNvbnNlbnN1cy1jcml0aWNhbCBhcHBzLiA9ZmFsc2UgZm9sbG93cyBSRkM4MDMyIC8gTklTVDE4Ni01LlxuICAgICAgICAgICAgLy8gUkZDODAzMiBwcm9oaWJpdHMgPj0gcCwgYnV0IFpJUDIxNSBkb2Vzbid0XG4gICAgICAgICAgICAvLyB6aXAyMTU9dHJ1ZTogIDAgPD0geSA8IE1BU0sgKDJeMjU2IGZvciBlZDI1NTE5KVxuICAgICAgICAgICAgLy8gemlwMjE1PWZhbHNlOiAwIDw9IHkgPCBQICgyXjI1NS0xOSBmb3IgZWQyNTUxOSlcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IHppcDIxNSA/IE1BU0sgOiBGcC5PUkRFUjtcbiAgICAgICAgICAgIGFJblJhbmdlKCdwb2ludC55JywgeSwgXzBuLCBtYXgpO1xuICAgICAgICAgICAgLy8gRWQyNTUxOTogeMKyID0gKHnCsi0xKS8oZHnCsisxKSBtb2QgcC4gRWQ0NDg6IHjCsiA9ICh5wrItMSkvKGR5wrItMSkgbW9kIHAuIEdlbmVyaWMgY2FzZTpcbiAgICAgICAgICAgIC8vIGF4wrIrecKyPTErZHjCsnnCsiA9PiB5wrItMT1keMKyecKyLWF4wrIgPT4gecKyLTE9eMKyKGR5wrItYSkgPT4geMKyPSh5wrItMSkvKGR5wrItYSlcbiAgICAgICAgICAgIGNvbnN0IHkyID0gbW9kUCh5ICogeSk7IC8vIGRlbm9taW5hdG9yIGlzIGFsd2F5cyBub24tMCBtb2QgcC5cbiAgICAgICAgICAgIGNvbnN0IHUgPSBtb2RQKHkyIC0gXzFuKTsgLy8gdSA9IHnCsiAtIDFcbiAgICAgICAgICAgIGNvbnN0IHYgPSBtb2RQKGQgKiB5MiAtIGEpOyAvLyB2ID0gZCB5wrIgKyAxLlxuICAgICAgICAgICAgbGV0IHsgaXNWYWxpZCwgdmFsdWU6IHggfSA9IHV2UmF0aW8odSwgdik7IC8vIOKImih1L3YpXG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IGludmFsaWQgeSBjb29yZGluYXRlJyk7XG4gICAgICAgICAgICBjb25zdCBpc1hPZGQgPSAoeCAmIF8xbikgPT09IF8xbjsgLy8gVGhlcmUgYXJlIDIgc3F1YXJlIHJvb3RzLiBVc2UgeF8wIGJpdCB0byBzZWxlY3QgcHJvcGVyXG4gICAgICAgICAgICBjb25zdCBpc0xhc3RCeXRlT2RkID0gKGxhc3RCeXRlICYgMHg4MCkgIT09IDA7IC8vIHhfMCwgbGFzdCBiaXRcbiAgICAgICAgICAgIGlmICghemlwMjE1ICYmIHggPT09IF8wbiAmJiBpc0xhc3RCeXRlT2RkKVxuICAgICAgICAgICAgICAgIC8vIGlmIHg9MCBhbmQgeF8wID0gMSwgZmFpbFxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiB4PTAgYW5kIHhfMD0xJyk7XG4gICAgICAgICAgICBpZiAoaXNMYXN0Qnl0ZU9kZCAhPT0gaXNYT2RkKVxuICAgICAgICAgICAgICAgIHggPSBtb2RQKC14KTsgLy8gaWYgeF8wICE9IHggbW9kIDIsIHNldCB4ID0gcC14XG4gICAgICAgICAgICByZXR1cm4gUG9pbnQuZnJvbUFmZmluZSh7IHgsIHkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGZyb21IZXgoYnl0ZXMsIHppcDIxNSA9IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gUG9pbnQuZnJvbUJ5dGVzKGVuc3VyZUJ5dGVzKCdwb2ludCcsIGJ5dGVzKSwgemlwMjE1KTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgICAgICAgfVxuICAgICAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUgPSA4LCBpc0xhenkgPSB0cnVlKSB7XG4gICAgICAgICAgICB3bmFmLmNyZWF0ZUNhY2hlKHRoaXMsIHdpbmRvd1NpemUpO1xuICAgICAgICAgICAgaWYgKCFpc0xhenkpXG4gICAgICAgICAgICAgICAgdGhpcy5tdWx0aXBseShfMm4pOyAvLyByYW5kb20gbnVtYmVyXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2VmdWwgaW4gZnJvbUFmZmluZSgpIC0gbm90IGZvciBmcm9tQnl0ZXMoKSwgd2hpY2ggYWx3YXlzIGNyZWF0ZWQgdmFsaWQgcG9pbnRzLlxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgICAgIGFzc2VydFZhbGlkTWVtbyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wYXJlIG9uZSBwb2ludCB0byBhbm90aGVyLlxuICAgICAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgICAgIGFleHRwb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IFg6IFgxLCBZOiBZMSwgWjogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IFg6IFgyLCBZOiBZMiwgWjogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgY29uc3QgWDFaMiA9IG1vZFAoWDEgKiBaMik7XG4gICAgICAgICAgICBjb25zdCBYMloxID0gbW9kUChYMiAqIFoxKTtcbiAgICAgICAgICAgIGNvbnN0IFkxWjIgPSBtb2RQKFkxICogWjIpO1xuICAgICAgICAgICAgY29uc3QgWTJaMSA9IG1vZFAoWTIgKiBaMSk7XG4gICAgICAgICAgICByZXR1cm4gWDFaMiA9PT0gWDJaMSAmJiBZMVoyID09PSBZMloxO1xuICAgICAgICB9XG4gICAgICAgIGlzMCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhQb2ludC5aRVJPKTtcbiAgICAgICAgfVxuICAgICAgICBuZWdhdGUoKSB7XG4gICAgICAgICAgICAvLyBGbGlwcyBwb2ludCBzaWduIHRvIGEgbmVnYXRpdmUgb25lICgteCwgeSBpbiBhZmZpbmUgY29vcmRzKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChtb2RQKC10aGlzLlgpLCB0aGlzLlksIHRoaXMuWiwgbW9kUCgtdGhpcy5UKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFzdCBhbGdvIGZvciBkb3VibGluZyBFeHRlbmRlZCBQb2ludC5cbiAgICAgICAgLy8gaHR0cHM6Ly9oeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tdHdpc3RlZC1leHRlbmRlZC5odG1sI2RvdWJsaW5nLWRibC0yMDA4LWh3Y2RcbiAgICAgICAgLy8gQ29zdDogNE0gKyA0UyArIDEqYSArIDZhZGQgKyAxKjIuXG4gICAgICAgIGRvdWJsZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYSB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBjb25zdCB7IFg6IFgxLCBZOiBZMSwgWjogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBBID0gbW9kUChYMSAqIFgxKTsgLy8gQSA9IFgxMlxuICAgICAgICAgICAgY29uc3QgQiA9IG1vZFAoWTEgKiBZMSk7IC8vIEIgPSBZMTJcbiAgICAgICAgICAgIGNvbnN0IEMgPSBtb2RQKF8ybiAqIG1vZFAoWjEgKiBaMSkpOyAvLyBDID0gMipaMTJcbiAgICAgICAgICAgIGNvbnN0IEQgPSBtb2RQKGEgKiBBKTsgLy8gRCA9IGEqQVxuICAgICAgICAgICAgY29uc3QgeDF5MSA9IFgxICsgWTE7XG4gICAgICAgICAgICBjb25zdCBFID0gbW9kUChtb2RQKHgxeTEgKiB4MXkxKSAtIEEgLSBCKTsgLy8gRSA9IChYMStZMSkyLUEtQlxuICAgICAgICAgICAgY29uc3QgRyA9IEQgKyBCOyAvLyBHID0gRCtCXG4gICAgICAgICAgICBjb25zdCBGID0gRyAtIEM7IC8vIEYgPSBHLUNcbiAgICAgICAgICAgIGNvbnN0IEggPSBEIC0gQjsgLy8gSCA9IEQtQlxuICAgICAgICAgICAgY29uc3QgWDMgPSBtb2RQKEUgKiBGKTsgLy8gWDMgPSBFKkZcbiAgICAgICAgICAgIGNvbnN0IFkzID0gbW9kUChHICogSCk7IC8vIFkzID0gRypIXG4gICAgICAgICAgICBjb25zdCBUMyA9IG1vZFAoRSAqIEgpOyAvLyBUMyA9IEUqSFxuICAgICAgICAgICAgY29uc3QgWjMgPSBtb2RQKEYgKiBHKTsgLy8gWjMgPSBGKkdcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMywgVDMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZhc3QgYWxnbyBmb3IgYWRkaW5nIDIgRXh0ZW5kZWQgUG9pbnRzLlxuICAgICAgICAvLyBodHRwczovL2h5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by10d2lzdGVkLWV4dGVuZGVkLmh0bWwjYWRkaXRpb24tYWRkLTIwMDgtaHdjZFxuICAgICAgICAvLyBDb3N0OiA5TSArIDEqYSArIDEqZCArIDdhZGQuXG4gICAgICAgIGFkZChvdGhlcikge1xuICAgICAgICAgICAgYWV4dHBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgYSwgZCB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBjb25zdCB7IFg6IFgxLCBZOiBZMSwgWjogWjEsIFQ6IFQxIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBYOiBYMiwgWTogWTIsIFo6IFoyLCBUOiBUMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBjb25zdCBBID0gbW9kUChYMSAqIFgyKTsgLy8gQSA9IFgxKlgyXG4gICAgICAgICAgICBjb25zdCBCID0gbW9kUChZMSAqIFkyKTsgLy8gQiA9IFkxKlkyXG4gICAgICAgICAgICBjb25zdCBDID0gbW9kUChUMSAqIGQgKiBUMik7IC8vIEMgPSBUMSpkKlQyXG4gICAgICAgICAgICBjb25zdCBEID0gbW9kUChaMSAqIFoyKTsgLy8gRCA9IFoxKloyXG4gICAgICAgICAgICBjb25zdCBFID0gbW9kUCgoWDEgKyBZMSkgKiAoWDIgKyBZMikgLSBBIC0gQik7IC8vIEUgPSAoWDErWTEpKihYMitZMiktQS1CXG4gICAgICAgICAgICBjb25zdCBGID0gRCAtIEM7IC8vIEYgPSBELUNcbiAgICAgICAgICAgIGNvbnN0IEcgPSBEICsgQzsgLy8gRyA9IEQrQ1xuICAgICAgICAgICAgY29uc3QgSCA9IG1vZFAoQiAtIGEgKiBBKTsgLy8gSCA9IEItYSpBXG4gICAgICAgICAgICBjb25zdCBYMyA9IG1vZFAoRSAqIEYpOyAvLyBYMyA9IEUqRlxuICAgICAgICAgICAgY29uc3QgWTMgPSBtb2RQKEcgKiBIKTsgLy8gWTMgPSBHKkhcbiAgICAgICAgICAgIGNvbnN0IFQzID0gbW9kUChFICogSCk7IC8vIFQzID0gRSpIXG4gICAgICAgICAgICBjb25zdCBaMyA9IG1vZFAoRiAqIEcpOyAvLyBaMyA9IEYqR1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozLCBUMyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29uc3RhbnQtdGltZSBtdWx0aXBsaWNhdGlvbi5cbiAgICAgICAgbXVsdGlwbHkoc2NhbGFyKSB7XG4gICAgICAgICAgICAvLyAxIDw9IHNjYWxhciA8IExcbiAgICAgICAgICAgIGlmICghRm4uaXNWYWxpZE5vdDAoc2NhbGFyKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2NhbGFyOiBleHBlY3RlZCAxIDw9IHNjIDwgY3VydmUubicpO1xuICAgICAgICAgICAgY29uc3QgeyBwLCBmIH0gPSB3bmFmLmNhY2hlZCh0aGlzLCBzY2FsYXIsIChwKSA9PiBub3JtYWxpemVaKFBvaW50LCBwKSk7XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplWihQb2ludCwgW3AsIGZdKVswXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb24tY29uc3RhbnQtdGltZSBtdWx0aXBsaWNhdGlvbi4gVXNlcyBkb3VibGUtYW5kLWFkZCBhbGdvcml0aG0uXG4gICAgICAgIC8vIEl0J3MgZmFzdGVyLCBidXQgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIHlvdSBkb24ndCBjYXJlIGFib3V0XG4gICAgICAgIC8vIGFuIGV4cG9zZWQgcHJpdmF0ZSBrZXkgZS5nLiBzaWcgdmVyaWZpY2F0aW9uLlxuICAgICAgICAvLyBEb2VzIE5PVCBhbGxvdyBzY2FsYXJzIGhpZ2hlciB0aGFuIENVUlZFLm4uXG4gICAgICAgIC8vIEFjY2VwdHMgb3B0aW9uYWwgYWNjdW11bGF0b3IgdG8gbWVyZ2Ugd2l0aCBtdWx0aXBseSAoaW1wb3J0YW50IGZvciBzcGFyc2Ugc2NhbGFycylcbiAgICAgICAgbXVsdGlwbHlVbnNhZmUoc2NhbGFyLCBhY2MgPSBQb2ludC5aRVJPKSB7XG4gICAgICAgICAgICAvLyAwIDw9IHNjYWxhciA8IExcbiAgICAgICAgICAgIGlmICghRm4uaXNWYWxpZChzY2FsYXIpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzY2FsYXI6IGV4cGVjdGVkIDAgPD0gc2MgPCBjdXJ2ZS5uJyk7XG4gICAgICAgICAgICBpZiAoc2NhbGFyID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBvaW50LlpFUk87XG4gICAgICAgICAgICBpZiAodGhpcy5pczAoKSB8fCBzY2FsYXIgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB3bmFmLnVuc2FmZSh0aGlzLCBzY2FsYXIsIChwKSA9PiBub3JtYWxpemVaKFBvaW50LCBwKSwgYWNjKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVja3MgaWYgcG9pbnQgaXMgb2Ygc21hbGwgb3JkZXIuXG4gICAgICAgIC8vIElmIHlvdSBhZGQgc29tZXRoaW5nIHRvIHNtYWxsIG9yZGVyIHBvaW50LCB5b3Ugd2lsbCBoYXZlIFwiZGlydHlcIlxuICAgICAgICAvLyBwb2ludCB3aXRoIHRvcnNpb24gY29tcG9uZW50LlxuICAgICAgICAvLyBNdWx0aXBsaWVzIHBvaW50IGJ5IGNvZmFjdG9yIGFuZCBjaGVja3MgaWYgdGhlIHJlc3VsdCBpcyAwLlxuICAgICAgICBpc1NtYWxsT3JkZXIoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShjb2ZhY3RvcikuaXMwKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlwbGllcyBwb2ludCBieSBjdXJ2ZSBvcmRlciBhbmQgY2hlY2tzIGlmIHRoZSByZXN1bHQgaXMgMC5cbiAgICAgICAgLy8gUmV0dXJucyBgZmFsc2VgIGlzIHRoZSBwb2ludCBpcyBkaXJ0eS5cbiAgICAgICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB3bmFmLnVuc2FmZSh0aGlzLCBDVVJWRS5uKS5pczAoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0cyBFeHRlbmRlZCBwb2ludCB0byBkZWZhdWx0ICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAgICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgICAgIHRvQWZmaW5lKGludmVydGVkWikge1xuICAgICAgICAgICAgcmV0dXJuIHRvQWZmaW5lTWVtbyh0aGlzLCBpbnZlcnRlZFopO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyQ29mYWN0b3IoKSB7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKGNvZmFjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB0b0J5dGVzKCkge1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLnRvQWZmaW5lKCk7XG4gICAgICAgICAgICAvLyBGcC50b0J5dGVzKCkgYWxsb3dzIG5vbi1jYW5vbmljYWwgZW5jb2Rpbmcgb2YgeSAoPj0gcCkuXG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IEZwLnRvQnl0ZXMoeSk7XG4gICAgICAgICAgICAvLyBFYWNoIHkgaGFzIDIgdmFsaWQgcG9pbnRzOiAoeCwgeSksICh4LC15KS5cbiAgICAgICAgICAgIC8vIFdoZW4gY29tcHJlc3NpbmcsIGl0J3MgZW5vdWdoIHRvIHN0b3JlIHkgYW5kIHVzZSB0aGUgbGFzdCBieXRlIHRvIGVuY29kZSBzaWduIG9mIHhcbiAgICAgICAgICAgIGJ5dGVzW2J5dGVzLmxlbmd0aCAtIDFdIHw9IHggJiBfMW4gPyAweDgwIDogMDtcbiAgICAgICAgICAgIHJldHVybiBieXRlcztcbiAgICAgICAgfVxuICAgICAgICB0b0hleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBieXRlc1RvSGV4KHRoaXMudG9CeXRlcygpKTtcbiAgICAgICAgfVxuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIHJldHVybiBgPFBvaW50ICR7dGhpcy5pczAoKSA/ICdaRVJPJyA6IHRoaXMudG9IZXgoKX0+YDtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiByZW1vdmVcbiAgICAgICAgZ2V0IGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuWDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgZXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ZO1xuICAgICAgICB9XG4gICAgICAgIGdldCBleigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLlo7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IGV0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuVDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgbm9ybWFsaXplWihwb2ludHMpIHtcbiAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVaKFBvaW50LCBwb2ludHMpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBtc20ocG9pbnRzLCBzY2FsYXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gcGlwcGVuZ2VyKFBvaW50LCBGbiwgcG9pbnRzLCBzY2FsYXJzKTtcbiAgICAgICAgfVxuICAgICAgICBfc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKSB7XG4gICAgICAgICAgICB0aGlzLnByZWNvbXB1dGUod2luZG93U2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9SYXdCeXRlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQnl0ZXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBiYXNlIC8gZ2VuZXJhdG9yIHBvaW50XG4gICAgUG9pbnQuQkFTRSA9IG5ldyBQb2ludChDVVJWRS5HeCwgQ1VSVkUuR3ksIF8xbiwgbW9kUChDVVJWRS5HeCAqIENVUlZFLkd5KSk7XG4gICAgLy8gemVybyAvIGluZmluaXR5IC8gaWRlbnRpdHkgcG9pbnRcbiAgICBQb2ludC5aRVJPID0gbmV3IFBvaW50KF8wbiwgXzFuLCBfMW4sIF8wbik7IC8vIDAsIDEsIDEsIDBcbiAgICAvLyBtYXRoIGZpZWxkXG4gICAgUG9pbnQuRnAgPSBGcDtcbiAgICAvLyBzY2FsYXIgZmllbGRcbiAgICBQb2ludC5GbiA9IEZuO1xuICAgIGNvbnN0IHduYWYgPSBuZXcgd05BRihQb2ludCwgRm4uQklUUyk7XG4gICAgUG9pbnQuQkFTRS5wcmVjb21wdXRlKDgpOyAvLyBFbmFibGUgcHJlY29tcHV0ZXMuIFNsb3dzIGRvd24gZmlyc3QgcHVibGljS2V5IGNvbXB1dGF0aW9uIGJ5IDIwbXMuXG4gICAgcmV0dXJuIFBvaW50O1xufVxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBwcmltZS1vcmRlciBwb2ludHMgbGlrZSBSaXN0cmV0dG8yNTUgYW5kIERlY2FmNDQ4LlxuICogVGhlc2UgcG9pbnRzIGVsaW1pbmF0ZSBjb2ZhY3RvciBpc3N1ZXMgYnkgcmVwcmVzZW50aW5nIGVxdWl2YWxlbmNlIGNsYXNzZXNcbiAqIG9mIEVkd2FyZHMgY3VydmUgcG9pbnRzLlxuICovXG5leHBvcnQgY2xhc3MgUHJpbWVFZHdhcmRzUG9pbnQge1xuICAgIGNvbnN0cnVjdG9yKGVwKSB7XG4gICAgICAgIHRoaXMuZXAgPSBlcDtcbiAgICB9XG4gICAgLy8gU3RhdGljIG1ldGhvZHMgdGhhdCBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IHN1YmNsYXNzZXNcbiAgICBzdGF0aWMgZnJvbUJ5dGVzKF9ieXRlcykge1xuICAgICAgICBub3RJbXBsZW1lbnRlZCgpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUhleChfaGV4KSB7XG4gICAgICAgIG5vdEltcGxlbWVudGVkKCk7XG4gICAgfVxuICAgIGdldCB4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLng7XG4gICAgfVxuICAgIGdldCB5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLnk7XG4gICAgfVxuICAgIC8vIENvbW1vbiBpbXBsZW1lbnRhdGlvbnNcbiAgICBjbGVhckNvZmFjdG9yKCkge1xuICAgICAgICAvLyBuby1vcCBmb3IgcHJpbWUtb3JkZXIgZ3JvdXBzXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgdGhpcy5lcC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIH1cbiAgICB0b0FmZmluZShpbnZlcnRlZFopIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXAudG9BZmZpbmUoaW52ZXJ0ZWRaKTtcbiAgICB9XG4gICAgdG9IZXgoKSB7XG4gICAgICAgIHJldHVybiBieXRlc1RvSGV4KHRoaXMudG9CeXRlcygpKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvSGV4KCk7XG4gICAgfVxuICAgIGlzVG9yc2lvbkZyZWUoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpc1NtYWxsT3JkZXIoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYWRkKG90aGVyKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2FtZShvdGhlcik7XG4gICAgICAgIHJldHVybiB0aGlzLmluaXQodGhpcy5lcC5hZGQob3RoZXIuZXApKTtcbiAgICB9XG4gICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRTYW1lKG90aGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdCh0aGlzLmVwLnN1YnRyYWN0KG90aGVyLmVwKSk7XG4gICAgfVxuICAgIG11bHRpcGx5KHNjYWxhcikge1xuICAgICAgICByZXR1cm4gdGhpcy5pbml0KHRoaXMuZXAubXVsdGlwbHkoc2NhbGFyKSk7XG4gICAgfVxuICAgIG11bHRpcGx5VW5zYWZlKHNjYWxhcikge1xuICAgICAgICByZXR1cm4gdGhpcy5pbml0KHRoaXMuZXAubXVsdGlwbHlVbnNhZmUoc2NhbGFyKSk7XG4gICAgfVxuICAgIGRvdWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5pdCh0aGlzLmVwLmRvdWJsZSgpKTtcbiAgICB9XG4gICAgbmVnYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbml0KHRoaXMuZXAubmVnYXRlKCkpO1xuICAgIH1cbiAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUsIGlzTGF6eSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbml0KHRoaXMuZXAucHJlY29tcHV0ZSh3aW5kb3dTaXplLCBpc0xhenkpKTtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSBgdG9CeXRlc2AgKi9cbiAgICB0b1Jhd0J5dGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0J5dGVzKCk7XG4gICAgfVxufVxuLyoqXG4gKiBJbml0aWFsaXplcyBFZERTQSBzaWduYXR1cmVzIG92ZXIgZ2l2ZW4gRWR3YXJkcyBjdXJ2ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVkZHNhKFBvaW50LCBjSGFzaCwgZWRkc2FPcHRzID0ge30pIHtcbiAgICBpZiAodHlwZW9mIGNIYXNoICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiaGFzaFwiIGZ1bmN0aW9uIHBhcmFtIGlzIHJlcXVpcmVkJyk7XG4gICAgX3ZhbGlkYXRlT2JqZWN0KGVkZHNhT3B0cywge30sIHtcbiAgICAgICAgYWRqdXN0U2NhbGFyQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgICAgIHJhbmRvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICBkb21haW46ICdmdW5jdGlvbicsXG4gICAgICAgIHByZWhhc2g6ICdmdW5jdGlvbicsXG4gICAgICAgIG1hcFRvQ3VydmU6ICdmdW5jdGlvbicsXG4gICAgfSk7XG4gICAgY29uc3QgeyBwcmVoYXNoIH0gPSBlZGRzYU9wdHM7XG4gICAgY29uc3QgeyBCQVNFLCBGcCwgRm4gfSA9IFBvaW50O1xuICAgIGNvbnN0IHJhbmRvbUJ5dGVzID0gZWRkc2FPcHRzLnJhbmRvbUJ5dGVzIHx8IHJhbmRvbUJ5dGVzV2ViO1xuICAgIGNvbnN0IGFkanVzdFNjYWxhckJ5dGVzID0gZWRkc2FPcHRzLmFkanVzdFNjYWxhckJ5dGVzIHx8ICgoYnl0ZXMpID0+IGJ5dGVzKTtcbiAgICBjb25zdCBkb21haW4gPSBlZGRzYU9wdHMuZG9tYWluIHx8XG4gICAgICAgICgoZGF0YSwgY3R4LCBwaGZsYWcpID0+IHtcbiAgICAgICAgICAgIGFib29sKHBoZmxhZywgJ3BoZmxhZycpO1xuICAgICAgICAgICAgaWYgKGN0eC5sZW5ndGggfHwgcGhmbGFnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udGV4dHMvcHJlLWhhc2ggYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KTsgLy8gTk9PUFxuICAgIC8vIExpdHRsZS1lbmRpYW4gU0hBNTEyIHdpdGggbW9kdWxvIG5cbiAgICBmdW5jdGlvbiBtb2ROX0xFKGhhc2gpIHtcbiAgICAgICAgcmV0dXJuIEZuLmNyZWF0ZShieXRlc1RvTnVtYmVyTEUoaGFzaCkpOyAvLyBOb3QgRm4uZnJvbUJ5dGVzOiBpdCBoYXMgbGVuZ3RoIGxpbWl0XG4gICAgfVxuICAgIC8vIEdldCB0aGUgaGFzaGVkIHByaXZhdGUgc2NhbGFyIHBlciBSRkM4MDMyIDUuMS41XG4gICAgZnVuY3Rpb24gZ2V0UHJpdmF0ZVNjYWxhcihrZXkpIHtcbiAgICAgICAgY29uc3QgbGVuID0gbGVuZ3Rocy5zZWNyZXRLZXk7XG4gICAgICAgIGtleSA9IGVuc3VyZUJ5dGVzKCdwcml2YXRlIGtleScsIGtleSwgbGVuKTtcbiAgICAgICAgLy8gSGFzaCBwcml2YXRlIGtleSB3aXRoIGN1cnZlJ3MgaGFzaCBmdW5jdGlvbiB0byBwcm9kdWNlIHVuaWZvcm1pbmdseSByYW5kb20gaW5wdXRcbiAgICAgICAgLy8gQ2hlY2sgYnl0ZSBsZW5ndGhzOiBlbnN1cmUoNjQsIGgoZW5zdXJlKDMyLCBrZXkpKSlcbiAgICAgICAgY29uc3QgaGFzaGVkID0gZW5zdXJlQnl0ZXMoJ2hhc2hlZCBwcml2YXRlIGtleScsIGNIYXNoKGtleSksIDIgKiBsZW4pO1xuICAgICAgICBjb25zdCBoZWFkID0gYWRqdXN0U2NhbGFyQnl0ZXMoaGFzaGVkLnNsaWNlKDAsIGxlbikpOyAvLyBjbGVhciBmaXJzdCBoYWxmIGJpdHMsIHByb2R1Y2UgRkVcbiAgICAgICAgY29uc3QgcHJlZml4ID0gaGFzaGVkLnNsaWNlKGxlbiwgMiAqIGxlbik7IC8vIHNlY29uZCBoYWxmIGlzIGNhbGxlZCBrZXkgcHJlZml4ICg1LjEuNilcbiAgICAgICAgY29uc3Qgc2NhbGFyID0gbW9kTl9MRShoZWFkKTsgLy8gVGhlIGFjdHVhbCBwcml2YXRlIHNjYWxhclxuICAgICAgICByZXR1cm4geyBoZWFkLCBwcmVmaXgsIHNjYWxhciB9O1xuICAgIH1cbiAgICAvKiogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgY3JlYXRlcyBwdWJsaWMga2V5IGZyb20gc2NhbGFyLiBSRkM4MDMyIDUuMS41ICovXG4gICAgZnVuY3Rpb24gZ2V0RXh0ZW5kZWRQdWJsaWNLZXkoc2VjcmV0S2V5KSB7XG4gICAgICAgIGNvbnN0IHsgaGVhZCwgcHJlZml4LCBzY2FsYXIgfSA9IGdldFByaXZhdGVTY2FsYXIoc2VjcmV0S2V5KTtcbiAgICAgICAgY29uc3QgcG9pbnQgPSBCQVNFLm11bHRpcGx5KHNjYWxhcik7IC8vIFBvaW50IG9uIEVkd2FyZHMgY3VydmUgYWthIHB1YmxpYyBrZXlcbiAgICAgICAgY29uc3QgcG9pbnRCeXRlcyA9IHBvaW50LnRvQnl0ZXMoKTtcbiAgICAgICAgcmV0dXJuIHsgaGVhZCwgcHJlZml4LCBzY2FsYXIsIHBvaW50LCBwb2ludEJ5dGVzIH07XG4gICAgfVxuICAgIC8qKiBDYWxjdWxhdGVzIEVkRFNBIHB1YiBrZXkuIFJGQzgwMzIgNS4xLjUuICovXG4gICAgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHNlY3JldEtleSkge1xuICAgICAgICByZXR1cm4gZ2V0RXh0ZW5kZWRQdWJsaWNLZXkoc2VjcmV0S2V5KS5wb2ludEJ5dGVzO1xuICAgIH1cbiAgICAvLyBpbnQoJ0xFJywgU0hBNTEyKGRvbTIoRiwgQykgfHwgbXNncykpIG1vZCBOXG4gICAgZnVuY3Rpb24gaGFzaERvbWFpblRvU2NhbGFyKGNvbnRleHQgPSBVaW50OEFycmF5Lm9mKCksIC4uLm1zZ3MpIHtcbiAgICAgICAgY29uc3QgbXNnID0gY29uY2F0Qnl0ZXMoLi4ubXNncyk7XG4gICAgICAgIHJldHVybiBtb2ROX0xFKGNIYXNoKGRvbWFpbihtc2csIGVuc3VyZUJ5dGVzKCdjb250ZXh0JywgY29udGV4dCksICEhcHJlaGFzaCkpKTtcbiAgICB9XG4gICAgLyoqIFNpZ25zIG1lc3NhZ2Ugd2l0aCBwcml2YXRlS2V5LiBSRkM4MDMyIDUuMS42ICovXG4gICAgZnVuY3Rpb24gc2lnbihtc2csIHNlY3JldEtleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIG1zZyA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbXNnKTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2cgPSBwcmVoYXNoKG1zZyk7IC8vIGZvciBlZDI1NTE5cGggZXRjLlxuICAgICAgICBjb25zdCB7IHByZWZpeCwgc2NhbGFyLCBwb2ludEJ5dGVzIH0gPSBnZXRFeHRlbmRlZFB1YmxpY0tleShzZWNyZXRLZXkpO1xuICAgICAgICBjb25zdCByID0gaGFzaERvbWFpblRvU2NhbGFyKG9wdGlvbnMuY29udGV4dCwgcHJlZml4LCBtc2cpOyAvLyByID0gZG9tMihGLCBDKSB8fCBwcmVmaXggfHwgUEgoTSlcbiAgICAgICAgY29uc3QgUiA9IEJBU0UubXVsdGlwbHkocikudG9CeXRlcygpOyAvLyBSID0gckdcbiAgICAgICAgY29uc3QgayA9IGhhc2hEb21haW5Ub1NjYWxhcihvcHRpb25zLmNvbnRleHQsIFIsIHBvaW50Qnl0ZXMsIG1zZyk7IC8vIFIgfHwgQSB8fCBQSChNKVxuICAgICAgICBjb25zdCBzID0gRm4uY3JlYXRlKHIgKyBrICogc2NhbGFyKTsgLy8gUyA9IChyICsgayAqIHMpIG1vZCBMXG4gICAgICAgIGlmICghRm4uaXNWYWxpZChzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbiBmYWlsZWQ6IGludmFsaWQgcycpOyAvLyAwIDw9IHMgPCBMXG4gICAgICAgIGNvbnN0IHJzID0gY29uY2F0Qnl0ZXMoUiwgRm4udG9CeXRlcyhzKSk7XG4gICAgICAgIHJldHVybiBhYnl0ZXMocnMsIGxlbmd0aHMuc2lnbmF0dXJlLCAncmVzdWx0Jyk7XG4gICAgfVxuICAgIC8vIHZlcmlmaWNhdGlvbiBydWxlIGlzIGVpdGhlciB6aXAyMTUgb3IgcmZjODAzMiAvIG5pc3QxODYtNS4gQ29uc3VsdCBmcm9tSGV4OlxuICAgIGNvbnN0IHZlcmlmeU9wdHMgPSB7IHppcDIxNTogdHJ1ZSB9O1xuICAgIC8qKlxuICAgICAqIFZlcmlmaWVzIEVkRFNBIHNpZ25hdHVyZSBhZ2FpbnN0IG1lc3NhZ2UgYW5kIHB1YmxpYyBrZXkuIFJGQzgwMzIgNS4xLjcuXG4gICAgICogQW4gZXh0ZW5kZWQgZ3JvdXAgZXF1YXRpb24gaXMgY2hlY2tlZC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2ZXJpZnkoc2lnLCBtc2csIHB1YmxpY0tleSwgb3B0aW9ucyA9IHZlcmlmeU9wdHMpIHtcbiAgICAgICAgY29uc3QgeyBjb250ZXh0LCB6aXAyMTUgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGxlbiA9IGxlbmd0aHMuc2lnbmF0dXJlO1xuICAgICAgICBzaWcgPSBlbnN1cmVCeXRlcygnc2lnbmF0dXJlJywgc2lnLCBsZW4pO1xuICAgICAgICBtc2cgPSBlbnN1cmVCeXRlcygnbWVzc2FnZScsIG1zZyk7XG4gICAgICAgIHB1YmxpY0tleSA9IGVuc3VyZUJ5dGVzKCdwdWJsaWNLZXknLCBwdWJsaWNLZXksIGxlbmd0aHMucHVibGljS2V5KTtcbiAgICAgICAgaWYgKHppcDIxNSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgYWJvb2woemlwMjE1LCAnemlwMjE1Jyk7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnID0gcHJlaGFzaChtc2cpOyAvLyBmb3IgZWQyNTUxOXBoLCBldGNcbiAgICAgICAgY29uc3QgbWlkID0gbGVuIC8gMjtcbiAgICAgICAgY29uc3QgciA9IHNpZy5zdWJhcnJheSgwLCBtaWQpO1xuICAgICAgICBjb25zdCBzID0gYnl0ZXNUb051bWJlckxFKHNpZy5zdWJhcnJheShtaWQsIGxlbikpO1xuICAgICAgICBsZXQgQSwgUiwgU0I7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyB6aXAyMTU9dHJ1ZSBpcyBnb29kIGZvciBjb25zZW5zdXMtY3JpdGljYWwgYXBwcy4gPWZhbHNlIGZvbGxvd3MgUkZDODAzMiAvIE5JU1QxODYtNS5cbiAgICAgICAgICAgIC8vIHppcDIxNT10cnVlOiAgMCA8PSB5IDwgTUFTSyAoMl4yNTYgZm9yIGVkMjU1MTkpXG4gICAgICAgICAgICAvLyB6aXAyMTU9ZmFsc2U6IDAgPD0geSA8IFAgKDJeMjU1LTE5IGZvciBlZDI1NTE5KVxuICAgICAgICAgICAgQSA9IFBvaW50LmZyb21CeXRlcyhwdWJsaWNLZXksIHppcDIxNSk7XG4gICAgICAgICAgICBSID0gUG9pbnQuZnJvbUJ5dGVzKHIsIHppcDIxNSk7XG4gICAgICAgICAgICBTQiA9IEJBU0UubXVsdGlwbHlVbnNhZmUocyk7IC8vIDAgPD0gcyA8IGwgaXMgZG9uZSBpbnNpZGVcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXppcDIxNSAmJiBBLmlzU21hbGxPcmRlcigpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyB6aXAyMTUgYWxsb3dzIHB1YmxpYyBrZXlzIG9mIHNtYWxsIG9yZGVyXG4gICAgICAgIGNvbnN0IGsgPSBoYXNoRG9tYWluVG9TY2FsYXIoY29udGV4dCwgUi50b0J5dGVzKCksIEEudG9CeXRlcygpLCBtc2cpO1xuICAgICAgICBjb25zdCBSa0EgPSBSLmFkZChBLm11bHRpcGx5VW5zYWZlKGspKTtcbiAgICAgICAgLy8gRXh0ZW5kZWQgZ3JvdXAgZXF1YXRpb25cbiAgICAgICAgLy8gWzhdW1NdQiA9IFs4XVIgKyBbOF1ba11BJ1xuICAgICAgICByZXR1cm4gUmtBLnN1YnRyYWN0KFNCKS5jbGVhckNvZmFjdG9yKCkuaXMwKCk7XG4gICAgfVxuICAgIGNvbnN0IF9zaXplID0gRnAuQllURVM7IC8vIDMyIGZvciBlZDI1NTE5LCA1NyBmb3IgZWQ0NDhcbiAgICBjb25zdCBsZW5ndGhzID0ge1xuICAgICAgICBzZWNyZXRLZXk6IF9zaXplLFxuICAgICAgICBwdWJsaWNLZXk6IF9zaXplLFxuICAgICAgICBzaWduYXR1cmU6IDIgKiBfc2l6ZSxcbiAgICAgICAgc2VlZDogX3NpemUsXG4gICAgfTtcbiAgICBmdW5jdGlvbiByYW5kb21TZWNyZXRLZXkoc2VlZCA9IHJhbmRvbUJ5dGVzKGxlbmd0aHMuc2VlZCkpIHtcbiAgICAgICAgcmV0dXJuIGFieXRlcyhzZWVkLCBsZW5ndGhzLnNlZWQsICdzZWVkJyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGtleWdlbihzZWVkKSB7XG4gICAgICAgIGNvbnN0IHNlY3JldEtleSA9IHV0aWxzLnJhbmRvbVNlY3JldEtleShzZWVkKTtcbiAgICAgICAgcmV0dXJuIHsgc2VjcmV0S2V5LCBwdWJsaWNLZXk6IGdldFB1YmxpY0tleShzZWNyZXRLZXkpIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVmFsaWRTZWNyZXRLZXkoa2V5KSB7XG4gICAgICAgIHJldHVybiBpc0J5dGVzKGtleSkgJiYga2V5Lmxlbmd0aCA9PT0gRm4uQllURVM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVmFsaWRQdWJsaWNLZXkoa2V5LCB6aXAyMTUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiAhIVBvaW50LmZyb21CeXRlcyhrZXksIHppcDIxNSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdXRpbHMgPSB7XG4gICAgICAgIGdldEV4dGVuZGVkUHVibGljS2V5LFxuICAgICAgICByYW5kb21TZWNyZXRLZXksXG4gICAgICAgIGlzVmFsaWRTZWNyZXRLZXksXG4gICAgICAgIGlzVmFsaWRQdWJsaWNLZXksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBlZCBwdWJsaWMga2V5IHRvIHggcHVibGljIGtleS4gVXNlcyBmb3JtdWxhOlxuICAgICAgICAgKiAtIGVkMjU1MTk6XG4gICAgICAgICAqICAgLSBgKHUsIHYpID0gKCgxK3kpLygxLXkpLCBzcXJ0KC00ODY2NjQpKnUveClgXG4gICAgICAgICAqICAgLSBgKHgsIHkpID0gKHNxcnQoLTQ4NjY2NCkqdS92LCAodS0xKS8odSsxKSlgXG4gICAgICAgICAqIC0gZWQ0NDg6XG4gICAgICAgICAqICAgLSBgKHUsIHYpID0gKCh5LTEpLyh5KzEpLCBzcXJ0KDE1NjMyNCkqdS94KWBcbiAgICAgICAgICogICAtIGAoeCwgeSkgPSAoc3FydCgxNTYzMjQpKnUvdiwgKDErdSkvKDEtdSkpYFxuICAgICAgICAgKi9cbiAgICAgICAgdG9Nb250Z29tZXJ5KHB1YmxpY0tleSkge1xuICAgICAgICAgICAgY29uc3QgeyB5IH0gPSBQb2ludC5mcm9tQnl0ZXMocHVibGljS2V5KTtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSBsZW5ndGhzLnB1YmxpY0tleTtcbiAgICAgICAgICAgIGNvbnN0IGlzMjU1MTkgPSBzaXplID09PSAzMjtcbiAgICAgICAgICAgIGlmICghaXMyNTUxOSAmJiBzaXplICE9PSA1NylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29ubHkgZGVmaW5lZCBmb3IgMjU1MTkgYW5kIDQ0OCcpO1xuICAgICAgICAgICAgY29uc3QgdSA9IGlzMjU1MTkgPyBGcC5kaXYoXzFuICsgeSwgXzFuIC0geSkgOiBGcC5kaXYoeSAtIF8xbiwgeSArIF8xbik7XG4gICAgICAgICAgICByZXR1cm4gRnAudG9CeXRlcyh1KTtcbiAgICAgICAgfSxcbiAgICAgICAgdG9Nb250Z29tZXJ5U2VjcmV0KHNlY3JldEtleSkge1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGxlbmd0aHMuc2VjcmV0S2V5O1xuICAgICAgICAgICAgYWJ5dGVzKHNlY3JldEtleSwgc2l6ZSk7XG4gICAgICAgICAgICBjb25zdCBoYXNoZWQgPSBjSGFzaChzZWNyZXRLZXkuc3ViYXJyYXkoMCwgc2l6ZSkpO1xuICAgICAgICAgICAgcmV0dXJuIGFkanVzdFNjYWxhckJ5dGVzKGhhc2hlZCkuc3ViYXJyYXkoMCwgc2l6ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiByYW5kb21TZWNyZXRLZXksXG4gICAgICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgICAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUgPSA4LCBwb2ludCA9IFBvaW50LkJBU0UpIHtcbiAgICAgICAgICAgIHJldHVybiBwb2ludC5wcmVjb21wdXRlKHdpbmRvd1NpemUsIGZhbHNlKTtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAga2V5Z2VuLFxuICAgICAgICBnZXRQdWJsaWNLZXksXG4gICAgICAgIHNpZ24sXG4gICAgICAgIHZlcmlmeSxcbiAgICAgICAgdXRpbHMsXG4gICAgICAgIFBvaW50LFxuICAgICAgICBsZW5ndGhzLFxuICAgIH0pO1xufVxuZnVuY3Rpb24gX2VkZHNhX2xlZ2FjeV9vcHRzX3RvX25ldyhjKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB7XG4gICAgICAgIGE6IGMuYSxcbiAgICAgICAgZDogYy5kLFxuICAgICAgICBwOiBjLkZwLk9SREVSLFxuICAgICAgICBuOiBjLm4sXG4gICAgICAgIGg6IGMuaCxcbiAgICAgICAgR3g6IGMuR3gsXG4gICAgICAgIEd5OiBjLkd5LFxuICAgIH07XG4gICAgY29uc3QgRnAgPSBjLkZwO1xuICAgIGNvbnN0IEZuID0gRmllbGQoQ1VSVkUubiwgYy5uQml0TGVuZ3RoLCB0cnVlKTtcbiAgICBjb25zdCBjdXJ2ZU9wdHMgPSB7IEZwLCBGbiwgdXZSYXRpbzogYy51dlJhdGlvIH07XG4gICAgY29uc3QgZWRkc2FPcHRzID0ge1xuICAgICAgICByYW5kb21CeXRlczogYy5yYW5kb21CeXRlcyxcbiAgICAgICAgYWRqdXN0U2NhbGFyQnl0ZXM6IGMuYWRqdXN0U2NhbGFyQnl0ZXMsXG4gICAgICAgIGRvbWFpbjogYy5kb21haW4sXG4gICAgICAgIHByZWhhc2g6IGMucHJlaGFzaCxcbiAgICAgICAgbWFwVG9DdXJ2ZTogYy5tYXBUb0N1cnZlLFxuICAgIH07XG4gICAgcmV0dXJuIHsgQ1VSVkUsIGN1cnZlT3B0cywgaGFzaDogYy5oYXNoLCBlZGRzYU9wdHMgfTtcbn1cbmZ1bmN0aW9uIF9lZGRzYV9uZXdfb3V0cHV0X3RvX2xlZ2FjeShjLCBlZGRzYSkge1xuICAgIGNvbnN0IFBvaW50ID0gZWRkc2EuUG9pbnQ7XG4gICAgY29uc3QgbGVnYWN5ID0gT2JqZWN0LmFzc2lnbih7fSwgZWRkc2EsIHtcbiAgICAgICAgRXh0ZW5kZWRQb2ludDogUG9pbnQsXG4gICAgICAgIENVUlZFOiBjLFxuICAgICAgICBuQml0TGVuZ3RoOiBQb2ludC5Gbi5CSVRTLFxuICAgICAgICBuQnl0ZUxlbmd0aDogUG9pbnQuRm4uQllURVMsXG4gICAgfSk7XG4gICAgcmV0dXJuIGxlZ2FjeTtcbn1cbi8vIFRPRE86IHJlbW92ZS4gVXNlIGVkZHNhXG5leHBvcnQgZnVuY3Rpb24gdHdpc3RlZEVkd2FyZHMoYykge1xuICAgIGNvbnN0IHsgQ1VSVkUsIGN1cnZlT3B0cywgaGFzaCwgZWRkc2FPcHRzIH0gPSBfZWRkc2FfbGVnYWN5X29wdHNfdG9fbmV3KGMpO1xuICAgIGNvbnN0IFBvaW50ID0gZWR3YXJkcyhDVVJWRSwgY3VydmVPcHRzKTtcbiAgICBjb25zdCBFRERTQSA9IGVkZHNhKFBvaW50LCBoYXNoLCBlZGRzYU9wdHMpO1xuICAgIHJldHVybiBfZWRkc2FfbmV3X291dHB1dF90b19sZWdhY3koYywgRUREU0EpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWR3YXJkcy5qcy5tYXAiXSwibmFtZXMiOlsiX3ZhbGlkYXRlT2JqZWN0IiwiX2Fib29sMiIsImFib29sIiwiX2FieXRlczIiLCJhYnl0ZXMiLCJhSW5SYW5nZSIsImJ5dGVzVG9IZXgiLCJieXRlc1RvTnVtYmVyTEUiLCJjb25jYXRCeXRlcyIsImNvcHlCeXRlcyIsImVuc3VyZUJ5dGVzIiwiaXNCeXRlcyIsIm1lbW9pemVkIiwibm90SW1wbGVtZW50ZWQiLCJyYW5kb21CeXRlcyIsInJhbmRvbUJ5dGVzV2ViIiwiX2NyZWF0ZUN1cnZlRmllbGRzIiwibm9ybWFsaXplWiIsInBpcHBlbmdlciIsIndOQUYiLCJGaWVsZCIsIl8wbiIsIkJpZ0ludCIsIl8xbiIsIl8ybiIsIl84biIsImlzRWRWYWxpZFhZIiwiRnAiLCJDVVJWRSIsIngiLCJ5IiwieDIiLCJzcXIiLCJ5MiIsImxlZnQiLCJhZGQiLCJtdWwiLCJhIiwicmlnaHQiLCJPTkUiLCJkIiwiZXFsIiwiZWR3YXJkcyIsInBhcmFtcyIsImV4dHJhT3B0cyIsInZhbGlkYXRlZCIsIkZwRm5MRSIsIkZuIiwiaCIsImNvZmFjdG9yIiwidXZSYXRpbyIsIk1BU0siLCJCWVRFUyIsIm1vZFAiLCJuIiwiY3JlYXRlIiwidSIsInYiLCJpc1ZhbGlkIiwidmFsdWUiLCJzcXJ0IiwiZGl2IiwiZSIsIkd4IiwiR3kiLCJFcnJvciIsImFjb29yZCIsInRpdGxlIiwiYmFuWmVybyIsIm1pbiIsImFleHRwb2ludCIsIm90aGVyIiwiUG9pbnQiLCJ0b0FmZmluZU1lbW8iLCJwIiwiaXoiLCJYIiwiWSIsIloiLCJpczAiLCJpbnYiLCJ6eiIsImFzc2VydFZhbGlkTWVtbyIsIlQiLCJYMiIsIlkyIiwiWjIiLCJaNCIsImFYMiIsIlhZIiwiWlQiLCJjb25zdHJ1Y3RvciIsIk9iamVjdCIsImZyZWV6ZSIsImZyb21BZmZpbmUiLCJmcm9tQnl0ZXMiLCJieXRlcyIsInppcDIxNSIsImxlbiIsIm5vcm1lZCIsImxhc3RCeXRlIiwibWF4IiwiT1JERVIiLCJpc1hPZGQiLCJpc0xhc3RCeXRlT2RkIiwiZnJvbUhleCIsInRvQWZmaW5lIiwicHJlY29tcHV0ZSIsIndpbmRvd1NpemUiLCJpc0xhenkiLCJ3bmFmIiwiY3JlYXRlQ2FjaGUiLCJtdWx0aXBseSIsImFzc2VydFZhbGlkaXR5IiwiZXF1YWxzIiwiWDEiLCJZMSIsIloxIiwiWDFaMiIsIlgyWjEiLCJZMVoyIiwiWTJaMSIsIlpFUk8iLCJuZWdhdGUiLCJkb3VibGUiLCJBIiwiQiIsIkMiLCJEIiwieDF5MSIsIkUiLCJHIiwiRiIsIkgiLCJYMyIsIlkzIiwiVDMiLCJaMyIsIlQxIiwiVDIiLCJzdWJ0cmFjdCIsInNjYWxhciIsImlzVmFsaWROb3QwIiwiZiIsImNhY2hlZCIsIm11bHRpcGx5VW5zYWZlIiwiYWNjIiwidW5zYWZlIiwiaXNTbWFsbE9yZGVyIiwiaXNUb3JzaW9uRnJlZSIsImludmVydGVkWiIsImNsZWFyQ29mYWN0b3IiLCJ0b0J5dGVzIiwibGVuZ3RoIiwidG9IZXgiLCJ0b1N0cmluZyIsImV4IiwiZXkiLCJleiIsImV0IiwicG9pbnRzIiwibXNtIiwic2NhbGFycyIsIl9zZXRXaW5kb3dTaXplIiwidG9SYXdCeXRlcyIsIkJBU0UiLCJCSVRTIiwiUHJpbWVFZHdhcmRzUG9pbnQiLCJlcCIsIl9ieXRlcyIsIl9oZXgiLCJhc3NlcnRTYW1lIiwiaW5pdCIsImVkZHNhIiwiY0hhc2giLCJlZGRzYU9wdHMiLCJhZGp1c3RTY2FsYXJCeXRlcyIsImRvbWFpbiIsInByZWhhc2giLCJtYXBUb0N1cnZlIiwiZGF0YSIsImN0eCIsInBoZmxhZyIsIm1vZE5fTEUiLCJoYXNoIiwiZ2V0UHJpdmF0ZVNjYWxhciIsImtleSIsImxlbmd0aHMiLCJzZWNyZXRLZXkiLCJoYXNoZWQiLCJoZWFkIiwic2xpY2UiLCJwcmVmaXgiLCJnZXRFeHRlbmRlZFB1YmxpY0tleSIsInBvaW50IiwicG9pbnRCeXRlcyIsImdldFB1YmxpY0tleSIsImhhc2hEb21haW5Ub1NjYWxhciIsImNvbnRleHQiLCJVaW50OEFycmF5Iiwib2YiLCJtc2dzIiwibXNnIiwic2lnbiIsIm9wdGlvbnMiLCJyIiwiUiIsImsiLCJzIiwicnMiLCJzaWduYXR1cmUiLCJ2ZXJpZnlPcHRzIiwidmVyaWZ5Iiwic2lnIiwicHVibGljS2V5IiwidW5kZWZpbmVkIiwibWlkIiwic3ViYXJyYXkiLCJTQiIsImVycm9yIiwiUmtBIiwiX3NpemUiLCJzZWVkIiwicmFuZG9tU2VjcmV0S2V5Iiwia2V5Z2VuIiwidXRpbHMiLCJpc1ZhbGlkU2VjcmV0S2V5IiwiaXNWYWxpZFB1YmxpY0tleSIsInRvTW9udGdvbWVyeSIsInNpemUiLCJpczI1NTE5IiwidG9Nb250Z29tZXJ5U2VjcmV0IiwicmFuZG9tUHJpdmF0ZUtleSIsIl9lZGRzYV9sZWdhY3lfb3B0c190b19uZXciLCJjIiwibkJpdExlbmd0aCIsImN1cnZlT3B0cyIsIl9lZGRzYV9uZXdfb3V0cHV0X3RvX2xlZ2FjeSIsImxlZ2FjeSIsImFzc2lnbiIsIkV4dGVuZGVkUG9pbnQiLCJuQnl0ZUxlbmd0aCIsInR3aXN0ZWRFZHdhcmRzIiwiRUREU0EiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/edwards.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _DST_scalar: () => (/* binding */ _DST_scalar),\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   expand_message_xmd: () => (/* binding */ expand_message_xmd),\n/* harmony export */   expand_message_xof: () => (/* binding */ expand_message_xof),\n/* harmony export */   hash_to_field: () => (/* binding */ hash_to_field),\n/* harmony export */   isogenyMap: () => (/* binding */ isogenyMap)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/utils.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/modular.js\");\n\n\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    anum(value);\n    anum(length);\n    if (value < 0 || value >= 1 << 8 * length) throw new Error(\"invalid I2OSP input: \" + value);\n    const res = Array.from({\n        length\n    }).fill(0);\n    for(let i = length - 1; i >= 0; i--){\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for(let i = 0; i < a.length; i++){\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item)) throw new Error(\"number expected\");\n}\nfunction normDST(DST) {\n    if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes)(DST) && typeof DST !== \"string\") throw new Error(\"DST must be Uint8Array or string\");\n    return typeof DST === \"string\" ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.utf8ToBytes)(DST) : DST;\n}\n/**\n * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.\n * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).\n */ function expand_message_xmd(msg, DST, lenInBytes, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(msg);\n    anum(lenInBytes);\n    DST = normDST(DST);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255) DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.utf8ToBytes)(\"H2C-OVERSIZE-DST-\"), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (lenInBytes > 65535 || ell > 255) throw new Error(\"expand_message_xmd: invalid lenInBytes\");\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for(let i = 1; i <= ell; i++){\n        const args = [\n            strxor(b_0, b[i - 1]),\n            i2osp(i + 1, 1),\n            DST_prime\n        ];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n/**\n * Produces a uniformly random byte string using an extendable-output function (XOF) H.\n * 1. The collision resistance of H MUST be at least k bits.\n * 2. H MUST be an XOF that has been proved indifferentiable from\n *    a random oracle under a reasonable cryptographic assumption.\n * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).\n */ function expand_message_xof(msg, DST, lenInBytes, k, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(msg);\n    anum(lenInBytes);\n    DST = normDST(DST);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil(2 * k / 8);\n        DST = H.create({\n            dkLen\n        }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.utf8ToBytes)(\"H2C-OVERSIZE-DST-\")).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255) throw new Error(\"expand_message_xof: invalid lenInBytes\");\n    return H.create({\n        dkLen: lenInBytes\n    }).update(msg).update(i2osp(lenInBytes, 2))// 2. DST_prime = DST || I2OSP(len(DST), 1)\n    .update(DST).update(i2osp(DST.length, 1)).digest();\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\n * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */ function hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._validateObject)(options, {\n        p: \"bigint\",\n        m: \"number\",\n        k: \"number\",\n        hash: \"function\"\n    });\n    const { p, k, m, hash, expand, DST } = options;\n    if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isHash)(options.hash)) throw new Error(\"expected valid hash\");\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(msg);\n    anum(count);\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === \"xmd\") {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    } else if (expand === \"xof\") {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    } else if (expand === \"_internal_pass\") {\n        // for internal tests only\n        prb = msg;\n    } else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for(let i = 0; i < count; i++){\n        const e = new Array(m);\n        for(let j = 0; j < m; j++){\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const coeff = map.map((i)=>Array.from(i).reverse());\n    return (x, y)=>{\n        const [xn, xd, yn, yd] = coeff.map((val)=>val.reduce((acc, i)=>field.add(field.mul(acc, x), i)));\n        // 6.6.3\n        // Exceptional cases of iso_map are inputs that cause the denominator of\n        // either rational function to evaluate to zero; such cases MUST return\n        // the identity point on E.\n        const [xd_inv, yd_inv] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.FpInvertBatch)(field, [\n            xd,\n            yd\n        ], true);\n        x = field.mul(xn, xd_inv); // xNum / xDen\n        y = field.mul(y, field.mul(yn, yd_inv)); // y * (yNum / yDev)\n        return {\n            x,\n            y\n        };\n    };\n}\nconst _DST_scalar = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.utf8ToBytes)(\"HashToScalar-\");\n/** Creates hash-to-curve methods from EC Point and mapToCurve function. See {@link H2CHasher}. */ function createHasher(Point, mapToCurve, defaults) {\n    if (typeof mapToCurve !== \"function\") throw new Error(\"mapToCurve() must be defined\");\n    function map(num) {\n        return Point.fromAffine(mapToCurve(num));\n    }\n    function clear(initial) {\n        const P = initial.clearCofactor();\n        if (P.equals(Point.ZERO)) return Point.ZERO; // zero will throw in assert\n        P.assertValidity();\n        return P;\n    }\n    return {\n        defaults,\n        hashToCurve (msg, options) {\n            const opts = Object.assign({}, defaults, options);\n            const u = hash_to_field(msg, 2, opts);\n            const u0 = map(u[0]);\n            const u1 = map(u[1]);\n            return clear(u0.add(u1));\n        },\n        encodeToCurve (msg, options) {\n            const optsDst = defaults.encodeDST ? {\n                DST: defaults.encodeDST\n            } : {};\n            const opts = Object.assign({}, defaults, optsDst, options);\n            const u = hash_to_field(msg, 1, opts);\n            const u0 = map(u[0]);\n            return clear(u0);\n        },\n        /** See {@link H2CHasher} */ mapToCurve (scalars) {\n            if (!Array.isArray(scalars)) throw new Error(\"expected array of bigints\");\n            for (const i of scalars)if (typeof i !== \"bigint\") throw new Error(\"expected array of bigints\");\n            return clear(map(scalars));\n        },\n        // hash_to_scalar can produce 0: https://www.rfc-editor.org/errata/eid8393\n        // RFC 9380, draft-irtf-cfrg-bbs-signatures-08\n        hashToScalar (msg, options) {\n            // @ts-ignore\n            const N = Point.Fn.ORDER;\n            const opts = Object.assign({}, defaults, {\n                p: N,\n                m: 1,\n                DST: _DST_scalar\n            }, options);\n            return hash_to_field(msg, 1, opts)[0][0];\n        }\n    };\n} //# sourceMappingURL=hash-to-curve.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjkuNy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBbUg7QUFDakU7QUFDbEQsNkZBQTZGO0FBQzdGLE1BQU1TLFFBQVFQLHNEQUFlQTtBQUM3Qiw0Q0FBNEM7QUFDNUMsU0FBU1EsTUFBTUMsS0FBSyxFQUFFQyxNQUFNO0lBQ3hCQyxLQUFLRjtJQUNMRSxLQUFLRDtJQUNMLElBQUlELFFBQVEsS0FBS0EsU0FBUyxLQUFNLElBQUlDLFFBQ2hDLE1BQU0sSUFBSUUsTUFBTSwwQkFBMEJIO0lBQzlDLE1BQU1JLE1BQU1DLE1BQU1DLElBQUksQ0FBQztRQUFFTDtJQUFPLEdBQUdNLElBQUksQ0FBQztJQUN4QyxJQUFLLElBQUlDLElBQUlQLFNBQVMsR0FBR08sS0FBSyxHQUFHQSxJQUFLO1FBQ2xDSixHQUFHLENBQUNJLEVBQUUsR0FBR1IsUUFBUTtRQUNqQkEsV0FBVztJQUNmO0lBQ0EsT0FBTyxJQUFJUyxXQUFXTDtBQUMxQjtBQUNBLFNBQVNNLE9BQU9DLENBQUMsRUFBRUMsQ0FBQztJQUNoQixNQUFNQyxNQUFNLElBQUlKLFdBQVdFLEVBQUVWLE1BQU07SUFDbkMsSUFBSyxJQUFJTyxJQUFJLEdBQUdBLElBQUlHLEVBQUVWLE1BQU0sRUFBRU8sSUFBSztRQUMvQkssR0FBRyxDQUFDTCxFQUFFLEdBQUdHLENBQUMsQ0FBQ0gsRUFBRSxHQUFHSSxDQUFDLENBQUNKLEVBQUU7SUFDeEI7SUFDQSxPQUFPSztBQUNYO0FBQ0EsU0FBU1gsS0FBS1ksSUFBSTtJQUNkLElBQUksQ0FBQ0MsT0FBT0MsYUFBYSxDQUFDRixPQUN0QixNQUFNLElBQUlYLE1BQU07QUFDeEI7QUFDQSxTQUFTYyxRQUFRQyxHQUFHO0lBQ2hCLElBQUksQ0FBQ3pCLGtEQUFPQSxDQUFDeUIsUUFBUSxPQUFPQSxRQUFR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SXhCLE1BQU15QixFQUFFLENBQUNDLEtBQUs7WUFDeEIsTUFBTWIsT0FBT0MsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR2IsVUFBVTtnQkFBRXJDLEdBQUcyRDtnQkFBRzFELEdBQUc7Z0JBQUc3QixLQUFLNkQ7WUFBWSxHQUFHbEM7WUFDM0UsT0FBT0YsY0FBY3ZCLEtBQUssR0FBRzBFLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRTtRQUM1QztJQUNKO0FBQ0osRUFDQSx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3Rhc2NhbS1wcm90b2NvbC8uL25vZGVfbW9kdWxlcy8ucG5wbS9Abm9ibGUrY3VydmVzQDEuOS43L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzPzY1OTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX3ZhbGlkYXRlT2JqZWN0LCBhYnl0ZXMsIGJ5dGVzVG9OdW1iZXJCRSwgY29uY2F0Qnl0ZXMsIGlzQnl0ZXMsIGlzSGFzaCwgdXRmOFRvQnl0ZXMsIH0gZnJvbSBcIi4uL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBGcEludmVydEJhdGNoLCBtb2QgfSBmcm9tIFwiLi9tb2R1bGFyLmpzXCI7XG4vLyBPY3RldCBTdHJlYW0gdG8gSW50ZWdlci4gXCJzcGVjXCIgaW1wbGVtZW50YXRpb24gb2Ygb3MyaXAgaXMgMi41eCBzbG93ZXIgdnMgYnl0ZXNUb051bWJlckJFLlxuY29uc3Qgb3MyaXAgPSBieXRlc1RvTnVtYmVyQkU7XG4vLyBJbnRlZ2VyIHRvIE9jdGV0IFN0cmVhbSAobnVtYmVyVG9CeXRlc0JFKVxuZnVuY3Rpb24gaTJvc3AodmFsdWUsIGxlbmd0aCkge1xuICAgIGFudW0odmFsdWUpO1xuICAgIGFudW0obGVuZ3RoKTtcbiAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID49IDEgPDwgKDggKiBsZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgSTJPU1AgaW5wdXQ6ICcgKyB2YWx1ZSk7XG4gICAgY29uc3QgcmVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aCB9KS5maWxsKDApO1xuICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICByZXNbaV0gPSB2YWx1ZSAmIDB4ZmY7XG4gICAgICAgIHZhbHVlID4+Pj0gODtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlcyk7XG59XG5mdW5jdGlvbiBzdHJ4b3IoYSwgYikge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGEubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYVtpXSBeIGJbaV07XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBhbnVtKGl0ZW0pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGl0ZW0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ251bWJlciBleHBlY3RlZCcpO1xufVxuZnVuY3Rpb24gbm9ybURTVChEU1QpIHtcbiAgICBpZiAoIWlzQnl0ZXMoRFNUKSAmJiB0eXBlb2YgRFNUICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEU1QgbXVzdCBiZSBVaW50OEFycmF5IG9yIHN0cmluZycpO1xuICAgIHJldHVybiB0eXBlb2YgRFNUID09PSAnc3RyaW5nJyA/IHV0ZjhUb0J5dGVzKERTVCkgOiBEU1Q7XG59XG4vKipcbiAqIFByb2R1Y2VzIGEgdW5pZm9ybWx5IHJhbmRvbSBieXRlIHN0cmluZyB1c2luZyBhIGNyeXB0b2dyYXBoaWMgaGFzaCBmdW5jdGlvbiBIIHRoYXQgb3V0cHV0cyBiIGJpdHMuXG4gKiBbUkZDIDkzODAgNS4zLjFdKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjEpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgRFNULCBsZW5JbkJ5dGVzLCBIKSB7XG4gICAgYWJ5dGVzKG1zZyk7XG4gICAgYW51bShsZW5JbkJ5dGVzKTtcbiAgICBEU1QgPSBub3JtRFNUKERTVCk7XG4gICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuM1xuICAgIGlmIChEU1QubGVuZ3RoID4gMjU1KVxuICAgICAgICBEU1QgPSBIKGNvbmNhdEJ5dGVzKHV0ZjhUb0J5dGVzKCdIMkMtT1ZFUlNJWkUtRFNULScpLCBEU1QpKTtcbiAgICBjb25zdCB7IG91dHB1dExlbjogYl9pbl9ieXRlcywgYmxvY2tMZW46IHJfaW5fYnl0ZXMgfSA9IEg7XG4gICAgY29uc3QgZWxsID0gTWF0aC5jZWlsKGxlbkluQnl0ZXMgLyBiX2luX2J5dGVzKTtcbiAgICBpZiAobGVuSW5CeXRlcyA+IDY1NTM1IHx8IGVsbCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmRfbWVzc2FnZV94bWQ6IGludmFsaWQgbGVuSW5CeXRlcycpO1xuICAgIGNvbnN0IERTVF9wcmltZSA9IGNvbmNhdEJ5dGVzKERTVCwgaTJvc3AoRFNULmxlbmd0aCwgMSkpO1xuICAgIGNvbnN0IFpfcGFkID0gaTJvc3AoMCwgcl9pbl9ieXRlcyk7XG4gICAgY29uc3QgbF9pX2Jfc3RyID0gaTJvc3AobGVuSW5CeXRlcywgMik7IC8vIGxlbl9pbl9ieXRlc19zdHJcbiAgICBjb25zdCBiID0gbmV3IEFycmF5KGVsbCk7XG4gICAgY29uc3QgYl8wID0gSChjb25jYXRCeXRlcyhaX3BhZCwgbXNnLCBsX2lfYl9zdHIsIGkyb3NwKDAsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBiWzBdID0gSChjb25jYXRCeXRlcyhiXzAsIGkyb3NwKDEsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBlbGw7IGkrKykge1xuICAgICAgICBjb25zdCBhcmdzID0gW3N0cnhvcihiXzAsIGJbaSAtIDFdKSwgaTJvc3AoaSArIDEsIDEpLCBEU1RfcHJpbWVdO1xuICAgICAgICBiW2ldID0gSChjb25jYXRCeXRlcyguLi5hcmdzKSk7XG4gICAgfVxuICAgIGNvbnN0IHBzZXVkb19yYW5kb21fYnl0ZXMgPSBjb25jYXRCeXRlcyguLi5iKTtcbiAgICByZXR1cm4gcHNldWRvX3JhbmRvbV9ieXRlcy5zbGljZSgwLCBsZW5JbkJ5dGVzKTtcbn1cbi8qKlxuICogUHJvZHVjZXMgYSB1bmlmb3JtbHkgcmFuZG9tIGJ5dGUgc3RyaW5nIHVzaW5nIGFuIGV4dGVuZGFibGUtb3V0cHV0IGZ1bmN0aW9uIChYT0YpIEguXG4gKiAxLiBUaGUgY29sbGlzaW9uIHJlc2lzdGFuY2Ugb2YgSCBNVVNUIGJlIGF0IGxlYXN0IGsgYml0cy5cbiAqIDIuIEggTVVTVCBiZSBhbiBYT0YgdGhhdCBoYXMgYmVlbiBwcm92ZWQgaW5kaWZmZXJlbnRpYWJsZSBmcm9tXG4gKiAgICBhIHJhbmRvbSBvcmFjbGUgdW5kZXIgYSByZWFzb25hYmxlIGNyeXB0b2dyYXBoaWMgYXNzdW1wdGlvbi5cbiAqIFtSRkMgOTM4MCA1LjMuMl0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuMikuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbkluQnl0ZXMsIGssIEgpIHtcbiAgICBhYnl0ZXMobXNnKTtcbiAgICBhbnVtKGxlbkluQnl0ZXMpO1xuICAgIERTVCA9IG5vcm1EU1QoRFNUKTtcbiAgICAvLyBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4zXG4gICAgLy8gRFNUID0gSCgnSDJDLU9WRVJTSVpFLURTVC0nIHx8IGFfdmVyeV9sb25nX0RTVCwgTWF0aC5jZWlsKChsZW5JbkJ5dGVzICogaykgLyA4KSk7XG4gICAgaWYgKERTVC5sZW5ndGggPiAyNTUpIHtcbiAgICAgICAgY29uc3QgZGtMZW4gPSBNYXRoLmNlaWwoKDIgKiBrKSAvIDgpO1xuICAgICAgICBEU1QgPSBILmNyZWF0ZSh7IGRrTGVuIH0pLnVwZGF0ZSh1dGY4VG9CeXRlcygnSDJDLU9WRVJTSVpFLURTVC0nKSkudXBkYXRlKERTVCkuZGlnZXN0KCk7XG4gICAgfVxuICAgIGlmIChsZW5JbkJ5dGVzID4gNjU1MzUgfHwgRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmRfbWVzc2FnZV94b2Y6IGludmFsaWQgbGVuSW5CeXRlcycpO1xuICAgIHJldHVybiAoSC5jcmVhdGUoeyBka0xlbjogbGVuSW5CeXRlcyB9KVxuICAgICAgICAudXBkYXRlKG1zZylcbiAgICAgICAgLnVwZGF0ZShpMm9zcChsZW5JbkJ5dGVzLCAyKSlcbiAgICAgICAgLy8gMi4gRFNUX3ByaW1lID0gRFNUIHx8IEkyT1NQKGxlbihEU1QpLCAxKVxuICAgICAgICAudXBkYXRlKERTVClcbiAgICAgICAgLnVwZGF0ZShpMm9zcChEU1QubGVuZ3RoLCAxKSlcbiAgICAgICAgLmRpZ2VzdCgpKTtcbn1cbi8qKlxuICogSGFzaGVzIGFyYml0cmFyeS1sZW5ndGggYnl0ZSBzdHJpbmdzIHRvIGEgbGlzdCBvZiBvbmUgb3IgbW9yZSBlbGVtZW50cyBvZiBhIGZpbml0ZSBmaWVsZCBGLlxuICogW1JGQyA5MzgwIDUuMl0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjIpLlxuICogQHBhcmFtIG1zZyBhIGJ5dGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIG1lc3NhZ2UgdG8gaGFzaFxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgb2YgRiB0byBvdXRwdXRcbiAqIEBwYXJhbSBvcHRpb25zIGB7RFNUOiBzdHJpbmcsIHA6IGJpZ2ludCwgbTogbnVtYmVyLCBrOiBudW1iZXIsIGV4cGFuZDogJ3htZCcgfCAneG9mJywgaGFzaDogSH1gLCBzZWUgYWJvdmVcbiAqIEByZXR1cm5zIFt1XzAsIC4uLiwgdV8oY291bnQgLSAxKV0sIGEgbGlzdCBvZiBmaWVsZCBlbGVtZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hfdG9fZmllbGQobXNnLCBjb3VudCwgb3B0aW9ucykge1xuICAgIF92YWxpZGF0ZU9iamVjdChvcHRpb25zLCB7XG4gICAgICAgIHA6ICdiaWdpbnQnLFxuICAgICAgICBtOiAnbnVtYmVyJyxcbiAgICAgICAgazogJ251bWJlcicsXG4gICAgICAgIGhhc2g6ICdmdW5jdGlvbicsXG4gICAgfSk7XG4gICAgY29uc3QgeyBwLCBrLCBtLCBoYXNoLCBleHBhbmQsIERTVCB9ID0gb3B0aW9ucztcbiAgICBpZiAoIWlzSGFzaChvcHRpb25zLmhhc2gpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIHZhbGlkIGhhc2gnKTtcbiAgICBhYnl0ZXMobXNnKTtcbiAgICBhbnVtKGNvdW50KTtcbiAgICBjb25zdCBsb2cycCA9IHAudG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIGNvbnN0IEwgPSBNYXRoLmNlaWwoKGxvZzJwICsgaykgLyA4KTsgLy8gc2VjdGlvbiA1LjEgb2YgaWV0ZiBkcmFmdCBsaW5rIGFib3ZlXG4gICAgY29uc3QgbGVuX2luX2J5dGVzID0gY291bnQgKiBtICogTDtcbiAgICBsZXQgcHJiOyAvLyBwc2V1ZG9fcmFuZG9tX2J5dGVzXG4gICAgaWYgKGV4cGFuZCA9PT0gJ3htZCcpIHtcbiAgICAgICAgcHJiID0gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgRFNULCBsZW5faW5fYnl0ZXMsIGhhc2gpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHBhbmQgPT09ICd4b2YnKSB7XG4gICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3hvZihtc2csIERTVCwgbGVuX2luX2J5dGVzLCBrLCBoYXNoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAnX2ludGVybmFsX3Bhc3MnKSB7XG4gICAgICAgIC8vIGZvciBpbnRlcm5hbCB0ZXN0cyBvbmx5XG4gICAgICAgIHByYiA9IG1zZztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kIG11c3QgYmUgXCJ4bWRcIiBvciBcInhvZlwiJyk7XG4gICAgfVxuICAgIGNvbnN0IHUgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBlID0gbmV3IEFycmF5KG0pO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG07IGorKykge1xuICAgICAgICAgICAgY29uc3QgZWxtX29mZnNldCA9IEwgKiAoaiArIGkgKiBtKTtcbiAgICAgICAgICAgIGNvbnN0IHR2ID0gcHJiLnN1YmFycmF5KGVsbV9vZmZzZXQsIGVsbV9vZmZzZXQgKyBMKTtcbiAgICAgICAgICAgIGVbal0gPSBtb2Qob3MyaXAodHYpLCBwKTtcbiAgICAgICAgfVxuICAgICAgICB1W2ldID0gZTtcbiAgICB9XG4gICAgcmV0dXJuIHU7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNvZ2VueU1hcChmaWVsZCwgbWFwKSB7XG4gICAgLy8gTWFrZSBzYW1lIG9yZGVyIGFzIGluIHNwZWNcbiAgICBjb25zdCBjb2VmZiA9IG1hcC5tYXAoKGkpID0+IEFycmF5LmZyb20oaSkucmV2ZXJzZSgpKTtcbiAgICByZXR1cm4gKHgsIHkpID0+IHtcbiAgICAgICAgY29uc3QgW3huLCB4ZCwgeW4sIHlkXSA9IGNvZWZmLm1hcCgodmFsKSA9PiB2YWwucmVkdWNlKChhY2MsIGkpID0+IGZpZWxkLmFkZChmaWVsZC5tdWwoYWNjLCB4KSwgaSkpKTtcbiAgICAgICAgLy8gNi42LjNcbiAgICAgICAgLy8gRXhjZXB0aW9uYWwgY2FzZXMgb2YgaXNvX21hcCBhcmUgaW5wdXRzIHRoYXQgY2F1c2UgdGhlIGRlbm9taW5hdG9yIG9mXG4gICAgICAgIC8vIGVpdGhlciByYXRpb25hbCBmdW5jdGlvbiB0byBldmFsdWF0ZSB0byB6ZXJvOyBzdWNoIGNhc2VzIE1VU1QgcmV0dXJuXG4gICAgICAgIC8vIHRoZSBpZGVudGl0eSBwb2ludCBvbiBFLlxuICAgICAgICBjb25zdCBbeGRfaW52LCB5ZF9pbnZdID0gRnBJbnZlcnRCYXRjaChmaWVsZCwgW3hkLCB5ZF0sIHRydWUpO1xuICAgICAgICB4ID0gZmllbGQubXVsKHhuLCB4ZF9pbnYpOyAvLyB4TnVtIC8geERlblxuICAgICAgICB5ID0gZmllbGQubXVsKHksIGZpZWxkLm11bCh5biwgeWRfaW52KSk7IC8vIHkgKiAoeU51bSAvIHlEZXYpXG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9O1xufVxuZXhwb3J0IGNvbnN0IF9EU1Rfc2NhbGFyID0gdXRmOFRvQnl0ZXMoJ0hhc2hUb1NjYWxhci0nKTtcbi8qKiBDcmVhdGVzIGhhc2gtdG8tY3VydmUgbWV0aG9kcyBmcm9tIEVDIFBvaW50IGFuZCBtYXBUb0N1cnZlIGZ1bmN0aW9uLiBTZWUge0BsaW5rIEgyQ0hhc2hlcn0uICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGFzaGVyKFBvaW50LCBtYXBUb0N1cnZlLCBkZWZhdWx0cykge1xuICAgIGlmICh0eXBlb2YgbWFwVG9DdXJ2ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlKCkgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgZnVuY3Rpb24gbWFwKG51bSkge1xuICAgICAgICByZXR1cm4gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKG51bSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjbGVhcihpbml0aWFsKSB7XG4gICAgICAgIGNvbnN0IFAgPSBpbml0aWFsLmNsZWFyQ29mYWN0b3IoKTtcbiAgICAgICAgaWYgKFAuZXF1YWxzKFBvaW50LlpFUk8pKVxuICAgICAgICAgICAgcmV0dXJuIFBvaW50LlpFUk87IC8vIHplcm8gd2lsbCB0aHJvdyBpbiBhc3NlcnRcbiAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICByZXR1cm4gUDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVmYXVsdHMsXG4gICAgICAgIGhhc2hUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBoYXNoX3RvX2ZpZWxkKG1zZywgMiwgb3B0cyk7XG4gICAgICAgICAgICBjb25zdCB1MCA9IG1hcCh1WzBdKTtcbiAgICAgICAgICAgIGNvbnN0IHUxID0gbWFwKHVbMV0pO1xuICAgICAgICAgICAgcmV0dXJuIGNsZWFyKHUwLmFkZCh1MSkpO1xuICAgICAgICB9LFxuICAgICAgICBlbmNvZGVUb0N1cnZlKG1zZywgb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3Qgb3B0c0RzdCA9IGRlZmF1bHRzLmVuY29kZURTVCA/IHsgRFNUOiBkZWZhdWx0cy5lbmNvZGVEU1QgfSA6IHt9O1xuICAgICAgICAgICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLCBvcHRzRHN0LCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBoYXNoX3RvX2ZpZWxkKG1zZywgMSwgb3B0cyk7XG4gICAgICAgICAgICBjb25zdCB1MCA9IG1hcCh1WzBdKTtcbiAgICAgICAgICAgIHJldHVybiBjbGVhcih1MCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKiBTZWUge0BsaW5rIEgyQ0hhc2hlcn0gKi9cbiAgICAgICAgbWFwVG9DdXJ2ZShzY2FsYXJzKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NhbGFycykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCBhcnJheSBvZiBiaWdpbnRzJyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGkgb2Ygc2NhbGFycylcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGkgIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdGVkIGFycmF5IG9mIGJpZ2ludHMnKTtcbiAgICAgICAgICAgIHJldHVybiBjbGVhcihtYXAoc2NhbGFycykpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBoYXNoX3RvX3NjYWxhciBjYW4gcHJvZHVjZSAwOiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9lcnJhdGEvZWlkODM5M1xuICAgICAgICAvLyBSRkMgOTM4MCwgZHJhZnQtaXJ0Zi1jZnJnLWJicy1zaWduYXR1cmVzLTA4XG4gICAgICAgIGhhc2hUb1NjYWxhcihtc2csIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IE4gPSBQb2ludC5Gbi5PUkRFUjtcbiAgICAgICAgICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0cywgeyBwOiBOLCBtOiAxLCBEU1Q6IF9EU1Rfc2NhbGFyIH0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIGhhc2hfdG9fZmllbGQobXNnLCAxLCBvcHRzKVswXVswXTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaC10by1jdXJ2ZS5qcy5tYXAiXSwibmFtZXMiOlsiX3ZhbGlkYXRlT2JqZWN0IiwiYWJ5dGVzIiwiYnl0ZXNUb051bWJlckJFIiwiY29uY2F0Qnl0ZXMiLCJpc0J5dGVzIiwiaXNIYXNoIiwidXRmOFRvQnl0ZXMiLCJGcEludmVydEJhdGNoIiwibW9kIiwib3MyaXAiLCJpMm9zcCIsInZhbHVlIiwibGVuZ3RoIiwiYW51bSIsIkVycm9yIiwicmVzIiwiQXJyYXkiLCJmcm9tIiwiZmlsbCIsImkiLCJVaW50OEFycmF5Iiwic3RyeG9yIiwiYSIsImIiLCJhcnIiLCJpdGVtIiwiTnVtYmVyIiwiaXNTYWZlSW50ZWdlciIsIm5vcm1EU1QiLCJEU1QiLCJleHBhbmRfbWVzc2FnZV94bWQiLCJtc2ciLCJsZW5JbkJ5dGVzIiwiSCIsIm91dHB1dExlbiIsImJfaW5fYnl0ZXMiLCJibG9ja0xlbiIsInJfaW5fYnl0ZXMiLCJlbGwiLCJNYXRoIiwiY2VpbCIsIkRTVF9wcmltZSIsIlpfcGFkIiwibF9pX2Jfc3RyIiwiYl8wIiwiYXJncyIsInBzZXVkb19yYW5kb21fYnl0ZXMiLCJzbGljZSIsImV4cGFuZF9tZXNzYWdlX3hvZiIsImsiLCJka0xlbiIsImNyZWF0ZSIsInVwZGF0ZSIsImRpZ2VzdCIsImhhc2hfdG9fZmllbGQiLCJjb3VudCIsIm9wdGlvbnMiLCJwIiwibSIsImhhc2giLCJleHBhbmQiLCJsb2cycCIsInRvU3RyaW5nIiwiTCIsImxlbl9pbl9ieXRlcyIsInByYiIsInUiLCJlIiwiaiIsImVsbV9vZmZzZXQiLCJ0diIsInN1YmFycmF5IiwiaXNvZ2VueU1hcCIsImZpZWxkIiwibWFwIiwiY29lZmYiLCJyZXZlcnNlIiwieCIsInkiLCJ4biIsInhkIiwieW4iLCJ5ZCIsInZhbCIsInJlZHVjZSIsImFjYyIsImFkZCIsIm11bCIsInhkX2ludiIsInlkX2ludiIsIl9EU1Rfc2NhbGFyIiwiY3JlYXRlSGFzaGVyIiwiUG9pbnQiLCJtYXBUb0N1cnZlIiwiZGVmYXVsdHMiLCJudW0iLCJmcm9tQWZmaW5lIiwiY2xlYXIiLCJpbml0aWFsIiwiUCIsImNsZWFyQ29mYWN0b3IiLCJlcXVhbHMiLCJaRVJPIiwiYXNzZXJ0VmFsaWRpdHkiLCJoYXNoVG9DdXJ2ZSIsIm9wdHMiLCJPYmplY3QiLCJhc3NpZ24iLCJ1MCIsInUxIiwiZW5jb2RlVG9DdXJ2ZSIsIm9wdHNEc3QiLCJlbmNvZGVEU1QiLCJzY2FsYXJzIiwiaXNBcnJheSIsImhhc2hUb1NjYWxhciIsIk4iLCJGbiIsIk9SREVSIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/modular.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/modular.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   FpDiv: () => (/* binding */ FpDiv),\n/* harmony export */   FpInvertBatch: () => (/* binding */ FpInvertBatch),\n/* harmony export */   FpIsSquare: () => (/* binding */ FpIsSquare),\n/* harmony export */   FpLegendre: () => (/* binding */ FpLegendre),\n/* harmony export */   FpPow: () => (/* binding */ FpPow),\n/* harmony export */   FpSqrt: () => (/* binding */ FpSqrt),\n/* harmony export */   FpSqrtEven: () => (/* binding */ FpSqrtEven),\n/* harmony export */   FpSqrtOdd: () => (/* binding */ FpSqrtOdd),\n/* harmony export */   getFieldBytesLength: () => (/* binding */ getFieldBytesLength),\n/* harmony export */   getMinHashLength: () => (/* binding */ getMinHashLength),\n/* harmony export */   hashToPrivateScalar: () => (/* binding */ hashToPrivateScalar),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   isNegativeLE: () => (/* binding */ isNegativeLE),\n/* harmony export */   mapHashToField: () => (/* binding */ mapHashToField),\n/* harmony export */   mod: () => (/* binding */ mod),\n/* harmony export */   nLength: () => (/* binding */ nLength),\n/* harmony export */   pow: () => (/* binding */ pow),\n/* harmony export */   pow2: () => (/* binding */ pow2),\n/* harmony export */   tonelliShanks: () => (/* binding */ tonelliShanks),\n/* harmony export */   validateField: () => (/* binding */ validateField)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/utils.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/utils.js\");\n/**\n * Utils for modular division and fields.\n * Field over 11 is a finite (Galois) field is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _7n = /* @__PURE__ */ BigInt(7);\n// prettier-ignore\nconst _8n = /* @__PURE__ */ BigInt(8), _9n = /* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */ function pow(num, power, modulo) {\n    return FpPow(Field(modulo), num, power);\n}\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */ function pow2(x, power, modulo) {\n    let res = x;\n    while(power-- > _0n){\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */ function invert(number, modulo) {\n    if (number === _0n) throw new Error(\"invert: expected non-zero number\");\n    if (modulo <= _0n) throw new Error(\"invert: expected positive modulus, got \" + modulo);\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while(a !== _0n){\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n) throw new Error(\"invert: does not exist\");\n    return mod(x, modulo);\n}\nfunction assertIsSquare(Fp, root, n) {\n    if (!Fp.eql(Fp.sqr(root), n)) throw new Error(\"Cannot find square root\");\n}\n// Not all roots are possible! Example which will throw:\n// const NUM =\n// n = 72057594037927816n;\n// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));\nfunction sqrt3mod4(Fp, n) {\n    const p1div4 = (Fp.ORDER + _1n) / _4n;\n    const root = Fp.pow(n, p1div4);\n    assertIsSquare(Fp, root, n);\n    return root;\n}\nfunction sqrt5mod8(Fp, n) {\n    const p5div8 = (Fp.ORDER - _5n) / _8n;\n    const n2 = Fp.mul(n, _2n);\n    const v = Fp.pow(n2, p5div8);\n    const nv = Fp.mul(n, v);\n    const i = Fp.mul(Fp.mul(nv, _2n), v);\n    const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n    assertIsSquare(Fp, root, n);\n    return root;\n}\n// Based on RFC9380, Kong algorithm\n// prettier-ignore\nfunction sqrt9mod16(P) {\n    const Fp_ = Field(P);\n    const tn = tonelliShanks(P);\n    const c1 = tn(Fp_, Fp_.neg(Fp_.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    const c2 = tn(Fp_, c1); //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    const c3 = tn(Fp_, Fp_.neg(c1)); //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    const c4 = (P + _7n) / _16n; //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    return (Fp, n)=>{\n        let tv1 = Fp.pow(n, c4); //  1. tv1 = x^c4\n        let tv2 = Fp.mul(tv1, c1); //  2. tv2 = c1 * tv1\n        const tv3 = Fp.mul(tv1, c2); //  3. tv3 = c2 * tv1\n        const tv4 = Fp.mul(tv1, c3); //  4. tv4 = c3 * tv1\n        const e1 = Fp.eql(Fp.sqr(tv2), n); //  5.  e1 = (tv2^2) == x\n        const e2 = Fp.eql(Fp.sqr(tv3), n); //  6.  e2 = (tv3^2) == x\n        tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        const e3 = Fp.eql(Fp.sqr(tv2), n); //  9.  e3 = (tv2^2) == x\n        const root = Fp.cmov(tv1, tv2, e3); // 10.  z = CMOV(tv1, tv2, e3)   # Select sqrt from tv1 & tv2\n        assertIsSquare(Fp, root, n);\n        return root;\n    };\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */ function tonelliShanks(P) {\n    // Initialization (precomputation).\n    // Caching initialization could boost perf by 7%.\n    if (P < _3n) throw new Error(\"sqrt is not defined for small field\");\n    // Factor P - 1 = Q * 2^S, where Q is odd\n    let Q = P - _1n;\n    let S = 0;\n    while(Q % _2n === _0n){\n        Q /= _2n;\n        S++;\n    }\n    // Find the first quadratic non-residue Z >= 2\n    let Z = _2n;\n    const _Fp = Field(P);\n    while(FpLegendre(_Fp, Z) === 1){\n        // Basic primality test for P. After x iterations, chance of\n        // not finding quadratic non-residue is 2^x, so 2^1000.\n        if (Z++ > 1000) throw new Error(\"Cannot find square root: probably non-prime P\");\n    }\n    // Fast-path; usually done before Z, but we do \"primality test\".\n    if (S === 1) return sqrt3mod4;\n    // Slow-path\n    // TODO: test on Fp2 and others\n    let cc = _Fp.pow(Z, Q); // c = z^Q\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        if (Fp.is0(n)) return n;\n        // Check if n is a quadratic residue using Legendre symbol\n        if (FpLegendre(Fp, n) !== 1) throw new Error(\"Cannot find square root\");\n        // Initialize variables for the main loop\n        let M = S;\n        let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp\n        let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor\n        let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root\n        // Main loop\n        // while t != 1\n        while(!Fp.eql(t, Fp.ONE)){\n            if (Fp.is0(t)) return Fp.ZERO; // if t=0 return R=0\n            let i = 1;\n            // Find the smallest i >= 1 such that t^(2^i) ≡ 1 (mod P)\n            let t_tmp = Fp.sqr(t); // t^(2^1)\n            while(!Fp.eql(t_tmp, Fp.ONE)){\n                i++;\n                t_tmp = Fp.sqr(t_tmp); // t^(2^2)...\n                if (i === M) throw new Error(\"Cannot find square root\");\n            }\n            // Calculate the exponent for b: 2^(M - i - 1)\n            const exponent = _1n << BigInt(M - i - 1); // bigint is important\n            const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)\n            // Update variables\n            M = i;\n            c = Fp.sqr(b); // c = b^2\n            t = Fp.mul(t, c); // t = (t * b^2)\n            R = Fp.mul(R, b); // R = R*b\n        }\n        return R;\n    };\n}\n/**\n * Square root for a finite field. Will try optimized versions first:\n *\n * 1. P ≡ 3 (mod 4)\n * 2. P ≡ 5 (mod 8)\n * 3. P ≡ 9 (mod 16)\n * 4. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */ function FpSqrt(P) {\n    // P ≡ 3 (mod 4) => √n = n^((P+1)/4)\n    if (P % _4n === _3n) return sqrt3mod4;\n    // P ≡ 5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf\n    if (P % _8n === _5n) return sqrt5mod8;\n    // P ≡ 9 (mod 16) => Kong algorithm, page 11 of https://eprint.iacr.org/2012/685.pdf (algorithm 4)\n    if (P % _16n === _9n) return sqrt9mod16(P);\n    // Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo)=>(mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    \"create\",\n    \"isValid\",\n    \"is0\",\n    \"neg\",\n    \"inv\",\n    \"sqrt\",\n    \"sqr\",\n    \"eql\",\n    \"add\",\n    \"sub\",\n    \"mul\",\n    \"pow\",\n    \"div\",\n    \"addN\",\n    \"subN\",\n    \"mulN\",\n    \"sqrN\"\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: \"bigint\",\n        MASK: \"bigint\",\n        BYTES: \"number\",\n        BITS: \"number\"\n    };\n    const opts = FIELD_FIELDS.reduce((map, val)=>{\n        map[val] = \"function\";\n        return map;\n    }, initial);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._validateObject)(field, opts);\n    // const max = 16384;\n    // if (field.BYTES < 1 || field.BYTES > max) throw new Error('invalid field');\n    // if (field.BITS < 1 || field.BITS > 8 * max) throw new Error('invalid field');\n    return field;\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */ function FpPow(Fp, num, power) {\n    if (power < _0n) throw new Error(\"invalid exponent, negatives unsupported\");\n    if (power === _0n) return Fp.ONE;\n    if (power === _1n) return num;\n    let p = Fp.ONE;\n    let d = num;\n    while(power > _0n){\n        if (power & _1n) p = Fp.mul(p, d);\n        d = Fp.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * Exception-free. Will return `undefined` for 0 elements.\n * @param passZero map 0 to 0 (instead of undefined)\n */ function FpInvertBatch(Fp, nums, passZero = false) {\n    const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n    // Walk from first to last, multiply them by each other MOD p\n    const multipliedAcc = nums.reduce((acc, num, i)=>{\n        if (Fp.is0(num)) return acc;\n        inverted[i] = acc;\n        return Fp.mul(acc, num);\n    }, Fp.ONE);\n    // Invert last element\n    const invertedAcc = Fp.inv(multipliedAcc);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i)=>{\n        if (Fp.is0(num)) return acc;\n        inverted[i] = Fp.mul(acc, inverted[i]);\n        return Fp.mul(acc, num);\n    }, invertedAcc);\n    return inverted;\n}\n// TODO: remove\nfunction FpDiv(Fp, lhs, rhs) {\n    return Fp.mul(lhs, typeof rhs === \"bigint\" ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));\n}\n/**\n * Legendre symbol.\n * Legendre constant is used to calculate Legendre symbol (a | p)\n * which denotes the value of a^((p-1)/2) (mod p).\n *\n * * (a | p) ≡ 1    if a is a square (mod p), quadratic residue\n * * (a | p) ≡ -1   if a is not a square (mod p), quadratic non residue\n * * (a | p) ≡ 0    if a ≡ 0 (mod p)\n */ function FpLegendre(Fp, n) {\n    // We can use 3rd argument as optional cache of this value\n    // but seems unneeded for now. The operation is very fast.\n    const p1mod2 = (Fp.ORDER - _1n) / _2n;\n    const powered = Fp.pow(n, p1mod2);\n    const yes = Fp.eql(powered, Fp.ONE);\n    const zero = Fp.eql(powered, Fp.ZERO);\n    const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n    if (!yes && !zero && !no) throw new Error(\"invalid Legendre symbol result\");\n    return yes ? 1 : zero ? 0 : -1;\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(Fp, n) {\n    const l = FpLegendre(Fp, n);\n    return l === 1;\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    if (nBitLength !== undefined) (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.anumber)(nBitLength);\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return {\n        nBitLength: _nBitLength,\n        nByteLength\n    };\n}\n/**\n * Creates a finite field. Major performance optimizations:\n * * 1. Denormalized operations like mulN instead of mul.\n * * 2. Identical object shape: never add or remove keys.\n * * 3. `Object.freeze`.\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n *\n * Note about field properties:\n * * CHARACTERISTIC p = prime number, number of elements in main subgroup.\n * * ORDER q = similar to cofactor in curves, may be composite `q = p^m`.\n *\n * @param ORDER field order, probably prime, or could be composite\n * @param bitLen how many bits the field consumes\n * @param isLE (default: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */ function Field(ORDER, bitLenOrOpts, isLE = false, opts = {}) {\n    if (ORDER <= _0n) throw new Error(\"invalid field: expected ORDER > 0, got \" + ORDER);\n    let _nbitLength = undefined;\n    let _sqrt = undefined;\n    let modFromBytes = false;\n    let allowedLengths = undefined;\n    if (typeof bitLenOrOpts === \"object\" && bitLenOrOpts != null) {\n        if (opts.sqrt || isLE) throw new Error(\"cannot specify opts in two arguments\");\n        const _opts = bitLenOrOpts;\n        if (_opts.BITS) _nbitLength = _opts.BITS;\n        if (_opts.sqrt) _sqrt = _opts.sqrt;\n        if (typeof _opts.isLE === \"boolean\") isLE = _opts.isLE;\n        if (typeof _opts.modFromBytes === \"boolean\") modFromBytes = _opts.modFromBytes;\n        allowedLengths = _opts.allowedLengths;\n    } else {\n        if (typeof bitLenOrOpts === \"number\") _nbitLength = bitLenOrOpts;\n        if (opts.sqrt) _sqrt = opts.sqrt;\n    }\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);\n    if (BYTES > 2048) throw new Error(\"invalid field: expected ORDER of <= 2048 bytes\");\n    let sqrtP; // cached sqrtP\n    const f = Object.freeze({\n        ORDER,\n        isLE,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        allowedLengths: allowedLengths,\n        create: (num)=>mod(num, ORDER),\n        isValid: (num)=>{\n            if (typeof num !== \"bigint\") throw new Error(\"invalid field element: expected bigint, got \" + typeof num);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num)=>num === _0n,\n        // is valid and invertible\n        isValidNot0: (num)=>!f.is0(num) && f.isValid(num),\n        isOdd: (num)=>(num & _1n) === _1n,\n        neg: (num)=>mod(-num, ORDER),\n        eql: (lhs, rhs)=>lhs === rhs,\n        sqr: (num)=>mod(num * num, ORDER),\n        add: (lhs, rhs)=>mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs)=>mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs)=>mod(lhs * rhs, ORDER),\n        pow: (num, power)=>FpPow(f, num, power),\n        div: (lhs, rhs)=>mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num)=>num * num,\n        addN: (lhs, rhs)=>lhs + rhs,\n        subN: (lhs, rhs)=>lhs - rhs,\n        mulN: (lhs, rhs)=>lhs * rhs,\n        inv: (num)=>invert(num, ORDER),\n        sqrt: _sqrt || ((n)=>{\n            if (!sqrtP) sqrtP = FpSqrt(ORDER);\n            return sqrtP(f, n);\n        }),\n        toBytes: (num)=>isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES),\n        fromBytes: (bytes, skipValidation = true)=>{\n            if (allowedLengths) {\n                if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {\n                    throw new Error(\"Field.fromBytes: expected \" + allowedLengths + \" bytes, got \" + bytes.length);\n                }\n                const padded = new Uint8Array(BYTES);\n                // isLE add 0 to right, !isLE to the left.\n                padded.set(bytes, isLE ? 0 : padded.length - bytes.length);\n                bytes = padded;\n            }\n            if (bytes.length !== BYTES) throw new Error(\"Field.fromBytes: expected \" + BYTES + \" bytes, got \" + bytes.length);\n            let scalar = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n            if (modFromBytes) scalar = mod(scalar, ORDER);\n            if (!skipValidation) {\n                if (!f.isValid(scalar)) throw new Error(\"invalid field element: outside of range 0..ORDER\");\n            }\n            // NOTE: we don't validate scalar here, please use isValid. This done such way because some\n            // protocol may allow non-reduced scalar that reduced later or changed some other way.\n            return scalar;\n        },\n        // TODO: we don't need it here, move out to separate fn\n        invertBatch: (lst)=>FpInvertBatch(f, lst),\n        // We can't move this out because Fp6, Fp12 implement it\n        // and it's unclear what to return in there.\n        cmov: (a, b, c)=>c ? b : a\n    });\n    return Object.freeze(f);\n}\n// Generic random scalar, we can do same for other fields if via Fp2.mul(Fp2.ONE, Fp2.random)?\n// This allows unsafe methods like ignore bias or zero. These unsafe, but often used in different protocols (if deterministic RNG).\n// which mean we cannot force this via opts.\n// Not sure what to do with randomBytes, we can accept it inside opts if wanted.\n// Probably need to export getMinHashLength somewhere?\n// random(bytes?: Uint8Array, unsafeAllowZero = false, unsafeAllowBias = false) {\n//   const LEN = !unsafeAllowBias ? getMinHashLength(ORDER) : BYTES;\n//   if (bytes === undefined) bytes = randomBytes(LEN); // _opts.randomBytes?\n//   const num = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n//   // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n//   const reduced = unsafeAllowZero ? mod(num, ORDER) : mod(num, ORDER - _1n) + _1n;\n//   return reduced;\n// },\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */ function hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"privateHash\", hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error(\"hashToPrivateScalar: expected \" + minLen + \"-1024 bytes of input, got \" + hashLen);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */ function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== \"bigint\") throw new Error(\"field order must be bigint\");\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */ function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */ function mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024) throw new Error(\"expected \" + minLen + \"-1024 bytes of input, got \" + len);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n} //# sourceMappingURL=modular.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjkuNy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvbW9kdWxhci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7OztDQUtDLEdBQ0Qsb0VBQW9FLEdBQzhFO0FBQ2xKLGtCQUFrQjtBQUNsQixNQUFNUSxNQUFNQyxPQUFPLElBQUlDLE1BQU1ELE9BQU8sSUFBSUUsTUFBTSxhQUFhLEdBQUdGLE9BQU8sSUFBSUcsTUFBTSxhQUFhLEdBQUdILE9BQU87QUFDdEcsa0JBQWtCO0FBQ2xCLE1BQU1JLE1BQU0sYUFBYSxHQUFHSixPQUFPLElBQUlLLE1BQU0sYUFBYSxHQUFHTCxPQUFPLElBQUlNLE1BQU0sYUFBYSxHQUFHTixPQUFPO0FBQ3JHLGtCQUFrQjtBQUNsQixNQUFNTyxNQUFNLGFBQWEsR0FBR1AsT0FBTyxJQUFJUSxNQUFNLGFBQWEsR0FBR1IsT0FBTyxJQUFJUyxPQUFPLGFBQWEsR0FBR1QsT0FBTztBQUN0Ryx3QkFBd0I7QUFDakIsU0FBU1UsSUFBSUMsQ0FBQyxFQUFFQyxDQUFDO0lBQ3BCLE1BQU1DLFNBQVNGLElBQUlDO0lBQ25CLE9BQU9DLFVBQVVkLE1BQU1jLFNBQVNELElBQUlDO0FBQ3hDO0FBQ0E7Ozs7O0NBS0MsR0FDTSxTQUFTQyxJQUFJQyxHQUFHLEVBQUVDLEtBQUssRUFBRUMsTUFBTTtJQUNsQyxPQUFPQyxNQUFNQyxNQUFNRixTQUFTRixLQUFLQztBQUNyQztBQUNBLDBEQUEwRCxHQUNuRCxTQUFTSSxLQUFLQyxDQUFDLEVBQUVMLEtBQUssRUFBRUMsTUFBTTtJQUNqQyxJQUFJSyxNQUFNRDtJQUNWLE1BQU9MLFVBQVVqQixJQUFLO1FBQ2xCdUIsT0FBT0E7UUFDUEEsT0FBT0w7SUFDWDtJQUNBLE9BQU9LO0FBQ1g7QUFDQTs7O0NBR0MsR0FDTSxTQUFTQyxPQUFPQyxNQUFNLEVBQUVQLE1BQU07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LE9BQU8sS0FBSztJQUN4RCxNQUFNOEMsTUFBTUQsSUFBSXZFLE1BQU07SUFDdEIsTUFBTXlFLFdBQVdQLG9CQUFvQkM7SUFDckMsTUFBTUYsU0FBU0ksaUJBQWlCRjtJQUNoQyxpR0FBaUc7SUFDakcsSUFBSUssTUFBTSxNQUFNQSxNQUFNUCxVQUFVTyxNQUFNLE1BQ2xDLE1BQU0sSUFBSXZKLE1BQU0sY0FBY2dKLFNBQVMsK0JBQStCTztJQUMxRSxNQUFNakssTUFBTW1ILE9BQU92SSwwREFBZUEsQ0FBQ29MLE9BQU9yTCwwREFBZUEsQ0FBQ3FMO0lBQzFELCtFQUErRTtJQUMvRSxNQUFNRyxVQUFVeEssSUFBSUssS0FBSzRKLGFBQWExSyxPQUFPQTtJQUM3QyxPQUFPaUksT0FBT3BJLDBEQUFlQSxDQUFDb0wsU0FBU0QsWUFBWXBMLDBEQUFlQSxDQUFDcUwsU0FBU0Q7QUFDaEYsRUFDQSxtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3Rhc2NhbS1wcm90b2NvbC8uL25vZGVfbW9kdWxlcy8ucG5wbS9Abm9ibGUrY3VydmVzQDEuOS43L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb2R1bGFyLmpzPzMwNjIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVdGlscyBmb3IgbW9kdWxhciBkaXZpc2lvbiBhbmQgZmllbGRzLlxuICogRmllbGQgb3ZlciAxMSBpcyBhIGZpbml0ZSAoR2Fsb2lzKSBmaWVsZCBpcyBpbnRlZ2VyIG51bWJlciBvcGVyYXRpb25zIGBtb2QgMTFgLlxuICogVGhlcmUgaXMgbm8gZGl2aXNpb246IGl0IGlzIHJlcGxhY2VkIGJ5IG1vZHVsYXIgbXVsdGlwbGljYXRpdmUgaW52ZXJzZS5cbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgX3ZhbGlkYXRlT2JqZWN0LCBhbnVtYmVyLCBiaXRNYXNrLCBieXRlc1RvTnVtYmVyQkUsIGJ5dGVzVG9OdW1iZXJMRSwgZW5zdXJlQnl0ZXMsIG51bWJlclRvQnl0ZXNCRSwgbnVtYmVyVG9CeXRlc0xFLCB9IGZyb20gXCIuLi91dGlscy5qc1wiO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyKSwgXzNuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgzKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzRuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg0KSwgXzVuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg1KSwgXzduID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg3KTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzhuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg4KSwgXzluID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg5KSwgXzE2biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMTYpO1xuLy8gQ2FsY3VsYXRlcyBhIG1vZHVsbyBiXG5leHBvcnQgZnVuY3Rpb24gbW9kKGEsIGIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhICUgYjtcbiAgICByZXR1cm4gcmVzdWx0ID49IF8wbiA/IHJlc3VsdCA6IGIgKyByZXN1bHQ7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IHJhaXNlIG51bSB0byBwb3dlciBhbmQgZG8gbW9kdWxhciBkaXZpc2lvbi5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqIEBleGFtcGxlXG4gKiBwb3coMm4sIDZuLCAxMW4pIC8vIDY0biAlIDExbiA9PSA5blxuICovXG5leHBvcnQgZnVuY3Rpb24gcG93KG51bSwgcG93ZXIsIG1vZHVsbykge1xuICAgIHJldHVybiBGcFBvdyhGaWVsZChtb2R1bG8pLCBudW0sIHBvd2VyKTtcbn1cbi8qKiBEb2VzIGB4XigyXnBvd2VyKWAgbW9kIHAuIGBwb3cyKDMwLCA0KWAgPT0gYDMwXigyXjQpYCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvdzIoeCwgcG93ZXIsIG1vZHVsbykge1xuICAgIGxldCByZXMgPSB4O1xuICAgIHdoaWxlIChwb3dlci0tID4gXzBuKSB7XG4gICAgICAgIHJlcyAqPSByZXM7XG4gICAgICAgIHJlcyAlPSBtb2R1bG87XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIEludmVyc2VzIG51bWJlciBvdmVyIG1vZHVsby5cbiAqIEltcGxlbWVudGVkIHVzaW5nIFtFdWNsaWRlYW4gR0NEXShodHRwczovL2JyaWxsaWFudC5vcmcvd2lraS9leHRlbmRlZC1ldWNsaWRlYW4tYWxnb3JpdGhtLykuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZlcnQobnVtYmVyLCBtb2R1bG8pIHtcbiAgICBpZiAobnVtYmVyID09PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52ZXJ0OiBleHBlY3RlZCBub24temVybyBudW1iZXInKTtcbiAgICBpZiAobW9kdWxvIDw9IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZlcnQ6IGV4cGVjdGVkIHBvc2l0aXZlIG1vZHVsdXMsIGdvdCAnICsgbW9kdWxvKTtcbiAgICAvLyBGZXJtYXQncyBsaXR0bGUgdGhlb3JlbSBcIkNULWxpa2VcIiB2ZXJzaW9uIGludihuKSA9IG5eKG0tMikgbW9kIG0gaXMgMzB4IHNsb3dlci5cbiAgICBsZXQgYSA9IG1vZChudW1iZXIsIG1vZHVsbyk7XG4gICAgbGV0IGIgPSBtb2R1bG87XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgbGV0IHggPSBfMG4sIHkgPSBfMW4sIHUgPSBfMW4sIHYgPSBfMG47XG4gICAgd2hpbGUgKGEgIT09IF8wbikge1xuICAgICAgICAvLyBKSVQgYXBwbGllcyBvcHRpbWl6YXRpb24gaWYgdGhvc2UgdHdvIGxpbmVzIGZvbGxvdyBlYWNoIG90aGVyXG4gICAgICAgIGNvbnN0IHEgPSBiIC8gYTtcbiAgICAgICAgY29uc3QgciA9IGIgJSBhO1xuICAgICAgICBjb25zdCBtID0geCAtIHUgKiBxO1xuICAgICAgICBjb25zdCBuID0geSAtIHYgKiBxO1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgYiA9IGEsIGEgPSByLCB4ID0gdSwgeSA9IHYsIHUgPSBtLCB2ID0gbjtcbiAgICB9XG4gICAgY29uc3QgZ2NkID0gYjtcbiAgICBpZiAoZ2NkICE9PSBfMW4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52ZXJ0OiBkb2VzIG5vdCBleGlzdCcpO1xuICAgIHJldHVybiBtb2QoeCwgbW9kdWxvKTtcbn1cbmZ1bmN0aW9uIGFzc2VydElzU3F1YXJlKEZwLCByb290LCBuKSB7XG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xufVxuLy8gTm90IGFsbCByb290cyBhcmUgcG9zc2libGUhIEV4YW1wbGUgd2hpY2ggd2lsbCB0aHJvdzpcbi8vIGNvbnN0IE5VTSA9XG4vLyBuID0gNzIwNTc1OTQwMzc5Mjc4MTZuO1xuLy8gRnAgPSBGaWVsZChCaWdJbnQoJzB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYWFiJykpO1xuZnVuY3Rpb24gc3FydDNtb2Q0KEZwLCBuKSB7XG4gICAgY29uc3QgcDFkaXY0ID0gKEZwLk9SREVSICsgXzFuKSAvIF80bjtcbiAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG4gICAgYXNzZXJ0SXNTcXVhcmUoRnAsIHJvb3QsIG4pO1xuICAgIHJldHVybiByb290O1xufVxuZnVuY3Rpb24gc3FydDVtb2Q4KEZwLCBuKSB7XG4gICAgY29uc3QgcDVkaXY4ID0gKEZwLk9SREVSIC0gXzVuKSAvIF84bjtcbiAgICBjb25zdCBuMiA9IEZwLm11bChuLCBfMm4pO1xuICAgIGNvbnN0IHYgPSBGcC5wb3cobjIsIHA1ZGl2OCk7XG4gICAgY29uc3QgbnYgPSBGcC5tdWwobiwgdik7XG4gICAgY29uc3QgaSA9IEZwLm11bChGcC5tdWwobnYsIF8ybiksIHYpO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5tdWwobnYsIEZwLnN1YihpLCBGcC5PTkUpKTtcbiAgICBhc3NlcnRJc1NxdWFyZShGcCwgcm9vdCwgbik7XG4gICAgcmV0dXJuIHJvb3Q7XG59XG4vLyBCYXNlZCBvbiBSRkM5MzgwLCBLb25nIGFsZ29yaXRobVxuLy8gcHJldHRpZXItaWdub3JlXG5mdW5jdGlvbiBzcXJ0OW1vZDE2KFApIHtcbiAgICBjb25zdCBGcF8gPSBGaWVsZChQKTtcbiAgICBjb25zdCB0biA9IHRvbmVsbGlTaGFua3MoUCk7XG4gICAgY29uc3QgYzEgPSB0bihGcF8sIEZwXy5uZWcoRnBfLk9ORSkpOyAvLyAgMS4gYzEgPSBzcXJ0KC0xKSBpbiBGLCBpLmUuLCAoYzFeMikgPT0gLTEgaW4gRlxuICAgIGNvbnN0IGMyID0gdG4oRnBfLCBjMSk7IC8vICAyLiBjMiA9IHNxcnQoYzEpIGluIEYsIGkuZS4sIChjMl4yKSA9PSBjMSBpbiBGXG4gICAgY29uc3QgYzMgPSB0bihGcF8sIEZwXy5uZWcoYzEpKTsgLy8gIDMuIGMzID0gc3FydCgtYzEpIGluIEYsIGkuZS4sIChjM14yKSA9PSAtYzEgaW4gRlxuICAgIGNvbnN0IGM0ID0gKFAgKyBfN24pIC8gXzE2bjsgLy8gIDQuIGM0ID0gKHEgKyA3KSAvIDE2ICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIHJldHVybiAoRnAsIG4pID0+IHtcbiAgICAgICAgbGV0IHR2MSA9IEZwLnBvdyhuLCBjNCk7IC8vICAxLiB0djEgPSB4XmM0XG4gICAgICAgIGxldCB0djIgPSBGcC5tdWwodHYxLCBjMSk7IC8vICAyLiB0djIgPSBjMSAqIHR2MVxuICAgICAgICBjb25zdCB0djMgPSBGcC5tdWwodHYxLCBjMik7IC8vICAzLiB0djMgPSBjMiAqIHR2MVxuICAgICAgICBjb25zdCB0djQgPSBGcC5tdWwodHYxLCBjMyk7IC8vICA0LiB0djQgPSBjMyAqIHR2MVxuICAgICAgICBjb25zdCBlMSA9IEZwLmVxbChGcC5zcXIodHYyKSwgbik7IC8vICA1LiAgZTEgPSAodHYyXjIpID09IHhcbiAgICAgICAgY29uc3QgZTIgPSBGcC5lcWwoRnAuc3FyKHR2MyksIG4pOyAvLyAgNi4gIGUyID0gKHR2M14yKSA9PSB4XG4gICAgICAgIHR2MSA9IEZwLmNtb3YodHYxLCB0djIsIGUxKTsgLy8gIDcuIHR2MSA9IENNT1YodHYxLCB0djIsIGUxKSAgIyBTZWxlY3QgdHYyIGlmICh0djJeMikgPT0geFxuICAgICAgICB0djIgPSBGcC5jbW92KHR2NCwgdHYzLCBlMik7IC8vICA4LiB0djIgPSBDTU9WKHR2NCwgdHYzLCBlMikgICMgU2VsZWN0IHR2MyBpZiAodHYzXjIpID09IHhcbiAgICAgICAgY29uc3QgZTMgPSBGcC5lcWwoRnAuc3FyKHR2MiksIG4pOyAvLyAgOS4gIGUzID0gKHR2Ml4yKSA9PSB4XG4gICAgICAgIGNvbnN0IHJvb3QgPSBGcC5jbW92KHR2MSwgdHYyLCBlMyk7IC8vIDEwLiAgeiA9IENNT1YodHYxLCB0djIsIGUzKSAgICMgU2VsZWN0IHNxcnQgZnJvbSB0djEgJiB0djJcbiAgICAgICAgYXNzZXJ0SXNTcXVhcmUoRnAsIHJvb3QsIG4pO1xuICAgICAgICByZXR1cm4gcm9vdDtcbiAgICB9O1xufVxuLyoqXG4gKiBUb25lbGxpLVNoYW5rcyBzcXVhcmUgcm9vdCBzZWFyY2ggYWxnb3JpdGhtLlxuICogMS4gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChwYWdlIDEyKVxuICogMi4gU3F1YXJlIFJvb3RzIGZyb20gMTsgMjQsIDUxLCAxMCB0byBEYW4gU2hhbmtzXG4gKiBAcGFyYW0gUCBmaWVsZCBvcmRlclxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB0YWtlcyBmaWVsZCBGcCAoY3JlYXRlZCBmcm9tIFApIGFuZCBudW1iZXIgblxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9uZWxsaVNoYW5rcyhQKSB7XG4gICAgLy8gSW5pdGlhbGl6YXRpb24gKHByZWNvbXB1dGF0aW9uKS5cbiAgICAvLyBDYWNoaW5nIGluaXRpYWxpemF0aW9uIGNvdWxkIGJvb3N0IHBlcmYgYnkgNyUuXG4gICAgaWYgKFAgPCBfM24pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3FydCBpcyBub3QgZGVmaW5lZCBmb3Igc21hbGwgZmllbGQnKTtcbiAgICAvLyBGYWN0b3IgUCAtIDEgPSBRICogMl5TLCB3aGVyZSBRIGlzIG9kZFxuICAgIGxldCBRID0gUCAtIF8xbjtcbiAgICBsZXQgUyA9IDA7XG4gICAgd2hpbGUgKFEgJSBfMm4gPT09IF8wbikge1xuICAgICAgICBRIC89IF8ybjtcbiAgICAgICAgUysrO1xuICAgIH1cbiAgICAvLyBGaW5kIHRoZSBmaXJzdCBxdWFkcmF0aWMgbm9uLXJlc2lkdWUgWiA+PSAyXG4gICAgbGV0IFogPSBfMm47XG4gICAgY29uc3QgX0ZwID0gRmllbGQoUCk7XG4gICAgd2hpbGUgKEZwTGVnZW5kcmUoX0ZwLCBaKSA9PT0gMSkge1xuICAgICAgICAvLyBCYXNpYyBwcmltYWxpdHkgdGVzdCBmb3IgUC4gQWZ0ZXIgeCBpdGVyYXRpb25zLCBjaGFuY2Ugb2ZcbiAgICAgICAgLy8gbm90IGZpbmRpbmcgcXVhZHJhdGljIG5vbi1yZXNpZHVlIGlzIDJeeCwgc28gMl4xMDAwLlxuICAgICAgICBpZiAoWisrID4gMTAwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3Q6IHByb2JhYmx5IG5vbi1wcmltZSBQJyk7XG4gICAgfVxuICAgIC8vIEZhc3QtcGF0aDsgdXN1YWxseSBkb25lIGJlZm9yZSBaLCBidXQgd2UgZG8gXCJwcmltYWxpdHkgdGVzdFwiLlxuICAgIGlmIChTID09PSAxKVxuICAgICAgICByZXR1cm4gc3FydDNtb2Q0O1xuICAgIC8vIFNsb3ctcGF0aFxuICAgIC8vIFRPRE86IHRlc3Qgb24gRnAyIGFuZCBvdGhlcnNcbiAgICBsZXQgY2MgPSBfRnAucG93KFosIFEpOyAvLyBjID0gel5RXG4gICAgY29uc3QgUTFkaXYyID0gKFEgKyBfMW4pIC8gXzJuO1xuICAgIHJldHVybiBmdW5jdGlvbiB0b25lbGxpU2xvdyhGcCwgbikge1xuICAgICAgICBpZiAoRnAuaXMwKG4pKVxuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIC8vIENoZWNrIGlmIG4gaXMgYSBxdWFkcmF0aWMgcmVzaWR1ZSB1c2luZyBMZWdlbmRyZSBzeW1ib2xcbiAgICAgICAgaWYgKEZwTGVnZW5kcmUoRnAsIG4pICE9PSAxKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAvLyBJbml0aWFsaXplIHZhcmlhYmxlcyBmb3IgdGhlIG1haW4gbG9vcFxuICAgICAgICBsZXQgTSA9IFM7XG4gICAgICAgIGxldCBjID0gRnAubXVsKEZwLk9ORSwgY2MpOyAvLyBjID0gel5RLCBtb3ZlIGNjIGZyb20gZmllbGQgX0ZwIGludG8gZmllbGQgRnBcbiAgICAgICAgbGV0IHQgPSBGcC5wb3cobiwgUSk7IC8vIHQgPSBuXlEsIGZpcnN0IGd1ZXNzIGF0IHRoZSBmdWRnZSBmYWN0b3JcbiAgICAgICAgbGV0IFIgPSBGcC5wb3cobiwgUTFkaXYyKTsgLy8gUiA9IG5eKChRKzEpLzIpLCBmaXJzdCBndWVzcyBhdCB0aGUgc3F1YXJlIHJvb3RcbiAgICAgICAgLy8gTWFpbiBsb29wXG4gICAgICAgIC8vIHdoaWxlIHQgIT0gMVxuICAgICAgICB3aGlsZSAoIUZwLmVxbCh0LCBGcC5PTkUpKSB7XG4gICAgICAgICAgICBpZiAoRnAuaXMwKHQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBGcC5aRVJPOyAvLyBpZiB0PTAgcmV0dXJuIFI9MFxuICAgICAgICAgICAgbGV0IGkgPSAxO1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgc21hbGxlc3QgaSA+PSAxIHN1Y2ggdGhhdCB0XigyXmkpIOKJoSAxIChtb2QgUClcbiAgICAgICAgICAgIGxldCB0X3RtcCA9IEZwLnNxcih0KTsgLy8gdF4oMl4xKVxuICAgICAgICAgICAgd2hpbGUgKCFGcC5lcWwodF90bXAsIEZwLk9ORSkpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgdF90bXAgPSBGcC5zcXIodF90bXApOyAvLyB0XigyXjIpLi4uXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IE0pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZXhwb25lbnQgZm9yIGI6IDJeKE0gLSBpIC0gMSlcbiAgICAgICAgICAgIGNvbnN0IGV4cG9uZW50ID0gXzFuIDw8IEJpZ0ludChNIC0gaSAtIDEpOyAvLyBiaWdpbnQgaXMgaW1wb3J0YW50XG4gICAgICAgICAgICBjb25zdCBiID0gRnAucG93KGMsIGV4cG9uZW50KTsgLy8gYiA9IDJeKE0gLSBpIC0gMSlcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB2YXJpYWJsZXNcbiAgICAgICAgICAgIE0gPSBpO1xuICAgICAgICAgICAgYyA9IEZwLnNxcihiKTsgLy8gYyA9IGJeMlxuICAgICAgICAgICAgdCA9IEZwLm11bCh0LCBjKTsgLy8gdCA9ICh0ICogYl4yKVxuICAgICAgICAgICAgUiA9IEZwLm11bChSLCBiKTsgLy8gUiA9IFIqYlxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBSO1xuICAgIH07XG59XG4vKipcbiAqIFNxdWFyZSByb290IGZvciBhIGZpbml0ZSBmaWVsZC4gV2lsbCB0cnkgb3B0aW1pemVkIHZlcnNpb25zIGZpcnN0OlxuICpcbiAqIDEuIFAg4omhIDMgKG1vZCA0KVxuICogMi4gUCDiiaEgNSAobW9kIDgpXG4gKiAzLiBQIOKJoSA5IChtb2QgMTYpXG4gKiA0LiBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG1cbiAqXG4gKiBEaWZmZXJlbnQgYWxnb3JpdGhtcyBjYW4gZ2l2ZSBkaWZmZXJlbnQgcm9vdHMsIGl0IGlzIHVwIHRvIHVzZXIgdG8gZGVjaWRlIHdoaWNoIG9uZSB0aGV5IHdhbnQuXG4gKiBGb3IgZXhhbXBsZSB0aGVyZSBpcyBGcFNxcnRPZGQvRnBTcXJ0RXZlbiB0byBjaG9pY2Ugcm9vdCBiYXNlZCBvbiBvZGRuZXNzICh1c2VkIGZvciBoYXNoLXRvLWN1cnZlKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydChQKSB7XG4gICAgLy8gUCDiiaEgMyAobW9kIDQpID0+IOKImm4gPSBuXigoUCsxKS80KVxuICAgIGlmIChQICUgXzRuID09PSBfM24pXG4gICAgICAgIHJldHVybiBzcXJ0M21vZDQ7XG4gICAgLy8gUCDiiaEgNSAobW9kIDgpID0+IEF0a2luIGFsZ29yaXRobSwgcGFnZSAxMCBvZiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGZcbiAgICBpZiAoUCAlIF84biA9PT0gXzVuKVxuICAgICAgICByZXR1cm4gc3FydDVtb2Q4O1xuICAgIC8vIFAg4omhIDkgKG1vZCAxNikgPT4gS29uZyBhbGdvcml0aG0sIHBhZ2UgMTEgb2YgaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChhbGdvcml0aG0gNClcbiAgICBpZiAoUCAlIF8xNm4gPT09IF85bilcbiAgICAgICAgcmV0dXJuIHNxcnQ5bW9kMTYoUCk7XG4gICAgLy8gVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtXG4gICAgcmV0dXJuIHRvbmVsbGlTaGFua3MoUCk7XG59XG4vLyBMaXR0bGUtZW5kaWFuIGNoZWNrIGZvciBmaXJzdCBMRSBiaXQgKGxhc3QgQkUgYml0KTtcbmV4cG9ydCBjb25zdCBpc05lZ2F0aXZlTEUgPSAobnVtLCBtb2R1bG8pID0+IChtb2QobnVtLCBtb2R1bG8pICYgXzFuKSA9PT0gXzFuO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBGSUVMRF9GSUVMRFMgPSBbXG4gICAgJ2NyZWF0ZScsICdpc1ZhbGlkJywgJ2lzMCcsICduZWcnLCAnaW52JywgJ3NxcnQnLCAnc3FyJyxcbiAgICAnZXFsJywgJ2FkZCcsICdzdWInLCAnbXVsJywgJ3BvdycsICdkaXYnLFxuICAgICdhZGROJywgJ3N1Yk4nLCAnbXVsTicsICdzcXJOJ1xuXTtcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUZpZWxkKGZpZWxkKSB7XG4gICAgY29uc3QgaW5pdGlhbCA9IHtcbiAgICAgICAgT1JERVI6ICdiaWdpbnQnLFxuICAgICAgICBNQVNLOiAnYmlnaW50JyxcbiAgICAgICAgQllURVM6ICdudW1iZXInLFxuICAgICAgICBCSVRTOiAnbnVtYmVyJyxcbiAgICB9O1xuICAgIGNvbnN0IG9wdHMgPSBGSUVMRF9GSUVMRFMucmVkdWNlKChtYXAsIHZhbCkgPT4ge1xuICAgICAgICBtYXBbdmFsXSA9ICdmdW5jdGlvbic7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfSwgaW5pdGlhbCk7XG4gICAgX3ZhbGlkYXRlT2JqZWN0KGZpZWxkLCBvcHRzKTtcbiAgICAvLyBjb25zdCBtYXggPSAxNjM4NDtcbiAgICAvLyBpZiAoZmllbGQuQllURVMgPCAxIHx8IGZpZWxkLkJZVEVTID4gbWF4KSB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmllbGQnKTtcbiAgICAvLyBpZiAoZmllbGQuQklUUyA8IDEgfHwgZmllbGQuQklUUyA+IDggKiBtYXgpIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBmaWVsZCcpO1xuICAgIHJldHVybiBmaWVsZDtcbn1cbi8vIEdlbmVyaWMgZmllbGQgZnVuY3Rpb25zXG4vKipcbiAqIFNhbWUgYXMgYHBvd2AgYnV0IGZvciBGcDogbm9uLWNvbnN0YW50LXRpbWUuXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcFBvdyhGcCwgbnVtLCBwb3dlcikge1xuICAgIGlmIChwb3dlciA8IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGV4cG9uZW50LCBuZWdhdGl2ZXMgdW5zdXBwb3J0ZWQnKTtcbiAgICBpZiAocG93ZXIgPT09IF8wbilcbiAgICAgICAgcmV0dXJuIEZwLk9ORTtcbiAgICBpZiAocG93ZXIgPT09IF8xbilcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICBsZXQgcCA9IEZwLk9ORTtcbiAgICBsZXQgZCA9IG51bTtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuICAgICAgICAgICAgcCA9IEZwLm11bChwLCBkKTtcbiAgICAgICAgZCA9IEZwLnNxcihkKTtcbiAgICAgICAgcG93ZXIgPj49IF8xbjtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IGludmVydCBhbiBhcnJheSBvZiBGaWVsZCBlbGVtZW50cy5cbiAqIEV4Y2VwdGlvbi1mcmVlLiBXaWxsIHJldHVybiBgdW5kZWZpbmVkYCBmb3IgMCBlbGVtZW50cy5cbiAqIEBwYXJhbSBwYXNzWmVybyBtYXAgMCB0byAwIChpbnN0ZWFkIG9mIHVuZGVmaW5lZClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwSW52ZXJ0QmF0Y2goRnAsIG51bXMsIHBhc3NaZXJvID0gZmFsc2UpIHtcbiAgICBjb25zdCBpbnZlcnRlZCA9IG5ldyBBcnJheShudW1zLmxlbmd0aCkuZmlsbChwYXNzWmVybyA/IEZwLlpFUk8gOiB1bmRlZmluZWQpO1xuICAgIC8vIFdhbGsgZnJvbSBmaXJzdCB0byBsYXN0LCBtdWx0aXBseSB0aGVtIGJ5IGVhY2ggb3RoZXIgTU9EIHBcbiAgICBjb25zdCBtdWx0aXBsaWVkQWNjID0gbnVtcy5yZWR1Y2UoKGFjYywgbnVtLCBpKSA9PiB7XG4gICAgICAgIGlmIChGcC5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIGludmVydGVkW2ldID0gYWNjO1xuICAgICAgICByZXR1cm4gRnAubXVsKGFjYywgbnVtKTtcbiAgICB9LCBGcC5PTkUpO1xuICAgIC8vIEludmVydCBsYXN0IGVsZW1lbnRcbiAgICBjb25zdCBpbnZlcnRlZEFjYyA9IEZwLmludihtdWx0aXBsaWVkQWNjKTtcbiAgICAvLyBXYWxrIGZyb20gbGFzdCB0byBmaXJzdCwgbXVsdGlwbHkgdGhlbSBieSBpbnZlcnRlZCBlYWNoIG90aGVyIE1PRCBwXG4gICAgbnVtcy5yZWR1Y2VSaWdodCgoYWNjLCBudW0sIGkpID0+IHtcbiAgICAgICAgaWYgKEZwLmlzMChudW0pKVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgaW52ZXJ0ZWRbaV0gPSBGcC5tdWwoYWNjLCBpbnZlcnRlZFtpXSk7XG4gICAgICAgIHJldHVybiBGcC5tdWwoYWNjLCBudW0pO1xuICAgIH0sIGludmVydGVkQWNjKTtcbiAgICByZXR1cm4gaW52ZXJ0ZWQ7XG59XG4vLyBUT0RPOiByZW1vdmVcbmV4cG9ydCBmdW5jdGlvbiBGcERpdihGcCwgbGhzLCByaHMpIHtcbiAgICByZXR1cm4gRnAubXVsKGxocywgdHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcgPyBpbnZlcnQocmhzLCBGcC5PUkRFUikgOiBGcC5pbnYocmhzKSk7XG59XG4vKipcbiAqIExlZ2VuZHJlIHN5bWJvbC5cbiAqIExlZ2VuZHJlIGNvbnN0YW50IGlzIHVzZWQgdG8gY2FsY3VsYXRlIExlZ2VuZHJlIHN5bWJvbCAoYSB8IHApXG4gKiB3aGljaCBkZW5vdGVzIHRoZSB2YWx1ZSBvZiBhXigocC0xKS8yKSAobW9kIHApLlxuICpcbiAqICogKGEgfCBwKSDiiaEgMSAgICBpZiBhIGlzIGEgc3F1YXJlIChtb2QgcCksIHF1YWRyYXRpYyByZXNpZHVlXG4gKiAqIChhIHwgcCkg4omhIC0xICAgaWYgYSBpcyBub3QgYSBzcXVhcmUgKG1vZCBwKSwgcXVhZHJhdGljIG5vbiByZXNpZHVlXG4gKiAqIChhIHwgcCkg4omhIDAgICAgaWYgYSDiiaEgMCAobW9kIHApXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcExlZ2VuZHJlKEZwLCBuKSB7XG4gICAgLy8gV2UgY2FuIHVzZSAzcmQgYXJndW1lbnQgYXMgb3B0aW9uYWwgY2FjaGUgb2YgdGhpcyB2YWx1ZVxuICAgIC8vIGJ1dCBzZWVtcyB1bm5lZWRlZCBmb3Igbm93LiBUaGUgb3BlcmF0aW9uIGlzIHZlcnkgZmFzdC5cbiAgICBjb25zdCBwMW1vZDIgPSAoRnAuT1JERVIgLSBfMW4pIC8gXzJuO1xuICAgIGNvbnN0IHBvd2VyZWQgPSBGcC5wb3cobiwgcDFtb2QyKTtcbiAgICBjb25zdCB5ZXMgPSBGcC5lcWwocG93ZXJlZCwgRnAuT05FKTtcbiAgICBjb25zdCB6ZXJvID0gRnAuZXFsKHBvd2VyZWQsIEZwLlpFUk8pO1xuICAgIGNvbnN0IG5vID0gRnAuZXFsKHBvd2VyZWQsIEZwLm5lZyhGcC5PTkUpKTtcbiAgICBpZiAoIXllcyAmJiAhemVybyAmJiAhbm8pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBMZWdlbmRyZSBzeW1ib2wgcmVzdWx0Jyk7XG4gICAgcmV0dXJuIHllcyA/IDEgOiB6ZXJvID8gMCA6IC0xO1xufVxuLy8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIFRydWUgd2hlbmV2ZXIgdGhlIHZhbHVlIHggaXMgYSBzcXVhcmUgaW4gdGhlIGZpZWxkIEYuXG5leHBvcnQgZnVuY3Rpb24gRnBJc1NxdWFyZShGcCwgbikge1xuICAgIGNvbnN0IGwgPSBGcExlZ2VuZHJlKEZwLCBuKTtcbiAgICByZXR1cm4gbCA9PT0gMTtcbn1cbi8vIENVUlZFLm4gbGVuZ3Roc1xuZXhwb3J0IGZ1bmN0aW9uIG5MZW5ndGgobiwgbkJpdExlbmd0aCkge1xuICAgIC8vIEJpdCBzaXplLCBieXRlIHNpemUgb2YgQ1VSVkUublxuICAgIGlmIChuQml0TGVuZ3RoICE9PSB1bmRlZmluZWQpXG4gICAgICAgIGFudW1iZXIobkJpdExlbmd0aCk7XG4gICAgY29uc3QgX25CaXRMZW5ndGggPSBuQml0TGVuZ3RoICE9PSB1bmRlZmluZWQgPyBuQml0TGVuZ3RoIDogbi50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgY29uc3QgbkJ5dGVMZW5ndGggPSBNYXRoLmNlaWwoX25CaXRMZW5ndGggLyA4KTtcbiAgICByZXR1cm4geyBuQml0TGVuZ3RoOiBfbkJpdExlbmd0aCwgbkJ5dGVMZW5ndGggfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGZpbml0ZSBmaWVsZC4gTWFqb3IgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uczpcbiAqICogMS4gRGVub3JtYWxpemVkIG9wZXJhdGlvbnMgbGlrZSBtdWxOIGluc3RlYWQgb2YgbXVsLlxuICogKiAyLiBJZGVudGljYWwgb2JqZWN0IHNoYXBlOiBuZXZlciBhZGQgb3IgcmVtb3ZlIGtleXMuXG4gKiAqIDMuIGBPYmplY3QuZnJlZXplYC5cbiAqIEZyYWdpbGU6IGFsd2F5cyBydW4gYSBiZW5jaG1hcmsgb24gYSBjaGFuZ2UuXG4gKiBTZWN1cml0eSBub3RlOiBvcGVyYXRpb25zIGRvbid0IGNoZWNrICdpc1ZhbGlkJyBmb3IgYWxsIGVsZW1lbnRzIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLFxuICogaXQgaXMgY2FsbGVyIHJlc3BvbnNpYmlsaXR5IHRvIGNoZWNrIHRoaXMuXG4gKiBUaGlzIGlzIGxvdy1sZXZlbCBjb2RlLCBwbGVhc2UgbWFrZSBzdXJlIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nLlxuICpcbiAqIE5vdGUgYWJvdXQgZmllbGQgcHJvcGVydGllczpcbiAqICogQ0hBUkFDVEVSSVNUSUMgcCA9IHByaW1lIG51bWJlciwgbnVtYmVyIG9mIGVsZW1lbnRzIGluIG1haW4gc3ViZ3JvdXAuXG4gKiAqIE9SREVSIHEgPSBzaW1pbGFyIHRvIGNvZmFjdG9yIGluIGN1cnZlcywgbWF5IGJlIGNvbXBvc2l0ZSBgcSA9IHBebWAuXG4gKlxuICogQHBhcmFtIE9SREVSIGZpZWxkIG9yZGVyLCBwcm9iYWJseSBwcmltZSwgb3IgY291bGQgYmUgY29tcG9zaXRlXG4gKiBAcGFyYW0gYml0TGVuIGhvdyBtYW55IGJpdHMgdGhlIGZpZWxkIGNvbnN1bWVzXG4gKiBAcGFyYW0gaXNMRSAoZGVmYXVsdDogZmFsc2UpIGlmIGVuY29kaW5nIC8gZGVjb2Rpbmcgc2hvdWxkIGJlIGluIGxpdHRsZS1lbmRpYW5cbiAqIEBwYXJhbSByZWRlZiBvcHRpb25hbCBmYXN0ZXIgcmVkZWZpbml0aW9ucyBvZiBzcXJ0IGFuZCBvdGhlciBtZXRob2RzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGaWVsZChPUkRFUiwgYml0TGVuT3JPcHRzLCAvLyBUT0RPOiB1c2Ugb3B0cyBvbmx5IGluIHYyP1xuaXNMRSA9IGZhbHNlLCBvcHRzID0ge30pIHtcbiAgICBpZiAoT1JERVIgPD0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmllbGQ6IGV4cGVjdGVkIE9SREVSID4gMCwgZ290ICcgKyBPUkRFUik7XG4gICAgbGV0IF9uYml0TGVuZ3RoID0gdW5kZWZpbmVkO1xuICAgIGxldCBfc3FydCA9IHVuZGVmaW5lZDtcbiAgICBsZXQgbW9kRnJvbUJ5dGVzID0gZmFsc2U7XG4gICAgbGV0IGFsbG93ZWRMZW5ndGhzID0gdW5kZWZpbmVkO1xuICAgIGlmICh0eXBlb2YgYml0TGVuT3JPcHRzID09PSAnb2JqZWN0JyAmJiBiaXRMZW5Pck9wdHMgIT0gbnVsbCkge1xuICAgICAgICBpZiAob3B0cy5zcXJ0IHx8IGlzTEUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBzcGVjaWZ5IG9wdHMgaW4gdHdvIGFyZ3VtZW50cycpO1xuICAgICAgICBjb25zdCBfb3B0cyA9IGJpdExlbk9yT3B0cztcbiAgICAgICAgaWYgKF9vcHRzLkJJVFMpXG4gICAgICAgICAgICBfbmJpdExlbmd0aCA9IF9vcHRzLkJJVFM7XG4gICAgICAgIGlmIChfb3B0cy5zcXJ0KVxuICAgICAgICAgICAgX3NxcnQgPSBfb3B0cy5zcXJ0O1xuICAgICAgICBpZiAodHlwZW9mIF9vcHRzLmlzTEUgPT09ICdib29sZWFuJylcbiAgICAgICAgICAgIGlzTEUgPSBfb3B0cy5pc0xFO1xuICAgICAgICBpZiAodHlwZW9mIF9vcHRzLm1vZEZyb21CeXRlcyA9PT0gJ2Jvb2xlYW4nKVxuICAgICAgICAgICAgbW9kRnJvbUJ5dGVzID0gX29wdHMubW9kRnJvbUJ5dGVzO1xuICAgICAgICBhbGxvd2VkTGVuZ3RocyA9IF9vcHRzLmFsbG93ZWRMZW5ndGhzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiaXRMZW5Pck9wdHMgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgX25iaXRMZW5ndGggPSBiaXRMZW5Pck9wdHM7XG4gICAgICAgIGlmIChvcHRzLnNxcnQpXG4gICAgICAgICAgICBfc3FydCA9IG9wdHMuc3FydDtcbiAgICB9XG4gICAgY29uc3QgeyBuQml0TGVuZ3RoOiBCSVRTLCBuQnl0ZUxlbmd0aDogQllURVMgfSA9IG5MZW5ndGgoT1JERVIsIF9uYml0TGVuZ3RoKTtcbiAgICBpZiAoQllURVMgPiAyMDQ4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZmllbGQ6IGV4cGVjdGVkIE9SREVSIG9mIDw9IDIwNDggYnl0ZXMnKTtcbiAgICBsZXQgc3FydFA7IC8vIGNhY2hlZCBzcXJ0UFxuICAgIGNvbnN0IGYgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgT1JERVIsXG4gICAgICAgIGlzTEUsXG4gICAgICAgIEJJVFMsXG4gICAgICAgIEJZVEVTLFxuICAgICAgICBNQVNLOiBiaXRNYXNrKEJJVFMpLFxuICAgICAgICBaRVJPOiBfMG4sXG4gICAgICAgIE9ORTogXzFuLFxuICAgICAgICBhbGxvd2VkTGVuZ3RoczogYWxsb3dlZExlbmd0aHMsXG4gICAgICAgIGNyZWF0ZTogKG51bSkgPT4gbW9kKG51bSwgT1JERVIpLFxuICAgICAgICBpc1ZhbGlkOiAobnVtKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGZpZWxkIGVsZW1lbnQ6IGV4cGVjdGVkIGJpZ2ludCwgZ290ICcgKyB0eXBlb2YgbnVtKTtcbiAgICAgICAgICAgIHJldHVybiBfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSOyAvLyAwIGlzIHZhbGlkIGVsZW1lbnQsIGJ1dCBpdCdzIG5vdCBpbnZlcnRpYmxlXG4gICAgICAgIH0sXG4gICAgICAgIGlzMDogKG51bSkgPT4gbnVtID09PSBfMG4sXG4gICAgICAgIC8vIGlzIHZhbGlkIGFuZCBpbnZlcnRpYmxlXG4gICAgICAgIGlzVmFsaWROb3QwOiAobnVtKSA9PiAhZi5pczAobnVtKSAmJiBmLmlzVmFsaWQobnVtKSxcbiAgICAgICAgaXNPZGQ6IChudW0pID0+IChudW0gJiBfMW4pID09PSBfMW4sXG4gICAgICAgIG5lZzogKG51bSkgPT4gbW9kKC1udW0sIE9SREVSKSxcbiAgICAgICAgZXFsOiAobGhzLCByaHMpID0+IGxocyA9PT0gcmhzLFxuICAgICAgICBzcXI6IChudW0pID0+IG1vZChudW0gKiBudW0sIE9SREVSKSxcbiAgICAgICAgYWRkOiAobGhzLCByaHMpID0+IG1vZChsaHMgKyByaHMsIE9SREVSKSxcbiAgICAgICAgc3ViOiAobGhzLCByaHMpID0+IG1vZChsaHMgLSByaHMsIE9SREVSKSxcbiAgICAgICAgbXVsOiAobGhzLCByaHMpID0+IG1vZChsaHMgKiByaHMsIE9SREVSKSxcbiAgICAgICAgcG93OiAobnVtLCBwb3dlcikgPT4gRnBQb3coZiwgbnVtLCBwb3dlciksXG4gICAgICAgIGRpdjogKGxocywgcmhzKSA9PiBtb2QobGhzICogaW52ZXJ0KHJocywgT1JERVIpLCBPUkRFUiksXG4gICAgICAgIC8vIFNhbWUgYXMgYWJvdmUsIGJ1dCBkb2Vzbid0IG5vcm1hbGl6ZVxuICAgICAgICBzcXJOOiAobnVtKSA9PiBudW0gKiBudW0sXG4gICAgICAgIGFkZE46IChsaHMsIHJocykgPT4gbGhzICsgcmhzLFxuICAgICAgICBzdWJOOiAobGhzLCByaHMpID0+IGxocyAtIHJocyxcbiAgICAgICAgbXVsTjogKGxocywgcmhzKSA9PiBsaHMgKiByaHMsXG4gICAgICAgIGludjogKG51bSkgPT4gaW52ZXJ0KG51bSwgT1JERVIpLFxuICAgICAgICBzcXJ0OiBfc3FydCB8fFxuICAgICAgICAgICAgKChuKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFzcXJ0UClcbiAgICAgICAgICAgICAgICAgICAgc3FydFAgPSBGcFNxcnQoT1JERVIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzcXJ0UChmLCBuKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB0b0J5dGVzOiAobnVtKSA9PiAoaXNMRSA/IG51bWJlclRvQnl0ZXNMRShudW0sIEJZVEVTKSA6IG51bWJlclRvQnl0ZXNCRShudW0sIEJZVEVTKSksXG4gICAgICAgIGZyb21CeXRlczogKGJ5dGVzLCBza2lwVmFsaWRhdGlvbiA9IHRydWUpID0+IHtcbiAgICAgICAgICAgIGlmIChhbGxvd2VkTGVuZ3Rocykge1xuICAgICAgICAgICAgICAgIGlmICghYWxsb3dlZExlbmd0aHMuaW5jbHVkZXMoYnl0ZXMubGVuZ3RoKSB8fCBieXRlcy5sZW5ndGggPiBCWVRFUykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpZWxkLmZyb21CeXRlczogZXhwZWN0ZWQgJyArIGFsbG93ZWRMZW5ndGhzICsgJyBieXRlcywgZ290ICcgKyBieXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwYWRkZWQgPSBuZXcgVWludDhBcnJheShCWVRFUyk7XG4gICAgICAgICAgICAgICAgLy8gaXNMRSBhZGQgMCB0byByaWdodCwgIWlzTEUgdG8gdGhlIGxlZnQuXG4gICAgICAgICAgICAgICAgcGFkZGVkLnNldChieXRlcywgaXNMRSA/IDAgOiBwYWRkZWQubGVuZ3RoIC0gYnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBieXRlcyA9IHBhZGRlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IEJZVEVTKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmllbGQuZnJvbUJ5dGVzOiBleHBlY3RlZCAnICsgQllURVMgKyAnIGJ5dGVzLCBnb3QgJyArIGJ5dGVzLmxlbmd0aCk7XG4gICAgICAgICAgICBsZXQgc2NhbGFyID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShieXRlcykgOiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpO1xuICAgICAgICAgICAgaWYgKG1vZEZyb21CeXRlcylcbiAgICAgICAgICAgICAgICBzY2FsYXIgPSBtb2Qoc2NhbGFyLCBPUkRFUik7XG4gICAgICAgICAgICBpZiAoIXNraXBWYWxpZGF0aW9uKVxuICAgICAgICAgICAgICAgIGlmICghZi5pc1ZhbGlkKHNjYWxhcikpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBmaWVsZCBlbGVtZW50OiBvdXRzaWRlIG9mIHJhbmdlIDAuLk9SREVSJyk7XG4gICAgICAgICAgICAvLyBOT1RFOiB3ZSBkb24ndCB2YWxpZGF0ZSBzY2FsYXIgaGVyZSwgcGxlYXNlIHVzZSBpc1ZhbGlkLiBUaGlzIGRvbmUgc3VjaCB3YXkgYmVjYXVzZSBzb21lXG4gICAgICAgICAgICAvLyBwcm90b2NvbCBtYXkgYWxsb3cgbm9uLXJlZHVjZWQgc2NhbGFyIHRoYXQgcmVkdWNlZCBsYXRlciBvciBjaGFuZ2VkIHNvbWUgb3RoZXIgd2F5LlxuICAgICAgICAgICAgcmV0dXJuIHNjYWxhcjtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gVE9ETzogd2UgZG9uJ3QgbmVlZCBpdCBoZXJlLCBtb3ZlIG91dCB0byBzZXBhcmF0ZSBmblxuICAgICAgICBpbnZlcnRCYXRjaDogKGxzdCkgPT4gRnBJbnZlcnRCYXRjaChmLCBsc3QpLFxuICAgICAgICAvLyBXZSBjYW4ndCBtb3ZlIHRoaXMgb3V0IGJlY2F1c2UgRnA2LCBGcDEyIGltcGxlbWVudCBpdFxuICAgICAgICAvLyBhbmQgaXQncyB1bmNsZWFyIHdoYXQgdG8gcmV0dXJuIGluIHRoZXJlLlxuICAgICAgICBjbW92OiAoYSwgYiwgYykgPT4gKGMgPyBiIDogYSksXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoZik7XG59XG4vLyBHZW5lcmljIHJhbmRvbSBzY2FsYXIsIHdlIGNhbiBkbyBzYW1lIGZvciBvdGhlciBmaWVsZHMgaWYgdmlhIEZwMi5tdWwoRnAyLk9ORSwgRnAyLnJhbmRvbSk/XG4vLyBUaGlzIGFsbG93cyB1bnNhZmUgbWV0aG9kcyBsaWtlIGlnbm9yZSBiaWFzIG9yIHplcm8uIFRoZXNlIHVuc2FmZSwgYnV0IG9mdGVuIHVzZWQgaW4gZGlmZmVyZW50IHByb3RvY29scyAoaWYgZGV0ZXJtaW5pc3RpYyBSTkcpLlxuLy8gd2hpY2ggbWVhbiB3ZSBjYW5ub3QgZm9yY2UgdGhpcyB2aWEgb3B0cy5cbi8vIE5vdCBzdXJlIHdoYXQgdG8gZG8gd2l0aCByYW5kb21CeXRlcywgd2UgY2FuIGFjY2VwdCBpdCBpbnNpZGUgb3B0cyBpZiB3YW50ZWQuXG4vLyBQcm9iYWJseSBuZWVkIHRvIGV4cG9ydCBnZXRNaW5IYXNoTGVuZ3RoIHNvbWV3aGVyZT9cbi8vIHJhbmRvbShieXRlcz86IFVpbnQ4QXJyYXksIHVuc2FmZUFsbG93WmVybyA9IGZhbHNlLCB1bnNhZmVBbGxvd0JpYXMgPSBmYWxzZSkge1xuLy8gICBjb25zdCBMRU4gPSAhdW5zYWZlQWxsb3dCaWFzID8gZ2V0TWluSGFzaExlbmd0aChPUkRFUikgOiBCWVRFUztcbi8vICAgaWYgKGJ5dGVzID09PSB1bmRlZmluZWQpIGJ5dGVzID0gcmFuZG9tQnl0ZXMoTEVOKTsgLy8gX29wdHMucmFuZG9tQnl0ZXM/XG4vLyAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoYnl0ZXMpIDogYnl0ZXNUb051bWJlckJFKGJ5dGVzKTtcbi8vICAgLy8gYG1vZCh4LCAxMSlgIGNhbiBzb21ldGltZXMgcHJvZHVjZSAwLiBgbW9kKHgsIDEwKSArIDFgIGlzIHRoZSBzYW1lLCBidXQgbm8gMFxuLy8gICBjb25zdCByZWR1Y2VkID0gdW5zYWZlQWxsb3daZXJvID8gbW9kKG51bSwgT1JERVIpIDogbW9kKG51bSwgT1JERVIgLSBfMW4pICsgXzFuO1xuLy8gICByZXR1cm4gcmVkdWNlZDtcbi8vIH0sXG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0T2RkKEZwLCBlbG0pIHtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IGhhdmUgaXNPZGRcIik7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyByb290IDogRnAubmVnKHJvb3QpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydEV2ZW4oRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZFwiKTtcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IEZwLm5lZyhyb290KSA6IHJvb3Q7XG59XG4vKipcbiAqIFwiQ29uc3RhbnQtdGltZVwiIHByaXZhdGUga2V5IGdlbmVyYXRpb24gdXRpbGl0eS5cbiAqIFNhbWUgYXMgbWFwS2V5VG9GaWVsZCwgYnV0IGFjY2VwdHMgbGVzcyBieXRlcyAoNDAgaW5zdGVhZCBvZiA0OCBmb3IgMzItYnl0ZSBmaWVsZCkuXG4gKiBXaGljaCBtYWtlcyBpdCBzbGlnaHRseSBtb3JlIGJpYXNlZCwgbGVzcyBzZWN1cmUuXG4gKiBAZGVwcmVjYXRlZCB1c2UgYG1hcEtleVRvRmllbGRgIGluc3RlYWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hUb1ByaXZhdGVTY2FsYXIoaGFzaCwgZ3JvdXBPcmRlciwgaXNMRSA9IGZhbHNlKSB7XG4gICAgaGFzaCA9IGVuc3VyZUJ5dGVzKCdwcml2YXRlSGFzaCcsIGhhc2gpO1xuICAgIGNvbnN0IGhhc2hMZW4gPSBoYXNoLmxlbmd0aDtcbiAgICBjb25zdCBtaW5MZW4gPSBuTGVuZ3RoKGdyb3VwT3JkZXIpLm5CeXRlTGVuZ3RoICsgODtcbiAgICBpZiAobWluTGVuIDwgMjQgfHwgaGFzaExlbiA8IG1pbkxlbiB8fCBoYXNoTGVuID4gMTAyNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoVG9Qcml2YXRlU2NhbGFyOiBleHBlY3RlZCAnICsgbWluTGVuICsgJy0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJyArIGhhc2hMZW4pO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoaGFzaCkgOiBieXRlc1RvTnVtYmVyQkUoaGFzaCk7XG4gICAgcmV0dXJuIG1vZChudW0sIGdyb3VwT3JkZXIgLSBfMW4pICsgXzFuO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRvdGFsIG51bWJlciBvZiBieXRlcyBjb25zdW1lZCBieSB0aGUgZmllbGQgZWxlbWVudC5cbiAqIEZvciBleGFtcGxlLCAzMiBieXRlcyBmb3IgdXN1YWwgMjU2LWJpdCB3ZWllcnN0cmFzcyBjdXJ2ZS5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiBmaWVsZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKSB7XG4gICAgaWYgKHR5cGVvZiBmaWVsZE9yZGVyICE9PSAnYmlnaW50JylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWVsZCBvcmRlciBtdXN0IGJlIGJpZ2ludCcpO1xuICAgIGNvbnN0IGJpdExlbmd0aCA9IGZpZWxkT3JkZXIudG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIHJldHVybiBNYXRoLmNlaWwoYml0TGVuZ3RoIC8gOCk7XG59XG4vKipcbiAqIFJldHVybnMgbWluaW1hbCBhbW91bnQgb2YgYnl0ZXMgdGhhdCBjYW4gYmUgc2FmZWx5IHJlZHVjZWRcbiAqIGJ5IGZpZWxkIG9yZGVyLlxuICogU2hvdWxkIGJlIDJeLTEyOCBmb3IgMTI4LWJpdCBjdXJ2ZSBzdWNoIGFzIFAyNTYuXG4gKiBAcGFyYW0gZmllbGRPcmRlciBudW1iZXIgb2YgZmllbGQgZWxlbWVudHMsIHVzdWFsbHkgQ1VSVkUublxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgdGFyZ2V0IGhhc2hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcikge1xuICAgIGNvbnN0IGxlbmd0aCA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgcmV0dXJuIGxlbmd0aCArIE1hdGguY2VpbChsZW5ndGggLyAyKTtcbn1cbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogQ2FuIHRha2UgKG4gKyBuLzIpIG9yIG1vcmUgYnl0ZXMgb2YgdW5pZm9ybSBpbnB1dCBlLmcuIGZyb20gQ1NQUk5HIG9yIEtERlxuICogYW5kIGNvbnZlcnQgdGhlbSBpbnRvIHByaXZhdGUgc2NhbGFyLCB3aXRoIHRoZSBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICogTmVlZHMgYXQgbGVhc3QgNDggYnl0ZXMgb2YgaW5wdXQgZm9yIDMyLWJ5dGUgcHJpdmF0ZSBrZXkuXG4gKiBodHRwczovL3Jlc2VhcmNoLmt1ZGVsc2tpc2VjdXJpdHkuY29tLzIwMjAvMDcvMjgvdGhlLWRlZmluaXRpdmUtZ3VpZGUtdG8tbW9kdWxvLWJpYXMtYW5kLWhvdy10by1hdm9pZC1pdC9cbiAqIEZJUFMgMTg2LTUsIEEuMiBodHRwczovL2NzcmMubmlzdC5nb3YvcHVibGljYXRpb25zL2RldGFpbC9maXBzLzE4Ni81L2ZpbmFsXG4gKiBSRkMgOTM4MCwgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01XG4gKiBAcGFyYW0gaGFzaCBoYXNoIG91dHB1dCBmcm9tIFNIQTMgb3IgYSBzaW1pbGFyIGZ1bmN0aW9uXG4gKiBAcGFyYW0gZ3JvdXBPcmRlciBzaXplIG9mIHN1Ymdyb3VwIC0gKGUuZy4gc2VjcDI1NmsxLkNVUlZFLm4pXG4gKiBAcGFyYW0gaXNMRSBpbnRlcnByZXQgaGFzaCBieXRlcyBhcyBMRSBudW1cbiAqIEByZXR1cm5zIHZhbGlkIHByaXZhdGUgc2NhbGFyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBIYXNoVG9GaWVsZChrZXksIGZpZWxkT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuICAgIGNvbnN0IGxlbiA9IGtleS5sZW5ndGg7XG4gICAgY29uc3QgZmllbGRMZW4gPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIGNvbnN0IG1pbkxlbiA9IGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgLy8gTm8gc21hbGwgbnVtYmVyczogbmVlZCB0byB1bmRlcnN0YW5kIGJpYXMgc3RvcnkuIE5vIGh1Z2UgbnVtYmVyczogZWFzaWVyIHRvIGRldGVjdCBKUyB0aW1pbmdzLlxuICAgIGlmIChsZW4gPCAxNiB8fCBsZW4gPCBtaW5MZW4gfHwgbGVuID4gMTAyNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCAnICsgbWluTGVuICsgJy0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJyArIGxlbik7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShrZXkpIDogYnl0ZXNUb051bWJlckJFKGtleSk7XG4gICAgLy8gYG1vZCh4LCAxMSlgIGNhbiBzb21ldGltZXMgcHJvZHVjZSAwLiBgbW9kKHgsIDEwKSArIDFgIGlzIHRoZSBzYW1lLCBidXQgbm8gMFxuICAgIGNvbnN0IHJlZHVjZWQgPSBtb2QobnVtLCBmaWVsZE9yZGVyIC0gXzFuKSArIF8xbjtcbiAgICByZXR1cm4gaXNMRSA/IG51bWJlclRvQnl0ZXNMRShyZWR1Y2VkLCBmaWVsZExlbikgOiBudW1iZXJUb0J5dGVzQkUocmVkdWNlZCwgZmllbGRMZW4pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxhci5qcy5tYXAiXSwibmFtZXMiOlsiX3ZhbGlkYXRlT2JqZWN0IiwiYW51bWJlciIsImJpdE1hc2siLCJieXRlc1RvTnVtYmVyQkUiLCJieXRlc1RvTnVtYmVyTEUiLCJlbnN1cmVCeXRlcyIsIm51bWJlclRvQnl0ZXNCRSIsIm51bWJlclRvQnl0ZXNMRSIsIl8wbiIsIkJpZ0ludCIsIl8xbiIsIl8ybiIsIl8zbiIsIl80biIsIl81biIsIl83biIsIl84biIsIl85biIsIl8xNm4iLCJtb2QiLCJhIiwiYiIsInJlc3VsdCIsInBvdyIsIm51bSIsInBvd2VyIiwibW9kdWxvIiwiRnBQb3ciLCJGaWVsZCIsInBvdzIiLCJ4IiwicmVzIiwiaW52ZXJ0IiwibnVtYmVyIiwiRXJyb3IiLCJ5IiwidSIsInYiLCJxIiwiciIsIm0iLCJuIiwiZ2NkIiwiYXNzZXJ0SXNTcXVhcmUiLCJGcCIsInJvb3QiLCJlcWwiLCJzcXIiLCJzcXJ0M21vZDQiLCJwMWRpdjQiLCJPUkRFUiIsInNxcnQ1bW9kOCIsInA1ZGl2OCIsIm4yIiwibXVsIiwibnYiLCJpIiwic3ViIiwiT05FIiwic3FydDltb2QxNiIsIlAiLCJGcF8iLCJ0biIsInRvbmVsbGlTaGFua3MiLCJjMSIsIm5lZyIsImMyIiwiYzMiLCJjNCIsInR2MSIsInR2MiIsInR2MyIsInR2NCIsImUxIiwiZTIiLCJjbW92IiwiZTMiLCJRIiwiUyIsIloiLCJfRnAiLCJGcExlZ2VuZHJlIiwiY2MiLCJRMWRpdjIiLCJ0b25lbGxpU2xvdyIsImlzMCIsIk0iLCJjIiwidCIsIlIiLCJaRVJPIiwidF90bXAiLCJleHBvbmVudCIsIkZwU3FydCIsImlzTmVnYXRpdmVMRSIsIkZJRUxEX0ZJRUxEUyIsInZhbGlkYXRlRmllbGQiLCJmaWVsZCIsImluaXRpYWwiLCJNQVNLIiwiQllURVMiLCJCSVRTIiwib3B0cyIsInJlZHVjZSIsIm1hcCIsInZhbCIsInAiLCJkIiwiRnBJbnZlcnRCYXRjaCIsIm51bXMiLCJwYXNzWmVybyIsImludmVydGVkIiwiQXJyYXkiLCJsZW5ndGgiLCJmaWxsIiwidW5kZWZpbmVkIiwibXVsdGlwbGllZEFjYyIsImFjYyIsImludmVydGVkQWNjIiwiaW52IiwicmVkdWNlUmlnaHQiLCJGcERpdiIsImxocyIsInJocyIsInAxbW9kMiIsInBvd2VyZWQiLCJ5ZXMiLCJ6ZXJvIiwibm8iLCJGcElzU3F1YXJlIiwibCIsIm5MZW5ndGgiLCJuQml0TGVuZ3RoIiwiX25CaXRMZW5ndGgiLCJ0b1N0cmluZyIsIm5CeXRlTGVuZ3RoIiwiTWF0aCIsImNlaWwiLCJiaXRMZW5Pck9wdHMiLCJpc0xFIiwiX25iaXRMZW5ndGgiLCJfc3FydCIsIm1vZEZyb21CeXRlcyIsImFsbG93ZWRMZW5ndGhzIiwic3FydCIsIl9vcHRzIiwic3FydFAiLCJmIiwiT2JqZWN0IiwiZnJlZXplIiwiY3JlYXRlIiwiaXNWYWxpZCIsImlzVmFsaWROb3QwIiwiaXNPZGQiLCJhZGQiLCJkaXYiLCJzcXJOIiwiYWRkTiIsInN1Yk4iLCJtdWxOIiwidG9CeXRlcyIsImZyb21CeXRlcyIsImJ5dGVzIiwic2tpcFZhbGlkYXRpb24iLCJpbmNsdWRlcyIsInBhZGRlZCIsIlVpbnQ4QXJyYXkiLCJzZXQiLCJzY2FsYXIiLCJpbnZlcnRCYXRjaCIsImxzdCIsIkZwU3FydE9kZCIsImVsbSIsIkZwU3FydEV2ZW4iLCJoYXNoVG9Qcml2YXRlU2NhbGFyIiwiaGFzaCIsImdyb3VwT3JkZXIiLCJoYXNoTGVuIiwibWluTGVuIiwiZ2V0RmllbGRCeXRlc0xlbmd0aCIsImZpZWxkT3JkZXIiLCJiaXRMZW5ndGgiLCJnZXRNaW5IYXNoTGVuZ3RoIiwibWFwSGFzaFRvRmllbGQiLCJrZXkiLCJsZW4iLCJmaWVsZExlbiIsInJlZHVjZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/modular.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/montgomery.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/montgomery.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   montgomery: () => (/* binding */ montgomery)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/utils.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/modular.js\");\n/**\n * Montgomery curve methods. It's not really whole montgomery curve,\n * just bunch of very specific methods for X25519 / X448 from\n * [RFC 7748](https://www.rfc-editor.org/rfc/rfc7748)\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nfunction validateOpts(curve) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._validateObject)(curve, {\n        adjustScalarBytes: \"function\",\n        powPminus2: \"function\"\n    });\n    return Object.freeze({\n        ...curve\n    });\n}\nfunction montgomery(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { P, type, adjustScalarBytes, powPminus2, randomBytes: rand } = CURVE;\n    const is25519 = type === \"x25519\";\n    if (!is25519 && type !== \"x448\") throw new Error(\"invalid type\");\n    const randomBytes_ = rand || _utils_js__WEBPACK_IMPORTED_MODULE_1__.randomBytes;\n    const montgomeryBits = is25519 ? 255 : 448;\n    const fieldLen = is25519 ? 32 : 56;\n    const Gu = is25519 ? BigInt(9) : BigInt(5);\n    // RFC 7748 #5:\n    // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519 and\n    // (156326 - 2) / 4 = 39081 for curve448/X448\n    // const a = is25519 ? 156326n : 486662n;\n    const a24 = is25519 ? BigInt(121665) : BigInt(39081);\n    // RFC: x25519 \"the resulting integer is of the form 2^254 plus\n    // eight times a value between 0 and 2^251 - 1 (inclusive)\"\n    // x448: \"2^447 plus four times a value between 0 and 2^445 - 1 (inclusive)\"\n    const minScalar = is25519 ? _2n ** BigInt(254) : _2n ** BigInt(447);\n    const maxAdded = is25519 ? BigInt(8) * _2n ** BigInt(251) - _1n : BigInt(4) * _2n ** BigInt(445) - _1n;\n    const maxScalar = minScalar + maxAdded + _1n; // (inclusive)\n    const modP = (n)=>(0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(n, P);\n    const GuBytes = encodeU(Gu);\n    function encodeU(u) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(modP(u), fieldLen);\n    }\n    function decodeU(u) {\n        const _u = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"u coordinate\", u, fieldLen);\n        // RFC: When receiving such an array, implementations of X25519\n        // (but not X448) MUST mask the most significant bit in the final byte.\n        if (is25519) _u[31] &= 127; // 0b0111_1111\n        // RFC: Implementations MUST accept non-canonical values and process them as\n        // if they had been reduced modulo the field prime.  The non-canonical\n        // values are 2^255 - 19 through 2^255 - 1 for X25519 and 2^448 - 2^224\n        // - 1 through 2^448 - 1 for X448.\n        return modP((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(_u));\n    }\n    function decodeScalar(scalar) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(adjustScalarBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"scalar\", scalar, fieldLen)));\n    }\n    function scalarMult(scalar, u) {\n        const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));\n        // Some public keys are useless, of low-order. Curve author doesn't think\n        // it needs to be validated, but we do it nonetheless.\n        // https://cr.yp.to/ecdh.html#validate\n        if (pu === _0n) throw new Error(\"invalid private or public key received\");\n        return encodeU(pu);\n    }\n    // Computes public key from private. By doing scalar multiplication of base point.\n    function scalarMultBase(scalar) {\n        return scalarMult(scalar, GuBytes);\n    }\n    // cswap from RFC7748 \"example code\"\n    function cswap(swap, x_2, x_3) {\n        // dummy = mask(swap) AND (x_2 XOR x_3)\n        // Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n        // and x_3, computed, e.g., as mask(swap) = 0 - swap.\n        const dummy = modP(swap * (x_2 - x_3));\n        x_2 = modP(x_2 - dummy); // x_2 = x_2 XOR dummy\n        x_3 = modP(x_3 + dummy); // x_3 = x_3 XOR dummy\n        return {\n            x_2,\n            x_3\n        };\n    }\n    /**\n     * Montgomery x-only multiplication ladder.\n     * @param pointU u coordinate (x) on Montgomery Curve 25519\n     * @param scalar by which the point would be multiplied\n     * @returns new Point on Montgomery curve\n     */ function montgomeryLadder(u, scalar) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)(\"u\", u, _0n, P);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)(\"scalar\", scalar, minScalar, maxScalar);\n        const k = scalar;\n        const x_1 = u;\n        let x_2 = _1n;\n        let z_2 = _0n;\n        let x_3 = u;\n        let z_3 = _1n;\n        let swap = _0n;\n        for(let t = BigInt(montgomeryBits - 1); t >= _0n; t--){\n            const k_t = k >> t & _1n;\n            swap ^= k_t;\n            ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n            ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n            swap = k_t;\n            const A = x_2 + z_2;\n            const AA = modP(A * A);\n            const B = x_2 - z_2;\n            const BB = modP(B * B);\n            const E = AA - BB;\n            const C = x_3 + z_3;\n            const D = x_3 - z_3;\n            const DA = modP(D * A);\n            const CB = modP(C * B);\n            const dacb = DA + CB;\n            const da_cb = DA - CB;\n            x_3 = modP(dacb * dacb);\n            z_3 = modP(x_1 * modP(da_cb * da_cb));\n            x_2 = modP(AA * BB);\n            z_2 = modP(E * (AA + modP(a24 * E)));\n        }\n        ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n        ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n        const z2 = powPminus2(z_2); // `Fp.pow(x, P - _2n)` is much slower equivalent\n        return modP(x_2 * z2); // Return x_2 * (z_2^(p - 2))\n    }\n    const lengths = {\n        secretKey: fieldLen,\n        publicKey: fieldLen,\n        seed: fieldLen\n    };\n    const randomSecretKey = (seed = randomBytes_(fieldLen))=>{\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(seed, lengths.seed);\n        return seed;\n    };\n    function keygen(seed) {\n        const secretKey = randomSecretKey(seed);\n        return {\n            secretKey,\n            publicKey: scalarMultBase(secretKey)\n        };\n    }\n    const utils = {\n        randomSecretKey,\n        randomPrivateKey: randomSecretKey\n    };\n    return {\n        keygen,\n        getSharedSecret: (secretKey, publicKey)=>scalarMult(secretKey, publicKey),\n        getPublicKey: (secretKey)=>scalarMultBase(secretKey),\n        scalarMult,\n        scalarMultBase,\n        utils,\n        GuBytes: GuBytes.slice(),\n        lengths\n    };\n} //# sourceMappingURL=montgomery.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjkuNy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvbW9udGdvbWVyeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7O0NBS0MsR0FDRCxvRUFBb0UsR0FDeUQ7QUFDMUY7QUFDbkMsTUFBTVEsTUFBTUMsT0FBTztBQUNuQixNQUFNQyxNQUFNRCxPQUFPO0FBQ25CLE1BQU1FLE1BQU1GLE9BQU87QUFDbkIsU0FBU0csYUFBYUMsS0FBSztJQUN2QmIsMERBQWVBLENBQUNhLE9BQU87UUFDbkJDLG1CQUFtQjtRQUNuQkMsWUFBWTtJQUNoQjtJQUNBLE9BQU9DLE9BQU9DLE1BQU0sQ0FBQztRQUFFLEdBQUdKLEtBQUs7SUFBQztBQUNwQztBQUNPLFNBQVNLLFdBQVdDLFFBQVE7SUFDL0IsTUFBTUMsUUFBUVIsYUFBYU87SUFDM0IsTUFBTSxFQUFFRSxDQUFDLEVBQUVDLElBQUksRUFBRVIsaUJBQWlCLEVBQUVDLFVBQVUsRUFBRVQsYUFBYWlCLElBQUksRUFBRSxHQUFHSDtJQUN0RSxNQUFNSSxVQUFVRixTQUFTO0lBQ3pCLElBQUksQ0FBQ0UsV0FBV0YsU0FBUyxRQUNyQixNQUFNLElBQUlHLE1BQU07SUFDcEIsTUFBTUMsZUFBZUgsUUFBUWpCLGtEQUFXQTtJQUN4QyxNQUFNcUIsaUJBQWlCSCxVQUFVLE1BQU07SUFDdkMsTUFBTUksV0FBV0osVUFBVSxLQUFLO0lBQ2hDLE1BQU1LLEtBQUtMLFVBQVVmLE9BQU8sS0FBS0EsT0FBTztJQUN4QyxlQUFlO0lBQ2YsMEVBQTBFO0lBQzFFLDZDQUE2QztJQUM3Qyx5Q0FBeUM7SUFDekMsTUFBTXFCLE1BQU1OLFVBQVVmLE9BQU8sVUFBVUEsT0FBTztJQUM5QywrREFBK0Q7SUFDL0QsMkRBQTJEO0lBQzNELDRFQUE0RTtJQUM1RSxNQUFNc0IsWUFBWVAsVUFBVWIsT0FBT0YsT0FBTyxPQUFPRSxPQUFPRixPQUFP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U0EsUUFBUTRDLEtBQUs7UUFDdEJWO0lBQ0o7QUFDSixFQUNBLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL25vdGFzY2FtLXByb3RvY29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bub2JsZStjdXJ2ZXNAMS45Ljcvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L21vbnRnb21lcnkuanM/NjE2YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1vbnRnb21lcnkgY3VydmUgbWV0aG9kcy4gSXQncyBub3QgcmVhbGx5IHdob2xlIG1vbnRnb21lcnkgY3VydmUsXG4gKiBqdXN0IGJ1bmNoIG9mIHZlcnkgc3BlY2lmaWMgbWV0aG9kcyBmb3IgWDI1NTE5IC8gWDQ0OCBmcm9tXG4gKiBbUkZDIDc3NDhdKGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM3NzQ4KVxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBfdmFsaWRhdGVPYmplY3QsIGFieXRlcywgYUluUmFuZ2UsIGJ5dGVzVG9OdW1iZXJMRSwgZW5zdXJlQnl0ZXMsIG51bWJlclRvQnl0ZXNMRSwgcmFuZG9tQnl0ZXMsIH0gZnJvbSBcIi4uL3V0aWxzLmpzXCI7XG5pbXBvcnQgeyBtb2QgfSBmcm9tIFwiLi9tb2R1bGFyLmpzXCI7XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSBCaWdJbnQoMik7XG5mdW5jdGlvbiB2YWxpZGF0ZU9wdHMoY3VydmUpIHtcbiAgICBfdmFsaWRhdGVPYmplY3QoY3VydmUsIHtcbiAgICAgICAgYWRqdXN0U2NhbGFyQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgICAgIHBvd1BtaW51czI6ICdmdW5jdGlvbicsXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5jdXJ2ZSB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtb250Z29tZXJ5KGN1cnZlRGVmKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZU9wdHMoY3VydmVEZWYpO1xuICAgIGNvbnN0IHsgUCwgdHlwZSwgYWRqdXN0U2NhbGFyQnl0ZXMsIHBvd1BtaW51czIsIHJhbmRvbUJ5dGVzOiByYW5kIH0gPSBDVVJWRTtcbiAgICBjb25zdCBpczI1NTE5ID0gdHlwZSA9PT0gJ3gyNTUxOSc7XG4gICAgaWYgKCFpczI1NTE5ICYmIHR5cGUgIT09ICd4NDQ4JylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHR5cGUnKTtcbiAgICBjb25zdCByYW5kb21CeXRlc18gPSByYW5kIHx8IHJhbmRvbUJ5dGVzO1xuICAgIGNvbnN0IG1vbnRnb21lcnlCaXRzID0gaXMyNTUxOSA/IDI1NSA6IDQ0ODtcbiAgICBjb25zdCBmaWVsZExlbiA9IGlzMjU1MTkgPyAzMiA6IDU2O1xuICAgIGNvbnN0IEd1ID0gaXMyNTUxOSA/IEJpZ0ludCg5KSA6IEJpZ0ludCg1KTtcbiAgICAvLyBSRkMgNzc0OCAjNTpcbiAgICAvLyBUaGUgY29uc3RhbnQgYTI0IGlzICg0ODY2NjIgLSAyKSAvIDQgPSAxMjE2NjUgZm9yIGN1cnZlMjU1MTkvWDI1NTE5IGFuZFxuICAgIC8vICgxNTYzMjYgLSAyKSAvIDQgPSAzOTA4MSBmb3IgY3VydmU0NDgvWDQ0OFxuICAgIC8vIGNvbnN0IGEgPSBpczI1NTE5ID8gMTU2MzI2biA6IDQ4NjY2Mm47XG4gICAgY29uc3QgYTI0ID0gaXMyNTUxOSA/IEJpZ0ludCgxMjE2NjUpIDogQmlnSW50KDM5MDgxKTtcbiAgICAvLyBSRkM6IHgyNTUxOSBcInRoZSByZXN1bHRpbmcgaW50ZWdlciBpcyBvZiB0aGUgZm9ybSAyXjI1NCBwbHVzXG4gICAgLy8gZWlnaHQgdGltZXMgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDJeMjUxIC0gMSAoaW5jbHVzaXZlKVwiXG4gICAgLy8geDQ0ODogXCIyXjQ0NyBwbHVzIGZvdXIgdGltZXMgYSB2YWx1ZSBiZXR3ZWVuIDAgYW5kIDJeNDQ1IC0gMSAoaW5jbHVzaXZlKVwiXG4gICAgY29uc3QgbWluU2NhbGFyID0gaXMyNTUxOSA/IF8ybiAqKiBCaWdJbnQoMjU0KSA6IF8ybiAqKiBCaWdJbnQoNDQ3KTtcbiAgICBjb25zdCBtYXhBZGRlZCA9IGlzMjU1MTlcbiAgICAgICAgPyBCaWdJbnQoOCkgKiBfMm4gKiogQmlnSW50KDI1MSkgLSBfMW5cbiAgICAgICAgOiBCaWdJbnQoNCkgKiBfMm4gKiogQmlnSW50KDQ0NSkgLSBfMW47XG4gICAgY29uc3QgbWF4U2NhbGFyID0gbWluU2NhbGFyICsgbWF4QWRkZWQgKyBfMW47IC8vIChpbmNsdXNpdmUpXG4gICAgY29uc3QgbW9kUCA9IChuKSA9PiBtb2QobiwgUCk7XG4gICAgY29uc3QgR3VCeXRlcyA9IGVuY29kZVUoR3UpO1xuICAgIGZ1bmN0aW9uIGVuY29kZVUodSkge1xuICAgICAgICByZXR1cm4gbnVtYmVyVG9CeXRlc0xFKG1vZFAodSksIGZpZWxkTGVuKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlVSh1KSB7XG4gICAgICAgIGNvbnN0IF91ID0gZW5zdXJlQnl0ZXMoJ3UgY29vcmRpbmF0ZScsIHUsIGZpZWxkTGVuKTtcbiAgICAgICAgLy8gUkZDOiBXaGVuIHJlY2VpdmluZyBzdWNoIGFuIGFycmF5LCBpbXBsZW1lbnRhdGlvbnMgb2YgWDI1NTE5XG4gICAgICAgIC8vIChidXQgbm90IFg0NDgpIE1VU1QgbWFzayB0aGUgbW9zdCBzaWduaWZpY2FudCBiaXQgaW4gdGhlIGZpbmFsIGJ5dGUuXG4gICAgICAgIGlmIChpczI1NTE5KVxuICAgICAgICAgICAgX3VbMzFdICY9IDEyNzsgLy8gMGIwMTExXzExMTFcbiAgICAgICAgLy8gUkZDOiBJbXBsZW1lbnRhdGlvbnMgTVVTVCBhY2NlcHQgbm9uLWNhbm9uaWNhbCB2YWx1ZXMgYW5kIHByb2Nlc3MgdGhlbSBhc1xuICAgICAgICAvLyBpZiB0aGV5IGhhZCBiZWVuIHJlZHVjZWQgbW9kdWxvIHRoZSBmaWVsZCBwcmltZS4gIFRoZSBub24tY2Fub25pY2FsXG4gICAgICAgIC8vIHZhbHVlcyBhcmUgMl4yNTUgLSAxOSB0aHJvdWdoIDJeMjU1IC0gMSBmb3IgWDI1NTE5IGFuZCAyXjQ0OCAtIDJeMjI0XG4gICAgICAgIC8vIC0gMSB0aHJvdWdoIDJeNDQ4IC0gMSBmb3IgWDQ0OC5cbiAgICAgICAgcmV0dXJuIG1vZFAoYnl0ZXNUb051bWJlckxFKF91KSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZVNjYWxhcihzY2FsYXIpIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzVG9OdW1iZXJMRShhZGp1c3RTY2FsYXJCeXRlcyhlbnN1cmVCeXRlcygnc2NhbGFyJywgc2NhbGFyLCBmaWVsZExlbikpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NhbGFyTXVsdChzY2FsYXIsIHUpIHtcbiAgICAgICAgY29uc3QgcHUgPSBtb250Z29tZXJ5TGFkZGVyKGRlY29kZVUodSksIGRlY29kZVNjYWxhcihzY2FsYXIpKTtcbiAgICAgICAgLy8gU29tZSBwdWJsaWMga2V5cyBhcmUgdXNlbGVzcywgb2YgbG93LW9yZGVyLiBDdXJ2ZSBhdXRob3IgZG9lc24ndCB0aGlua1xuICAgICAgICAvLyBpdCBuZWVkcyB0byBiZSB2YWxpZGF0ZWQsIGJ1dCB3ZSBkbyBpdCBub25ldGhlbGVzcy5cbiAgICAgICAgLy8gaHR0cHM6Ly9jci55cC50by9lY2RoLmh0bWwjdmFsaWRhdGVcbiAgICAgICAgaWYgKHB1ID09PSBfMG4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcHJpdmF0ZSBvciBwdWJsaWMga2V5IHJlY2VpdmVkJyk7XG4gICAgICAgIHJldHVybiBlbmNvZGVVKHB1KTtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZXMgcHVibGljIGtleSBmcm9tIHByaXZhdGUuIEJ5IGRvaW5nIHNjYWxhciBtdWx0aXBsaWNhdGlvbiBvZiBiYXNlIHBvaW50LlxuICAgIGZ1bmN0aW9uIHNjYWxhck11bHRCYXNlKHNjYWxhcikge1xuICAgICAgICByZXR1cm4gc2NhbGFyTXVsdChzY2FsYXIsIEd1Qnl0ZXMpO1xuICAgIH1cbiAgICAvLyBjc3dhcCBmcm9tIFJGQzc3NDggXCJleGFtcGxlIGNvZGVcIlxuICAgIGZ1bmN0aW9uIGNzd2FwKHN3YXAsIHhfMiwgeF8zKSB7XG4gICAgICAgIC8vIGR1bW15ID0gbWFzayhzd2FwKSBBTkQgKHhfMiBYT1IgeF8zKVxuICAgICAgICAvLyBXaGVyZSBtYXNrKHN3YXApIGlzIHRoZSBhbGwtMSBvciBhbGwtMCB3b3JkIG9mIHRoZSBzYW1lIGxlbmd0aCBhcyB4XzJcbiAgICAgICAgLy8gYW5kIHhfMywgY29tcHV0ZWQsIGUuZy4sIGFzIG1hc2soc3dhcCkgPSAwIC0gc3dhcC5cbiAgICAgICAgY29uc3QgZHVtbXkgPSBtb2RQKHN3YXAgKiAoeF8yIC0geF8zKSk7XG4gICAgICAgIHhfMiA9IG1vZFAoeF8yIC0gZHVtbXkpOyAvLyB4XzIgPSB4XzIgWE9SIGR1bW15XG4gICAgICAgIHhfMyA9IG1vZFAoeF8zICsgZHVtbXkpOyAvLyB4XzMgPSB4XzMgWE9SIGR1bW15XG4gICAgICAgIHJldHVybiB7IHhfMiwgeF8zIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vbnRnb21lcnkgeC1vbmx5IG11bHRpcGxpY2F0aW9uIGxhZGRlci5cbiAgICAgKiBAcGFyYW0gcG9pbnRVIHUgY29vcmRpbmF0ZSAoeCkgb24gTW9udGdvbWVyeSBDdXJ2ZSAyNTUxOVxuICAgICAqIEBwYXJhbSBzY2FsYXIgYnkgd2hpY2ggdGhlIHBvaW50IHdvdWxkIGJlIG11bHRpcGxpZWRcbiAgICAgKiBAcmV0dXJucyBuZXcgUG9pbnQgb24gTW9udGdvbWVyeSBjdXJ2ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1vbnRnb21lcnlMYWRkZXIodSwgc2NhbGFyKSB7XG4gICAgICAgIGFJblJhbmdlKCd1JywgdSwgXzBuLCBQKTtcbiAgICAgICAgYUluUmFuZ2UoJ3NjYWxhcicsIHNjYWxhciwgbWluU2NhbGFyLCBtYXhTY2FsYXIpO1xuICAgICAgICBjb25zdCBrID0gc2NhbGFyO1xuICAgICAgICBjb25zdCB4XzEgPSB1O1xuICAgICAgICBsZXQgeF8yID0gXzFuO1xuICAgICAgICBsZXQgel8yID0gXzBuO1xuICAgICAgICBsZXQgeF8zID0gdTtcbiAgICAgICAgbGV0IHpfMyA9IF8xbjtcbiAgICAgICAgbGV0IHN3YXAgPSBfMG47XG4gICAgICAgIGZvciAobGV0IHQgPSBCaWdJbnQobW9udGdvbWVyeUJpdHMgLSAxKTsgdCA+PSBfMG47IHQtLSkge1xuICAgICAgICAgICAgY29uc3Qga190ID0gKGsgPj4gdCkgJiBfMW47XG4gICAgICAgICAgICBzd2FwIF49IGtfdDtcbiAgICAgICAgICAgICh7IHhfMiwgeF8zIH0gPSBjc3dhcChzd2FwLCB4XzIsIHhfMykpO1xuICAgICAgICAgICAgKHsgeF8yOiB6XzIsIHhfMzogel8zIH0gPSBjc3dhcChzd2FwLCB6XzIsIHpfMykpO1xuICAgICAgICAgICAgc3dhcCA9IGtfdDtcbiAgICAgICAgICAgIGNvbnN0IEEgPSB4XzIgKyB6XzI7XG4gICAgICAgICAgICBjb25zdCBBQSA9IG1vZFAoQSAqIEEpO1xuICAgICAgICAgICAgY29uc3QgQiA9IHhfMiAtIHpfMjtcbiAgICAgICAgICAgIGNvbnN0IEJCID0gbW9kUChCICogQik7XG4gICAgICAgICAgICBjb25zdCBFID0gQUEgLSBCQjtcbiAgICAgICAgICAgIGNvbnN0IEMgPSB4XzMgKyB6XzM7XG4gICAgICAgICAgICBjb25zdCBEID0geF8zIC0gel8zO1xuICAgICAgICAgICAgY29uc3QgREEgPSBtb2RQKEQgKiBBKTtcbiAgICAgICAgICAgIGNvbnN0IENCID0gbW9kUChDICogQik7XG4gICAgICAgICAgICBjb25zdCBkYWNiID0gREEgKyBDQjtcbiAgICAgICAgICAgIGNvbnN0IGRhX2NiID0gREEgLSBDQjtcbiAgICAgICAgICAgIHhfMyA9IG1vZFAoZGFjYiAqIGRhY2IpO1xuICAgICAgICAgICAgel8zID0gbW9kUCh4XzEgKiBtb2RQKGRhX2NiICogZGFfY2IpKTtcbiAgICAgICAgICAgIHhfMiA9IG1vZFAoQUEgKiBCQik7XG4gICAgICAgICAgICB6XzIgPSBtb2RQKEUgKiAoQUEgKyBtb2RQKGEyNCAqIEUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgKHsgeF8yLCB4XzMgfSA9IGNzd2FwKHN3YXAsIHhfMiwgeF8zKSk7XG4gICAgICAgICh7IHhfMjogel8yLCB4XzM6IHpfMyB9ID0gY3N3YXAoc3dhcCwgel8yLCB6XzMpKTtcbiAgICAgICAgY29uc3QgejIgPSBwb3dQbWludXMyKHpfMik7IC8vIGBGcC5wb3coeCwgUCAtIF8ybilgIGlzIG11Y2ggc2xvd2VyIGVxdWl2YWxlbnRcbiAgICAgICAgcmV0dXJuIG1vZFAoeF8yICogejIpOyAvLyBSZXR1cm4geF8yICogKHpfMl4ocCAtIDIpKVxuICAgIH1cbiAgICBjb25zdCBsZW5ndGhzID0ge1xuICAgICAgICBzZWNyZXRLZXk6IGZpZWxkTGVuLFxuICAgICAgICBwdWJsaWNLZXk6IGZpZWxkTGVuLFxuICAgICAgICBzZWVkOiBmaWVsZExlbixcbiAgICB9O1xuICAgIGNvbnN0IHJhbmRvbVNlY3JldEtleSA9IChzZWVkID0gcmFuZG9tQnl0ZXNfKGZpZWxkTGVuKSkgPT4ge1xuICAgICAgICBhYnl0ZXMoc2VlZCwgbGVuZ3Rocy5zZWVkKTtcbiAgICAgICAgcmV0dXJuIHNlZWQ7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBrZXlnZW4oc2VlZCkge1xuICAgICAgICBjb25zdCBzZWNyZXRLZXkgPSByYW5kb21TZWNyZXRLZXkoc2VlZCk7XG4gICAgICAgIHJldHVybiB7IHNlY3JldEtleSwgcHVibGljS2V5OiBzY2FsYXJNdWx0QmFzZShzZWNyZXRLZXkpIH07XG4gICAgfVxuICAgIGNvbnN0IHV0aWxzID0ge1xuICAgICAgICByYW5kb21TZWNyZXRLZXksXG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6IHJhbmRvbVNlY3JldEtleSxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGtleWdlbixcbiAgICAgICAgZ2V0U2hhcmVkU2VjcmV0OiAoc2VjcmV0S2V5LCBwdWJsaWNLZXkpID0+IHNjYWxhck11bHQoc2VjcmV0S2V5LCBwdWJsaWNLZXkpLFxuICAgICAgICBnZXRQdWJsaWNLZXk6IChzZWNyZXRLZXkpID0+IHNjYWxhck11bHRCYXNlKHNlY3JldEtleSksXG4gICAgICAgIHNjYWxhck11bHQsXG4gICAgICAgIHNjYWxhck11bHRCYXNlLFxuICAgICAgICB1dGlscyxcbiAgICAgICAgR3VCeXRlczogR3VCeXRlcy5zbGljZSgpLFxuICAgICAgICBsZW5ndGhzLFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb250Z29tZXJ5LmpzLm1hcCJdLCJuYW1lcyI6WyJfdmFsaWRhdGVPYmplY3QiLCJhYnl0ZXMiLCJhSW5SYW5nZSIsImJ5dGVzVG9OdW1iZXJMRSIsImVuc3VyZUJ5dGVzIiwibnVtYmVyVG9CeXRlc0xFIiwicmFuZG9tQnl0ZXMiLCJtb2QiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJ2YWxpZGF0ZU9wdHMiLCJjdXJ2ZSIsImFkanVzdFNjYWxhckJ5dGVzIiwicG93UG1pbnVzMiIsIk9iamVjdCIsImZyZWV6ZSIsIm1vbnRnb21lcnkiLCJjdXJ2ZURlZiIsIkNVUlZFIiwiUCIsInR5cGUiLCJyYW5kIiwiaXMyNTUxOSIsIkVycm9yIiwicmFuZG9tQnl0ZXNfIiwibW9udGdvbWVyeUJpdHMiLCJmaWVsZExlbiIsIkd1IiwiYTI0IiwibWluU2NhbGFyIiwibWF4QWRkZWQiLCJtYXhTY2FsYXIiLCJtb2RQIiwibiIsIkd1Qnl0ZXMiLCJlbmNvZGVVIiwidSIsImRlY29kZVUiLCJfdSIsImRlY29kZVNjYWxhciIsInNjYWxhciIsInNjYWxhck11bHQiLCJwdSIsIm1vbnRnb21lcnlMYWRkZXIiLCJzY2FsYXJNdWx0QmFzZSIsImNzd2FwIiwic3dhcCIsInhfMiIsInhfMyIsImR1bW15IiwiayIsInhfMSIsInpfMiIsInpfMyIsInQiLCJrX3QiLCJBIiwiQUEiLCJCIiwiQkIiLCJFIiwiQyIsIkQiLCJEQSIsIkNCIiwiZGFjYiIsImRhX2NiIiwiejIiLCJsZW5ndGhzIiwic2VjcmV0S2V5IiwicHVibGljS2V5Iiwic2VlZCIsInJhbmRvbVNlY3JldEtleSIsImtleWdlbiIsInV0aWxzIiwicmFuZG9tUHJpdmF0ZUtleSIsImdldFNoYXJlZFNlY3JldCIsImdldFB1YmxpY0tleSIsInNsaWNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/montgomery.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/tower.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/tower.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   psiFrobenius: () => (/* binding */ psiFrobenius),\n/* harmony export */   tower12: () => (/* binding */ tower12)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/utils.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/modular.js\");\n/**\n * Towered extension fields.\n * Rather than implementing a massive 12th-degree extension directly, it is more efficient\n * to build it up from smaller extensions: a tower of extensions.\n *\n * For BLS12-381, the Fp12 field is implemented as a quadratic (degree two) extension,\n * on top of a cubic (degree three) extension, on top of a quadratic extension of Fp.\n *\n * For more info: \"Pairings for beginners\" by Costello, section 7.3.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\nfunction calcFrobeniusCoefficients(Fp, nonResidue, modulus, degree, num = 1, divisor) {\n    const _divisor = BigInt(divisor === undefined ? degree : divisor);\n    const towerModulus = modulus ** BigInt(degree);\n    const res = [];\n    for(let i = 0; i < num; i++){\n        const a = BigInt(i + 1);\n        const powers = [];\n        for(let j = 0, qPower = _1n; j < degree; j++){\n            const power = (a * qPower - a) / _divisor % towerModulus;\n            powers.push(Fp.pow(nonResidue, power));\n            qPower *= modulus;\n        }\n        res.push(powers);\n    }\n    return res;\n}\n// This works same at least for bls12-381, bn254 and bls12-377\nfunction psiFrobenius(Fp, Fp2, base) {\n    // GLV endomorphism Ψ(P)\n    const PSI_X = Fp2.pow(base, (Fp.ORDER - _1n) / _3n); // u^((p-1)/3)\n    const PSI_Y = Fp2.pow(base, (Fp.ORDER - _1n) / _2n); // u^((p-1)/2)\n    function psi(x, y) {\n        // This x10 faster than previous version in bls12-381\n        const x2 = Fp2.mul(Fp2.frobeniusMap(x, 1), PSI_X);\n        const y2 = Fp2.mul(Fp2.frobeniusMap(y, 1), PSI_Y);\n        return [\n            x2,\n            y2\n        ];\n    }\n    // Ψ²(P) endomorphism (psi2(x) = psi(psi(x)))\n    const PSI2_X = Fp2.pow(base, (Fp.ORDER ** _2n - _1n) / _3n); // u^((p^2 - 1)/3)\n    // This equals -1, which causes y to be Fp2.neg(y).\n    // But not sure if there are case when this is not true?\n    const PSI2_Y = Fp2.pow(base, (Fp.ORDER ** _2n - _1n) / _2n); // u^((p^2 - 1)/3)\n    if (!Fp2.eql(PSI2_Y, Fp2.neg(Fp2.ONE))) throw new Error(\"psiFrobenius: PSI2_Y!==-1\");\n    function psi2(x, y) {\n        return [\n            Fp2.mul(x, PSI2_X),\n            Fp2.neg(y)\n        ];\n    }\n    // Map points\n    const mapAffine = (fn)=>(c, P)=>{\n            const affine = P.toAffine();\n            const p = fn(affine.x, affine.y);\n            return c.fromAffine({\n                x: p[0],\n                y: p[1]\n            });\n        };\n    const G2psi = mapAffine(psi);\n    const G2psi2 = mapAffine(psi2);\n    return {\n        psi,\n        psi2,\n        G2psi,\n        G2psi2,\n        PSI_X,\n        PSI_Y,\n        PSI2_X,\n        PSI2_Y\n    };\n}\nconst Fp2fromBigTuple = (Fp, tuple)=>{\n    if (tuple.length !== 2) throw new Error(\"invalid tuple\");\n    const fps = tuple.map((n)=>Fp.create(n));\n    return {\n        c0: fps[0],\n        c1: fps[1]\n    };\n};\nclass _Field2 {\n    constructor(Fp, opts = {}){\n        this.MASK = _1n;\n        const ORDER = Fp.ORDER;\n        const FP2_ORDER = ORDER * ORDER;\n        this.Fp = Fp;\n        this.ORDER = FP2_ORDER;\n        this.BITS = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitLen)(FP2_ORDER);\n        this.BYTES = Math.ceil((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitLen)(FP2_ORDER) / 8);\n        this.isLE = Fp.isLE;\n        this.ZERO = {\n            c0: Fp.ZERO,\n            c1: Fp.ZERO\n        };\n        this.ONE = {\n            c0: Fp.ONE,\n            c1: Fp.ZERO\n        };\n        this.Fp_NONRESIDUE = Fp.create(opts.NONRESIDUE || BigInt(-1));\n        this.Fp_div2 = Fp.div(Fp.ONE, _2n); // 1/2\n        this.NONRESIDUE = Fp2fromBigTuple(Fp, opts.FP2_NONRESIDUE);\n        // const Fp2Nonresidue = Fp2fromBigTuple(opts.FP2_NONRESIDUE);\n        this.FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(Fp, this.Fp_NONRESIDUE, Fp.ORDER, 2)[0];\n        this.mulByB = opts.Fp2mulByB;\n        Object.seal(this);\n    }\n    fromBigTuple(tuple) {\n        return Fp2fromBigTuple(this.Fp, tuple);\n    }\n    create(num) {\n        return num;\n    }\n    isValid({ c0, c1 }) {\n        function isValidC(num, ORDER) {\n            return typeof num === \"bigint\" && _0n <= num && num < ORDER;\n        }\n        return isValidC(c0, this.ORDER) && isValidC(c1, this.ORDER);\n    }\n    is0({ c0, c1 }) {\n        return this.Fp.is0(c0) && this.Fp.is0(c1);\n    }\n    isValidNot0(num) {\n        return !this.is0(num) && this.isValid(num);\n    }\n    eql({ c0, c1 }, { c0: r0, c1: r1 }) {\n        return this.Fp.eql(c0, r0) && this.Fp.eql(c1, r1);\n    }\n    neg({ c0, c1 }) {\n        return {\n            c0: this.Fp.neg(c0),\n            c1: this.Fp.neg(c1)\n        };\n    }\n    pow(num, power) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_1__.FpPow(this, num, power);\n    }\n    invertBatch(nums) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_1__.FpInvertBatch(this, nums);\n    }\n    // Normalized\n    add(f1, f2) {\n        const { c0, c1 } = f1;\n        const { c0: r0, c1: r1 } = f2;\n        return {\n            c0: this.Fp.add(c0, r0),\n            c1: this.Fp.add(c1, r1)\n        };\n    }\n    sub({ c0, c1 }, { c0: r0, c1: r1 }) {\n        return {\n            c0: this.Fp.sub(c0, r0),\n            c1: this.Fp.sub(c1, r1)\n        };\n    }\n    mul({ c0, c1 }, rhs) {\n        const { Fp } = this;\n        if (typeof rhs === \"bigint\") return {\n            c0: Fp.mul(c0, rhs),\n            c1: Fp.mul(c1, rhs)\n        };\n        // (a+bi)(c+di) = (ac−bd) + (ad+bc)i\n        const { c0: r0, c1: r1 } = rhs;\n        let t1 = Fp.mul(c0, r0); // c0 * o0\n        let t2 = Fp.mul(c1, r1); // c1 * o1\n        // (T1 - T2) + ((c0 + c1) * (r0 + r1) - (T1 + T2))*i\n        const o0 = Fp.sub(t1, t2);\n        const o1 = Fp.sub(Fp.mul(Fp.add(c0, c1), Fp.add(r0, r1)), Fp.add(t1, t2));\n        return {\n            c0: o0,\n            c1: o1\n        };\n    }\n    sqr({ c0, c1 }) {\n        const { Fp } = this;\n        const a = Fp.add(c0, c1);\n        const b = Fp.sub(c0, c1);\n        const c = Fp.add(c0, c0);\n        return {\n            c0: Fp.mul(a, b),\n            c1: Fp.mul(c, c1)\n        };\n    }\n    // NonNormalized stuff\n    addN(a, b) {\n        return this.add(a, b);\n    }\n    subN(a, b) {\n        return this.sub(a, b);\n    }\n    mulN(a, b) {\n        return this.mul(a, b);\n    }\n    sqrN(a) {\n        return this.sqr(a);\n    }\n    // Why inversion for bigint inside Fp instead of Fp2? it is even used in that context?\n    div(lhs, rhs) {\n        const { Fp } = this;\n        // @ts-ignore\n        return this.mul(lhs, typeof rhs === \"bigint\" ? Fp.inv(Fp.create(rhs)) : this.inv(rhs));\n    }\n    inv({ c0: a, c1: b }) {\n        // We wish to find the multiplicative inverse of a nonzero\n        // element a + bu in Fp2. We leverage an identity\n        //\n        // (a + bu)(a - bu) = a² + b²\n        //\n        // which holds because u² = -1. This can be rewritten as\n        //\n        // (a + bu)(a - bu)/(a² + b²) = 1\n        //\n        // because a² + b² = 0 has no nonzero solutions for (a, b).\n        // This gives that (a - bu)/(a² + b²) is the inverse\n        // of (a + bu). Importantly, this can be computing using\n        // only a single inversion in Fp.\n        const { Fp } = this;\n        const factor = Fp.inv(Fp.create(a * a + b * b));\n        return {\n            c0: Fp.mul(factor, Fp.create(a)),\n            c1: Fp.mul(factor, Fp.create(-b))\n        };\n    }\n    sqrt(num) {\n        // This is generic for all quadratic extensions (Fp2)\n        const { Fp } = this;\n        const Fp2 = this;\n        const { c0, c1 } = num;\n        if (Fp.is0(c1)) {\n            // if c0 is quadratic residue\n            if (_modular_js__WEBPACK_IMPORTED_MODULE_1__.FpLegendre(Fp, c0) === 1) return Fp2.create({\n                c0: Fp.sqrt(c0),\n                c1: Fp.ZERO\n            });\n            else return Fp2.create({\n                c0: Fp.ZERO,\n                c1: Fp.sqrt(Fp.div(c0, this.Fp_NONRESIDUE))\n            });\n        }\n        const a = Fp.sqrt(Fp.sub(Fp.sqr(c0), Fp.mul(Fp.sqr(c1), this.Fp_NONRESIDUE)));\n        let d = Fp.mul(Fp.add(a, c0), this.Fp_div2);\n        const legendre = _modular_js__WEBPACK_IMPORTED_MODULE_1__.FpLegendre(Fp, d);\n        // -1, Quadratic non residue\n        if (legendre === -1) d = Fp.sub(d, a);\n        const a0 = Fp.sqrt(d);\n        const candidateSqrt = Fp2.create({\n            c0: a0,\n            c1: Fp.div(Fp.mul(c1, this.Fp_div2), a0)\n        });\n        if (!Fp2.eql(Fp2.sqr(candidateSqrt), num)) throw new Error(\"Cannot find square root\");\n        // Normalize root: at this point candidateSqrt ** 2 = num, but also -candidateSqrt ** 2 = num\n        const x1 = candidateSqrt;\n        const x2 = Fp2.neg(x1);\n        const { re: re1, im: im1 } = Fp2.reim(x1);\n        const { re: re2, im: im2 } = Fp2.reim(x2);\n        if (im1 > im2 || im1 === im2 && re1 > re2) return x1;\n        return x2;\n    }\n    // Same as sgn0_m_eq_2 in RFC 9380\n    isOdd(x) {\n        const { re: x0, im: x1 } = this.reim(x);\n        const sign_0 = x0 % _2n;\n        const zero_0 = x0 === _0n;\n        const sign_1 = x1 % _2n;\n        return BigInt(sign_0 || zero_0 && sign_1) == _1n;\n    }\n    // Bytes util\n    fromBytes(b) {\n        const { Fp } = this;\n        if (b.length !== this.BYTES) throw new Error(\"fromBytes invalid length=\" + b.length);\n        return {\n            c0: Fp.fromBytes(b.subarray(0, Fp.BYTES)),\n            c1: Fp.fromBytes(b.subarray(Fp.BYTES))\n        };\n    }\n    toBytes({ c0, c1 }) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.concatBytes)(this.Fp.toBytes(c0), this.Fp.toBytes(c1));\n    }\n    cmov({ c0, c1 }, { c0: r0, c1: r1 }, c) {\n        return {\n            c0: this.Fp.cmov(c0, r0, c),\n            c1: this.Fp.cmov(c1, r1, c)\n        };\n    }\n    reim({ c0, c1 }) {\n        return {\n            re: c0,\n            im: c1\n        };\n    }\n    Fp4Square(a, b) {\n        const Fp2 = this;\n        const a2 = Fp2.sqr(a);\n        const b2 = Fp2.sqr(b);\n        return {\n            first: Fp2.add(Fp2.mulByNonresidue(b2), a2),\n            second: Fp2.sub(Fp2.sub(Fp2.sqr(Fp2.add(a, b)), a2), b2)\n        };\n    }\n    // multiply by u + 1\n    mulByNonresidue({ c0, c1 }) {\n        return this.mul({\n            c0,\n            c1\n        }, this.NONRESIDUE);\n    }\n    frobeniusMap({ c0, c1 }, power) {\n        return {\n            c0,\n            c1: this.Fp.mul(c1, this.FROBENIUS_COEFFICIENTS[power % 2])\n        };\n    }\n}\nclass _Field6 {\n    constructor(Fp2){\n        this.MASK = _1n;\n        this.Fp2 = Fp2;\n        this.ORDER = Fp2.ORDER; // TODO: unused, but need to verify\n        this.BITS = 3 * Fp2.BITS;\n        this.BYTES = 3 * Fp2.BYTES;\n        this.isLE = Fp2.isLE;\n        this.ZERO = {\n            c0: Fp2.ZERO,\n            c1: Fp2.ZERO,\n            c2: Fp2.ZERO\n        };\n        this.ONE = {\n            c0: Fp2.ONE,\n            c1: Fp2.ZERO,\n            c2: Fp2.ZERO\n        };\n        const { Fp } = Fp2;\n        const frob = calcFrobeniusCoefficients(Fp2, Fp2.NONRESIDUE, Fp.ORDER, 6, 2, 3);\n        this.FROBENIUS_COEFFICIENTS_1 = frob[0];\n        this.FROBENIUS_COEFFICIENTS_2 = frob[1];\n        Object.seal(this);\n    }\n    add({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }) {\n        const { Fp2 } = this;\n        return {\n            c0: Fp2.add(c0, r0),\n            c1: Fp2.add(c1, r1),\n            c2: Fp2.add(c2, r2)\n        };\n    }\n    sub({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }) {\n        const { Fp2 } = this;\n        return {\n            c0: Fp2.sub(c0, r0),\n            c1: Fp2.sub(c1, r1),\n            c2: Fp2.sub(c2, r2)\n        };\n    }\n    mul({ c0, c1, c2 }, rhs) {\n        const { Fp2 } = this;\n        if (typeof rhs === \"bigint\") {\n            return {\n                c0: Fp2.mul(c0, rhs),\n                c1: Fp2.mul(c1, rhs),\n                c2: Fp2.mul(c2, rhs)\n            };\n        }\n        const { c0: r0, c1: r1, c2: r2 } = rhs;\n        const t0 = Fp2.mul(c0, r0); // c0 * o0\n        const t1 = Fp2.mul(c1, r1); // c1 * o1\n        const t2 = Fp2.mul(c2, r2); // c2 * o2\n        return {\n            // t0 + (c1 + c2) * (r1 * r2) - (T1 + T2) * (u + 1)\n            c0: Fp2.add(t0, Fp2.mulByNonresidue(Fp2.sub(Fp2.mul(Fp2.add(c1, c2), Fp2.add(r1, r2)), Fp2.add(t1, t2)))),\n            // (c0 + c1) * (r0 + r1) - (T0 + T1) + T2 * (u + 1)\n            c1: Fp2.add(Fp2.sub(Fp2.mul(Fp2.add(c0, c1), Fp2.add(r0, r1)), Fp2.add(t0, t1)), Fp2.mulByNonresidue(t2)),\n            // T1 + (c0 + c2) * (r0 + r2) - T0 + T2\n            c2: Fp2.sub(Fp2.add(t1, Fp2.mul(Fp2.add(c0, c2), Fp2.add(r0, r2))), Fp2.add(t0, t2))\n        };\n    }\n    sqr({ c0, c1, c2 }) {\n        const { Fp2 } = this;\n        let t0 = Fp2.sqr(c0); // c0²\n        let t1 = Fp2.mul(Fp2.mul(c0, c1), _2n); // 2 * c0 * c1\n        let t3 = Fp2.mul(Fp2.mul(c1, c2), _2n); // 2 * c1 * c2\n        let t4 = Fp2.sqr(c2); // c2²\n        return {\n            c0: Fp2.add(Fp2.mulByNonresidue(t3), t0),\n            c1: Fp2.add(Fp2.mulByNonresidue(t4), t1),\n            // T1 + (c0 - c1 + c2)² + T3 - T0 - T4\n            c2: Fp2.sub(Fp2.sub(Fp2.add(Fp2.add(t1, Fp2.sqr(Fp2.add(Fp2.sub(c0, c1), c2))), t3), t0), t4)\n        };\n    }\n    addN(a, b) {\n        return this.add(a, b);\n    }\n    subN(a, b) {\n        return this.sub(a, b);\n    }\n    mulN(a, b) {\n        return this.mul(a, b);\n    }\n    sqrN(a) {\n        return this.sqr(a);\n    }\n    create(num) {\n        return num;\n    }\n    isValid({ c0, c1, c2 }) {\n        const { Fp2 } = this;\n        return Fp2.isValid(c0) && Fp2.isValid(c1) && Fp2.isValid(c2);\n    }\n    is0({ c0, c1, c2 }) {\n        const { Fp2 } = this;\n        return Fp2.is0(c0) && Fp2.is0(c1) && Fp2.is0(c2);\n    }\n    isValidNot0(num) {\n        return !this.is0(num) && this.isValid(num);\n    }\n    neg({ c0, c1, c2 }) {\n        const { Fp2 } = this;\n        return {\n            c0: Fp2.neg(c0),\n            c1: Fp2.neg(c1),\n            c2: Fp2.neg(c2)\n        };\n    }\n    eql({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }) {\n        const { Fp2 } = this;\n        return Fp2.eql(c0, r0) && Fp2.eql(c1, r1) && Fp2.eql(c2, r2);\n    }\n    sqrt(_) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.notImplemented)();\n    }\n    // Do we need division by bigint at all? Should be done via order:\n    div(lhs, rhs) {\n        const { Fp2 } = this;\n        const { Fp } = Fp2;\n        return this.mul(lhs, typeof rhs === \"bigint\" ? Fp.inv(Fp.create(rhs)) : this.inv(rhs));\n    }\n    pow(num, power) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_1__.FpPow(this, num, power);\n    }\n    invertBatch(nums) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_1__.FpInvertBatch(this, nums);\n    }\n    inv({ c0, c1, c2 }) {\n        const { Fp2 } = this;\n        let t0 = Fp2.sub(Fp2.sqr(c0), Fp2.mulByNonresidue(Fp2.mul(c2, c1))); // c0² - c2 * c1 * (u + 1)\n        let t1 = Fp2.sub(Fp2.mulByNonresidue(Fp2.sqr(c2)), Fp2.mul(c0, c1)); // c2² * (u + 1) - c0 * c1\n        let t2 = Fp2.sub(Fp2.sqr(c1), Fp2.mul(c0, c2)); // c1² - c0 * c2\n        // 1/(((c2 * T1 + c1 * T2) * v) + c0 * T0)\n        let t4 = Fp2.inv(Fp2.add(Fp2.mulByNonresidue(Fp2.add(Fp2.mul(c2, t1), Fp2.mul(c1, t2))), Fp2.mul(c0, t0)));\n        return {\n            c0: Fp2.mul(t4, t0),\n            c1: Fp2.mul(t4, t1),\n            c2: Fp2.mul(t4, t2)\n        };\n    }\n    // Bytes utils\n    fromBytes(b) {\n        const { Fp2 } = this;\n        if (b.length !== this.BYTES) throw new Error(\"fromBytes invalid length=\" + b.length);\n        const B2 = Fp2.BYTES;\n        return {\n            c0: Fp2.fromBytes(b.subarray(0, B2)),\n            c1: Fp2.fromBytes(b.subarray(B2, B2 * 2)),\n            c2: Fp2.fromBytes(b.subarray(2 * B2))\n        };\n    }\n    toBytes({ c0, c1, c2 }) {\n        const { Fp2 } = this;\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.concatBytes)(Fp2.toBytes(c0), Fp2.toBytes(c1), Fp2.toBytes(c2));\n    }\n    cmov({ c0, c1, c2 }, { c0: r0, c1: r1, c2: r2 }, c) {\n        const { Fp2 } = this;\n        return {\n            c0: Fp2.cmov(c0, r0, c),\n            c1: Fp2.cmov(c1, r1, c),\n            c2: Fp2.cmov(c2, r2, c)\n        };\n    }\n    fromBigSix(t) {\n        const { Fp2 } = this;\n        if (!Array.isArray(t) || t.length !== 6) throw new Error(\"invalid Fp6 usage\");\n        return {\n            c0: Fp2.fromBigTuple(t.slice(0, 2)),\n            c1: Fp2.fromBigTuple(t.slice(2, 4)),\n            c2: Fp2.fromBigTuple(t.slice(4, 6))\n        };\n    }\n    frobeniusMap({ c0, c1, c2 }, power) {\n        const { Fp2 } = this;\n        return {\n            c0: Fp2.frobeniusMap(c0, power),\n            c1: Fp2.mul(Fp2.frobeniusMap(c1, power), this.FROBENIUS_COEFFICIENTS_1[power % 6]),\n            c2: Fp2.mul(Fp2.frobeniusMap(c2, power), this.FROBENIUS_COEFFICIENTS_2[power % 6])\n        };\n    }\n    mulByFp2({ c0, c1, c2 }, rhs) {\n        const { Fp2 } = this;\n        return {\n            c0: Fp2.mul(c0, rhs),\n            c1: Fp2.mul(c1, rhs),\n            c2: Fp2.mul(c2, rhs)\n        };\n    }\n    mulByNonresidue({ c0, c1, c2 }) {\n        const { Fp2 } = this;\n        return {\n            c0: Fp2.mulByNonresidue(c2),\n            c1: c0,\n            c2: c1\n        };\n    }\n    // Sparse multiplication\n    mul1({ c0, c1, c2 }, b1) {\n        const { Fp2 } = this;\n        return {\n            c0: Fp2.mulByNonresidue(Fp2.mul(c2, b1)),\n            c1: Fp2.mul(c0, b1),\n            c2: Fp2.mul(c1, b1)\n        };\n    }\n    // Sparse multiplication\n    mul01({ c0, c1, c2 }, b0, b1) {\n        const { Fp2 } = this;\n        let t0 = Fp2.mul(c0, b0); // c0 * b0\n        let t1 = Fp2.mul(c1, b1); // c1 * b1\n        return {\n            // ((c1 + c2) * b1 - T1) * (u + 1) + T0\n            c0: Fp2.add(Fp2.mulByNonresidue(Fp2.sub(Fp2.mul(Fp2.add(c1, c2), b1), t1)), t0),\n            // (b0 + b1) * (c0 + c1) - T0 - T1\n            c1: Fp2.sub(Fp2.sub(Fp2.mul(Fp2.add(b0, b1), Fp2.add(c0, c1)), t0), t1),\n            // (c0 + c2) * b0 - T0 + T1\n            c2: Fp2.add(Fp2.sub(Fp2.mul(Fp2.add(c0, c2), b0), t0), t1)\n        };\n    }\n}\nclass _Field12 {\n    constructor(Fp6, opts){\n        this.MASK = _1n;\n        const { Fp2 } = Fp6;\n        const { Fp } = Fp2;\n        this.Fp6 = Fp6;\n        this.ORDER = Fp2.ORDER; // TODO: verify if it's unuesd\n        this.BITS = 2 * Fp6.BITS;\n        this.BYTES = 2 * Fp6.BYTES;\n        this.isLE = Fp6.isLE;\n        this.ZERO = {\n            c0: Fp6.ZERO,\n            c1: Fp6.ZERO\n        };\n        this.ONE = {\n            c0: Fp6.ONE,\n            c1: Fp6.ZERO\n        };\n        this.FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(Fp2, Fp2.NONRESIDUE, Fp.ORDER, 12, 1, 6)[0];\n        this.X_LEN = opts.X_LEN;\n        this.finalExponentiate = opts.Fp12finalExponentiate;\n    }\n    create(num) {\n        return num;\n    }\n    isValid({ c0, c1 }) {\n        const { Fp6 } = this;\n        return Fp6.isValid(c0) && Fp6.isValid(c1);\n    }\n    is0({ c0, c1 }) {\n        const { Fp6 } = this;\n        return Fp6.is0(c0) && Fp6.is0(c1);\n    }\n    isValidNot0(num) {\n        return !this.is0(num) && this.isValid(num);\n    }\n    neg({ c0, c1 }) {\n        const { Fp6 } = this;\n        return {\n            c0: Fp6.neg(c0),\n            c1: Fp6.neg(c1)\n        };\n    }\n    eql({ c0, c1 }, { c0: r0, c1: r1 }) {\n        const { Fp6 } = this;\n        return Fp6.eql(c0, r0) && Fp6.eql(c1, r1);\n    }\n    sqrt(_) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.notImplemented)();\n    }\n    inv({ c0, c1 }) {\n        const { Fp6 } = this;\n        let t = Fp6.inv(Fp6.sub(Fp6.sqr(c0), Fp6.mulByNonresidue(Fp6.sqr(c1)))); // 1 / (c0² - c1² * v)\n        return {\n            c0: Fp6.mul(c0, t),\n            c1: Fp6.neg(Fp6.mul(c1, t))\n        }; // ((C0 * T) * T) + (-C1 * T) * w\n    }\n    div(lhs, rhs) {\n        const { Fp6 } = this;\n        const { Fp2 } = Fp6;\n        const { Fp } = Fp2;\n        return this.mul(lhs, typeof rhs === \"bigint\" ? Fp.inv(Fp.create(rhs)) : this.inv(rhs));\n    }\n    pow(num, power) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_1__.FpPow(this, num, power);\n    }\n    invertBatch(nums) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_1__.FpInvertBatch(this, nums);\n    }\n    // Normalized\n    add({ c0, c1 }, { c0: r0, c1: r1 }) {\n        const { Fp6 } = this;\n        return {\n            c0: Fp6.add(c0, r0),\n            c1: Fp6.add(c1, r1)\n        };\n    }\n    sub({ c0, c1 }, { c0: r0, c1: r1 }) {\n        const { Fp6 } = this;\n        return {\n            c0: Fp6.sub(c0, r0),\n            c1: Fp6.sub(c1, r1)\n        };\n    }\n    mul({ c0, c1 }, rhs) {\n        const { Fp6 } = this;\n        if (typeof rhs === \"bigint\") return {\n            c0: Fp6.mul(c0, rhs),\n            c1: Fp6.mul(c1, rhs)\n        };\n        let { c0: r0, c1: r1 } = rhs;\n        let t1 = Fp6.mul(c0, r0); // c0 * r0\n        let t2 = Fp6.mul(c1, r1); // c1 * r1\n        return {\n            c0: Fp6.add(t1, Fp6.mulByNonresidue(t2)),\n            // (c0 + c1) * (r0 + r1) - (T1 + T2)\n            c1: Fp6.sub(Fp6.mul(Fp6.add(c0, c1), Fp6.add(r0, r1)), Fp6.add(t1, t2))\n        };\n    }\n    sqr({ c0, c1 }) {\n        const { Fp6 } = this;\n        let ab = Fp6.mul(c0, c1); // c0 * c1\n        return {\n            // (c1 * v + c0) * (c0 + c1) - AB - AB * v\n            c0: Fp6.sub(Fp6.sub(Fp6.mul(Fp6.add(Fp6.mulByNonresidue(c1), c0), Fp6.add(c0, c1)), ab), Fp6.mulByNonresidue(ab)),\n            c1: Fp6.add(ab, ab)\n        }; // AB + AB\n    }\n    // NonNormalized stuff\n    addN(a, b) {\n        return this.add(a, b);\n    }\n    subN(a, b) {\n        return this.sub(a, b);\n    }\n    mulN(a, b) {\n        return this.mul(a, b);\n    }\n    sqrN(a) {\n        return this.sqr(a);\n    }\n    // Bytes utils\n    fromBytes(b) {\n        const { Fp6 } = this;\n        if (b.length !== this.BYTES) throw new Error(\"fromBytes invalid length=\" + b.length);\n        return {\n            c0: Fp6.fromBytes(b.subarray(0, Fp6.BYTES)),\n            c1: Fp6.fromBytes(b.subarray(Fp6.BYTES))\n        };\n    }\n    toBytes({ c0, c1 }) {\n        const { Fp6 } = this;\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.concatBytes)(Fp6.toBytes(c0), Fp6.toBytes(c1));\n    }\n    cmov({ c0, c1 }, { c0: r0, c1: r1 }, c) {\n        const { Fp6 } = this;\n        return {\n            c0: Fp6.cmov(c0, r0, c),\n            c1: Fp6.cmov(c1, r1, c)\n        };\n    }\n    // Utils\n    // toString() {\n    //   return '' + 'Fp12(' + this.c0 + this.c1 + '* w');\n    // },\n    // fromTuple(c: [Fp6, Fp6]) {\n    //   return new Fp12(...c);\n    // }\n    fromBigTwelve(t) {\n        const { Fp6 } = this;\n        return {\n            c0: Fp6.fromBigSix(t.slice(0, 6)),\n            c1: Fp6.fromBigSix(t.slice(6, 12))\n        };\n    }\n    // Raises to q**i -th power\n    frobeniusMap(lhs, power) {\n        const { Fp6 } = this;\n        const { Fp2 } = Fp6;\n        const { c0, c1, c2 } = Fp6.frobeniusMap(lhs.c1, power);\n        const coeff = this.FROBENIUS_COEFFICIENTS[power % 12];\n        return {\n            c0: Fp6.frobeniusMap(lhs.c0, power),\n            c1: Fp6.create({\n                c0: Fp2.mul(c0, coeff),\n                c1: Fp2.mul(c1, coeff),\n                c2: Fp2.mul(c2, coeff)\n            })\n        };\n    }\n    mulByFp2({ c0, c1 }, rhs) {\n        const { Fp6 } = this;\n        return {\n            c0: Fp6.mulByFp2(c0, rhs),\n            c1: Fp6.mulByFp2(c1, rhs)\n        };\n    }\n    conjugate({ c0, c1 }) {\n        return {\n            c0,\n            c1: this.Fp6.neg(c1)\n        };\n    }\n    // Sparse multiplication\n    mul014({ c0, c1 }, o0, o1, o4) {\n        const { Fp6 } = this;\n        const { Fp2 } = Fp6;\n        let t0 = Fp6.mul01(c0, o0, o1);\n        let t1 = Fp6.mul1(c1, o4);\n        return {\n            c0: Fp6.add(Fp6.mulByNonresidue(t1), t0),\n            // (c1 + c0) * [o0, o1+o4] - T0 - T1\n            c1: Fp6.sub(Fp6.sub(Fp6.mul01(Fp6.add(c1, c0), o0, Fp2.add(o1, o4)), t0), t1)\n        };\n    }\n    mul034({ c0, c1 }, o0, o3, o4) {\n        const { Fp6 } = this;\n        const { Fp2 } = Fp6;\n        const a = Fp6.create({\n            c0: Fp2.mul(c0.c0, o0),\n            c1: Fp2.mul(c0.c1, o0),\n            c2: Fp2.mul(c0.c2, o0)\n        });\n        const b = Fp6.mul01(c1, o3, o4);\n        const e = Fp6.mul01(Fp6.add(c0, c1), Fp2.add(o0, o3), o4);\n        return {\n            c0: Fp6.add(Fp6.mulByNonresidue(b), a),\n            c1: Fp6.sub(e, Fp6.add(a, b))\n        };\n    }\n    // A cyclotomic group is a subgroup of Fp^n defined by\n    //   GΦₙ(p) = {α ∈ Fpⁿ : α^Φₙ(p) = 1}\n    // The result of any pairing is in a cyclotomic subgroup\n    // https://eprint.iacr.org/2009/565.pdf\n    // https://eprint.iacr.org/2010/354.pdf\n    _cyclotomicSquare({ c0, c1 }) {\n        const { Fp6 } = this;\n        const { Fp2 } = Fp6;\n        const { c0: c0c0, c1: c0c1, c2: c0c2 } = c0;\n        const { c0: c1c0, c1: c1c1, c2: c1c2 } = c1;\n        const { first: t3, second: t4 } = Fp2.Fp4Square(c0c0, c1c1);\n        const { first: t5, second: t6 } = Fp2.Fp4Square(c1c0, c0c2);\n        const { first: t7, second: t8 } = Fp2.Fp4Square(c0c1, c1c2);\n        const t9 = Fp2.mulByNonresidue(t8); // T8 * (u + 1)\n        return {\n            c0: Fp6.create({\n                c0: Fp2.add(Fp2.mul(Fp2.sub(t3, c0c0), _2n), t3),\n                c1: Fp2.add(Fp2.mul(Fp2.sub(t5, c0c1), _2n), t5),\n                c2: Fp2.add(Fp2.mul(Fp2.sub(t7, c0c2), _2n), t7)\n            }),\n            c1: Fp6.create({\n                c0: Fp2.add(Fp2.mul(Fp2.add(t9, c1c0), _2n), t9),\n                c1: Fp2.add(Fp2.mul(Fp2.add(t4, c1c1), _2n), t4),\n                c2: Fp2.add(Fp2.mul(Fp2.add(t6, c1c2), _2n), t6)\n            })\n        }; // 2 * (T6 + c1c2) + T6\n    }\n    // https://eprint.iacr.org/2009/565.pdf\n    _cyclotomicExp(num, n) {\n        let z = this.ONE;\n        for(let i = this.X_LEN - 1; i >= 0; i--){\n            z = this._cyclotomicSquare(z);\n            if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitGet)(n, i)) z = this.mul(z, num);\n        }\n        return z;\n    }\n}\nfunction tower12(opts) {\n    const Fp = _modular_js__WEBPACK_IMPORTED_MODULE_1__.Field(opts.ORDER);\n    const Fp2 = new _Field2(Fp, opts);\n    const Fp6 = new _Field6(Fp2);\n    const Fp12 = new _Field12(Fp6, opts);\n    return {\n        Fp,\n        Fp2,\n        Fp6,\n        Fp12\n    };\n} //# sourceMappingURL=tower.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjkuNy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvdG93ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7OztDQVVDLEdBQ0Qsb0VBQW9FLEdBQ007QUFDdEM7QUFDcEMscUVBQXFFO0FBQ3JFLGtCQUFrQjtBQUNsQixNQUFNSyxNQUFNQyxPQUFPLElBQUlDLE1BQU1ELE9BQU8sSUFBSUUsTUFBTUYsT0FBTyxJQUFJRyxNQUFNSCxPQUFPO0FBQ3RFLFNBQVNJLDBCQUEwQkMsRUFBRSxFQUFFQyxVQUFVLEVBQUVDLE9BQU8sRUFBRUMsTUFBTSxFQUFFQyxNQUFNLENBQUMsRUFBRUMsT0FBTztJQUNoRixNQUFNQyxXQUFXWCxPQUFPVSxZQUFZRSxZQUFZSixTQUFTRTtJQUN6RCxNQUFNRyxlQUFlTixXQUFXUCxPQUFPUTtJQUN2QyxNQUFNTSxNQUFNLEVBQUU7SUFDZCxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSU4sS0FBS00sSUFBSztRQUMxQixNQUFNQyxJQUFJaEIsT0FBT2UsSUFBSTtRQUNyQixNQUFNRSxTQUFTLEVBQUU7UUFDakIsSUFBSyxJQUFJQyxJQUFJLEdBQUdDLFNBQVNsQixLQUFLaUIsSUFBSVYsUUFBUVUsSUFBSztZQUMzQyxNQUFNRSxRQUFRLENBQUVKLElBQUlHLFNBQVNILENBQUFBLElBQUtMLFdBQVlFO1lBQzlDSSxPQUFPSSxJQUFJLENBQUNoQixHQUFHaUIsR0FBRyxDQUFDaEIsWUFBWWM7WUFDL0JELFVBQVVaO1FBQ2Q7UUFDQU8sSUFBSU8sSUFBSSxDQUFDSjtJQUNiO0lBQ0EsT0FBT0g7QUFDWDtBQUNBLDhEQUE4RDtBQUN2RCxTQUFTUyxhQUFhbEIsRUFBRSxFQUFFbUIsR0FBRyxFQUFFQyxJQUFJO0lBQ3RDLHdCQUF3QjtJQUN4QixNQUFNQyxRQUFRRixJQUFJRixHQUFHLENBQUNHLE1BQU0sQ0FBQ3BCLEdB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Q0FBQ2E7WUFDM0IsSUFBSW5NLGlEQUFNQSxDQUFDZ0UsR0FBRzNDLElBQ1Y4SyxJQUFJLElBQUksQ0FBQzVKLEdBQUcsQ0FBQzRKLEdBQUdwTDtRQUN4QjtRQUNBLE9BQU9vTDtJQUNYO0FBQ0o7QUFDTyxTQUFTQyxRQUFROUgsSUFBSTtJQUN4QixNQUFNM0QsS0FBS1AsOENBQVMsQ0FBQ2tFLEtBQUtyQyxLQUFLO0lBQy9CLE1BQU1ILE1BQU0sSUFBSXNDLFFBQVF6RCxJQUFJMkQ7SUFDNUIsTUFBTW1HLE1BQU0sSUFBSXRCLFFBQVFySDtJQUN4QixNQUFNd0ssT0FBTyxJQUFJOUIsU0FBU0MsS0FBS25HO0lBQy9CLE9BQU87UUFBRTNEO1FBQUltQjtRQUFLMkk7UUFBSzZCO0lBQUs7QUFDaEMsRUFDQSxpQ0FBaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3Rhc2NhbS1wcm90b2NvbC8uL25vZGVfbW9kdWxlcy8ucG5wbS9Abm9ibGUrY3VydmVzQDEuOS43L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC90b3dlci5qcz8yZTI3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVG93ZXJlZCBleHRlbnNpb24gZmllbGRzLlxuICogUmF0aGVyIHRoYW4gaW1wbGVtZW50aW5nIGEgbWFzc2l2ZSAxMnRoLWRlZ3JlZSBleHRlbnNpb24gZGlyZWN0bHksIGl0IGlzIG1vcmUgZWZmaWNpZW50XG4gKiB0byBidWlsZCBpdCB1cCBmcm9tIHNtYWxsZXIgZXh0ZW5zaW9uczogYSB0b3dlciBvZiBleHRlbnNpb25zLlxuICpcbiAqIEZvciBCTFMxMi0zODEsIHRoZSBGcDEyIGZpZWxkIGlzIGltcGxlbWVudGVkIGFzIGEgcXVhZHJhdGljIChkZWdyZWUgdHdvKSBleHRlbnNpb24sXG4gKiBvbiB0b3Agb2YgYSBjdWJpYyAoZGVncmVlIHRocmVlKSBleHRlbnNpb24sIG9uIHRvcCBvZiBhIHF1YWRyYXRpYyBleHRlbnNpb24gb2YgRnAuXG4gKlxuICogRm9yIG1vcmUgaW5mbzogXCJQYWlyaW5ncyBmb3IgYmVnaW5uZXJzXCIgYnkgQ29zdGVsbG8sIHNlY3Rpb24gNy4zLlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBiaXRHZXQsIGJpdExlbiwgY29uY2F0Qnl0ZXMsIG5vdEltcGxlbWVudGVkIH0gZnJvbSBcIi4uL3V0aWxzLmpzXCI7XG5pbXBvcnQgKiBhcyBtb2QgZnJvbSBcIi4vbW9kdWxhci5qc1wiO1xuLy8gQmUgZnJpZW5kbHkgdG8gYmFkIEVDTUFTY3JpcHQgcGFyc2VycyBieSBub3QgdXNpbmcgYmlnaW50IGxpdGVyYWxzXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKTtcbmZ1bmN0aW9uIGNhbGNGcm9iZW5pdXNDb2VmZmljaWVudHMoRnAsIG5vblJlc2lkdWUsIG1vZHVsdXMsIGRlZ3JlZSwgbnVtID0gMSwgZGl2aXNvcikge1xuICAgIGNvbnN0IF9kaXZpc29yID0gQmlnSW50KGRpdmlzb3IgPT09IHVuZGVmaW5lZCA/IGRlZ3JlZSA6IGRpdmlzb3IpO1xuICAgIGNvbnN0IHRvd2VyTW9kdWx1cyA9IG1vZHVsdXMgKiogQmlnSW50KGRlZ3JlZSk7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW07IGkrKykge1xuICAgICAgICBjb25zdCBhID0gQmlnSW50KGkgKyAxKTtcbiAgICAgICAgY29uc3QgcG93ZXJzID0gW107XG4gICAgICAgIGZvciAobGV0IGogPSAwLCBxUG93ZXIgPSBfMW47IGogPCBkZWdyZWU7IGorKykge1xuICAgICAgICAgICAgY29uc3QgcG93ZXIgPSAoKGEgKiBxUG93ZXIgLSBhKSAvIF9kaXZpc29yKSAlIHRvd2VyTW9kdWx1cztcbiAgICAgICAgICAgIHBvd2Vycy5wdXNoKEZwLnBvdyhub25SZXNpZHVlLCBwb3dlcikpO1xuICAgICAgICAgICAgcVBvd2VyICo9IG1vZHVsdXM7XG4gICAgICAgIH1cbiAgICAgICAgcmVzLnB1c2gocG93ZXJzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIFRoaXMgd29ya3Mgc2FtZSBhdCBsZWFzdCBmb3IgYmxzMTItMzgxLCBibjI1NCBhbmQgYmxzMTItMzc3XG5leHBvcnQgZnVuY3Rpb24gcHNpRnJvYmVuaXVzKEZwLCBGcDIsIGJhc2UpIHtcbiAgICAvLyBHTFYgZW5kb21vcnBoaXNtIM6oKFApXG4gICAgY29uc3QgUFNJX1ggPSBGcDIucG93KGJhc2UsIChGcC5PUkRFUiAtIF8xbikgLyBfM24pOyAvLyB1XigocC0xKS8zKVxuICAgIGNvbnN0IFBTSV9ZID0gRnAyLnBvdyhiYXNlLCAoRnAuT1JERVIgLSBfMW4pIC8gXzJuKTsgLy8gdV4oKHAtMSkvMilcbiAgICBmdW5jdGlvbiBwc2koeCwgeSkge1xuICAgICAgICAvLyBUaGlzIHgxMCBmYXN0ZXIgdGhhbiBwcmV2aW91cyB2ZXJzaW9uIGluIGJsczEyLTM4MVxuICAgICAgICBjb25zdCB4MiA9IEZwMi5tdWwoRnAyLmZyb2Jlbml1c01hcCh4LCAxKSwgUFNJX1gpO1xuICAgICAgICBjb25zdCB5MiA9IEZwMi5tdWwoRnAyLmZyb2Jlbml1c01hcCh5LCAxKSwgUFNJX1kpO1xuICAgICAgICByZXR1cm4gW3gyLCB5Ml07XG4gICAgfVxuICAgIC8vIM6owrIoUCkgZW5kb21vcnBoaXNtIChwc2kyKHgpID0gcHNpKHBzaSh4KSkpXG4gICAgY29uc3QgUFNJMl9YID0gRnAyLnBvdyhiYXNlLCAoRnAuT1JERVIgKiogXzJuIC0gXzFuKSAvIF8zbik7IC8vIHVeKChwXjIgLSAxKS8zKVxuICAgIC8vIFRoaXMgZXF1YWxzIC0xLCB3aGljaCBjYXVzZXMgeSB0byBiZSBGcDIubmVnKHkpLlxuICAgIC8vIEJ1dCBub3Qgc3VyZSBpZiB0aGVyZSBhcmUgY2FzZSB3aGVuIHRoaXMgaXMgbm90IHRydWU/XG4gICAgY29uc3QgUFNJMl9ZID0gRnAyLnBvdyhiYXNlLCAoRnAuT1JERVIgKiogXzJuIC0gXzFuKSAvIF8ybik7IC8vIHVeKChwXjIgLSAxKS8zKVxuICAgIGlmICghRnAyLmVxbChQU0kyX1ksIEZwMi5uZWcoRnAyLk9ORSkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BzaUZyb2Jlbml1czogUFNJMl9ZIT09LTEnKTtcbiAgICBmdW5jdGlvbiBwc2kyKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIFtGcDIubXVsKHgsIFBTSTJfWCksIEZwMi5uZWcoeSldO1xuICAgIH1cbiAgICAvLyBNYXAgcG9pbnRzXG4gICAgY29uc3QgbWFwQWZmaW5lID0gKGZuKSA9PiAoYywgUCkgPT4ge1xuICAgICAgICBjb25zdCBhZmZpbmUgPSBQLnRvQWZmaW5lKCk7XG4gICAgICAgIGNvbnN0IHAgPSBmbihhZmZpbmUueCwgYWZmaW5lLnkpO1xuICAgICAgICByZXR1cm4gYy5mcm9tQWZmaW5lKHsgeDogcFswXSwgeTogcFsxXSB9KTtcbiAgICB9O1xuICAgIGNvbnN0IEcycHNpID0gbWFwQWZmaW5lKHBzaSk7XG4gICAgY29uc3QgRzJwc2kyID0gbWFwQWZmaW5lKHBzaTIpO1xuICAgIHJldHVybiB7IHBzaSwgcHNpMiwgRzJwc2ksIEcycHNpMiwgUFNJX1gsIFBTSV9ZLCBQU0kyX1gsIFBTSTJfWSB9O1xufVxuY29uc3QgRnAyZnJvbUJpZ1R1cGxlID0gKEZwLCB0dXBsZSkgPT4ge1xuICAgIGlmICh0dXBsZS5sZW5ndGggIT09IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB0dXBsZScpO1xuICAgIGNvbnN0IGZwcyA9IHR1cGxlLm1hcCgobikgPT4gRnAuY3JlYXRlKG4pKTtcbiAgICByZXR1cm4geyBjMDogZnBzWzBdLCBjMTogZnBzWzFdIH07XG59O1xuY2xhc3MgX0ZpZWxkMiB7XG4gICAgY29uc3RydWN0b3IoRnAsIG9wdHMgPSB7fSkge1xuICAgICAgICB0aGlzLk1BU0sgPSBfMW47XG4gICAgICAgIGNvbnN0IE9SREVSID0gRnAuT1JERVI7XG4gICAgICAgIGNvbnN0IEZQMl9PUkRFUiA9IE9SREVSICogT1JERVI7XG4gICAgICAgIHRoaXMuRnAgPSBGcDtcbiAgICAgICAgdGhpcy5PUkRFUiA9IEZQMl9PUkRFUjtcbiAgICAgICAgdGhpcy5CSVRTID0gYml0TGVuKEZQMl9PUkRFUik7XG4gICAgICAgIHRoaXMuQllURVMgPSBNYXRoLmNlaWwoYml0TGVuKEZQMl9PUkRFUikgLyA4KTtcbiAgICAgICAgdGhpcy5pc0xFID0gRnAuaXNMRTtcbiAgICAgICAgdGhpcy5aRVJPID0geyBjMDogRnAuWkVSTywgYzE6IEZwLlpFUk8gfTtcbiAgICAgICAgdGhpcy5PTkUgPSB7IGMwOiBGcC5PTkUsIGMxOiBGcC5aRVJPIH07XG4gICAgICAgIHRoaXMuRnBfTk9OUkVTSURVRSA9IEZwLmNyZWF0ZShvcHRzLk5PTlJFU0lEVUUgfHwgQmlnSW50KC0xKSk7XG4gICAgICAgIHRoaXMuRnBfZGl2MiA9IEZwLmRpdihGcC5PTkUsIF8ybik7IC8vIDEvMlxuICAgICAgICB0aGlzLk5PTlJFU0lEVUUgPSBGcDJmcm9tQmlnVHVwbGUoRnAsIG9wdHMuRlAyX05PTlJFU0lEVUUpO1xuICAgICAgICAvLyBjb25zdCBGcDJOb25yZXNpZHVlID0gRnAyZnJvbUJpZ1R1cGxlKG9wdHMuRlAyX05PTlJFU0lEVUUpO1xuICAgICAgICB0aGlzLkZST0JFTklVU19DT0VGRklDSUVOVFMgPSBjYWxjRnJvYmVuaXVzQ29lZmZpY2llbnRzKEZwLCB0aGlzLkZwX05PTlJFU0lEVUUsIEZwLk9SREVSLCAyKVswXTtcbiAgICAgICAgdGhpcy5tdWxCeUIgPSBvcHRzLkZwMm11bEJ5QjtcbiAgICAgICAgT2JqZWN0LnNlYWwodGhpcyk7XG4gICAgfVxuICAgIGZyb21CaWdUdXBsZSh0dXBsZSkge1xuICAgICAgICByZXR1cm4gRnAyZnJvbUJpZ1R1cGxlKHRoaXMuRnAsIHR1cGxlKTtcbiAgICB9XG4gICAgY3JlYXRlKG51bSkge1xuICAgICAgICByZXR1cm4gbnVtO1xuICAgIH1cbiAgICBpc1ZhbGlkKHsgYzAsIGMxIH0pIHtcbiAgICAgICAgZnVuY3Rpb24gaXNWYWxpZEMobnVtLCBPUkRFUikge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBudW0gPT09ICdiaWdpbnQnICYmIF8wbiA8PSBudW0gJiYgbnVtIDwgT1JERVI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzVmFsaWRDKGMwLCB0aGlzLk9SREVSKSAmJiBpc1ZhbGlkQyhjMSwgdGhpcy5PUkRFUik7XG4gICAgfVxuICAgIGlzMCh7IGMwLCBjMSB9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkZwLmlzMChjMCkgJiYgdGhpcy5GcC5pczAoYzEpO1xuICAgIH1cbiAgICBpc1ZhbGlkTm90MChudW0pIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzMChudW0pICYmIHRoaXMuaXNWYWxpZChudW0pO1xuICAgIH1cbiAgICBlcWwoeyBjMCwgYzEgfSwgeyBjMDogcjAsIGMxOiByMSB9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLkZwLmVxbChjMCwgcjApICYmIHRoaXMuRnAuZXFsKGMxLCByMSk7XG4gICAgfVxuICAgIG5lZyh7IGMwLCBjMSB9KSB7XG4gICAgICAgIHJldHVybiB7IGMwOiB0aGlzLkZwLm5lZyhjMCksIGMxOiB0aGlzLkZwLm5lZyhjMSkgfTtcbiAgICB9XG4gICAgcG93KG51bSwgcG93ZXIpIHtcbiAgICAgICAgcmV0dXJuIG1vZC5GcFBvdyh0aGlzLCBudW0sIHBvd2VyKTtcbiAgICB9XG4gICAgaW52ZXJ0QmF0Y2gobnVtcykge1xuICAgICAgICByZXR1cm4gbW9kLkZwSW52ZXJ0QmF0Y2godGhpcywgbnVtcyk7XG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZWRcbiAgICBhZGQoZjEsIGYyKSB7XG4gICAgICAgIGNvbnN0IHsgYzAsIGMxIH0gPSBmMTtcbiAgICAgICAgY29uc3QgeyBjMDogcjAsIGMxOiByMSB9ID0gZjI7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjMDogdGhpcy5GcC5hZGQoYzAsIHIwKSxcbiAgICAgICAgICAgIGMxOiB0aGlzLkZwLmFkZChjMSwgcjEpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdWIoeyBjMCwgYzEgfSwgeyBjMDogcjAsIGMxOiByMSB9KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjMDogdGhpcy5GcC5zdWIoYzAsIHIwKSxcbiAgICAgICAgICAgIGMxOiB0aGlzLkZwLnN1YihjMSwgcjEpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBtdWwoeyBjMCwgYzEgfSwgcmhzKSB7XG4gICAgICAgIGNvbnN0IHsgRnAgfSA9IHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2YgcmhzID09PSAnYmlnaW50JylcbiAgICAgICAgICAgIHJldHVybiB7IGMwOiBGcC5tdWwoYzAsIHJocyksIGMxOiBGcC5tdWwoYzEsIHJocykgfTtcbiAgICAgICAgLy8gKGErYmkpKGMrZGkpID0gKGFj4oiSYmQpICsgKGFkK2JjKWlcbiAgICAgICAgY29uc3QgeyBjMDogcjAsIGMxOiByMSB9ID0gcmhzO1xuICAgICAgICBsZXQgdDEgPSBGcC5tdWwoYzAsIHIwKTsgLy8gYzAgKiBvMFxuICAgICAgICBsZXQgdDIgPSBGcC5tdWwoYzEsIHIxKTsgLy8gYzEgKiBvMVxuICAgICAgICAvLyAoVDEgLSBUMikgKyAoKGMwICsgYzEpICogKHIwICsgcjEpIC0gKFQxICsgVDIpKSppXG4gICAgICAgIGNvbnN0IG8wID0gRnAuc3ViKHQxLCB0Mik7XG4gICAgICAgIGNvbnN0IG8xID0gRnAuc3ViKEZwLm11bChGcC5hZGQoYzAsIGMxKSwgRnAuYWRkKHIwLCByMSkpLCBGcC5hZGQodDEsIHQyKSk7XG4gICAgICAgIHJldHVybiB7IGMwOiBvMCwgYzE6IG8xIH07XG4gICAgfVxuICAgIHNxcih7IGMwLCBjMSB9KSB7XG4gICAgICAgIGNvbnN0IHsgRnAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGEgPSBGcC5hZGQoYzAsIGMxKTtcbiAgICAgICAgY29uc3QgYiA9IEZwLnN1YihjMCwgYzEpO1xuICAgICAgICBjb25zdCBjID0gRnAuYWRkKGMwLCBjMCk7XG4gICAgICAgIHJldHVybiB7IGMwOiBGcC5tdWwoYSwgYiksIGMxOiBGcC5tdWwoYywgYzEpIH07XG4gICAgfVxuICAgIC8vIE5vbk5vcm1hbGl6ZWQgc3R1ZmZcbiAgICBhZGROKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkKGEsIGIpO1xuICAgIH1cbiAgICBzdWJOKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViKGEsIGIpO1xuICAgIH1cbiAgICBtdWxOKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsKGEsIGIpO1xuICAgIH1cbiAgICBzcXJOKGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3FyKGEpO1xuICAgIH1cbiAgICAvLyBXaHkgaW52ZXJzaW9uIGZvciBiaWdpbnQgaW5zaWRlIEZwIGluc3RlYWQgb2YgRnAyPyBpdCBpcyBldmVuIHVzZWQgaW4gdGhhdCBjb250ZXh0P1xuICAgIGRpdihsaHMsIHJocykge1xuICAgICAgICBjb25zdCB7IEZwIH0gPSB0aGlzO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiB0aGlzLm11bChsaHMsIHR5cGVvZiByaHMgPT09ICdiaWdpbnQnID8gRnAuaW52KEZwLmNyZWF0ZShyaHMpKSA6IHRoaXMuaW52KHJocykpO1xuICAgIH1cbiAgICBpbnYoeyBjMDogYSwgYzE6IGIgfSkge1xuICAgICAgICAvLyBXZSB3aXNoIHRvIGZpbmQgdGhlIG11bHRpcGxpY2F0aXZlIGludmVyc2Ugb2YgYSBub256ZXJvXG4gICAgICAgIC8vIGVsZW1lbnQgYSArIGJ1IGluIEZwMi4gV2UgbGV2ZXJhZ2UgYW4gaWRlbnRpdHlcbiAgICAgICAgLy9cbiAgICAgICAgLy8gKGEgKyBidSkoYSAtIGJ1KSA9IGHCsiArIGLCslxuICAgICAgICAvL1xuICAgICAgICAvLyB3aGljaCBob2xkcyBiZWNhdXNlIHXCsiA9IC0xLiBUaGlzIGNhbiBiZSByZXdyaXR0ZW4gYXNcbiAgICAgICAgLy9cbiAgICAgICAgLy8gKGEgKyBidSkoYSAtIGJ1KS8oYcKyICsgYsKyKSA9IDFcbiAgICAgICAgLy9cbiAgICAgICAgLy8gYmVjYXVzZSBhwrIgKyBiwrIgPSAwIGhhcyBubyBub256ZXJvIHNvbHV0aW9ucyBmb3IgKGEsIGIpLlxuICAgICAgICAvLyBUaGlzIGdpdmVzIHRoYXQgKGEgLSBidSkvKGHCsiArIGLCsikgaXMgdGhlIGludmVyc2VcbiAgICAgICAgLy8gb2YgKGEgKyBidSkuIEltcG9ydGFudGx5LCB0aGlzIGNhbiBiZSBjb21wdXRpbmcgdXNpbmdcbiAgICAgICAgLy8gb25seSBhIHNpbmdsZSBpbnZlcnNpb24gaW4gRnAuXG4gICAgICAgIGNvbnN0IHsgRnAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGZhY3RvciA9IEZwLmludihGcC5jcmVhdGUoYSAqIGEgKyBiICogYikpO1xuICAgICAgICByZXR1cm4geyBjMDogRnAubXVsKGZhY3RvciwgRnAuY3JlYXRlKGEpKSwgYzE6IEZwLm11bChmYWN0b3IsIEZwLmNyZWF0ZSgtYikpIH07XG4gICAgfVxuICAgIHNxcnQobnVtKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgZ2VuZXJpYyBmb3IgYWxsIHF1YWRyYXRpYyBleHRlbnNpb25zIChGcDIpXG4gICAgICAgIGNvbnN0IHsgRnAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IEZwMiA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgYzAsIGMxIH0gPSBudW07XG4gICAgICAgIGlmIChGcC5pczAoYzEpKSB7XG4gICAgICAgICAgICAvLyBpZiBjMCBpcyBxdWFkcmF0aWMgcmVzaWR1ZVxuICAgICAgICAgICAgaWYgKG1vZC5GcExlZ2VuZHJlKEZwLCBjMCkgPT09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZwMi5jcmVhdGUoeyBjMDogRnAuc3FydChjMCksIGMxOiBGcC5aRVJPIH0pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBGcDIuY3JlYXRlKHsgYzA6IEZwLlpFUk8sIGMxOiBGcC5zcXJ0KEZwLmRpdihjMCwgdGhpcy5GcF9OT05SRVNJRFVFKSkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYSA9IEZwLnNxcnQoRnAuc3ViKEZwLnNxcihjMCksIEZwLm11bChGcC5zcXIoYzEpLCB0aGlzLkZwX05PTlJFU0lEVUUpKSk7XG4gICAgICAgIGxldCBkID0gRnAubXVsKEZwLmFkZChhLCBjMCksIHRoaXMuRnBfZGl2Mik7XG4gICAgICAgIGNvbnN0IGxlZ2VuZHJlID0gbW9kLkZwTGVnZW5kcmUoRnAsIGQpO1xuICAgICAgICAvLyAtMSwgUXVhZHJhdGljIG5vbiByZXNpZHVlXG4gICAgICAgIGlmIChsZWdlbmRyZSA9PT0gLTEpXG4gICAgICAgICAgICBkID0gRnAuc3ViKGQsIGEpO1xuICAgICAgICBjb25zdCBhMCA9IEZwLnNxcnQoZCk7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZVNxcnQgPSBGcDIuY3JlYXRlKHsgYzA6IGEwLCBjMTogRnAuZGl2KEZwLm11bChjMSwgdGhpcy5GcF9kaXYyKSwgYTApIH0pO1xuICAgICAgICBpZiAoIUZwMi5lcWwoRnAyLnNxcihjYW5kaWRhdGVTcXJ0KSwgbnVtKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgLy8gTm9ybWFsaXplIHJvb3Q6IGF0IHRoaXMgcG9pbnQgY2FuZGlkYXRlU3FydCAqKiAyID0gbnVtLCBidXQgYWxzbyAtY2FuZGlkYXRlU3FydCAqKiAyID0gbnVtXG4gICAgICAgIGNvbnN0IHgxID0gY2FuZGlkYXRlU3FydDtcbiAgICAgICAgY29uc3QgeDIgPSBGcDIubmVnKHgxKTtcbiAgICAgICAgY29uc3QgeyByZTogcmUxLCBpbTogaW0xIH0gPSBGcDIucmVpbSh4MSk7XG4gICAgICAgIGNvbnN0IHsgcmU6IHJlMiwgaW06IGltMiB9ID0gRnAyLnJlaW0oeDIpO1xuICAgICAgICBpZiAoaW0xID4gaW0yIHx8IChpbTEgPT09IGltMiAmJiByZTEgPiByZTIpKVxuICAgICAgICAgICAgcmV0dXJuIHgxO1xuICAgICAgICByZXR1cm4geDI7XG4gICAgfVxuICAgIC8vIFNhbWUgYXMgc2duMF9tX2VxXzIgaW4gUkZDIDkzODBcbiAgICBpc09kZCh4KSB7XG4gICAgICAgIGNvbnN0IHsgcmU6IHgwLCBpbTogeDEgfSA9IHRoaXMucmVpbSh4KTtcbiAgICAgICAgY29uc3Qgc2lnbl8wID0geDAgJSBfMm47XG4gICAgICAgIGNvbnN0IHplcm9fMCA9IHgwID09PSBfMG47XG4gICAgICAgIGNvbnN0IHNpZ25fMSA9IHgxICUgXzJuO1xuICAgICAgICByZXR1cm4gQmlnSW50KHNpZ25fMCB8fCAoemVyb18wICYmIHNpZ25fMSkpID09IF8xbjtcbiAgICB9XG4gICAgLy8gQnl0ZXMgdXRpbFxuICAgIGZyb21CeXRlcyhiKSB7XG4gICAgICAgIGNvbnN0IHsgRnAgfSA9IHRoaXM7XG4gICAgICAgIGlmIChiLmxlbmd0aCAhPT0gdGhpcy5CWVRFUylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZnJvbUJ5dGVzIGludmFsaWQgbGVuZ3RoPScgKyBiLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiB7IGMwOiBGcC5mcm9tQnl0ZXMoYi5zdWJhcnJheSgwLCBGcC5CWVRFUykpLCBjMTogRnAuZnJvbUJ5dGVzKGIuc3ViYXJyYXkoRnAuQllURVMpKSB9O1xuICAgIH1cbiAgICB0b0J5dGVzKHsgYzAsIGMxIH0pIHtcbiAgICAgICAgcmV0dXJuIGNvbmNhdEJ5dGVzKHRoaXMuRnAudG9CeXRlcyhjMCksIHRoaXMuRnAudG9CeXRlcyhjMSkpO1xuICAgIH1cbiAgICBjbW92KHsgYzAsIGMxIH0sIHsgYzA6IHIwLCBjMTogcjEgfSwgYykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYzA6IHRoaXMuRnAuY21vdihjMCwgcjAsIGMpLFxuICAgICAgICAgICAgYzE6IHRoaXMuRnAuY21vdihjMSwgcjEsIGMpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZWltKHsgYzAsIGMxIH0pIHtcbiAgICAgICAgcmV0dXJuIHsgcmU6IGMwLCBpbTogYzEgfTtcbiAgICB9XG4gICAgRnA0U3F1YXJlKGEsIGIpIHtcbiAgICAgICAgY29uc3QgRnAyID0gdGhpcztcbiAgICAgICAgY29uc3QgYTIgPSBGcDIuc3FyKGEpO1xuICAgICAgICBjb25zdCBiMiA9IEZwMi5zcXIoYik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmaXJzdDogRnAyLmFkZChGcDIubXVsQnlOb25yZXNpZHVlKGIyKSwgYTIpLCAvLyBiwrIgKiBOb25yZXNpZHVlICsgYcKyXG4gICAgICAgICAgICBzZWNvbmQ6IEZwMi5zdWIoRnAyLnN1YihGcDIuc3FyKEZwMi5hZGQoYSwgYikpLCBhMiksIGIyKSwgLy8gKGEgKyBiKcKyIC0gYcKyIC0gYsKyXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIG11bHRpcGx5IGJ5IHUgKyAxXG4gICAgbXVsQnlOb25yZXNpZHVlKHsgYzAsIGMxIH0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsKHsgYzAsIGMxIH0sIHRoaXMuTk9OUkVTSURVRSk7XG4gICAgfVxuICAgIGZyb2Jlbml1c01hcCh7IGMwLCBjMSB9LCBwb3dlcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYzAsXG4gICAgICAgICAgICBjMTogdGhpcy5GcC5tdWwoYzEsIHRoaXMuRlJPQkVOSVVTX0NPRUZGSUNJRU5UU1twb3dlciAlIDJdKSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5jbGFzcyBfRmllbGQ2IHtcbiAgICBjb25zdHJ1Y3RvcihGcDIpIHtcbiAgICAgICAgdGhpcy5NQVNLID0gXzFuO1xuICAgICAgICB0aGlzLkZwMiA9IEZwMjtcbiAgICAgICAgdGhpcy5PUkRFUiA9IEZwMi5PUkRFUjsgLy8gVE9ETzogdW51c2VkLCBidXQgbmVlZCB0byB2ZXJpZnlcbiAgICAgICAgdGhpcy5CSVRTID0gMyAqIEZwMi5CSVRTO1xuICAgICAgICB0aGlzLkJZVEVTID0gMyAqIEZwMi5CWVRFUztcbiAgICAgICAgdGhpcy5pc0xFID0gRnAyLmlzTEU7XG4gICAgICAgIHRoaXMuWkVSTyA9IHsgYzA6IEZwMi5aRVJPLCBjMTogRnAyLlpFUk8sIGMyOiBGcDIuWkVSTyB9O1xuICAgICAgICB0aGlzLk9ORSA9IHsgYzA6IEZwMi5PTkUsIGMxOiBGcDIuWkVSTywgYzI6IEZwMi5aRVJPIH07XG4gICAgICAgIGNvbnN0IHsgRnAgfSA9IEZwMjtcbiAgICAgICAgY29uc3QgZnJvYiA9IGNhbGNGcm9iZW5pdXNDb2VmZmljaWVudHMoRnAyLCBGcDIuTk9OUkVTSURVRSwgRnAuT1JERVIsIDYsIDIsIDMpO1xuICAgICAgICB0aGlzLkZST0JFTklVU19DT0VGRklDSUVOVFNfMSA9IGZyb2JbMF07XG4gICAgICAgIHRoaXMuRlJPQkVOSVVTX0NPRUZGSUNJRU5UU18yID0gZnJvYlsxXTtcbiAgICAgICAgT2JqZWN0LnNlYWwodGhpcyk7XG4gICAgfVxuICAgIGFkZCh7IGMwLCBjMSwgYzIgfSwgeyBjMDogcjAsIGMxOiByMSwgYzI6IHIyIH0pIHtcbiAgICAgICAgY29uc3QgeyBGcDIgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjMDogRnAyLmFkZChjMCwgcjApLFxuICAgICAgICAgICAgYzE6IEZwMi5hZGQoYzEsIHIxKSxcbiAgICAgICAgICAgIGMyOiBGcDIuYWRkKGMyLCByMiksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHN1Yih7IGMwLCBjMSwgYzIgfSwgeyBjMDogcjAsIGMxOiByMSwgYzI6IHIyIH0pIHtcbiAgICAgICAgY29uc3QgeyBGcDIgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjMDogRnAyLnN1YihjMCwgcjApLFxuICAgICAgICAgICAgYzE6IEZwMi5zdWIoYzEsIHIxKSxcbiAgICAgICAgICAgIGMyOiBGcDIuc3ViKGMyLCByMiksXG4gICAgICAgIH07XG4gICAgfVxuICAgIG11bCh7IGMwLCBjMSwgYzIgfSwgcmhzKSB7XG4gICAgICAgIGNvbnN0IHsgRnAyIH0gPSB0aGlzO1xuICAgICAgICBpZiAodHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYzA6IEZwMi5tdWwoYzAsIHJocyksXG4gICAgICAgICAgICAgICAgYzE6IEZwMi5tdWwoYzEsIHJocyksXG4gICAgICAgICAgICAgICAgYzI6IEZwMi5tdWwoYzIsIHJocyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgYzA6IHIwLCBjMTogcjEsIGMyOiByMiB9ID0gcmhzO1xuICAgICAgICBjb25zdCB0MCA9IEZwMi5tdWwoYzAsIHIwKTsgLy8gYzAgKiBvMFxuICAgICAgICBjb25zdCB0MSA9IEZwMi5tdWwoYzEsIHIxKTsgLy8gYzEgKiBvMVxuICAgICAgICBjb25zdCB0MiA9IEZwMi5tdWwoYzIsIHIyKTsgLy8gYzIgKiBvMlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gdDAgKyAoYzEgKyBjMikgKiAocjEgKiByMikgLSAoVDEgKyBUMikgKiAodSArIDEpXG4gICAgICAgICAgICBjMDogRnAyLmFkZCh0MCwgRnAyLm11bEJ5Tm9ucmVzaWR1ZShGcDIuc3ViKEZwMi5tdWwoRnAyLmFkZChjMSwgYzIpLCBGcDIuYWRkKHIxLCByMikpLCBGcDIuYWRkKHQxLCB0MikpKSksXG4gICAgICAgICAgICAvLyAoYzAgKyBjMSkgKiAocjAgKyByMSkgLSAoVDAgKyBUMSkgKyBUMiAqICh1ICsgMSlcbiAgICAgICAgICAgIGMxOiBGcDIuYWRkKEZwMi5zdWIoRnAyLm11bChGcDIuYWRkKGMwLCBjMSksIEZwMi5hZGQocjAsIHIxKSksIEZwMi5hZGQodDAsIHQxKSksIEZwMi5tdWxCeU5vbnJlc2lkdWUodDIpKSxcbiAgICAgICAgICAgIC8vIFQxICsgKGMwICsgYzIpICogKHIwICsgcjIpIC0gVDAgKyBUMlxuICAgICAgICAgICAgYzI6IEZwMi5zdWIoRnAyLmFkZCh0MSwgRnAyLm11bChGcDIuYWRkKGMwLCBjMiksIEZwMi5hZGQocjAsIHIyKSkpLCBGcDIuYWRkKHQwLCB0MikpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzcXIoeyBjMCwgYzEsIGMyIH0pIHtcbiAgICAgICAgY29uc3QgeyBGcDIgfSA9IHRoaXM7XG4gICAgICAgIGxldCB0MCA9IEZwMi5zcXIoYzApOyAvLyBjMMKyXG4gICAgICAgIGxldCB0MSA9IEZwMi5tdWwoRnAyLm11bChjMCwgYzEpLCBfMm4pOyAvLyAyICogYzAgKiBjMVxuICAgICAgICBsZXQgdDMgPSBGcDIubXVsKEZwMi5tdWwoYzEsIGMyKSwgXzJuKTsgLy8gMiAqIGMxICogYzJcbiAgICAgICAgbGV0IHQ0ID0gRnAyLnNxcihjMik7IC8vIGMywrJcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGMwOiBGcDIuYWRkKEZwMi5tdWxCeU5vbnJlc2lkdWUodDMpLCB0MCksIC8vIFQzICogKHUgKyAxKSArIFQwXG4gICAgICAgICAgICBjMTogRnAyLmFkZChGcDIubXVsQnlOb25yZXNpZHVlKHQ0KSwgdDEpLCAvLyBUNCAqICh1ICsgMSkgKyBUMVxuICAgICAgICAgICAgLy8gVDEgKyAoYzAgLSBjMSArIGMyKcKyICsgVDMgLSBUMCAtIFQ0XG4gICAgICAgICAgICBjMjogRnAyLnN1YihGcDIuc3ViKEZwMi5hZGQoRnAyLmFkZCh0MSwgRnAyLnNxcihGcDIuYWRkKEZwMi5zdWIoYzAsIGMxKSwgYzIpKSksIHQzKSwgdDApLCB0NCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFkZE4oYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQoYSwgYik7XG4gICAgfVxuICAgIHN1Yk4oYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWIoYSwgYik7XG4gICAgfVxuICAgIG11bE4oYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5tdWwoYSwgYik7XG4gICAgfVxuICAgIHNxck4oYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zcXIoYSk7XG4gICAgfVxuICAgIGNyZWF0ZShudW0pIHtcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICB9XG4gICAgaXNWYWxpZCh7IGMwLCBjMSwgYzIgfSkge1xuICAgICAgICBjb25zdCB7IEZwMiB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIEZwMi5pc1ZhbGlkKGMwKSAmJiBGcDIuaXNWYWxpZChjMSkgJiYgRnAyLmlzVmFsaWQoYzIpO1xuICAgIH1cbiAgICBpczAoeyBjMCwgYzEsIGMyIH0pIHtcbiAgICAgICAgY29uc3QgeyBGcDIgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBGcDIuaXMwKGMwKSAmJiBGcDIuaXMwKGMxKSAmJiBGcDIuaXMwKGMyKTtcbiAgICB9XG4gICAgaXNWYWxpZE5vdDAobnVtKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5pczAobnVtKSAmJiB0aGlzLmlzVmFsaWQobnVtKTtcbiAgICB9XG4gICAgbmVnKHsgYzAsIGMxLCBjMiB9KSB7XG4gICAgICAgIGNvbnN0IHsgRnAyIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4geyBjMDogRnAyLm5lZyhjMCksIGMxOiBGcDIubmVnKGMxKSwgYzI6IEZwMi5uZWcoYzIpIH07XG4gICAgfVxuICAgIGVxbCh7IGMwLCBjMSwgYzIgfSwgeyBjMDogcjAsIGMxOiByMSwgYzI6IHIyIH0pIHtcbiAgICAgICAgY29uc3QgeyBGcDIgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBGcDIuZXFsKGMwLCByMCkgJiYgRnAyLmVxbChjMSwgcjEpICYmIEZwMi5lcWwoYzIsIHIyKTtcbiAgICB9XG4gICAgc3FydChfKSB7XG4gICAgICAgIHJldHVybiBub3RJbXBsZW1lbnRlZCgpO1xuICAgIH1cbiAgICAvLyBEbyB3ZSBuZWVkIGRpdmlzaW9uIGJ5IGJpZ2ludCBhdCBhbGw/IFNob3VsZCBiZSBkb25lIHZpYSBvcmRlcjpcbiAgICBkaXYobGhzLCByaHMpIHtcbiAgICAgICAgY29uc3QgeyBGcDIgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgRnAgfSA9IEZwMjtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsKGxocywgdHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcgPyBGcC5pbnYoRnAuY3JlYXRlKHJocykpIDogdGhpcy5pbnYocmhzKSk7XG4gICAgfVxuICAgIHBvdyhudW0sIHBvd2VyKSB7XG4gICAgICAgIHJldHVybiBtb2QuRnBQb3codGhpcywgbnVtLCBwb3dlcik7XG4gICAgfVxuICAgIGludmVydEJhdGNoKG51bXMpIHtcbiAgICAgICAgcmV0dXJuIG1vZC5GcEludmVydEJhdGNoKHRoaXMsIG51bXMpO1xuICAgIH1cbiAgICBpbnYoeyBjMCwgYzEsIGMyIH0pIHtcbiAgICAgICAgY29uc3QgeyBGcDIgfSA9IHRoaXM7XG4gICAgICAgIGxldCB0MCA9IEZwMi5zdWIoRnAyLnNxcihjMCksIEZwMi5tdWxCeU5vbnJlc2lkdWUoRnAyLm11bChjMiwgYzEpKSk7IC8vIGMwwrIgLSBjMiAqIGMxICogKHUgKyAxKVxuICAgICAgICBsZXQgdDEgPSBGcDIuc3ViKEZwMi5tdWxCeU5vbnJlc2lkdWUoRnAyLnNxcihjMikpLCBGcDIubXVsKGMwLCBjMSkpOyAvLyBjMsKyICogKHUgKyAxKSAtIGMwICogYzFcbiAgICAgICAgbGV0IHQyID0gRnAyLnN1YihGcDIuc3FyKGMxKSwgRnAyLm11bChjMCwgYzIpKTsgLy8gYzHCsiAtIGMwICogYzJcbiAgICAgICAgLy8gMS8oKChjMiAqIFQxICsgYzEgKiBUMikgKiB2KSArIGMwICogVDApXG4gICAgICAgIGxldCB0NCA9IEZwMi5pbnYoRnAyLmFkZChGcDIubXVsQnlOb25yZXNpZHVlKEZwMi5hZGQoRnAyLm11bChjMiwgdDEpLCBGcDIubXVsKGMxLCB0MikpKSwgRnAyLm11bChjMCwgdDApKSk7XG4gICAgICAgIHJldHVybiB7IGMwOiBGcDIubXVsKHQ0LCB0MCksIGMxOiBGcDIubXVsKHQ0LCB0MSksIGMyOiBGcDIubXVsKHQ0LCB0MikgfTtcbiAgICB9XG4gICAgLy8gQnl0ZXMgdXRpbHNcbiAgICBmcm9tQnl0ZXMoYikge1xuICAgICAgICBjb25zdCB7IEZwMiB9ID0gdGhpcztcbiAgICAgICAgaWYgKGIubGVuZ3RoICE9PSB0aGlzLkJZVEVTKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmcm9tQnl0ZXMgaW52YWxpZCBsZW5ndGg9JyArIGIubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgQjIgPSBGcDIuQllURVM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjMDogRnAyLmZyb21CeXRlcyhiLnN1YmFycmF5KDAsIEIyKSksXG4gICAgICAgICAgICBjMTogRnAyLmZyb21CeXRlcyhiLnN1YmFycmF5KEIyLCBCMiAqIDIpKSxcbiAgICAgICAgICAgIGMyOiBGcDIuZnJvbUJ5dGVzKGIuc3ViYXJyYXkoMiAqIEIyKSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHRvQnl0ZXMoeyBjMCwgYzEsIGMyIH0pIHtcbiAgICAgICAgY29uc3QgeyBGcDIgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBjb25jYXRCeXRlcyhGcDIudG9CeXRlcyhjMCksIEZwMi50b0J5dGVzKGMxKSwgRnAyLnRvQnl0ZXMoYzIpKTtcbiAgICB9XG4gICAgY21vdih7IGMwLCBjMSwgYzIgfSwgeyBjMDogcjAsIGMxOiByMSwgYzI6IHIyIH0sIGMpIHtcbiAgICAgICAgY29uc3QgeyBGcDIgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjMDogRnAyLmNtb3YoYzAsIHIwLCBjKSxcbiAgICAgICAgICAgIGMxOiBGcDIuY21vdihjMSwgcjEsIGMpLFxuICAgICAgICAgICAgYzI6IEZwMi5jbW92KGMyLCByMiwgYyksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZyb21CaWdTaXgodCkge1xuICAgICAgICBjb25zdCB7IEZwMiB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHQpIHx8IHQubGVuZ3RoICE9PSA2KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIEZwNiB1c2FnZScpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYzA6IEZwMi5mcm9tQmlnVHVwbGUodC5zbGljZSgwLCAyKSksXG4gICAgICAgICAgICBjMTogRnAyLmZyb21CaWdUdXBsZSh0LnNsaWNlKDIsIDQpKSxcbiAgICAgICAgICAgIGMyOiBGcDIuZnJvbUJpZ1R1cGxlKHQuc2xpY2UoNCwgNikpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmcm9iZW5pdXNNYXAoeyBjMCwgYzEsIGMyIH0sIHBvd2VyKSB7XG4gICAgICAgIGNvbnN0IHsgRnAyIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYzA6IEZwMi5mcm9iZW5pdXNNYXAoYzAsIHBvd2VyKSxcbiAgICAgICAgICAgIGMxOiBGcDIubXVsKEZwMi5mcm9iZW5pdXNNYXAoYzEsIHBvd2VyKSwgdGhpcy5GUk9CRU5JVVNfQ09FRkZJQ0lFTlRTXzFbcG93ZXIgJSA2XSksXG4gICAgICAgICAgICBjMjogRnAyLm11bChGcDIuZnJvYmVuaXVzTWFwKGMyLCBwb3dlciksIHRoaXMuRlJPQkVOSVVTX0NPRUZGSUNJRU5UU18yW3Bvd2VyICUgNl0pLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBtdWxCeUZwMih7IGMwLCBjMSwgYzIgfSwgcmhzKSB7XG4gICAgICAgIGNvbnN0IHsgRnAyIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYzA6IEZwMi5tdWwoYzAsIHJocyksXG4gICAgICAgICAgICBjMTogRnAyLm11bChjMSwgcmhzKSxcbiAgICAgICAgICAgIGMyOiBGcDIubXVsKGMyLCByaHMpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBtdWxCeU5vbnJlc2lkdWUoeyBjMCwgYzEsIGMyIH0pIHtcbiAgICAgICAgY29uc3QgeyBGcDIgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7IGMwOiBGcDIubXVsQnlOb25yZXNpZHVlKGMyKSwgYzE6IGMwLCBjMjogYzEgfTtcbiAgICB9XG4gICAgLy8gU3BhcnNlIG11bHRpcGxpY2F0aW9uXG4gICAgbXVsMSh7IGMwLCBjMSwgYzIgfSwgYjEpIHtcbiAgICAgICAgY29uc3QgeyBGcDIgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjMDogRnAyLm11bEJ5Tm9ucmVzaWR1ZShGcDIubXVsKGMyLCBiMSkpLFxuICAgICAgICAgICAgYzE6IEZwMi5tdWwoYzAsIGIxKSxcbiAgICAgICAgICAgIGMyOiBGcDIubXVsKGMxLCBiMSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFNwYXJzZSBtdWx0aXBsaWNhdGlvblxuICAgIG11bDAxKHsgYzAsIGMxLCBjMiB9LCBiMCwgYjEpIHtcbiAgICAgICAgY29uc3QgeyBGcDIgfSA9IHRoaXM7XG4gICAgICAgIGxldCB0MCA9IEZwMi5tdWwoYzAsIGIwKTsgLy8gYzAgKiBiMFxuICAgICAgICBsZXQgdDEgPSBGcDIubXVsKGMxLCBiMSk7IC8vIGMxICogYjFcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vICgoYzEgKyBjMikgKiBiMSAtIFQxKSAqICh1ICsgMSkgKyBUMFxuICAgICAgICAgICAgYzA6IEZwMi5hZGQoRnAyLm11bEJ5Tm9ucmVzaWR1ZShGcDIuc3ViKEZwMi5tdWwoRnAyLmFkZChjMSwgYzIpLCBiMSksIHQxKSksIHQwKSxcbiAgICAgICAgICAgIC8vIChiMCArIGIxKSAqIChjMCArIGMxKSAtIFQwIC0gVDFcbiAgICAgICAgICAgIGMxOiBGcDIuc3ViKEZwMi5zdWIoRnAyLm11bChGcDIuYWRkKGIwLCBiMSksIEZwMi5hZGQoYzAsIGMxKSksIHQwKSwgdDEpLFxuICAgICAgICAgICAgLy8gKGMwICsgYzIpICogYjAgLSBUMCArIFQxXG4gICAgICAgICAgICBjMjogRnAyLmFkZChGcDIuc3ViKEZwMi5tdWwoRnAyLmFkZChjMCwgYzIpLCBiMCksIHQwKSwgdDEpLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmNsYXNzIF9GaWVsZDEyIHtcbiAgICBjb25zdHJ1Y3RvcihGcDYsIG9wdHMpIHtcbiAgICAgICAgdGhpcy5NQVNLID0gXzFuO1xuICAgICAgICBjb25zdCB7IEZwMiB9ID0gRnA2O1xuICAgICAgICBjb25zdCB7IEZwIH0gPSBGcDI7XG4gICAgICAgIHRoaXMuRnA2ID0gRnA2O1xuICAgICAgICB0aGlzLk9SREVSID0gRnAyLk9SREVSOyAvLyBUT0RPOiB2ZXJpZnkgaWYgaXQncyB1bnVlc2RcbiAgICAgICAgdGhpcy5CSVRTID0gMiAqIEZwNi5CSVRTO1xuICAgICAgICB0aGlzLkJZVEVTID0gMiAqIEZwNi5CWVRFUztcbiAgICAgICAgdGhpcy5pc0xFID0gRnA2LmlzTEU7XG4gICAgICAgIHRoaXMuWkVSTyA9IHsgYzA6IEZwNi5aRVJPLCBjMTogRnA2LlpFUk8gfTtcbiAgICAgICAgdGhpcy5PTkUgPSB7IGMwOiBGcDYuT05FLCBjMTogRnA2LlpFUk8gfTtcbiAgICAgICAgdGhpcy5GUk9CRU5JVVNfQ09FRkZJQ0lFTlRTID0gY2FsY0Zyb2Jlbml1c0NvZWZmaWNpZW50cyhGcDIsIEZwMi5OT05SRVNJRFVFLCBGcC5PUkRFUiwgMTIsIDEsIDYpWzBdO1xuICAgICAgICB0aGlzLlhfTEVOID0gb3B0cy5YX0xFTjtcbiAgICAgICAgdGhpcy5maW5hbEV4cG9uZW50aWF0ZSA9IG9wdHMuRnAxMmZpbmFsRXhwb25lbnRpYXRlO1xuICAgIH1cbiAgICBjcmVhdGUobnVtKSB7XG4gICAgICAgIHJldHVybiBudW07XG4gICAgfVxuICAgIGlzVmFsaWQoeyBjMCwgYzEgfSkge1xuICAgICAgICBjb25zdCB7IEZwNiB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIEZwNi5pc1ZhbGlkKGMwKSAmJiBGcDYuaXNWYWxpZChjMSk7XG4gICAgfVxuICAgIGlzMCh7IGMwLCBjMSB9KSB7XG4gICAgICAgIGNvbnN0IHsgRnA2IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gRnA2LmlzMChjMCkgJiYgRnA2LmlzMChjMSk7XG4gICAgfVxuICAgIGlzVmFsaWROb3QwKG51bSkge1xuICAgICAgICByZXR1cm4gIXRoaXMuaXMwKG51bSkgJiYgdGhpcy5pc1ZhbGlkKG51bSk7XG4gICAgfVxuICAgIG5lZyh7IGMwLCBjMSB9KSB7XG4gICAgICAgIGNvbnN0IHsgRnA2IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4geyBjMDogRnA2Lm5lZyhjMCksIGMxOiBGcDYubmVnKGMxKSB9O1xuICAgIH1cbiAgICBlcWwoeyBjMCwgYzEgfSwgeyBjMDogcjAsIGMxOiByMSB9KSB7XG4gICAgICAgIGNvbnN0IHsgRnA2IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gRnA2LmVxbChjMCwgcjApICYmIEZwNi5lcWwoYzEsIHIxKTtcbiAgICB9XG4gICAgc3FydChfKSB7XG4gICAgICAgIG5vdEltcGxlbWVudGVkKCk7XG4gICAgfVxuICAgIGludih7IGMwLCBjMSB9KSB7XG4gICAgICAgIGNvbnN0IHsgRnA2IH0gPSB0aGlzO1xuICAgICAgICBsZXQgdCA9IEZwNi5pbnYoRnA2LnN1YihGcDYuc3FyKGMwKSwgRnA2Lm11bEJ5Tm9ucmVzaWR1ZShGcDYuc3FyKGMxKSkpKTsgLy8gMSAvIChjMMKyIC0gYzHCsiAqIHYpXG4gICAgICAgIHJldHVybiB7IGMwOiBGcDYubXVsKGMwLCB0KSwgYzE6IEZwNi5uZWcoRnA2Lm11bChjMSwgdCkpIH07IC8vICgoQzAgKiBUKSAqIFQpICsgKC1DMSAqIFQpICogd1xuICAgIH1cbiAgICBkaXYobGhzLCByaHMpIHtcbiAgICAgICAgY29uc3QgeyBGcDYgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgRnAyIH0gPSBGcDY7XG4gICAgICAgIGNvbnN0IHsgRnAgfSA9IEZwMjtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsKGxocywgdHlwZW9mIHJocyA9PT0gJ2JpZ2ludCcgPyBGcC5pbnYoRnAuY3JlYXRlKHJocykpIDogdGhpcy5pbnYocmhzKSk7XG4gICAgfVxuICAgIHBvdyhudW0sIHBvd2VyKSB7XG4gICAgICAgIHJldHVybiBtb2QuRnBQb3codGhpcywgbnVtLCBwb3dlcik7XG4gICAgfVxuICAgIGludmVydEJhdGNoKG51bXMpIHtcbiAgICAgICAgcmV0dXJuIG1vZC5GcEludmVydEJhdGNoKHRoaXMsIG51bXMpO1xuICAgIH1cbiAgICAvLyBOb3JtYWxpemVkXG4gICAgYWRkKHsgYzAsIGMxIH0sIHsgYzA6IHIwLCBjMTogcjEgfSkge1xuICAgICAgICBjb25zdCB7IEZwNiB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGMwOiBGcDYuYWRkKGMwLCByMCksXG4gICAgICAgICAgICBjMTogRnA2LmFkZChjMSwgcjEpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdWIoeyBjMCwgYzEgfSwgeyBjMDogcjAsIGMxOiByMSB9KSB7XG4gICAgICAgIGNvbnN0IHsgRnA2IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYzA6IEZwNi5zdWIoYzAsIHIwKSxcbiAgICAgICAgICAgIGMxOiBGcDYuc3ViKGMxLCByMSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIG11bCh7IGMwLCBjMSB9LCByaHMpIHtcbiAgICAgICAgY29uc3QgeyBGcDYgfSA9IHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2YgcmhzID09PSAnYmlnaW50JylcbiAgICAgICAgICAgIHJldHVybiB7IGMwOiBGcDYubXVsKGMwLCByaHMpLCBjMTogRnA2Lm11bChjMSwgcmhzKSB9O1xuICAgICAgICBsZXQgeyBjMDogcjAsIGMxOiByMSB9ID0gcmhzO1xuICAgICAgICBsZXQgdDEgPSBGcDYubXVsKGMwLCByMCk7IC8vIGMwICogcjBcbiAgICAgICAgbGV0IHQyID0gRnA2Lm11bChjMSwgcjEpOyAvLyBjMSAqIHIxXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjMDogRnA2LmFkZCh0MSwgRnA2Lm11bEJ5Tm9ucmVzaWR1ZSh0MikpLCAvLyBUMSArIFQyICogdlxuICAgICAgICAgICAgLy8gKGMwICsgYzEpICogKHIwICsgcjEpIC0gKFQxICsgVDIpXG4gICAgICAgICAgICBjMTogRnA2LnN1YihGcDYubXVsKEZwNi5hZGQoYzAsIGMxKSwgRnA2LmFkZChyMCwgcjEpKSwgRnA2LmFkZCh0MSwgdDIpKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3FyKHsgYzAsIGMxIH0pIHtcbiAgICAgICAgY29uc3QgeyBGcDYgfSA9IHRoaXM7XG4gICAgICAgIGxldCBhYiA9IEZwNi5tdWwoYzAsIGMxKTsgLy8gYzAgKiBjMVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gKGMxICogdiArIGMwKSAqIChjMCArIGMxKSAtIEFCIC0gQUIgKiB2XG4gICAgICAgICAgICBjMDogRnA2LnN1YihGcDYuc3ViKEZwNi5tdWwoRnA2LmFkZChGcDYubXVsQnlOb25yZXNpZHVlKGMxKSwgYzApLCBGcDYuYWRkKGMwLCBjMSkpLCBhYiksIEZwNi5tdWxCeU5vbnJlc2lkdWUoYWIpKSxcbiAgICAgICAgICAgIGMxOiBGcDYuYWRkKGFiLCBhYiksXG4gICAgICAgIH07IC8vIEFCICsgQUJcbiAgICB9XG4gICAgLy8gTm9uTm9ybWFsaXplZCBzdHVmZlxuICAgIGFkZE4oYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQoYSwgYik7XG4gICAgfVxuICAgIHN1Yk4oYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWIoYSwgYik7XG4gICAgfVxuICAgIG11bE4oYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5tdWwoYSwgYik7XG4gICAgfVxuICAgIHNxck4oYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zcXIoYSk7XG4gICAgfVxuICAgIC8vIEJ5dGVzIHV0aWxzXG4gICAgZnJvbUJ5dGVzKGIpIHtcbiAgICAgICAgY29uc3QgeyBGcDYgfSA9IHRoaXM7XG4gICAgICAgIGlmIChiLmxlbmd0aCAhPT0gdGhpcy5CWVRFUylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZnJvbUJ5dGVzIGludmFsaWQgbGVuZ3RoPScgKyBiLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjMDogRnA2LmZyb21CeXRlcyhiLnN1YmFycmF5KDAsIEZwNi5CWVRFUykpLFxuICAgICAgICAgICAgYzE6IEZwNi5mcm9tQnl0ZXMoYi5zdWJhcnJheShGcDYuQllURVMpKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdG9CeXRlcyh7IGMwLCBjMSB9KSB7XG4gICAgICAgIGNvbnN0IHsgRnA2IH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoRnA2LnRvQnl0ZXMoYzApLCBGcDYudG9CeXRlcyhjMSkpO1xuICAgIH1cbiAgICBjbW92KHsgYzAsIGMxIH0sIHsgYzA6IHIwLCBjMTogcjEgfSwgYykge1xuICAgICAgICBjb25zdCB7IEZwNiB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGMwOiBGcDYuY21vdihjMCwgcjAsIGMpLFxuICAgICAgICAgICAgYzE6IEZwNi5jbW92KGMxLCByMSwgYyksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFV0aWxzXG4gICAgLy8gdG9TdHJpbmcoKSB7XG4gICAgLy8gICByZXR1cm4gJycgKyAnRnAxMignICsgdGhpcy5jMCArIHRoaXMuYzEgKyAnKiB3Jyk7XG4gICAgLy8gfSxcbiAgICAvLyBmcm9tVHVwbGUoYzogW0ZwNiwgRnA2XSkge1xuICAgIC8vICAgcmV0dXJuIG5ldyBGcDEyKC4uLmMpO1xuICAgIC8vIH1cbiAgICBmcm9tQmlnVHdlbHZlKHQpIHtcbiAgICAgICAgY29uc3QgeyBGcDYgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjMDogRnA2LmZyb21CaWdTaXgodC5zbGljZSgwLCA2KSksXG4gICAgICAgICAgICBjMTogRnA2LmZyb21CaWdTaXgodC5zbGljZSg2LCAxMikpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBSYWlzZXMgdG8gcSoqaSAtdGggcG93ZXJcbiAgICBmcm9iZW5pdXNNYXAobGhzLCBwb3dlcikge1xuICAgICAgICBjb25zdCB7IEZwNiB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBGcDIgfSA9IEZwNjtcbiAgICAgICAgY29uc3QgeyBjMCwgYzEsIGMyIH0gPSBGcDYuZnJvYmVuaXVzTWFwKGxocy5jMSwgcG93ZXIpO1xuICAgICAgICBjb25zdCBjb2VmZiA9IHRoaXMuRlJPQkVOSVVTX0NPRUZGSUNJRU5UU1twb3dlciAlIDEyXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGMwOiBGcDYuZnJvYmVuaXVzTWFwKGxocy5jMCwgcG93ZXIpLFxuICAgICAgICAgICAgYzE6IEZwNi5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIGMwOiBGcDIubXVsKGMwLCBjb2VmZiksXG4gICAgICAgICAgICAgICAgYzE6IEZwMi5tdWwoYzEsIGNvZWZmKSxcbiAgICAgICAgICAgICAgICBjMjogRnAyLm11bChjMiwgY29lZmYpLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIG11bEJ5RnAyKHsgYzAsIGMxIH0sIHJocykge1xuICAgICAgICBjb25zdCB7IEZwNiB9ID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGMwOiBGcDYubXVsQnlGcDIoYzAsIHJocyksXG4gICAgICAgICAgICBjMTogRnA2Lm11bEJ5RnAyKGMxLCByaHMpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25qdWdhdGUoeyBjMCwgYzEgfSkge1xuICAgICAgICByZXR1cm4geyBjMCwgYzE6IHRoaXMuRnA2Lm5lZyhjMSkgfTtcbiAgICB9XG4gICAgLy8gU3BhcnNlIG11bHRpcGxpY2F0aW9uXG4gICAgbXVsMDE0KHsgYzAsIGMxIH0sIG8wLCBvMSwgbzQpIHtcbiAgICAgICAgY29uc3QgeyBGcDYgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgRnAyIH0gPSBGcDY7XG4gICAgICAgIGxldCB0MCA9IEZwNi5tdWwwMShjMCwgbzAsIG8xKTtcbiAgICAgICAgbGV0IHQxID0gRnA2Lm11bDEoYzEsIG80KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGMwOiBGcDYuYWRkKEZwNi5tdWxCeU5vbnJlc2lkdWUodDEpLCB0MCksIC8vIFQxICogdiArIFQwXG4gICAgICAgICAgICAvLyAoYzEgKyBjMCkgKiBbbzAsIG8xK280XSAtIFQwIC0gVDFcbiAgICAgICAgICAgIGMxOiBGcDYuc3ViKEZwNi5zdWIoRnA2Lm11bDAxKEZwNi5hZGQoYzEsIGMwKSwgbzAsIEZwMi5hZGQobzEsIG80KSksIHQwKSwgdDEpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBtdWwwMzQoeyBjMCwgYzEgfSwgbzAsIG8zLCBvNCkge1xuICAgICAgICBjb25zdCB7IEZwNiB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBGcDIgfSA9IEZwNjtcbiAgICAgICAgY29uc3QgYSA9IEZwNi5jcmVhdGUoe1xuICAgICAgICAgICAgYzA6IEZwMi5tdWwoYzAuYzAsIG8wKSxcbiAgICAgICAgICAgIGMxOiBGcDIubXVsKGMwLmMxLCBvMCksXG4gICAgICAgICAgICBjMjogRnAyLm11bChjMC5jMiwgbzApLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYiA9IEZwNi5tdWwwMShjMSwgbzMsIG80KTtcbiAgICAgICAgY29uc3QgZSA9IEZwNi5tdWwwMShGcDYuYWRkKGMwLCBjMSksIEZwMi5hZGQobzAsIG8zKSwgbzQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYzA6IEZwNi5hZGQoRnA2Lm11bEJ5Tm9ucmVzaWR1ZShiKSwgYSksXG4gICAgICAgICAgICBjMTogRnA2LnN1YihlLCBGcDYuYWRkKGEsIGIpKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQSBjeWNsb3RvbWljIGdyb3VwIGlzIGEgc3ViZ3JvdXAgb2YgRnBebiBkZWZpbmVkIGJ5XG4gICAgLy8gICBHzqbigpkocCkgPSB7zrEg4oiIIEZw4oG/IDogzrFezqbigpkocCkgPSAxfVxuICAgIC8vIFRoZSByZXN1bHQgb2YgYW55IHBhaXJpbmcgaXMgaW4gYSBjeWNsb3RvbWljIHN1Ymdyb3VwXG4gICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAwOS81NjUucGRmXG4gICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMC8zNTQucGRmXG4gICAgX2N5Y2xvdG9taWNTcXVhcmUoeyBjMCwgYzEgfSkge1xuICAgICAgICBjb25zdCB7IEZwNiB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBGcDIgfSA9IEZwNjtcbiAgICAgICAgY29uc3QgeyBjMDogYzBjMCwgYzE6IGMwYzEsIGMyOiBjMGMyIH0gPSBjMDtcbiAgICAgICAgY29uc3QgeyBjMDogYzFjMCwgYzE6IGMxYzEsIGMyOiBjMWMyIH0gPSBjMTtcbiAgICAgICAgY29uc3QgeyBmaXJzdDogdDMsIHNlY29uZDogdDQgfSA9IEZwMi5GcDRTcXVhcmUoYzBjMCwgYzFjMSk7XG4gICAgICAgIGNvbnN0IHsgZmlyc3Q6IHQ1LCBzZWNvbmQ6IHQ2IH0gPSBGcDIuRnA0U3F1YXJlKGMxYzAsIGMwYzIpO1xuICAgICAgICBjb25zdCB7IGZpcnN0OiB0Nywgc2Vjb25kOiB0OCB9ID0gRnAyLkZwNFNxdWFyZShjMGMxLCBjMWMyKTtcbiAgICAgICAgY29uc3QgdDkgPSBGcDIubXVsQnlOb25yZXNpZHVlKHQ4KTsgLy8gVDggKiAodSArIDEpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjMDogRnA2LmNyZWF0ZSh7XG4gICAgICAgICAgICAgICAgYzA6IEZwMi5hZGQoRnAyLm11bChGcDIuc3ViKHQzLCBjMGMwKSwgXzJuKSwgdDMpLCAvLyAyICogKFQzIC0gYzBjMCkgICsgVDNcbiAgICAgICAgICAgICAgICBjMTogRnAyLmFkZChGcDIubXVsKEZwMi5zdWIodDUsIGMwYzEpLCBfMm4pLCB0NSksIC8vIDIgKiAoVDUgLSBjMGMxKSAgKyBUNVxuICAgICAgICAgICAgICAgIGMyOiBGcDIuYWRkKEZwMi5tdWwoRnAyLnN1Yih0NywgYzBjMiksIF8ybiksIHQ3KSxcbiAgICAgICAgICAgIH0pLCAvLyAyICogKFQ3IC0gYzBjMikgICsgVDdcbiAgICAgICAgICAgIGMxOiBGcDYuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBjMDogRnAyLmFkZChGcDIubXVsKEZwMi5hZGQodDksIGMxYzApLCBfMm4pLCB0OSksIC8vIDIgKiAoVDkgKyBjMWMwKSArIFQ5XG4gICAgICAgICAgICAgICAgYzE6IEZwMi5hZGQoRnAyLm11bChGcDIuYWRkKHQ0LCBjMWMxKSwgXzJuKSwgdDQpLCAvLyAyICogKFQ0ICsgYzFjMSkgKyBUNFxuICAgICAgICAgICAgICAgIGMyOiBGcDIuYWRkKEZwMi5tdWwoRnAyLmFkZCh0NiwgYzFjMiksIF8ybiksIHQ2KSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9OyAvLyAyICogKFQ2ICsgYzFjMikgKyBUNlxuICAgIH1cbiAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDA5LzU2NS5wZGZcbiAgICBfY3ljbG90b21pY0V4cChudW0sIG4pIHtcbiAgICAgICAgbGV0IHogPSB0aGlzLk9ORTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuWF9MRU4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgeiA9IHRoaXMuX2N5Y2xvdG9taWNTcXVhcmUoeik7XG4gICAgICAgICAgICBpZiAoYml0R2V0KG4sIGkpKVxuICAgICAgICAgICAgICAgIHogPSB0aGlzLm11bCh6LCBudW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB6O1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB0b3dlcjEyKG9wdHMpIHtcbiAgICBjb25zdCBGcCA9IG1vZC5GaWVsZChvcHRzLk9SREVSKTtcbiAgICBjb25zdCBGcDIgPSBuZXcgX0ZpZWxkMihGcCwgb3B0cyk7XG4gICAgY29uc3QgRnA2ID0gbmV3IF9GaWVsZDYoRnAyKTtcbiAgICBjb25zdCBGcDEyID0gbmV3IF9GaWVsZDEyKEZwNiwgb3B0cyk7XG4gICAgcmV0dXJuIHsgRnAsIEZwMiwgRnA2LCBGcDEyIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b3dlci5qcy5tYXAiXSwibmFtZXMiOlsiYml0R2V0IiwiYml0TGVuIiwiY29uY2F0Qnl0ZXMiLCJub3RJbXBsZW1lbnRlZCIsIm1vZCIsIl8wbiIsIkJpZ0ludCIsIl8xbiIsIl8ybiIsIl8zbiIsImNhbGNGcm9iZW5pdXNDb2VmZmljaWVudHMiLCJGcCIsIm5vblJlc2lkdWUiLCJtb2R1bHVzIiwiZGVncmVlIiwibnVtIiwiZGl2aXNvciIsIl9kaXZpc29yIiwidW5kZWZpbmVkIiwidG93ZXJNb2R1bHVzIiwicmVzIiwiaSIsImEiLCJwb3dlcnMiLCJqIiwicVBvd2VyIiwicG93ZXIiLCJwdXNoIiwicG93IiwicHNpRnJvYmVuaXVzIiwiRnAyIiwiYmFzZSIsIlBTSV9YIiwiT1JERVIiLCJQU0lfWSIsInBzaSIsIngiLCJ5IiwieDIiLCJtdWwiLCJmcm9iZW5pdXNNYXAiLCJ5MiIsIlBTSTJfWCIsIlBTSTJfWSIsImVxbCIsIm5lZyIsIk9ORSIsIkVycm9yIiwicHNpMiIsIm1hcEFmZmluZSIsImZuIiwiYyIsIlAiLCJhZmZpbmUiLCJ0b0FmZmluZSIsInAiLCJmcm9tQWZmaW5lIiwiRzJwc2kiLCJHMnBzaTIiLCJGcDJmcm9tQmlnVHVwbGUiLCJ0dXBsZSIsImxlbmd0aCIsImZwcyIsIm1hcCIsIm4iLCJjcmVhdGUiLCJjMCIsImMxIiwiX0ZpZWxkMiIsImNvbnN0cnVjdG9yIiwib3B0cyIsIk1BU0siLCJGUDJfT1JERVIiLCJCSVRTIiwiQllURVMiLCJNYXRoIiwiY2VpbCIsImlzTEUiLCJaRVJPIiwiRnBfTk9OUkVTSURVRSIsIk5PTlJFU0lEVUUiLCJGcF9kaXYyIiwiZGl2IiwiRlAyX05PTlJFU0lEVUUiLCJGUk9CRU5JVVNfQ09FRkZJQ0lFTlRTIiwibXVsQnlCIiwiRnAybXVsQnlCIiwiT2JqZWN0Iiwic2VhbCIsImZyb21CaWdUdXBsZSIsImlzVmFsaWQiLCJpc1ZhbGlkQyIsImlzMCIsImlzVmFsaWROb3QwIiwicjAiLCJyMSIsIkZwUG93IiwiaW52ZXJ0QmF0Y2giLCJudW1zIiwiRnBJbnZlcnRCYXRjaCIsImFkZCIsImYxIiwiZjIiLCJzdWIiLCJyaHMiLCJ0MSIsInQyIiwibzAiLCJvMSIsInNxciIsImIiLCJhZGROIiwic3ViTiIsIm11bE4iLCJzcXJOIiwibGhzIiwiaW52IiwiZmFjdG9yIiwic3FydCIsIkZwTGVnZW5kcmUiLCJkIiwibGVnZW5kcmUiLCJhMCIsImNhbmRpZGF0ZVNxcnQiLCJ4MSIsInJlIiwicmUxIiwiaW0iLCJpbTEiLCJyZWltIiwicmUyIiwiaW0yIiwiaXNPZGQiLCJ4MCIsInNpZ25fMCIsInplcm9fMCIsInNpZ25fMSIsImZyb21CeXRlcyIsInN1YmFycmF5IiwidG9CeXRlcyIsImNtb3YiLCJGcDRTcXVhcmUiLCJhMiIsImIyIiwiZmlyc3QiLCJtdWxCeU5vbnJlc2lkdWUiLCJzZWNvbmQiLCJfRmllbGQ2IiwiYzIiLCJmcm9iIiwiRlJPQkVOSVVTX0NPRUZGSUNJRU5UU18xIiwiRlJPQkVOSVVTX0NPRUZGSUNJRU5UU18yIiwicjIiLCJ0MCIsInQzIiwidDQiLCJfIiwiQjIiLCJmcm9tQmlnU2l4IiwidCIsIkFycmF5IiwiaXNBcnJheSIsInNsaWNlIiwibXVsQnlGcDIiLCJtdWwxIiwiYjEiLCJtdWwwMSIsImIwIiwiX0ZpZWxkMTIiLCJGcDYiLCJYX0xFTiIsImZpbmFsRXhwb25lbnRpYXRlIiwiRnAxMmZpbmFsRXhwb25lbnRpYXRlIiwiYWIiLCJmcm9tQmlnVHdlbHZlIiwiY29lZmYiLCJjb25qdWdhdGUiLCJtdWwwMTQiLCJvNCIsIm11bDAzNCIsIm8zIiwiZSIsIl9jeWNsb3RvbWljU3F1YXJlIiwiYzBjMCIsImMwYzEiLCJjMGMyIiwiYzFjMCIsImMxYzEiLCJjMWMyIiwidDUiLCJ0NiIsInQ3IiwidDgiLCJ0OSIsIl9jeWNsb3RvbWljRXhwIiwieiIsInRvd2VyMTIiLCJGaWVsZCIsIkZwMTIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/tower.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/utils.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/utils.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   aInRange: () => (/* binding */ aInRange),\n/* harmony export */   abool: () => (/* binding */ abool),\n/* harmony export */   abytes: () => (/* binding */ abytes),\n/* harmony export */   anumber: () => (/* binding */ anumber),\n/* harmony export */   asciiToBytes: () => (/* binding */ asciiToBytes),\n/* harmony export */   bitGet: () => (/* binding */ bitGet),\n/* harmony export */   bitLen: () => (/* binding */ bitLen),\n/* harmony export */   bitMask: () => (/* binding */ bitMask),\n/* harmony export */   bitSet: () => (/* binding */ bitSet),\n/* harmony export */   bytesToHex: () => (/* binding */ bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToNumberLE: () => (/* binding */ bytesToNumberLE),\n/* harmony export */   bytesToUtf8: () => (/* binding */ bytesToUtf8),\n/* harmony export */   concatBytes: () => (/* binding */ concatBytes),\n/* harmony export */   copyBytes: () => (/* binding */ copyBytes),\n/* harmony export */   createHmacDrbg: () => (/* binding */ createHmacDrbg),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* binding */ hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   inRange: () => (/* binding */ inRange),\n/* harmony export */   isBytes: () => (/* binding */ isBytes),\n/* harmony export */   isHash: () => (/* binding */ isHash),\n/* harmony export */   memoized: () => (/* binding */ memoized),\n/* harmony export */   notImplemented: () => (/* binding */ notImplemented),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   numberToBytesLE: () => (/* binding */ numberToBytesLE),\n/* harmony export */   numberToHexUnpadded: () => (/* binding */ numberToHexUnpadded),\n/* harmony export */   numberToVarBytesBE: () => (/* binding */ numberToVarBytesBE),\n/* harmony export */   randomBytes: () => (/* binding */ randomBytes),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   validateObject: () => (/* binding */ validateObject)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/utils.js\");\n/**\n * Deprecated module: moved from curves/abstract/utils.js to curves/utils.js\n * @module\n */ \n/** @deprecated moved to `@noble/curves/utils.js` */ const abytes = _utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes;\n/** @deprecated moved to `@noble/curves/utils.js` */ const anumber = _utils_js__WEBPACK_IMPORTED_MODULE_0__.anumber;\n/** @deprecated moved to `@noble/curves/utils.js` */ const bytesToHex = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex;\n/** @deprecated moved to `@noble/curves/utils.js` */ const bytesToUtf8 = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToUtf8;\n/** @deprecated moved to `@noble/curves/utils.js` */ const concatBytes = _utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes;\n/** @deprecated moved to `@noble/curves/utils.js` */ const hexToBytes = _utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes;\n/** @deprecated moved to `@noble/curves/utils.js` */ const isBytes = _utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes;\n/** @deprecated moved to `@noble/curves/utils.js` */ const randomBytes = _utils_js__WEBPACK_IMPORTED_MODULE_0__.randomBytes;\n/** @deprecated moved to `@noble/curves/utils.js` */ const utf8ToBytes = _utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes;\n/** @deprecated moved to `@noble/curves/utils.js` */ const abool = _utils_js__WEBPACK_IMPORTED_MODULE_1__.abool;\n/** @deprecated moved to `@noble/curves/utils.js` */ const numberToHexUnpadded = _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToHexUnpadded;\n/** @deprecated moved to `@noble/curves/utils.js` */ const hexToNumber = _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToNumber;\n/** @deprecated moved to `@noble/curves/utils.js` */ const bytesToNumberBE = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE;\n/** @deprecated moved to `@noble/curves/utils.js` */ const bytesToNumberLE = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE;\n/** @deprecated moved to `@noble/curves/utils.js` */ const numberToBytesBE = _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE;\n/** @deprecated moved to `@noble/curves/utils.js` */ const numberToBytesLE = _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesLE;\n/** @deprecated moved to `@noble/curves/utils.js` */ const numberToVarBytesBE = _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToVarBytesBE;\n/** @deprecated moved to `@noble/curves/utils.js` */ const ensureBytes = _utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes;\n/** @deprecated moved to `@noble/curves/utils.js` */ const equalBytes = _utils_js__WEBPACK_IMPORTED_MODULE_1__.equalBytes;\n/** @deprecated moved to `@noble/curves/utils.js` */ const copyBytes = _utils_js__WEBPACK_IMPORTED_MODULE_1__.copyBytes;\n/** @deprecated moved to `@noble/curves/utils.js` */ const asciiToBytes = _utils_js__WEBPACK_IMPORTED_MODULE_1__.asciiToBytes;\n/** @deprecated moved to `@noble/curves/utils.js` */ const inRange = _utils_js__WEBPACK_IMPORTED_MODULE_1__.inRange;\n/** @deprecated moved to `@noble/curves/utils.js` */ const aInRange = _utils_js__WEBPACK_IMPORTED_MODULE_1__.aInRange;\n/** @deprecated moved to `@noble/curves/utils.js` */ const bitLen = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bitLen;\n/** @deprecated moved to `@noble/curves/utils.js` */ const bitGet = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bitGet;\n/** @deprecated moved to `@noble/curves/utils.js` */ const bitSet = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bitSet;\n/** @deprecated moved to `@noble/curves/utils.js` */ const bitMask = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask;\n/** @deprecated moved to `@noble/curves/utils.js` */ const createHmacDrbg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.createHmacDrbg;\n/** @deprecated moved to `@noble/curves/utils.js` */ const notImplemented = _utils_js__WEBPACK_IMPORTED_MODULE_1__.notImplemented;\n/** @deprecated moved to `@noble/curves/utils.js` */ const memoized = _utils_js__WEBPACK_IMPORTED_MODULE_1__.memoized;\n/** @deprecated moved to `@noble/curves/utils.js` */ const validateObject = _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject;\n/** @deprecated moved to `@noble/curves/utils.js` */ const isHash = _utils_js__WEBPACK_IMPORTED_MODULE_1__.isHash; //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjkuNy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Q0FHQyxHQUNnQztBQUNqQyxrREFBa0QsR0FDM0MsTUFBTUMsU0FBU0QsNkNBQVEsQ0FBQztBQUMvQixrREFBa0QsR0FDM0MsTUFBTUUsVUFBVUYsOENBQVMsQ0FBQztBQUNqQyxrREFBa0QsR0FDM0MsTUFBTUcsYUFBYUgsaURBQVksQ0FBQztBQUN2QyxrREFBa0QsR0FDM0MsTUFBTUksY0FBY0osa0RBQWEsQ0FBQztBQUN6QyxrREFBa0QsR0FDM0MsTUFBTUssY0FBY0wsa0RBQWEsQ0FBQztBQUN6QyxrREFBa0QsR0FDM0MsTUFBTU0sYUFBYU4saURBQVksQ0FBQztBQUN2QyxrREFBa0QsR0FDM0MsTUFBTU8sVUFBVVAsOENBQVMsQ0FBQztBQUNqQyxrREFBa0QsR0FDM0MsTUFBTVEsY0FBY1Isa0RBQWEsQ0FBQztBQUN6QyxrREFBa0QsR0FDM0MsTUFBTVMsY0FBY1Qsa0RBQWEsQ0FBQztBQUN6QyxrREFBa0QsR0FDM0MsTUFBTVUsUUFBUVYsNENBQU8sQ0FBQztBQUM3QixrREFBa0QsR0FDM0MsTUFBTVcsc0JBQXNCWCwwREFBcUIsQ0FBQztBQUN6RCxrREFBa0QsR0FDM0MsTUFBTVksY0FBY1osa0RBQWEsQ0FBQztBQUN6QyxrREFBa0QsR0FDM0MsTUFBTWEsa0JBQWtCYixzREFBaUIsQ0FBQztBQUNqRCxrREFBa0QsR0FDM0MsTUFBTWMsa0JBQWtCZCxzREFBaUIsQ0FBQztBQUNqRCxrREFBa0QsR0FDM0MsTUFBTWUsa0JBQWtCZixzREFBaUIsQ0FBQztBQUNqRCxrREFBa0QsR0FDM0MsTUFBTWdCLGtCQUFrQmhCLHNEQUFpQixDQUFDO0FBQ2pELGtEQUFrRCxHQUMzQyxNQUFNaUIscUJBQXFCakIseURBQW9CLENBQUM7QUFDdkQsa0RBQWtELEdBQzNDLE1BQU1rQixjQUFjbEIsa0RBQWEsQ0FBQztBQUN6QyxrREFBa0QsR0FDM0MsTUFBTW1CLGFBQWFuQixpREFBWSxDQUFDO0FBQ3ZDLGtEQUFrRCxHQUMzQyxNQUFNb0IsWUFBWXBCLGdEQUFXLENBQUM7QUFDckMsa0RBQWtELEdBQzNDLE1BQU1xQixlQUFlckIsbURBQWMsQ0FBQztBQUMzQyxrREFBa0QsR0FDM0MsTUFBTXNCLFVBQVV0Qiw4Q0FBUyxDQUFDO0FBQ2pDLGtEQUFrRCxHQUMzQyxNQUFNdUIsV0FBV3ZCLCtDQUFVLENBQUM7QUFDbkMsa0RBQWtELEdBQzNDLE1BQU13QixTQUFTeEIsNkNBQVEsQ0FBQztBQUMvQixrREFBa0QsR0FDM0MsTUFBTXlCLFNBQVN6Qiw2Q0FBUSxDQUFDO0FBQy9CLGtEQUFrRCxHQUMzQyxNQUFNMEIsU0FBUzFCLDZDQUFRLENBQUM7QUFDL0Isa0RBQWtELEdBQzNDLE1BQU0yQixVQUFVM0IsOENBQVMsQ0FBQztBQUNqQyxrREFBa0QsR0FDM0MsTUFBTTRCLGlCQUFpQjVCLHFEQUFnQixDQUFDO0FBQy9DLGtEQUFrRCxHQUMzQyxNQUFNNkIsaUJBQWlCN0IscURBQWdCLENBQUM7QUFDL0Msa0RBQWtELEdBQzNDLE1BQU04QixXQUFXOUIsK0NBQVUsQ0FBQztBQUNuQyxrREFBa0QsR0FDM0MsTUFBTStCLGlCQUFpQi9CLHFEQUFnQixDQUFDO0FBQy9DLGtEQUFrRCxHQUMzQyxNQUFNZ0MsU0FBU2hDLDZDQUFRLENBQUMsQ0FDL0IsaUNBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbm90YXNjYW0tcHJvdG9jb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjkuNy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvdXRpbHMuanM/YmNlYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIERlcHJlY2F0ZWQgbW9kdWxlOiBtb3ZlZCBmcm9tIGN1cnZlcy9hYnN0cmFjdC91dGlscy5qcyB0byBjdXJ2ZXMvdXRpbHMuanNcbiAqIEBtb2R1bGVcbiAqL1xuaW1wb3J0ICogYXMgdSBmcm9tIFwiLi4vdXRpbHMuanNcIjtcbi8qKiBAZGVwcmVjYXRlZCBtb3ZlZCB0byBgQG5vYmxlL2N1cnZlcy91dGlscy5qc2AgKi9cbmV4cG9ydCBjb25zdCBhYnl0ZXMgPSB1LmFieXRlcztcbi8qKiBAZGVwcmVjYXRlZCBtb3ZlZCB0byBgQG5vYmxlL2N1cnZlcy91dGlscy5qc2AgKi9cbmV4cG9ydCBjb25zdCBhbnVtYmVyID0gdS5hbnVtYmVyO1xuLyoqIEBkZXByZWNhdGVkIG1vdmVkIHRvIGBAbm9ibGUvY3VydmVzL3V0aWxzLmpzYCAqL1xuZXhwb3J0IGNvbnN0IGJ5dGVzVG9IZXggPSB1LmJ5dGVzVG9IZXg7XG4vKiogQGRlcHJlY2F0ZWQgbW92ZWQgdG8gYEBub2JsZS9jdXJ2ZXMvdXRpbHMuanNgICovXG5leHBvcnQgY29uc3QgYnl0ZXNUb1V0ZjggPSB1LmJ5dGVzVG9VdGY4O1xuLyoqIEBkZXByZWNhdGVkIG1vdmVkIHRvIGBAbm9ibGUvY3VydmVzL3V0aWxzLmpzYCAqL1xuZXhwb3J0IGNvbnN0IGNvbmNhdEJ5dGVzID0gdS5jb25jYXRCeXRlcztcbi8qKiBAZGVwcmVjYXRlZCBtb3ZlZCB0byBgQG5vYmxlL2N1cnZlcy91dGlscy5qc2AgKi9cbmV4cG9ydCBjb25zdCBoZXhUb0J5dGVzID0gdS5oZXhUb0J5dGVzO1xuLyoqIEBkZXByZWNhdGVkIG1vdmVkIHRvIGBAbm9ibGUvY3VydmVzL3V0aWxzLmpzYCAqL1xuZXhwb3J0IGNvbnN0IGlzQnl0ZXMgPSB1LmlzQnl0ZXM7XG4vKiogQGRlcHJlY2F0ZWQgbW92ZWQgdG8gYEBub2JsZS9jdXJ2ZXMvdXRpbHMuanNgICovXG5leHBvcnQgY29uc3QgcmFuZG9tQnl0ZXMgPSB1LnJhbmRvbUJ5dGVzO1xuLyoqIEBkZXByZWNhdGVkIG1vdmVkIHRvIGBAbm9ibGUvY3VydmVzL3V0aWxzLmpzYCAqL1xuZXhwb3J0IGNvbnN0IHV0ZjhUb0J5dGVzID0gdS51dGY4VG9CeXRlcztcbi8qKiBAZGVwcmVjYXRlZCBtb3ZlZCB0byBgQG5vYmxlL2N1cnZlcy91dGlscy5qc2AgKi9cbmV4cG9ydCBjb25zdCBhYm9vbCA9IHUuYWJvb2w7XG4vKiogQGRlcHJlY2F0ZWQgbW92ZWQgdG8gYEBub2JsZS9jdXJ2ZXMvdXRpbHMuanNgICovXG5leHBvcnQgY29uc3QgbnVtYmVyVG9IZXhVbnBhZGRlZCA9IHUubnVtYmVyVG9IZXhVbnBhZGRlZDtcbi8qKiBAZGVwcmVjYXRlZCBtb3ZlZCB0byBgQG5vYmxlL2N1cnZlcy91dGlscy5qc2AgKi9cbmV4cG9ydCBjb25zdCBoZXhUb051bWJlciA9IHUuaGV4VG9OdW1iZXI7XG4vKiogQGRlcHJlY2F0ZWQgbW92ZWQgdG8gYEBub2JsZS9jdXJ2ZXMvdXRpbHMuanNgICovXG5leHBvcnQgY29uc3QgYnl0ZXNUb051bWJlckJFID0gdS5ieXRlc1RvTnVtYmVyQkU7XG4vKiogQGRlcHJlY2F0ZWQgbW92ZWQgdG8gYEBub2JsZS9jdXJ2ZXMvdXRpbHMuanNgICovXG5leHBvcnQgY29uc3QgYnl0ZXNUb051bWJlckxFID0gdS5ieXRlc1RvTnVtYmVyTEU7XG4vKiogQGRlcHJlY2F0ZWQgbW92ZWQgdG8gYEBub2JsZS9jdXJ2ZXMvdXRpbHMuanNgICovXG5leHBvcnQgY29uc3QgbnVtYmVyVG9CeXRlc0JFID0gdS5udW1iZXJUb0J5dGVzQkU7XG4vKiogQGRlcHJlY2F0ZWQgbW92ZWQgdG8gYEBub2JsZS9jdXJ2ZXMvdXRpbHMuanNgICovXG5leHBvcnQgY29uc3QgbnVtYmVyVG9CeXRlc0xFID0gdS5udW1iZXJUb0J5dGVzTEU7XG4vKiogQGRlcHJlY2F0ZWQgbW92ZWQgdG8gYEBub2JsZS9jdXJ2ZXMvdXRpbHMuanNgICovXG5leHBvcnQgY29uc3QgbnVtYmVyVG9WYXJCeXRlc0JFID0gdS5udW1iZXJUb1ZhckJ5dGVzQkU7XG4vKiogQGRlcHJlY2F0ZWQgbW92ZWQgdG8gYEBub2JsZS9jdXJ2ZXMvdXRpbHMuanNgICovXG5leHBvcnQgY29uc3QgZW5zdXJlQnl0ZXMgPSB1LmVuc3VyZUJ5dGVzO1xuLyoqIEBkZXByZWNhdGVkIG1vdmVkIHRvIGBAbm9ibGUvY3VydmVzL3V0aWxzLmpzYCAqL1xuZXhwb3J0IGNvbnN0IGVxdWFsQnl0ZXMgPSB1LmVxdWFsQnl0ZXM7XG4vKiogQGRlcHJlY2F0ZWQgbW92ZWQgdG8gYEBub2JsZS9jdXJ2ZXMvdXRpbHMuanNgICovXG5leHBvcnQgY29uc3QgY29weUJ5dGVzID0gdS5jb3B5Qnl0ZXM7XG4vKiogQGRlcHJlY2F0ZWQgbW92ZWQgdG8gYEBub2JsZS9jdXJ2ZXMvdXRpbHMuanNgICovXG5leHBvcnQgY29uc3QgYXNjaWlUb0J5dGVzID0gdS5hc2NpaVRvQnl0ZXM7XG4vKiogQGRlcHJlY2F0ZWQgbW92ZWQgdG8gYEBub2JsZS9jdXJ2ZXMvdXRpbHMuanNgICovXG5leHBvcnQgY29uc3QgaW5SYW5nZSA9IHUuaW5SYW5nZTtcbi8qKiBAZGVwcmVjYXRlZCBtb3ZlZCB0byBgQG5vYmxlL2N1cnZlcy91dGlscy5qc2AgKi9cbmV4cG9ydCBjb25zdCBhSW5SYW5nZSA9IHUuYUluUmFuZ2U7XG4vKiogQGRlcHJlY2F0ZWQgbW92ZWQgdG8gYEBub2JsZS9jdXJ2ZXMvdXRpbHMuanNgICovXG5leHBvcnQgY29uc3QgYml0TGVuID0gdS5iaXRMZW47XG4vKiogQGRlcHJlY2F0ZWQgbW92ZWQgdG8gYEBub2JsZS9jdXJ2ZXMvdXRpbHMuanNgICovXG5leHBvcnQgY29uc3QgYml0R2V0ID0gdS5iaXRHZXQ7XG4vKiogQGRlcHJlY2F0ZWQgbW92ZWQgdG8gYEBub2JsZS9jdXJ2ZXMvdXRpbHMuanNgICovXG5leHBvcnQgY29uc3QgYml0U2V0ID0gdS5iaXRTZXQ7XG4vKiogQGRlcHJlY2F0ZWQgbW92ZWQgdG8gYEBub2JsZS9jdXJ2ZXMvdXRpbHMuanNgICovXG5leHBvcnQgY29uc3QgYml0TWFzayA9IHUuYml0TWFzaztcbi8qKiBAZGVwcmVjYXRlZCBtb3ZlZCB0byBgQG5vYmxlL2N1cnZlcy91dGlscy5qc2AgKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVIbWFjRHJiZyA9IHUuY3JlYXRlSG1hY0RyYmc7XG4vKiogQGRlcHJlY2F0ZWQgbW92ZWQgdG8gYEBub2JsZS9jdXJ2ZXMvdXRpbHMuanNgICovXG5leHBvcnQgY29uc3Qgbm90SW1wbGVtZW50ZWQgPSB1Lm5vdEltcGxlbWVudGVkO1xuLyoqIEBkZXByZWNhdGVkIG1vdmVkIHRvIGBAbm9ibGUvY3VydmVzL3V0aWxzLmpzYCAqL1xuZXhwb3J0IGNvbnN0IG1lbW9pemVkID0gdS5tZW1vaXplZDtcbi8qKiBAZGVwcmVjYXRlZCBtb3ZlZCB0byBgQG5vYmxlL2N1cnZlcy91dGlscy5qc2AgKi9cbmV4cG9ydCBjb25zdCB2YWxpZGF0ZU9iamVjdCA9IHUudmFsaWRhdGVPYmplY3Q7XG4vKiogQGRlcHJlY2F0ZWQgbW92ZWQgdG8gYEBub2JsZS9jdXJ2ZXMvdXRpbHMuanNgICovXG5leHBvcnQgY29uc3QgaXNIYXNoID0gdS5pc0hhc2g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOlsidSIsImFieXRlcyIsImFudW1iZXIiLCJieXRlc1RvSGV4IiwiYnl0ZXNUb1V0ZjgiLCJjb25jYXRCeXRlcyIsImhleFRvQnl0ZXMiLCJpc0J5dGVzIiwicmFuZG9tQnl0ZXMiLCJ1dGY4VG9CeXRlcyIsImFib29sIiwibnVtYmVyVG9IZXhVbnBhZGRlZCIsImhleFRvTnVtYmVyIiwiYnl0ZXNUb051bWJlckJFIiwiYnl0ZXNUb051bWJlckxFIiwibnVtYmVyVG9CeXRlc0JFIiwibnVtYmVyVG9CeXRlc0xFIiwibnVtYmVyVG9WYXJCeXRlc0JFIiwiZW5zdXJlQnl0ZXMiLCJlcXVhbEJ5dGVzIiwiY29weUJ5dGVzIiwiYXNjaWlUb0J5dGVzIiwiaW5SYW5nZSIsImFJblJhbmdlIiwiYml0TGVuIiwiYml0R2V0IiwiYml0U2V0IiwiYml0TWFzayIsImNyZWF0ZUhtYWNEcmJnIiwibm90SW1wbGVtZW50ZWQiLCJtZW1vaXplZCIsInZhbGlkYXRlT2JqZWN0IiwiaXNIYXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/utils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: () => (/* binding */ DER),\n/* harmony export */   DERErr: () => (/* binding */ DERErr),\n/* harmony export */   SWUFpSqrtRatio: () => (/* binding */ SWUFpSqrtRatio),\n/* harmony export */   _legacyHelperEquat: () => (/* binding */ _legacyHelperEquat),\n/* harmony export */   _normFnElement: () => (/* binding */ _normFnElement),\n/* harmony export */   _splitEndoScalar: () => (/* binding */ _splitEndoScalar),\n/* harmony export */   ecdh: () => (/* binding */ ecdh),\n/* harmony export */   ecdsa: () => (/* binding */ ecdsa),\n/* harmony export */   mapToCurveSimpleSWU: () => (/* binding */ mapToCurveSimpleSWU),\n/* harmony export */   weierstrass: () => (/* binding */ weierstrass),\n/* harmony export */   weierstrassN: () => (/* binding */ weierstrassN),\n/* harmony export */   weierstrassPoints: () => (/* binding */ weierstrassPoints)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/hmac.js */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/curve.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modular.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/modular.js\");\n/**\n * Short Weierstrass curve methods. The formula is: y² = x³ + ax + b.\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n\n\n// We construct basis in such way that den is always positive and equals n, but num sign depends on basis (not on secret value)\nconst divNearest = (num, den)=>(num + (num >= 0 ? den : -den) / _2n) / den;\n/**\n * Splits scalar for GLV endomorphism.\n */ function _splitEndoScalar(k, basis, n) {\n    // Split scalar into two such that part is ~half bits: `abs(part) < sqrt(N)`\n    // Since part can be negative, we need to do this on point.\n    // TODO: verifyScalar function which consumes lambda\n    const [[a1, b1], [a2, b2]] = basis;\n    const c1 = divNearest(b2 * k, n);\n    const c2 = divNearest(-b1 * k, n);\n    // |k1|/|k2| is < sqrt(N), but can be negative.\n    // If we do `k1 mod N`, we'll get big scalar (`> sqrt(N)`): so, we do cheaper negation instead.\n    let k1 = k - c1 * a1 - c2 * a2;\n    let k2 = -c1 * b1 - c2 * b2;\n    const k1neg = k1 < _0n;\n    const k2neg = k2 < _0n;\n    if (k1neg) k1 = -k1;\n    if (k2neg) k2 = -k2;\n    // Double check that resulting scalar less than half bits of N: otherwise wNAF will fail.\n    // This should only happen on wrong basises. Also, math inside is too complex and I don't trust it.\n    const MAX_NUM = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(Math.ceil((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitLen)(n) / 2)) + _1n; // Half bits of N\n    if (k1 < _0n || k1 >= MAX_NUM || k2 < _0n || k2 >= MAX_NUM) {\n        throw new Error(\"splitScalar (endomorphism): failed, k=\" + k);\n    }\n    return {\n        k1neg,\n        k1,\n        k2neg,\n        k2\n    };\n}\nfunction validateSigFormat(format) {\n    if (![\n        \"compact\",\n        \"recovered\",\n        \"der\"\n    ].includes(format)) throw new Error('Signature format must be \"compact\", \"recovered\", or \"der\"');\n    return format;\n}\nfunction validateSigOpts(opts, def) {\n    const optsn = {};\n    for (let optName of Object.keys(def)){\n        // @ts-ignore\n        optsn[optName] = opts[optName] === undefined ? def[optName] : opts[optName];\n    }\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._abool2)(optsn.lowS, \"lowS\");\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._abool2)(optsn.prehash, \"prehash\");\n    if (optsn.format !== undefined) validateSigFormat(optsn.format);\n    return optsn;\n}\nclass DERErr extends Error {\n    constructor(m = \"\"){\n        super(m);\n    }\n}\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */ const DER = {\n    // asn.1 DER encoding utils\n    Err: DERErr,\n    // Basic building block is TLV (Tag-Length-Value)\n    _tlv: {\n        encode: (tag, data)=>{\n            const { Err: E } = DER;\n            if (tag < 0 || tag > 256) throw new E(\"tlv.encode: wrong tag\");\n            if (data.length & 1) throw new E(\"tlv.encode: unpadded data\");\n            const dataLen = data.length / 2;\n            const len = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded)(dataLen);\n            if (len.length / 2 & 128) throw new E(\"tlv.encode: long form length too big\");\n            // length of length with long form flag\n            const lenLen = dataLen > 127 ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded)(len.length / 2 | 128) : \"\";\n            const t = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded)(tag);\n            return t + lenLen + len + data;\n        },\n        // v - value, l - left bytes (unparsed)\n        decode (tag, data) {\n            const { Err: E } = DER;\n            let pos = 0;\n            if (tag < 0 || tag > 256) throw new E(\"tlv.encode: wrong tag\");\n            if (data.length < 2 || data[pos++] !== tag) throw new E(\"tlv.decode: wrong tlv\");\n            const first = data[pos++];\n            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form\n            let length = 0;\n            if (!isLong) length = first;\n            else {\n                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n                const lenLen = first & 127;\n                if (!lenLen) throw new E(\"tlv.decode(long): indefinite length not supported\");\n                if (lenLen > 4) throw new E(\"tlv.decode(long): byte length is too big\"); // this will overflow u32 in js\n                const lengthBytes = data.subarray(pos, pos + lenLen);\n                if (lengthBytes.length !== lenLen) throw new E(\"tlv.decode: length bytes not complete\");\n                if (lengthBytes[0] === 0) throw new E(\"tlv.decode(long): zero leftmost byte\");\n                for (const b of lengthBytes)length = length << 8 | b;\n                pos += lenLen;\n                if (length < 128) throw new E(\"tlv.decode(long): not minimal encoding\");\n            }\n            const v = data.subarray(pos, pos + length);\n            if (v.length !== length) throw new E(\"tlv.decode: wrong value length\");\n            return {\n                v,\n                l: data.subarray(pos + length)\n            };\n        }\n    },\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    _int: {\n        encode (num) {\n            const { Err: E } = DER;\n            if (num < _0n) throw new E(\"integer: negative integers are not allowed\");\n            let hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded)(num);\n            // Pad with zero byte if negative flag is present\n            if (Number.parseInt(hex[0], 16) & 8) hex = \"00\" + hex;\n            if (hex.length & 1) throw new E(\"unexpected DER parsing assertion: unpadded hex\");\n            return hex;\n        },\n        decode (data) {\n            const { Err: E } = DER;\n            if (data[0] & 128) throw new E(\"invalid signature integer: negative\");\n            if (data[0] === 0x00 && !(data[1] & 128)) throw new E(\"invalid signature integer: unnecessary leading zero\");\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(data);\n        }\n    },\n    toSig (hex) {\n        // parse DER signature\n        const { Err: E, _int: int, _tlv: tlv } = DER;\n        const data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"signature\", hex);\n        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n        if (seqLeftBytes.length) throw new E(\"invalid signature: left bytes after parsing\");\n        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n        if (sLeftBytes.length) throw new E(\"invalid signature: left bytes after parsing\");\n        return {\n            r: int.decode(rBytes),\n            s: int.decode(sBytes)\n        };\n    },\n    hexFromSig (sig) {\n        const { _tlv: tlv, _int: int } = DER;\n        const rs = tlv.encode(0x02, int.encode(sig.r));\n        const ss = tlv.encode(0x02, int.encode(sig.s));\n        const seq = rs + ss;\n        return tlv.encode(0x30, seq);\n    }\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction _normFnElement(Fn, key) {\n    const { BYTES: expected } = Fn;\n    let num;\n    if (typeof key === \"bigint\") {\n        num = key;\n    } else {\n        let bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"private key\", key);\n        try {\n            num = Fn.fromBytes(bytes);\n        } catch (error) {\n            throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);\n        }\n    }\n    if (!Fn.isValidNot0(num)) throw new Error(\"invalid private key: out of range [1..N-1]\");\n    return num;\n}\n/**\n * Creates weierstrass Point constructor, based on specified curve options.\n *\n * @example\n```js\nconst opts = {\n  p: BigInt('0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff'),\n  n: BigInt('0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551'),\n  h: BigInt(1),\n  a: BigInt('0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc'),\n  b: BigInt('0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b'),\n  Gx: BigInt('0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296'),\n  Gy: BigInt('0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5'),\n};\nconst p256_Point = weierstrass(opts);\n```\n */ function weierstrassN(params, extraOpts = {}) {\n    const validated = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__._createCurveFields)(\"weierstrass\", params, extraOpts);\n    const { Fp, Fn } = validated;\n    let CURVE = validated.CURVE;\n    const { h: cofactor, n: CURVE_ORDER } = CURVE;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._validateObject)(extraOpts, {}, {\n        allowInfinityPoint: \"boolean\",\n        clearCofactor: \"function\",\n        isTorsionFree: \"function\",\n        fromBytes: \"function\",\n        toBytes: \"function\",\n        endo: \"object\",\n        wrapPrivateKey: \"boolean\"\n    });\n    const { endo } = extraOpts;\n    if (endo) {\n        // validateObject(endo, { beta: 'bigint', splitScalar: 'function' });\n        if (!Fp.is0(CURVE.a) || typeof endo.beta !== \"bigint\" || !Array.isArray(endo.basises)) {\n            throw new Error('invalid endo: expected \"beta\": bigint and \"basises\": array');\n        }\n    }\n    const lengths = getWLengths(Fp, Fn);\n    function assertCompressionIsSupported() {\n        if (!Fp.isOdd) throw new Error(\"compression is not supported: Field does not have .isOdd()\");\n    }\n    // Implements IEEE P1363 point encoding\n    function pointToBytes(_c, point, isCompressed) {\n        const { x, y } = point.toAffine();\n        const bx = Fp.toBytes(x);\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._abool2)(isCompressed, \"isCompressed\");\n        if (isCompressed) {\n            assertCompressionIsSupported();\n            const hasEvenY = !Fp.isOdd(y);\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.concatBytes)(pprefix(hasEvenY), bx);\n        } else {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.concatBytes)(Uint8Array.of(0x04), bx, Fp.toBytes(y));\n        }\n    }\n    function pointFromBytes(bytes) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._abytes2)(bytes, undefined, \"Point\");\n        const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths; // e.g. for 32-byte: 33, 65\n        const length = bytes.length;\n        const head = bytes[0];\n        const tail = bytes.subarray(1);\n        // No actual validation is done here: use .assertValidity()\n        if (length === comp && (head === 0x02 || head === 0x03)) {\n            const x = Fp.fromBytes(tail);\n            if (!Fp.isValid(x)) throw new Error(\"bad point: is not on curve, wrong x\");\n            const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n            let y;\n            try {\n                y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n            } catch (sqrtError) {\n                const err = sqrtError instanceof Error ? \": \" + sqrtError.message : \"\";\n                throw new Error(\"bad point: is not on curve, sqrt error\" + err);\n            }\n            assertCompressionIsSupported();\n            const isYOdd = Fp.isOdd(y); // (y & _1n) === _1n;\n            const isHeadOdd = (head & 1) === 1; // ECDSA-specific\n            if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n            return {\n                x,\n                y\n            };\n        } else if (length === uncomp && head === 0x04) {\n            // TODO: more checks\n            const L = Fp.BYTES;\n            const x = Fp.fromBytes(tail.subarray(0, L));\n            const y = Fp.fromBytes(tail.subarray(L, L * 2));\n            if (!isValidXY(x, y)) throw new Error(\"bad point: is not on curve\");\n            return {\n                x,\n                y\n            };\n        } else {\n            throw new Error(`bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`);\n        }\n    }\n    const encodePoint = extraOpts.toBytes || pointToBytes;\n    const decodePoint = extraOpts.fromBytes || pointFromBytes;\n    function weierstrassEquation(x) {\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x² * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, CURVE.a)), CURVE.b); // x³ + a * x + b\n    }\n    // TODO: move top-level\n    /** Checks whether equation holds for given x, y: y² == x³ + ax + b */ function isValidXY(x, y) {\n        const left = Fp.sqr(y); // y²\n        const right = weierstrassEquation(x); // x³ + ax + b\n        return Fp.eql(left, right);\n    }\n    // Validate whether the passed curve params are valid.\n    // Test 1: equation y² = x³ + ax + b should work for generator point.\n    if (!isValidXY(CURVE.Gx, CURVE.Gy)) throw new Error(\"bad curve params: generator point\");\n    // Test 2: discriminant Δ part should be non-zero: 4a³ + 27b² != 0.\n    // Guarantees curve is genus-1, smooth (non-singular).\n    const _4a3 = Fp.mul(Fp.pow(CURVE.a, _3n), _4n);\n    const _27b2 = Fp.mul(Fp.sqr(CURVE.b), BigInt(27));\n    if (Fp.is0(Fp.add(_4a3, _27b2))) throw new Error(\"bad curve params: a or b\");\n    /** Asserts coordinate is valid: 0 <= n < Fp.ORDER. */ function acoord(title, n, banZero = false) {\n        if (!Fp.isValid(n) || banZero && Fp.is0(n)) throw new Error(`bad point coordinate ${title}`);\n        return n;\n    }\n    function aprjpoint(other) {\n        if (!(other instanceof Point)) throw new Error(\"ProjectivePoint expected\");\n    }\n    function splitEndoScalarN(k) {\n        if (!endo || !endo.basises) throw new Error(\"no endo\");\n        return _splitEndoScalar(k, endo.basises, Fn.ORDER);\n    }\n    // Memoized toAffine / validity check. They are heavy. Points are immutable.\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (X, Y, Z) ∋ (x=X/Z, y=Y/Z)\n    const toAffineMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memoized)((p, iz)=>{\n        const { X, Y, Z } = p;\n        // Fast-path for normalized points\n        if (Fp.eql(Z, Fp.ONE)) return {\n            x: X,\n            y: Y\n        };\n        const is0 = p.is0();\n        // If invZ was 0, we return zero point. However we still want to execute\n        // all operations, so we replace invZ with a random number, 1.\n        if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(Z);\n        const x = Fp.mul(X, iz);\n        const y = Fp.mul(Y, iz);\n        const zz = Fp.mul(Z, iz);\n        if (is0) return {\n            x: Fp.ZERO,\n            y: Fp.ZERO\n        };\n        if (!Fp.eql(zz, Fp.ONE)) throw new Error(\"invZ was invalid\");\n        return {\n            x,\n            y\n        };\n    });\n    // NOTE: on exception this will crash 'cached' and no value will be set.\n    // Otherwise true will be return\n    const assertValidMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memoized)((p)=>{\n        if (p.is0()) {\n            // (0, 1, 0) aka ZERO is invalid in most contexts.\n            // In BLS, ZERO can be serialized, so we allow it.\n            // (0, 0, 0) is invalid representation of ZERO.\n            if (extraOpts.allowInfinityPoint && !Fp.is0(p.Y)) return;\n            throw new Error(\"bad point: ZERO\");\n        }\n        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n        const { x, y } = p.toAffine();\n        if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"bad point: x or y not field elements\");\n        if (!isValidXY(x, y)) throw new Error(\"bad point: equation left != right\");\n        if (!p.isTorsionFree()) throw new Error(\"bad point: not in prime-order subgroup\");\n        return true;\n    });\n    function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {\n        k2p = new Point(Fp.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);\n        k1p = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.negateCt)(k1neg, k1p);\n        k2p = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.negateCt)(k2neg, k2p);\n        return k1p.add(k2p);\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates:(X, Y, Z) ∋ (x=X/Z, y=Y/Z).\n     * Default Point works in 2d / affine coordinates: (x, y).\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */ class Point {\n        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */ constructor(X, Y, Z){\n            this.X = acoord(\"x\", X);\n            this.Y = acoord(\"y\", Y, true);\n            this.Z = acoord(\"z\", Z);\n            Object.freeze(this);\n        }\n        static CURVE() {\n            return CURVE;\n        }\n        /** Does NOT validate if the point is valid. Use `.assertValidity()`. */ static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error(\"invalid affine point\");\n            if (p instanceof Point) throw new Error(\"projective point not allowed\");\n            // (0, 0) would've produced (0, 0, 1) - instead, we need (0, 1, 0)\n            if (Fp.is0(x) && Fp.is0(y)) return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        static fromBytes(bytes) {\n            const P = Point.fromAffine(decodePoint((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._abytes2)(bytes, undefined, \"point\")));\n            P.assertValidity();\n            return P;\n        }\n        static fromHex(hex) {\n            return Point.fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"pointHex\", hex));\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         *\n         * @param windowSize\n         * @param isLazy true will defer table computation until the first multiplication\n         * @returns\n         */ precompute(windowSize = 8, isLazy = true) {\n            wnaf.createCache(this, windowSize);\n            if (!isLazy) this.multiply(_3n); // random number\n            return this;\n        }\n        // TODO: return `this`\n        /** A point on curve is valid if it conforms to equation. */ assertValidity() {\n            assertValidMemo(this);\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (!Fp.isOdd) throw new Error(\"Field doesn't support isOdd\");\n            return !Fp.isOdd(y);\n        }\n        /** Compare one point to another. */ equals(other) {\n            aprjpoint(other);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            const { X: X2, Y: Y2, Z: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /** Flips point to one corresponding to (x, -y) in Affine coordinates. */ negate() {\n            return new Point(this.X, Fp.neg(this.Y), this.Z);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            aprjpoint(other);\n            const { X: X1, Y: Y1, Z: Z1 } = this;\n            const { X: X2, Y: Y2, Z: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */ multiply(scalar) {\n            const { endo } = extraOpts;\n            if (!Fn.isValidNot0(scalar)) throw new Error(\"invalid scalar: out of range\"); // 0 is invalid\n            let point, fake; // Fake point is used to const-time mult\n            const mul = (n)=>wnaf.cached(this, n, (p)=>(0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.normalizeZ)(Point, p));\n            /** See docs for {@link EndomorphismOpts} */ if (endo) {\n                const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);\n                const { p: k1p, f: k1f } = mul(k1);\n                const { p: k2p, f: k2f } = mul(k2);\n                fake = k1f.add(k2f);\n                point = finishEndo(endo.beta, k1p, k2p, k1neg, k2neg);\n            } else {\n                const { p, f } = mul(scalar);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.normalizeZ)(Point, [\n                point,\n                fake\n            ])[0];\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed secret key e.g. sig verification, which works over *public* keys.\n         */ multiplyUnsafe(sc) {\n            const { endo } = extraOpts;\n            const p = this;\n            if (!Fn.isValid(sc)) throw new Error(\"invalid scalar: out of range\"); // 0 is valid\n            if (sc === _0n || p.is0()) return Point.ZERO;\n            if (sc === _1n) return p; // fast-path\n            if (wnaf.hasCache(this)) return this.multiply(sc);\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);\n                const { p1, p2 } = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.mulEndoUnsafe)(Point, p, k1, k2); // 30% faster vs wnaf.unsafe\n                return finishEndo(endo.beta, p1, p2, k1neg, k2neg);\n            } else {\n                return wnaf.unsafe(p, sc);\n            }\n        }\n        multiplyAndAddUnsafe(Q, a, b) {\n            const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));\n            return sum.is0() ? undefined : sum;\n        }\n        /**\n         * Converts Projective point to affine (x, y) coordinates.\n         * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch\n         */ toAffine(invertedZ) {\n            return toAffineMemo(this, invertedZ);\n        }\n        /**\n         * Checks whether Point is free of torsion elements (is in prime subgroup).\n         * Always torsion-free for cofactor=1 curves.\n         */ isTorsionFree() {\n            const { isTorsionFree } = extraOpts;\n            if (cofactor === _1n) return true;\n            if (isTorsionFree) return isTorsionFree(Point, this);\n            return wnaf.unsafe(this, CURVE_ORDER).is0();\n        }\n        clearCofactor() {\n            const { clearCofactor } = extraOpts;\n            if (cofactor === _1n) return this; // Fast-path\n            if (clearCofactor) return clearCofactor(Point, this);\n            return this.multiplyUnsafe(cofactor);\n        }\n        isSmallOrder() {\n            // can we use this.clearCofactor()?\n            return this.multiplyUnsafe(cofactor).is0();\n        }\n        toBytes(isCompressed = true) {\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._abool2)(isCompressed, \"isCompressed\");\n            this.assertValidity();\n            return encodePoint(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.bytesToHex)(this.toBytes(isCompressed));\n        }\n        toString() {\n            return `<Point ${this.is0() ? \"ZERO\" : this.toHex()}>`;\n        }\n        // TODO: remove\n        get px() {\n            return this.X;\n        }\n        get py() {\n            return this.X;\n        }\n        get pz() {\n            return this.Z;\n        }\n        toRawBytes(isCompressed = true) {\n            return this.toBytes(isCompressed);\n        }\n        _setWindowSize(windowSize) {\n            this.precompute(windowSize);\n        }\n        static normalizeZ(points) {\n            return (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.normalizeZ)(Point, points);\n        }\n        static msm(points, scalars) {\n            return (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.pippenger)(Point, Fn, points, scalars);\n        }\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(_normFnElement(Fn, privateKey));\n        }\n    }\n    // base / generator point\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    // zero / infinity / identity point\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO); // 0, 1, 0\n    // math field\n    Point.Fp = Fp;\n    // scalar field\n    Point.Fn = Fn;\n    const bits = Fn.BITS;\n    const wnaf = new _curve_js__WEBPACK_IMPORTED_MODULE_1__.wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);\n    Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n    return Point;\n}\n// Points start with byte 0x02 when y is even; otherwise 0x03\nfunction pprefix(hasEvenY) {\n    return Uint8Array.of(hasEvenY ? 0x02 : 0x03);\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */ function SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for(let o = q - _1n; o % _2n === _0n; o /= _2n)l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v)=>{\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for(let i = c1; i > _1n; i--){\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << tv5 - _1n; // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return {\n            isValid: isQR,\n            value: tv3\n        };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v)=>{\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return {\n                isValid: isQR,\n                value: y\n            }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */ function mapToCurveSimpleSWU(Fp, opts) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_3__.validateField)(Fp);\n    const { A, B, Z } = opts;\n    if (!Fp.isValid(A) || !Fp.isValid(B) || !Fp.isValid(Z)) throw new Error(\"mapToCurveSimpleSWU: invalid opts\");\n    const sqrtRatio = SWUFpSqrtRatio(Fp, Z);\n    if (!Fp.isOdd) throw new Error(\"Field does not have .isOdd()\");\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u)=>{\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        const tv4_inv = (0,_modular_js__WEBPACK_IMPORTED_MODULE_3__.FpInvertBatch)(Fp, [\n            tv4\n        ], true)[0];\n        x = Fp.mul(x, tv4_inv); // 25.   x = x / tv4\n        return {\n            x,\n            y\n        };\n    };\n}\nfunction getWLengths(Fp, Fn) {\n    return {\n        secretKey: Fn.BYTES,\n        publicKey: 1 + Fp.BYTES,\n        publicKeyUncompressed: 1 + 2 * Fp.BYTES,\n        publicKeyHasPrefix: true,\n        signature: 2 * Fn.BYTES\n    };\n}\n/**\n * Sometimes users only need getPublicKey, getSharedSecret, and secret key handling.\n * This helper ensures no signature functionality is present. Less code, smaller bundle size.\n */ function ecdh(Point, ecdhOpts = {}) {\n    const { Fn } = Point;\n    const randomBytes_ = ecdhOpts.randomBytes || _utils_js__WEBPACK_IMPORTED_MODULE_2__.randomBytes;\n    const lengths = Object.assign(getWLengths(Point.Fp, Fn), {\n        seed: (0,_modular_js__WEBPACK_IMPORTED_MODULE_3__.getMinHashLength)(Fn.ORDER)\n    });\n    function isValidSecretKey(secretKey) {\n        try {\n            return !!_normFnElement(Fn, secretKey);\n        } catch (error) {\n            return false;\n        }\n    }\n    function isValidPublicKey(publicKey, isCompressed) {\n        const { publicKey: comp, publicKeyUncompressed } = lengths;\n        try {\n            const l = publicKey.length;\n            if (isCompressed === true && l !== comp) return false;\n            if (isCompressed === false && l !== publicKeyUncompressed) return false;\n            return !!Point.fromBytes(publicKey);\n        } catch (error) {\n            return false;\n        }\n    }\n    /**\n     * Produces cryptographically secure secret key from random of size\n     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n     */ function randomSecretKey(seed = randomBytes_(lengths.seed)) {\n        return (0,_modular_js__WEBPACK_IMPORTED_MODULE_3__.mapHashToField)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._abytes2)(seed, lengths.seed, \"seed\"), Fn.ORDER);\n    }\n    /**\n     * Computes public key for a secret key. Checks for validity of the secret key.\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */ function getPublicKey(secretKey, isCompressed = true) {\n        return Point.BASE.multiply(_normFnElement(Fn, secretKey)).toBytes(isCompressed);\n    }\n    function keygen(seed) {\n        const secretKey = randomSecretKey(seed);\n        return {\n            secretKey,\n            publicKey: getPublicKey(secretKey)\n        };\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */ function isProbPub(item) {\n        if (typeof item === \"bigint\") return false;\n        if (item instanceof Point) return true;\n        const { secretKey, publicKey, publicKeyUncompressed } = lengths;\n        if (Fn.allowedLengths || secretKey === publicKey) return undefined;\n        const l = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"key\", item).length;\n        return l === publicKey || l === publicKeyUncompressed;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from secret key A and public key B.\n     * Checks: 1) secret key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */ function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {\n        if (isProbPub(secretKeyA) === true) throw new Error(\"first arg must be private key\");\n        if (isProbPub(publicKeyB) === false) throw new Error(\"second arg must be public key\");\n        const s = _normFnElement(Fn, secretKeyA);\n        const b = Point.fromHex(publicKeyB); // checks for being on-curve\n        return b.multiply(s).toBytes(isCompressed);\n    }\n    const utils = {\n        isValidSecretKey,\n        isValidPublicKey,\n        randomSecretKey,\n        // TODO: remove\n        isValidPrivateKey: isValidSecretKey,\n        randomPrivateKey: randomSecretKey,\n        normPrivateKeyToScalar: (key)=>_normFnElement(Fn, key),\n        precompute (windowSize = 8, point = Point.BASE) {\n            return point.precompute(windowSize, false);\n        }\n    };\n    return Object.freeze({\n        getPublicKey,\n        getSharedSecret,\n        keygen,\n        Point,\n        utils,\n        lengths\n    });\n}\n/**\n * Creates ECDSA signing interface for given elliptic curve `Point` and `hash` function.\n * We need `hash` for 2 features:\n * 1. Message prehash-ing. NOT used if `sign` / `verify` are called with `prehash: false`\n * 2. k generation in `sign`, using HMAC-drbg(hash)\n *\n * ECDSAOpts are only rarely needed.\n *\n * @example\n * ```js\n * const p256_Point = weierstrass(...);\n * const p256_sha256 = ecdsa(p256_Point, sha256);\n * const p256_sha224 = ecdsa(p256_Point, sha224);\n * const p256_sha224_r = ecdsa(p256_Point, sha224, { randomBytes: (length) => { ... } });\n * ```\n */ function ecdsa(Point, hash, ecdsaOpts = {}) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.ahash)(hash);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._validateObject)(ecdsaOpts, {}, {\n        hmac: \"function\",\n        lowS: \"boolean\",\n        randomBytes: \"function\",\n        bits2int: \"function\",\n        bits2int_modN: \"function\"\n    });\n    const randomBytes = ecdsaOpts.randomBytes || _utils_js__WEBPACK_IMPORTED_MODULE_2__.randomBytes;\n    const hmac = ecdsaOpts.hmac || ((key, ...msgs)=>(0,_noble_hashes_hmac_js__WEBPACK_IMPORTED_MODULE_4__.hmac)(hash, key, (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.concatBytes)(...msgs)));\n    const { Fp, Fn } = Point;\n    const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn;\n    const { keygen, getPublicKey, getSharedSecret, utils, lengths } = ecdh(Point, ecdsaOpts);\n    const defaultSigOpts = {\n        prehash: false,\n        lowS: typeof ecdsaOpts.lowS === \"boolean\" ? ecdsaOpts.lowS : false,\n        format: undefined,\n        extraEntropy: false\n    };\n    const defaultSigOpts_format = \"compact\";\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function validateRS(title, num) {\n        if (!Fn.isValidNot0(num)) throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);\n        return num;\n    }\n    function validateSigLength(bytes, format) {\n        validateSigFormat(format);\n        const size = lengths.signature;\n        const sizer = format === \"compact\" ? size : format === \"recovered\" ? size + 1 : undefined;\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._abytes2)(bytes, sizer, `${format} signature`);\n    }\n    /**\n     * ECDSA signature with its (r, s) properties. Supports compact, recovered & DER representations.\n     */ class Signature {\n        constructor(r, s, recovery){\n            this.r = validateRS(\"r\", r); // r in [1..N-1];\n            this.s = validateRS(\"s\", s); // s in [1..N-1];\n            if (recovery != null) this.recovery = recovery;\n            Object.freeze(this);\n        }\n        static fromBytes(bytes, format = defaultSigOpts_format) {\n            validateSigLength(bytes, format);\n            let recid;\n            if (format === \"der\") {\n                const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._abytes2)(bytes));\n                return new Signature(r, s);\n            }\n            if (format === \"recovered\") {\n                recid = bytes[0];\n                format = \"compact\";\n                bytes = bytes.subarray(1);\n            }\n            const L = Fn.BYTES;\n            const r = bytes.subarray(0, L);\n            const s = bytes.subarray(L, L * 2);\n            return new Signature(Fn.fromBytes(r), Fn.fromBytes(s), recid);\n        }\n        static fromHex(hex, format) {\n            return this.fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.hexToBytes)(hex), format);\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(messageHash) {\n            const FIELD_ORDER = Fp.ORDER;\n            const { r, s, recovery: rec } = this;\n            if (rec == null || ![\n                0,\n                1,\n                2,\n                3\n            ].includes(rec)) throw new Error(\"recovery id invalid\");\n            // ECDSA recovery is hard for cofactor > 1 curves.\n            // In sign, `r = q.x mod n`, and here we recover q.x from r.\n            // While recovering q.x >= n, we need to add r+n for cofactor=1 curves.\n            // However, for cofactor>1, r+n may not get q.x:\n            // r+n*i would need to be done instead where i is unknown.\n            // To easily get i, we either need to:\n            // a. increase amount of valid recid values (4, 5...); OR\n            // b. prohibit non-prime-order signatures (recid > 1).\n            const hasCofactor = CURVE_ORDER * _2n < FIELD_ORDER;\n            if (hasCofactor && rec > 1) throw new Error(\"recovery id is ambiguous for h>1 curve\");\n            const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;\n            if (!Fp.isValid(radj)) throw new Error(\"recovery id 2 or 3 invalid\");\n            const x = Fp.toBytes(radj);\n            const R = Point.fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.concatBytes)(pprefix((rec & 1) === 0), x));\n            const ir = Fn.inv(radj); // r^-1\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"msgHash\", messageHash)); // Truncate hash\n            const u1 = Fn.create(-h * ir); // -hr^-1\n            const u2 = Fn.create(s * ir); // sr^-1\n            // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1). unsafe is fine: there is no private data.\n            const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));\n            if (Q.is0()) throw new Error(\"point at infinify\");\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        toBytes(format = defaultSigOpts_format) {\n            validateSigFormat(format);\n            if (format === \"der\") return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.hexToBytes)(DER.hexFromSig(this));\n            const r = Fn.toBytes(this.r);\n            const s = Fn.toBytes(this.s);\n            if (format === \"recovered\") {\n                if (this.recovery == null) throw new Error(\"recovery bit must be present\");\n                return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.concatBytes)(Uint8Array.of(this.recovery), r, s);\n            }\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.concatBytes)(r, s);\n        }\n        toHex(format) {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.bytesToHex)(this.toBytes(format));\n        }\n        // TODO: remove\n        assertValidity() {}\n        static fromCompact(hex) {\n            return Signature.fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"sig\", hex), \"compact\");\n        }\n        static fromDER(hex) {\n            return Signature.fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"sig\", hex), \"der\");\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, Fn.neg(this.s), this.recovery) : this;\n        }\n        toDERRawBytes() {\n            return this.toBytes(\"der\");\n        }\n        toDERHex() {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.bytesToHex)(this.toBytes(\"der\"));\n        }\n        toCompactRawBytes() {\n            return this.toBytes(\"compact\");\n        }\n        toCompactHex() {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.bytesToHex)(this.toBytes(\"compact\"));\n        }\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = ecdsaOpts.bits2int || function bits2int_def(bytes) {\n        // Our custom check \"just in case\", for protection against DoS\n        if (bytes.length > 8192) throw new Error(\"input is too large\");\n        // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n        // for some cases, since bytes.length * 8 is not actual bitLength.\n        const num = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes); // check for == u8 done here\n        const delta = bytes.length * 8 - fnBits; // truncate to nBitLength leftmost bits\n        return delta > 0 ? num >> BigInt(delta) : num;\n    };\n    const bits2int_modN = ecdsaOpts.bits2int_modN || function bits2int_modN_def(bytes) {\n        return Fn.create(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n    // Pads output with zero as per spec\n    const ORDER_MASK = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(fnBits);\n    /** Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`. */ function int2octets(num) {\n        // IMPORTANT: the check ensures working for case `Fn.BYTES != Fn.BITS * 8`\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange)(\"num < 2^\" + fnBits, num, _0n, ORDER_MASK);\n        return Fn.toBytes(num);\n    }\n    function validateMsgAndHash(message, prehash) {\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._abytes2)(message, undefined, \"message\");\n        return prehash ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__._abytes2)(hash(message), undefined, \"prehashed message\") : message;\n    }\n    /**\n     * Steps A, D of RFC6979 3.2.\n     * Creates RFC6979 seed; converts msg/privKey to numbers.\n     * Used only in sign, not in verify.\n     *\n     * Warning: we cannot assume here that message has same amount of bytes as curve order,\n     * this will be invalid at least for P521. Also it can be bigger for P224 + SHA256.\n     */ function prepSig(message, privateKey, opts) {\n        if ([\n            \"recovered\",\n            \"canonical\"\n        ].some((k)=>k in opts)) throw new Error(\"sign() legacy options not supported\");\n        const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);\n        message = validateMsgAndHash(message, prehash); // RFC6979 3.2 A: h1 = H(m)\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with fnBits % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(message);\n        const d = _normFnElement(Fn, privateKey); // validate secret key, convert to bigint\n        const seedArgs = [\n            int2octets(d),\n            int2octets(h1int)\n        ];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (extraEntropy != null && extraEntropy !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            // gen random bytes OR pass as-is\n            const e = extraEntropy === true ? randomBytes(lengths.secretKey) : extraEntropy;\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"extraEntropy\", e)); // check for being bytes\n        }\n        const seed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.concatBytes)(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        // To transform k => Signature:\n        // q = k⋅G\n        // r = q.x mod n\n        // s = k^-1(m + rd) mod n\n        // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n        // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n        // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            // Important: all mod() calls here must be done over N\n            const k = bits2int(kBytes); // mod n, not mod p\n            if (!Fn.isValidNot0(k)) return; // Valid scalars (including k) must be in 1..N-1\n            const ik = Fn.inv(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = k⋅G\n            const r = Fn.create(q.x); // r = q.x mod n\n            if (r === _0n) return;\n            const s = Fn.create(ik * Fn.create(m + r * d)); // Not using blinding here, see comment above\n            if (s === _0n) return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = Fn.neg(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return {\n            seed,\n            k2sig\n        };\n    }\n    /**\n     * Signs message hash with a secret key.\n     *\n     * ```\n     * sign(m, d) where\n     *   k = rfc6979_hmac_drbg(m, d)\n     *   (x, y) = G × k\n     *   r = x mod n\n     *   s = (m + dr) / k mod n\n     * ```\n     */ function sign(message, secretKey, opts = {}) {\n        message = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"message\", message);\n        const { seed, k2sig } = prepSig(message, secretKey, opts); // Steps A, D of RFC6979 3.2.\n        const drbg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createHmacDrbg)(hash.outputLen, Fn.BYTES, hmac);\n        const sig = drbg(seed, k2sig); // Steps B, C, D, E, F, G\n        return sig;\n    }\n    function tryParsingSig(sg) {\n        // Try to deduce format\n        let sig = undefined;\n        const isHex = typeof sg === \"string\" || (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.isBytes)(sg);\n        const isObj = !isHex && sg !== null && typeof sg === \"object\" && typeof sg.r === \"bigint\" && typeof sg.s === \"bigint\";\n        if (!isHex && !isObj) throw new Error(\"invalid signature, expected Uint8Array, hex string or Signature instance\");\n        if (isObj) {\n            sig = new Signature(sg.r, sg.s);\n        } else if (isHex) {\n            try {\n                sig = Signature.fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"sig\", sg), \"der\");\n            } catch (derError) {\n                if (!(derError instanceof DER.Err)) throw derError;\n            }\n            if (!sig) {\n                try {\n                    sig = Signature.fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"sig\", sg), \"compact\");\n                } catch (error) {\n                    return false;\n                }\n            }\n        }\n        if (!sig) return false;\n        return sig;\n    }\n    /**\n     * Verifies a signature against message and public key.\n     * Rejects lowS signatures by default: see {@link ECDSAVerifyOpts}.\n     * Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   u1 = hs^-1 mod n\n     *   u2 = rs^-1 mod n\n     *   R = u1⋅G + u2⋅P\n     *   mod(R.x, n) == r\n     * ```\n     */ function verify(signature, message, publicKey, opts = {}) {\n        const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"publicKey\", publicKey);\n        message = validateMsgAndHash((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"message\", message), prehash);\n        if (\"strict\" in opts) throw new Error(\"options.strict was renamed to lowS\");\n        const sig = format === undefined ? tryParsingSig(signature) : Signature.fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"sig\", signature), format);\n        if (sig === false) return false;\n        try {\n            const P = Point.fromBytes(publicKey);\n            if (lowS && sig.hasHighS()) return false;\n            const { r, s } = sig;\n            const h = bits2int_modN(message); // mod n, not mod p\n            const is = Fn.inv(s); // s^-1 mod n\n            const u1 = Fn.create(h * is); // u1 = hs^-1 mod n\n            const u2 = Fn.create(r * is); // u2 = rs^-1 mod n\n            const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2)); // u1⋅G + u2⋅P\n            if (R.is0()) return false;\n            const v = Fn.create(R.x); // v = r.x mod n\n            return v === r;\n        } catch (e) {\n            return false;\n        }\n    }\n    function recoverPublicKey(signature, message, opts = {}) {\n        const { prehash } = validateSigOpts(opts, defaultSigOpts);\n        message = validateMsgAndHash(message, prehash);\n        return Signature.fromBytes(signature, \"recovered\").recoverPublicKey(message).toBytes();\n    }\n    return Object.freeze({\n        keygen,\n        getPublicKey,\n        getSharedSecret,\n        utils,\n        lengths,\n        Point,\n        sign,\n        verify,\n        recoverPublicKey,\n        Signature,\n        hash\n    });\n}\n/** @deprecated use `weierstrass` in newer releases */ function weierstrassPoints(c) {\n    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);\n    const Point = weierstrassN(CURVE, curveOpts);\n    return _weierstrass_new_output_to_legacy(c, Point);\n}\nfunction _weierstrass_legacy_opts_to_new(c) {\n    const CURVE = {\n        a: c.a,\n        b: c.b,\n        p: c.Fp.ORDER,\n        n: c.n,\n        h: c.h,\n        Gx: c.Gx,\n        Gy: c.Gy\n    };\n    const Fp = c.Fp;\n    let allowedLengths = c.allowedPrivateKeyLengths ? Array.from(new Set(c.allowedPrivateKeyLengths.map((l)=>Math.ceil(l / 2)))) : undefined;\n    const Fn = (0,_modular_js__WEBPACK_IMPORTED_MODULE_3__.Field)(CURVE.n, {\n        BITS: c.nBitLength,\n        allowedLengths: allowedLengths,\n        modFromBytes: c.wrapPrivateKey\n    });\n    const curveOpts = {\n        Fp,\n        Fn,\n        allowInfinityPoint: c.allowInfinityPoint,\n        endo: c.endo,\n        isTorsionFree: c.isTorsionFree,\n        clearCofactor: c.clearCofactor,\n        fromBytes: c.fromBytes,\n        toBytes: c.toBytes\n    };\n    return {\n        CURVE,\n        curveOpts\n    };\n}\nfunction _ecdsa_legacy_opts_to_new(c) {\n    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);\n    const ecdsaOpts = {\n        hmac: c.hmac,\n        randomBytes: c.randomBytes,\n        lowS: c.lowS,\n        bits2int: c.bits2int,\n        bits2int_modN: c.bits2int_modN\n    };\n    return {\n        CURVE,\n        curveOpts,\n        hash: c.hash,\n        ecdsaOpts\n    };\n}\nfunction _legacyHelperEquat(Fp, a, b) {\n    /**\n     * y² = x³ + ax + b: Short weierstrass curve formula. Takes x, returns y².\n     * @returns y²\n     */ function weierstrassEquation(x) {\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x² * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x³ + a * x + b\n    }\n    return weierstrassEquation;\n}\nfunction _weierstrass_new_output_to_legacy(c, Point) {\n    const { Fp, Fn } = Point;\n    function isWithinCurveOrder(num) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.inRange)(num, _1n, Fn.ORDER);\n    }\n    const weierstrassEquation = _legacyHelperEquat(Fp, c.a, c.b);\n    return Object.assign({}, {\n        CURVE: c,\n        Point: Point,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar: (key)=>_normFnElement(Fn, key),\n        weierstrassEquation,\n        isWithinCurveOrder\n    });\n}\nfunction _ecdsa_new_output_to_legacy(c, _ecdsa) {\n    const Point = _ecdsa.Point;\n    return Object.assign({}, _ecdsa, {\n        ProjectivePoint: Point,\n        CURVE: Object.assign({}, c, (0,_modular_js__WEBPACK_IMPORTED_MODULE_3__.nLength)(Point.Fn.ORDER, Point.Fn.BITS))\n    });\n}\n// _ecdsa_legacy\nfunction weierstrass(c) {\n    const { CURVE, curveOpts, hash, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);\n    const Point = weierstrassN(CURVE, curveOpts);\n    const signs = ecdsa(Point, hash, ecdsaOpts);\n    return _ecdsa_new_output_to_legacy(c, signs);\n} //# sourceMappingURL=weierstrass.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjkuNy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQXlCQyxHQUNELG9FQUFvRSxHQUNWO0FBQ2Q7QUFDdU87QUFDNUs7QUFDUTtBQUMvRywrSEFBK0g7QUFDL0gsTUFBTW1DLGFBQWEsQ0FBQ0MsS0FBS0MsTUFBUSxDQUFDRCxNQUFNLENBQUNBLE9BQU8sSUFBSUMsTUFBTSxDQUFDQSxHQUFFLElBQUtDLEdBQUUsSUFBS0Q7QUFDekU7O0NBRUMsR0FDTSxTQUFTRSxpQkFBaUJDLENBQUMsRUFBRUMsS0FBSyxFQUFFQyxDQUFDO0lBQ3hDLDRFQUE0RTtJQUM1RSwyREFBMkQ7SUFDM0Qsb0RBQW9EO0lBQ3BELE1BQU0sQ0FBQyxDQUFDQyxJQUFJQyxHQUFHLEVBQUUsQ0FBQ0MsSUFBSUMsR0FBRyxDQUFDLEdBQUdMO0lBQzdCLE1BQU1NLEtBQUtaLFdBQVdXLEtBQUtOLEdBQUdFO0lBQzlCLE1BQU1NLEtBQUtiLFdBQVcsQ0FBQ1MsS0FBS0osR0FBR0U7SUFDL0IsK0NBQStDO0lBQy9DLCtGQUErRjtJQUMvRixJQUFJTyxLQUFLVCxJQUFJTyxLQUFLSixLQUFLSyxLQUFLSDtJQUM1QixJQUFJSyxLQUFLLENBQUNILEtBQUtILEtBQUtJLEtBQUtGO0lBQ3pCLE1BQU1LLFFBQVFGLEtBQUtHO0lBQ25CLE1BQU1DLFFBQVFILEtBQUtFO0lBQ25CLElBQUlELE9BQ0FGLEtBQUssQ0FBQ0E7SUFDVixJQUFJSSxPQUNBSCxLQUFLLENBQUNBO0lBQ1YseUZBQXlGO0lBQ3pGLG1HQUFtRztJQUNuRyxNQUFNSSxVQUFVNUMsa0RBQU9BLENBQUM2QyxLQUFLQyxJQUFJLENBQUMvQyxpREFBTUEsQ0FBQ2lDLEtBQUssTUFBTWUsS0FBSyxpQkFBaUI7SUFDMUUsSUFBSVIsS0FBS0csT0FBT0gsTUFBTUssV0FBV0osS0FBS0UsT0FBT0YsTUFBTUksU0FBUztRQUN4RCxNQUFNLElBQUlJLE1BQU0sMkNBQTJDbEI7SUFDL0Q7SUFDQSxPQUFPO1FBQUVXO1FBQU9GO1FBQUlJO1FBQU9IO0lBQUc7QUFDbEM7QUFDQSxTQUFTUyxrQkFBa0JDLE1BQU07SUFDN0IsSUFBSSxDQUFDO1FBQUM7UUFBVztRQUFhO0tBQU0sQ0FBQ0MsUUFBUSxDQUFDRCxTQUMxQyxNQUFNLElBQUlGLE1BQU07SUFDcEIsT0FBT0U7QUFDWDtBQUNBLFNBQVNFLGdCQUFnQkMsSUFBSSxFQUFFQyxHQUFHO0lBQzlCLE1BQU1DLFFBQVEsQ0FBQztJQUNmLEtBQUssSUFBSUMsV0FBV0MsT0FBT0MsSUFBSSxDQUFDSixLQUFNO1FBQ2xDLGFBQWE7UUFDYkMsS0FBSyxDQUFDQyxRQUFRLEdBQUdILElBQUksQ0FBQ0csUUFBUSxLQUFLRyxZQUFZTCxHQUFHLENBQUNFLFFBQVEsR0FBR0gsSUFBSSxDQUFDRyxRQUFRO0lBQy9FO0lBQ0E3RCxrREFBS0EsQ0FBQzRELE1BQU1LLElBQUksRUFBRTtJQUNsQmpFLGtEQUFLQSxDQUFDNEQsTUFBTU0sT0FBTyxFQUFFO0lBQ3JCLElBQUlOLE1BQU1MLE1BQU0sS0FBS1MsV0FDakJWLGtCQUFrQk0sTUFBTUwsTUFBTTtJQUNsQyxPQUFPSztBQUNYO0FBQ08sTUFBTU8sZUFBZWQ7SUFDeEJlLFlBQVlDLElBQUksRUFBRSxDQUFFO1FBQ2hCLEtBQUssQ0FBQ0E7SUFDVjtBQUNKO0FBQ0E7Ozs7OztDQU1DLEdBQ00sTUFBTUMsTUFBTTtJQUNmLDJCQUEyQjtJQUMzQkMsS0FBS0o7SUFDTCxpREFBaUQ7SUFDakRLLE1BQU07UUFDRkMsUUFBUSxDQUFDQyxLQUFLQztZQUNWLE1BQU0sRUFBRUosS0FBS0ssQ0FBQyxFQUFFLEdBQUdOO1lBQ25CLElBQUlJLE1BQU0sS0FBS0EsTUFBTSxLQUNqQixNQUFNLElBQUlFLEVBQUU7WUFDaEIsSUFBSUQsS0FBS0UsTUFBTSxHQUFHLEdBQ2QsTUFBTSxJQUFJRCxFQUFFO1lBQ2hCLE1BQU1FLFVBQVVILEtBQUtFLE1BQU0sR0FBRztZQUM5QixNQUFNRSxNQUFNaEUsOERBQW1CQSxDQUFDK0Q7WUFDaEMsSUFBSSxJQUFLRCxNQUFNLEdBQUcsSUFBSyxLQUNuQixNQUFNLElBQUlELEVBQUU7WUFDaEIsdUNBQXVDO1lBQ3ZDLE1BQU1JLFNBQVNGLFVBQVUsTUFBTS9ELDhEQUFtQkEsQ0FBQyxJQUFLOEQsTUFBTSxHQUFHLElBQUssT0FBTztZQUM3RSxNQUFNSSxJQUFJbEUsOERBQW1CQSxDQUFDMkQ7WUFDOUIsT0FBT08sSUFBSUQsU0FBU0QsTUFBTUo7UUFDOUI7UUFDQSx1Q0FBdUM7UUFDdkNPLFFBQU9SLEdBQUcsRUFBRUMsSUFBSTtZQUNaLE1BQU0sRUFBRUosS0FBS0ssQ0FBQyxFQUFFLEdBQUdOO1lBQ25CLElBQUlhLE1BQU07WUFDVixJQUFJVCxNQUFNLEtBQUtBLE1BQU0sS0FDakIsTUFBTSxJQUFJRSxFQUFFO1lBQ2hCLElBQUlELEtBQUtFLE1BQU0sR0FBRyxLQUFLRixJQUFJLENBQUNRLE1BQU0sS0FBS1QsS0FDbkMsTUFBTSxJQUFJRSxFQUFFO1lBQ2hCLE1BQU1RLFFBQVFULElBQUksQ0FBQ1EsTUFBTTtZQUN6QixNQUFNRSxTQUFTLENBQUMsQ0FBRUQsQ0FBQUEsUUFBUSxHQUFFLEdBQUksNkRBQTZEO1lBQzdGLElBQUlQLFNBQVM7WUFDYixJQUFJLENBQUNRLFFBQ0RSLFNBQVNPO2lCQUNSO2dCQUNELCtEQUErRDtnQkFDL0QsTUFBTUosU0FBU0ksUUFBUTtnQkFDdkIsSUFBSSxDQUFDSixRQUNELE1BQU0sSUFBSUosRUFBRTtnQkFDaEIsSUFBSUksU0FBUyxHQUNULE1BQU0sSUFBSUosRUFBRSw2Q0FBNkMsK0JBQStCO2dCQUM1RixNQUFNVSxjQUFjWCxLQUFLWSxRQUFRLENBQUNKLEtBQUtBLE1BQU1IO2dCQUM3QyxJQUFJTSxZQUFZVCxNQUFNLEtBQUtHLFFBQ3ZCLE1BQU0sSUFBSUosRUFBRTtnQkFDaEIsSUFBSVUsV0FBVyxDQUFDLEVBQUUsS0FBSyxHQUNuQixNQUFNLElBQUlWLEVBQUU7Z0JBQ2hCLEtBQUssTUFBTVksS0FBS0YsWUFDWlQsU0FBUyxVQUFXLElBQUtXO2dCQUM3QkwsT0FBT0g7Z0JBQ1AsSUFBSUgsU0FBUyxLQUNULE1BQU0sSUFBSUQsRUFBRTtZQUNwQjtZQUNBLE1BQU1hLElBQUlkLEtBQUtZLFFBQVEsQ0FBQ0osS0FBS0EsTUFBTU47WUFDbkMsSUFBSVksRUFBRVosTUFBTSxLQUFLQSxRQUNiLE1BQU0sSUFBSUQsRUFBRTtZQUNoQixPQUFPO2dCQUFFYTtnQkFBR0MsR0FBR2YsS0FBS1ksUUFBUSxDQUFDSixNQUFNTjtZQUFRO1FBQy9DO0lBQ0o7SUFDQSwwRkFBMEY7SUFDMUYsdUVBQXVFO0lBQ3ZFLDRCQUE0QjtJQUM1QixxRkFBcUY7SUFDckZjLE1BQU07UUFDRmxCLFFBQU8xQyxHQUFHO1lBQ04sTUFBTSxFQUFFd0MsS0FBS0ssQ0FBQyxFQUFFLEdBQUdOO1lBQ25CLElBQUl2QyxNQUFNZ0IsS0FDTixNQUFNLElBQUk2QixFQUFFO1lBQ2hCLElBQUlnQixNQUFNN0UsOERBQW1CQSxDQUFDZ0I7WUFDOUIsaURBQWlEO1lBQ2pELElBQUk4RCxPQUFPQyxRQUFRLENBQUNGLEdBQUcsQ0FBQyxFQUFFLEVBQUUsTUFBTSxHQUM5QkEsTUFBTSxPQUFPQTtZQUNqQixJQUFJQSxJQUFJZixNQUFNLEdBQUcsR0FDYixNQUFNLElBQUlELEVBQUU7WUFDaEIsT0FBT2dCO1FBQ1g7UUFDQVYsUUFBT1AsSUFBSTtZQUNQLE1BQU0sRUFBRUosS0FBS0ssQ0FBQyxFQUFFLEdBQUdOO1lBQ25CLElBQUlLLElBQUksQ0FBQyxFQUFFLEdBQUcsS0FDVixNQUFNLElBQUlDLEVBQUU7WUFDaEIsSUFBSUQsSUFBSSxDQUFDLEVBQUUsS0FBSyxRQUFRLENBQUVBLENBQUFBLElBQUksQ0FBQyxFQUFFLEdBQUcsR0FBRSxHQUNsQyxNQUFNLElBQUlDLEVBQUU7WUFDaEIsT0FBT3JFLDBEQUFlQSxDQUFDb0U7UUFDM0I7SUFDSjtJQUNBb0IsT0FBTUgsR0FBRztRQUNMLHNCQUFzQjtRQUN0QixNQUFNLEVBQUVyQixLQUFLSyxDQUFDLEVBQUVlLE1BQU1LLEdBQUcsRUFBRXhCLE1BQU15QixHQUFHLEVBQUUsR0FBRzNCO1FBQ3pDLE1BQU1LLE9BQU9qRSxzREFBV0EsQ0FBQyxhQUFha0Y7UUFDdEMsTUFBTSxFQUFFSCxHQUFHUyxRQUFRLEVBQUVSLEdBQUdTLFlBQVksRUFBRSxHQUFHRixJQUFJZixNQUFNLENBQUMsTUFBTVA7UUFDMUQsSUFBSXdCLGFBQWF0QixNQUFNLEVBQ25CLE1BQU0sSUFBSUQsRUFBRTtRQUNoQixNQUFNLEVBQUVhLEdBQUdXLE1BQU0sRUFBRVYsR0FBR1csVUFBVSxFQUFFLEdBQUdKLElBQUlmLE1BQU0sQ0FBQyxNQUFNZ0I7UUFDdEQsTUFBTSxFQUFFVCxHQUFHYSxNQUFNLEVBQUVaLEdBQUdhLFVBQVUsRUFBRSxHQUFHTixJQUFJZixNQUFNLENBQUMsTUFBTW1CO1FBQ3RELElBQUlFLFdBQVcxQixNQUFNLEVBQ2pCLE1BQU0sSUFBSUQsRUFBRTtRQUNoQixPQUFPO1lBQUU0QixHQUFHUixJQUFJZCxNQUFNLENBQUNrQjtZQUFTSyxHQUFHVCxJQUFJZCxNQUFNLENBQUNvQjtRQUFRO0lBQzFEO0lBQ0FJLFlBQVdDLEdBQUc7UUFDVixNQUFNLEVBQUVuQyxNQUFNeUIsR0FBRyxFQUFFTixNQUFNSyxHQUFHLEVBQUUsR0FBRzFCO1FBQ2pDLE1BQU1zQyxLQUFLWCxJQUFJeEIsTUFBTSxDQUFDLE1BQU11QixJQUFJdkIsTUFBTSxDQUFDa0MsSUFBSUgsQ0FBQztRQUM1QyxNQUFNSyxLQUFLWixJQUFJeEIsTUFBTSxDQUFDLE1BQU11QixJQUFJdkIsTUFBTSxDQUFDa0MsSUFBSUYsQ0FBQztRQUM1QyxNQUFNSyxNQUFNRixLQUFLQztRQUNqQixPQUFPWixJQUFJeEIsTUFBTSxDQUFDLE1BQU1xQztJQUM1QjtBQUNKLEVBQUU7QUFDRixxRUFBcUU7QUFDckUsa0JBQWtCO0FBQ2xCLE1BQU0vRCxNQUFNZ0UsT0FBTyxJQUFJM0QsTUFBTTJELE9BQU8sSUFBSTlFLE1BQU04RSxPQUFPLElBQUlDLE1BQU1ELE9BQU8sSUFBSUUsTUFBTUYsT0FBTztBQUNoRixTQUFTRyxlQUFlQyxFQUFFLEVBQUVDLEdBQUc7SUFDbEMsTUFBTSxFQUFFQyxPQUFPQyxRQUFRLEVBQUUsR0FBR0g7SUFDNUIsSUFBSXBGO0lBQ0osSUFBSSxPQUFPcUYsUUFBUSxVQUFVO1FBQ3pCckYsTUFBTXFGO0lBQ1YsT0FDSztRQUNELElBQUlHLFFBQVE3RyxzREFBV0EsQ0FBQyxlQUFlMEc7UUFDdkMsSUFBSTtZQUNBckYsTUFBTW9GLEdBQUdLLFNBQVMsQ0FBQ0Q7UUFDdkIsRUFDQSxPQUFPRSxPQUFPO1lBQ1YsTUFBTSxJQUFJcEUsTUFBTSxDQUFDLDJDQUEyQyxFQUFFaUUsU0FBUyxNQUFNLEVBQUUsT0FBT0YsSUFBSSxDQUFDO1FBQy9GO0lBQ0o7SUFDQSxJQUFJLENBQUNELEdBQUdPLFdBQVcsQ0FBQzNGLE1BQ2hCLE1BQU0sSUFBSXNCLE1BQU07SUFDcEIsT0FBT3RCO0FBQ1g7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztDQWdCQyxHQUNNLFNBQVM0RixhQUFhQyxNQUFNLEVBQUVDLFlBQVksQ0FBQyxDQUFDO0lBQy9DLE1BQU1DLFlBQVk1Ryw2REFBa0JBLENBQUMsZUFBZTBHLFFBQVFDO0lBQzVELE1BQU0sRUFBRUUsRUFBRSxFQUFFWixFQUFFLEVBQUUsR0FBR1c7SUFDbkIsSUFBSUUsUUFBUUYsVUFBVUUsS0FBSztJQUMzQixNQUFNLEVBQUVDLEdBQUdDLFFBQVEsRUFBRTdGLEdBQUc4RixXQUFXLEVBQUUsR0FBR0g7SUFDeENsSSwwREFBZUEsQ0FBQytILFdBQVcsQ0FBQyxHQUFHO1FBQzNCTyxvQkFBb0I7UUFDcEJDLGVBQWU7UUFDZkMsZUFBZTtRQUNmZCxXQUFXO1FBQ1hlLFNBQVM7UUFDVEMsTUFBTTtRQUNOQyxnQkFBZ0I7SUFDcEI7SUFDQSxNQUFNLEVBQUVELElBQUksRUFBRSxHQUFHWDtJQUNqQixJQUFJVyxNQUFNO1FBQ04scUVBQXFFO1FBQ3JFLElBQUksQ0FBQ1QsR0FBR1csR0FBRyxDQUFDVixNQUFNVyxDQUFDLEtBQUssT0FBT0gsS0FBS0ksSUFBSSxLQUFLLFlBQVksQ0FBQ0MsTUFBTUMsT0FBTyxDQUFDTixLQUFLTyxPQUFPLEdBQUc7WUFDbkYsTUFBTSxJQUFJMUYsTUFBTTtRQUNwQjtJQUNKO0lBQ0EsTUFBTTJGLFVBQVVDLFlBQVlsQixJQUFJWjtJQUNoQyxTQUFTK0I7UUFDTCxJQUFJLENBQUNuQixHQUFHb0IsS0FBSyxFQUNULE1BQU0sSUFBSTlGLE1BQU07SUFDeEI7SUFDQSx1Q0FBdUM7SUFDdkMsU0FBUytGLGFBQWFDLEVBQUUsRUFBRUMsS0FBSyxFQUFFQyxZQUFZO1FBQ3pDLE1BQU0sRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUUsR0FBR0gsTUFBTUksUUFBUTtRQUMvQixNQUFNQyxLQUFLNUIsR0FBR1EsT0FBTyxDQUFDaUI7UUFDdEJ4SixrREFBS0EsQ0FBQ3VKLGNBQWM7UUFDcEIsSUFBSUEsY0FBYztZQUNkTDtZQUNBLE1BQU1VLFdBQVcsQ0FBQzdCLEdBQUdvQixLQUFLLENBQUNNO1lBQzNCLE9BQU9qSixzREFBV0EsQ0FBQ3FKLFFBQVFELFdBQVdEO1FBQzFDLE9BQ0s7WUFDRCxPQUFPbkosc0RBQVdBLENBQUNzSixXQUFXQyxFQUFFLENBQUMsT0FBT0osSUFBSTVCLEdBQUdRLE9BQU8sQ0FBQ2tCO1FBQzNEO0lBQ0o7SUFDQSxTQUFTTyxlQUFlekMsS0FBSztRQUN6QnJILG1EQUFNQSxDQUFDcUgsT0FBT3ZELFdBQVc7UUFDekIsTUFBTSxFQUFFaUcsV0FBV0MsSUFBSSxFQUFFQyx1QkFBdUJDLE1BQU0sRUFBRSxHQUFHcEIsU0FBUywyQkFBMkI7UUFDL0YsTUFBTW5FLFNBQVMwQyxNQUFNMUMsTUFBTTtRQUMzQixNQUFNd0YsT0FBTzlDLEtBQUssQ0FBQyxFQUFFO1FBQ3JCLE1BQU0rQyxPQUFPL0MsTUFBTWhDLFFBQVEsQ0FBQztRQUM1QiwyREFBMkQ7UUFDM0QsSUFBSVYsV0FBV3FGLFFBQVNHLENBQUFBLFNBQVMsUUFBUUEsU0FBUyxJQUFHLEdBQUk7WUFDckQsTUFBTWIsSUFBSXpCLEdBQUdQLFNBQVMsQ0FBQzhDO1lBQ3ZCLElBQUksQ0FBQ3ZDLEdBQUd3QyxPQUFPLENBQUNmLElBQ1osTUFBTSxJQUFJbkcsTUFBTTtZQUNwQixNQUFNbUgsS0FBS0Msb0JBQW9CakIsSUFBSSxtQkFBbUI7WUFDdEQsSUFBSUM7WUFDSixJQUFJO2dCQUNBQSxJQUFJMUIsR0FBRzJDLElBQUksQ0FBQ0YsS0FBSyxtQkFBbUI7WUFDeEMsRUFDQSxPQUFPRyxXQUFXO2dCQUNkLE1BQU1DLE1BQU1ELHFCQUFxQnRILFFBQVEsT0FBT3NILFVBQVVFLE9BQU8sR0FBRztnQkFDcEUsTUFBTSxJQUFJeEgsTUFBTSwyQ0FBMkN1SDtZQUMvRDtZQUNBMUI7WUFDQSxNQUFNNEIsU0FBUy9DLEdBQUdvQixLQUFLLENBQUNNLElBQUkscUJBQXFCO1lBQ2pELE1BQU1zQixZQUFZLENBQUNWLE9BQU8sT0FBTyxHQUFHLGlCQUFpQjtZQUNyRCxJQUFJVSxjQUFjRCxRQUNkckIsSUFBSTFCLEdBQUdpRCxHQUFHLENBQUN2QjtZQUNmLE9BQU87Z0JBQUVEO2dCQUFHQztZQUFFO1FBQ2xCLE9BQ0ssSUFBSTVFLFdBQVd1RixVQUFVQyxTQUFTLE1BQU07WUFDekMsb0JBQW9CO1lBQ3BCLE1BQU1ZLElBQUlsRCxHQUFHVixLQUFLO1lBQ2xCLE1BQU1tQyxJQUFJekIsR0FBR1AsU0FBUyxDQUFDOEMsS0FBSy9FLFFBQVEsQ0FBQyxHQUFHMEY7WUFDeEMsTUFBTXhCLElBQUkxQixHQUFHUCxTQUFTLENBQUM4QyxLQUFLL0UsUUFBUSxDQUFDMEYsR0FBR0EsSUFBSTtZQUM1QyxJQUFJLENBQUNDLFVBQVUxQixHQUFHQyxJQUNkLE1BQU0sSUFBSXBHLE1BQU07WUFDcEIsT0FBTztnQkFBRW1HO2dCQUFHQztZQUFFO1FBQ2xCLE9BQ0s7WUFDRCxNQUFNLElBQUlwRyxNQUFNLENBQUMsc0JBQXNCLEVBQUV3QixPQUFPLHNCQUFzQixFQUFFcUYsS0FBSyxpQkFBaUIsRUFBRUUsT0FBTyxDQUFDO1FBQzVHO0lBQ0o7SUFDQSxNQUFNZSxjQUFjdEQsVUFBVVUsT0FBTyxJQUFJYTtJQUN6QyxNQUFNZ0MsY0FBY3ZELFVBQVVMLFNBQVMsSUFBSXdDO0lBQzNDLFNBQVNTLG9CQUFvQmpCLENBQUM7UUFDMUIsTUFBTTZCLEtBQUt0RCxHQUFHdUQsR0FBRyxDQUFDOUIsSUFBSSxRQUFRO1FBQzlCLE1BQU0rQixLQUFLeEQsR0FBR3lELEdBQUcsQ0FBQ0gsSUFBSTdCLElBQUksU0FBUztRQUNuQyxPQUFPekIsR0FBRzBELEdBQUcsQ0FBQzFELEdBQUcwRCxHQUFHLENBQUNGLElBQUl4RCxHQUFHeUQsR0FBRyxDQUFDaEMsR0FBR3hCLE1BQU1XLENBQUMsSUFBSVgsTUFBTXhDLENBQUMsR0FBRyxpQkFBaUI7SUFDN0U7SUFDQSx1QkFBdUI7SUFDdkIsb0VBQW9FLEdBQ3BFLFNBQVMwRixVQUFVMUIsQ0FBQyxFQUFFQyxDQUFDO1FBQ25CLE1BQU1pQyxPQUFPM0QsR0FBR3VELEdBQUcsQ0FBQzdCLElBQUksS0FBSztRQUM3QixNQUFNa0MsUUFBUWxCLG9CQUFvQmpCLElBQUksY0FBYztRQUNwRCxPQUFPekIsR0FBRzZELEdBQUcsQ0FBQ0YsTUFBTUM7SUFDeEI7SUFDQSxzREFBc0Q7SUFDdEQscUVBQXFFO0lBQ3JFLElBQUksQ0FBQ1QsVUFBVWxELE1BQU02RCxFQUFFLEVBQUU3RCxNQUFNOEQsRUFBRSxHQUM3QixNQUFNLElBQUl6SSxNQUFNO0lBQ3BCLG1FQUFtRTtJQUNuRSxzREFBc0Q7SUFDdEQsTUFBTTBJLE9BQU9oRSxHQUFHeUQsR0FBRyxDQUFDekQsR0FBR2lFLEdBQUcsQ0FBQ2hFLE1BQU1XLENBQUMsRUFBRTNCLE1BQU1DO0lBQzFDLE1BQU1nRixRQUFRbEUsR0FBR3lELEdBQUcsQ0FBQ3pELEdBQUd1RCxHQUFHLENBQUN0RCxNQUFNeEMsQ0FBQyxHQUFHdUIsT0FBTztJQUM3QyxJQUFJZ0IsR0FBR1csR0FBRyxDQUFDWCxHQUFHMEQsR0FBRyxDQUFDTSxNQUFNRSxTQUNwQixNQUFNLElBQUk1SSxNQUFNO0lBQ3BCLG9EQUFvRCxHQUNwRCxTQUFTNkksT0FBT0MsS0FBSyxFQUFFOUosQ0FBQyxFQUFFK0osVUFBVSxLQUFLO1FBQ3JDLElBQUksQ0FBQ3JFLEdBQUd3QyxPQUFPLENBQUNsSSxNQUFPK0osV0FBV3JFLEdBQUdXLEdBQUcsQ0FBQ3JHLElBQ3JDLE1BQU0sSUFBSWdCLE1BQU0sQ0FBQyxxQkFBcUIsRUFBRThJLE1BQU0sQ0FBQztRQUNuRCxPQUFPOUo7SUFDWDtJQUNBLFNBQVNnSyxVQUFVQyxLQUFLO1FBQ3BCLElBQUksQ0FBRUEsQ0FBQUEsaUJBQWlCQyxLQUFJLEdBQ3ZCLE1BQU0sSUFBSWxKLE1BQU07SUFDeEI7SUFDQSxTQUFTbUosaUJBQWlCckssQ0FBQztRQUN2QixJQUFJLENBQUNxRyxRQUFRLENBQUNBLEtBQUtPLE9BQU8sRUFDdEIsTUFBTSxJQUFJMUYsTUFBTTtRQUNwQixPQUFPbkIsaUJBQWlCQyxHQUFHcUcsS0FBS08sT0FBTyxFQUFFNUIsR0FBR3NGLEtBQUs7SUFDckQ7SUFDQSw0RUFBNEU7SUFDNUUsMERBQTBEO0lBQzFELCtEQUErRDtJQUMvRCw2QkFBNkI7SUFDN0IsTUFBTUMsZUFBZTVMLG1EQUFRQSxDQUFDLENBQUM2TCxHQUFHQztRQUM5QixNQUFNLEVBQUVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUUsR0FBR0o7UUFDcEIsa0NBQWtDO1FBQ2xDLElBQUk1RSxHQUFHNkQsR0FBRyxDQUFDbUIsR0FBR2hGLEdBQUdpRixHQUFHLEdBQ2hCLE9BQU87WUFBRXhELEdBQUdxRDtZQUFHcEQsR0FBR3FEO1FBQUU7UUFDeEIsTUFBTXBFLE1BQU1pRSxFQUFFakUsR0FBRztRQUNqQix3RUFBd0U7UUFDeEUsOERBQThEO1FBQzlELElBQUlrRSxNQUFNLE1BQ05BLEtBQUtsRSxNQUFNWCxHQUFHaUYsR0FBRyxHQUFHakYsR0FBR2tGLEdBQUcsQ0FBQ0Y7UUFDL0IsTUFBTXZELElBQUl6QixHQUFHeUQsR0FBRyxDQUFDcUIsR0FBR0Q7UUFDcEIsTUFBTW5ELElBQUkxQixHQUFHeUQsR0FBRyxDQUFDc0IsR0FBR0Y7UUFDcEIsTUFBTU0sS0FBS25GLEdBQUd5RCxHQUFHLENBQUN1QixHQUFHSDtRQUNyQixJQUFJbEUsS0FDQSxPQUFPO1lBQUVjLEdBQUd6QixHQUFHb0YsSUFBSTtZQUFFMUQsR0FBRzFCLEdBQUdvRixJQUFJO1FBQUM7UUFDcEMsSUFBSSxDQUFDcEYsR0FBRzZELEdBQUcsQ0FBQ3NCLElBQUluRixHQUFHaUYsR0FBRyxHQUNsQixNQUFNLElBQUkzSixNQUFNO1FBQ3BCLE9BQU87WUFBRW1HO1lBQUdDO1FBQUU7SUFDbEI7SUFDQSx3RUFBd0U7SUFDeEUsZ0NBQWdDO0lBQ2hDLE1BQU0yRCxrQkFBa0J0TSxtREFBUUEsQ0FBQyxDQUFDNkw7UUFDOUIsSUFBSUEsRUFBRWpFLEdBQUcsSUFBSTtZQUNULGtEQUFrRDtZQUNsRCxrREFBa0Q7WUFDbEQsK0NBQStDO1lBQy9DLElBQUliLFVBQVVPLGtCQUFrQixJQUFJLENBQUNMLEdBQUdXLEdBQUcsQ0FBQ2lFLEVBQUVHLENBQUMsR0FDM0M7WUFDSixNQUFNLElBQUl6SixNQUFNO1FBQ3BCO1FBQ0EsMkZBQTJGO1FBQzNGLE1BQU0sRUFBRW1HLENBQUMsRUFBRUMsQ0FBQyxFQUFFLEdBQUdrRCxFQUFFakQsUUFBUTtRQUMzQixJQUFJLENBQUMzQixHQUFHd0MsT0FBTyxDQUFDZixNQUFNLENBQUN6QixHQUFHd0MsT0FBTyxDQUFDZCxJQUM5QixNQUFNLElBQUlwRyxNQUFNO1FBQ3BCLElBQUksQ0FBQzZILFVBQVUxQixHQUFHQyxJQUNkLE1BQU0sSUFBSXBHLE1BQU07UUFDcEIsSUFBSSxDQUFDc0osRUFBRXJFLGFBQWEsSUFDaEIsTUFBTSxJQUFJakYsTUFBTTtRQUNwQixPQUFPO0lBQ1g7SUFDQSxTQUFTZ0ssV0FBV0MsUUFBUSxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRTFLLEtBQUssRUFBRUUsS0FBSztRQUNoRHdLLE1BQU0sSUFBSWpCLE1BQU14RSxHQUFHeUQsR0FBRyxDQUFDZ0MsSUFBSVgsQ0FBQyxFQUFFUyxXQUFXRSxJQUFJVixDQUFDLEVBQUVVLElBQUlULENBQUM7UUFDckRRLE1BQU1uTSxtREFBUUEsQ0FBQzBCLE9BQU95SztRQUN0QkMsTUFBTXBNLG1EQUFRQSxDQUFDNEIsT0FBT3dLO1FBQ3RCLE9BQU9ELElBQUk5QixHQUFHLENBQUMrQjtJQUNuQjtJQUNBOzs7O0tBSUMsR0FDRCxNQUFNakI7UUFDRixzRUFBc0UsR0FDdEVuSSxZQUFZeUksQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsQ0FBRTtZQUNqQixJQUFJLENBQUNGLENBQUMsR0FBR1gsT0FBTyxLQUFLVztZQUNyQixJQUFJLENBQUNDLENBQUMsR0FBR1osT0FBTyxLQUFLWSxHQUFHO1lBQ3hCLElBQUksQ0FBQ0MsQ0FBQyxHQUFHYixPQUFPLEtBQUthO1lBQ3JCakosT0FBTzJKLE1BQU0sQ0FBQyxJQUFJO1FBQ3RCO1FBQ0EsT0FBT3pGLFFBQVE7WUFDWCxPQUFPQTtRQUNYO1FBQ0Esc0VBQXNFLEdBQ3RFLE9BQU8wRixXQUFXZixDQUFDLEVBQUU7WUFDakIsTUFBTSxFQUFFbkQsQ0FBQyxFQUFFQyxDQUFDLEVBQUUsR0FBR2tELEtBQUssQ0FBQztZQUN2QixJQUFJLENBQUNBLEtBQUssQ0FBQzVFLEdBQUd3QyxPQUFPLENBQUNmLE1BQU0sQ0FBQ3pCLEdBQUd3QyxPQUFPLENBQUNkLElBQ3BDLE1BQU0sSUFBSXBHLE1BQU07WUFDcEIsSUFBSXNKLGFBQWFKLE9BQ2IsTUFBTSxJQUFJbEosTUFBTTtZQUNwQixrRUFBa0U7WUFDbEUsSUFBSTBFLEdBQUdXLEdBQUcsQ0FBQ2MsTUFBTXpCLEdBQUdXLEdBQUcsQ0FBQ2UsSUFDcEIsT0FBTzhDLE1BQU1ZLElBQUk7WUFDckIsT0FBTyxJQUFJWixNQUFNL0MsR0FBR0MsR0FBRzFCLEdBQUdpRixHQUFHO1FBQ2pDO1FBQ0EsT0FBT3hGLFVBQVVELEtBQUssRUFBRTtZQUNwQixNQUFNb0csSUFBSXBCLE1BQU1tQixVQUFVLENBQUN0QyxZQUFZbEwsbURBQU1BLENBQUNxSCxPQUFPdkQsV0FBVztZQUNoRTJKLEVBQUVDLGNBQWM7WUFDaEIsT0FBT0Q7UUFDWDtRQUNBLE9BQU9FLFFBQVFqSSxHQUFHLEVBQUU7WUFDaEIsT0FBTzJHLE1BQU0vRSxTQUFTLENBQUM5RyxzREFBV0EsQ0FBQyxZQUFZa0Y7UUFDbkQ7UUFDQSxJQUFJNEQsSUFBSTtZQUNKLE9BQU8sSUFBSSxDQUFDRSxRQUFRLEdBQUdGLENBQUM7UUFDNUI7UUFDQSxJQUFJQyxJQUFJO1lBQ0osT0FBTyxJQUFJLENBQUNDLFFBQVEsR0FBR0QsQ0FBQztRQUM1QjtRQUNBOzs7OztTQUtDLEdBQ0RxRSxXQUFXQyxhQUFhLENBQUMsRUFBRUMsU0FBUyxJQUFJLEVBQUU7WUFDdENDLEtBQUtDLFdBQVcsQ0FBQyxJQUFJLEVBQUVIO1lBQ3ZCLElBQUksQ0FBQ0MsUUFDRCxJQUFJLENBQUNHLFFBQVEsQ0FBQ25ILE1BQU0sZ0JBQWdCO1lBQ3hDLE9BQU8sSUFBSTtRQUNmO1FBQ0Esc0JBQXNCO1FBQ3RCLDBEQUEwRCxHQUMxRDRHLGlCQUFpQjtZQUNiUixnQkFBZ0IsSUFBSTtRQUN4QjtRQUNBeEQsV0FBVztZQUNQLE1BQU0sRUFBRUgsQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDQyxRQUFRO1lBQzNCLElBQUksQ0FBQzNCLEdBQUdvQixLQUFLLEVBQ1QsTUFBTSxJQUFJOUYsTUFBTTtZQUNwQixPQUFPLENBQUMwRSxHQUFHb0IsS0FBSyxDQUFDTTtRQUNyQjtRQUNBLGtDQUFrQyxHQUNsQzJFLE9BQU85QixLQUFLLEVBQUU7WUFDVkQsVUFBVUM7WUFDVixNQUFNLEVBQUVPLEdBQUd3QixFQUFFLEVBQUV2QixHQUFHd0IsRUFBRSxFQUFFdkIsR0FBR3dCLEVBQUUsRUFBRSxHQUFHLElBQUk7WUFDcEMsTUFBTSxFQUFFMUIsR0FBRzJCLEVBQUUsRUFBRTFCLEdBQUcyQixFQUFFLEVBQUUxQixHQUFHMkIsRUFBRSxFQUFFLEdBQUdwQztZQUNoQyxNQUFNcUMsS0FBSzVHLEdBQUc2RCxHQUFHLENBQUM3RCxHQUFHeUQsR0FBRyxDQUFDNkMsSUFBSUssS0FBSzNHLEdBQUd5RCxHQUFHLENBQUNnRCxJQUFJRDtZQUM3QyxNQUFNSyxLQUFLN0csR0FBRzZELEdBQUcsQ0FBQzdELEdBQUd5RCxHQUFHLENBQUM4QyxJQUFJSSxLQUFLM0csR0FBR3lELEdBQUcsQ0FBQ2lELElBQUlGO1lBQzdDLE9BQU9JLE1BQU1DO1FBQ2pCO1FBQ0EsdUVBQXVFLEdBQ3ZFQyxTQUFTO1lBQ0wsT0FBTyxJQUFJdEMsTUFBTSxJQUFJLENBQUNNLENBQUMsRUFBRTlFLEdBQUdpRCxHQUFHLENBQUMsSUFBSSxDQUFDOEIsQ0FBQyxHQUFHLElBQUksQ0FBQ0MsQ0FBQztRQUNuRDtRQUNBLHlEQUF5RDtRQUN6RCxnRUFBZ0U7UUFDaEUsaURBQWlEO1FBQ2pELHNDQUFzQztRQUN0QytCLFNBQVM7WUFDTCxNQUFNLEVBQUVuRyxDQUFDLEVBQUVuRCxDQUFDLEVBQUUsR0FBR3dDO1lBQ2pCLE1BQU0rRyxLQUFLaEgsR0FBR3lELEdBQUcsQ0FBQ2hHLEdBQUd3QjtZQUNyQixNQUFNLEVBQUU2RixHQUFHd0IsRUFBRSxFQUFFdkIsR0FBR3dCLEVBQUUsRUFBRXZCLEdBQUd3QixFQUFFLEVBQUUsR0FBRyxJQUFJO1lBQ3BDLElBQUlTLEtBQUtqSCxHQUFHb0YsSUFBSSxFQUFFOEIsS0FBS2xILEdBQUdvRixJQUFJLEVBQUUrQixLQUFLbkgsR0FBR29GLElBQUksRUFBRSxrQkFBa0I7WUFDaEUsSUFBSWdDLEtBQUtwSCxHQUFHeUQsR0FBRyxDQUFDNkMsSUFBSUEsS0FBSyxTQUFTO1lBQ2xDLElBQUllLEtBQUtySCxHQUFHeUQsR0FBRyxDQUFDOEMsSUFBSUE7WUFDcEIsSUFBSWUsS0FBS3RILEdBQUd5RCxHQUFHLENBQUMrQyxJQUFJQTtZQUNwQixJQUFJZSxLQUFLdkgsR0FBR3lELEdBQUcsQ0FBQzZDLElBQUlDO1lBQ3BCZ0IsS0FBS3ZILEdBQUcwRCxHQUFHLENBQUM2RCxJQUFJQSxLQUFLLFNBQVM7WUFDOUJKLEtBQUtuSCxHQUFHeUQsR0FBRyxDQUFDNkMsSUFBSUU7WUFDaEJXLEtBQUtuSCxHQUFHMEQsR0FBRyxDQUFDeUQsSUFBSUE7WUFDaEJGLEtBQUtqSCxHQUFHeUQsR0FBRyxDQUFDN0MsR0FBR3VHO1lBQ2ZELEtBQUtsSCxHQUFHeUQsR0FBRyxDQUFDdUQsSUFBSU07WUFDaEJKLEtBQUtsSCxHQUFHMEQsR0FBRyxDQUFDdUQsSUFBSUMsS0FBSyxVQUFVO1lBQy9CRCxLQUFLakgsR0FBR3dILEdBQUcsQ0FBQ0gsSUFBSUg7WUFDaEJBLEtBQUtsSCxHQUFHMEQsR0FBRyxDQUFDMkQsSUFBSUg7WUFDaEJBLEtBQUtsSCxHQUFHeUQsR0FBRyxDQUFDd0QsSUFBSUM7WUFDaEJELEtBQUtqSCxHQUFHeUQsR0FBRyxDQUFDOEQsSUFBSU47WUFDaEJFLEtBQUtuSCxHQUFHeUQsR0FBRyxDQUFDdUQsSUFBSUcsS0FBSyxVQUFVO1lBQy9CRyxLQUFLdEgsR0FBR3lELEdBQUcsQ0FBQzdDLEdBQUcwRztZQUNmQyxLQUFLdkgsR0FBR3dILEdBQUcsQ0FBQ0osSUFBSUU7WUFDaEJDLEtBQUt2SCxHQUFHeUQsR0FBRyxDQUFDN0MsR0FBRzJHO1lBQ2ZBLEtBQUt2SCxHQUFHMEQsR0FBRyxDQUFDNkQsSUFBSUo7WUFDaEJBLEtBQUtuSCxHQUFHMEQsR0FBRyxDQUFDMEQsSUFBSUEsS0FBSyxVQUFVO1lBQy9CQSxLQUFLcEgsR0FBRzBELEdBQUcsQ0FBQ3lELElBQUlDO1lBQ2hCQSxLQUFLcEgsR0FBRzBELEdBQUcsQ0FBQzBELElBQUlFO1lBQ2hCRixLQUFLcEgsR0FBR3lELEdBQUcsQ0FBQzJELElBQUlHO1lBQ2hCTCxLQUFLbEgsR0FBRzBELEdBQUcsQ0FBQ3dELElBQUlFO1lBQ2hCRSxLQUFLdEgsR0FBR3lELEdBQUcsQ0FBQzhDLElBQUlDLEtBQUssVUFBVTtZQUMvQmMsS0FBS3RILEdBQUcwRCxHQUFHLENBQUM0RCxJQUFJQTtZQUNoQkYsS0FBS3BILEdBQUd5RCxHQUFHLENBQUM2RCxJQUFJQztZQUNoQk4sS0FBS2pILEdBQUd3SCxHQUFHLENBQUNQLElBQUlHO1lBQ2hCRCxLQUFLbkgsR0FBR3lELEdBQUcsQ0FBQzZELElBQUlEO1lBQ2hCRixLQUFLbkgsR0FBRzBELEdBQUcsQ0FBQ3lELElBQUlBLEtBQUssVUFBVTtZQUMvQkEsS0FBS25ILEdBQUcwRCxHQUFHLENBQUN5RCxJQUFJQTtZQUNoQixPQUFPLElBQUkzQyxNQUFNeUMsSUFBSUMsSUFBSUM7UUFDN0I7UUFDQSx5REFBeUQ7UUFDekQsZ0VBQWdFO1FBQ2hFLGlEQUFpRDtRQUNqRCx1Q0FBdUM7UUFDdkN6RCxJQUFJYSxLQUFLLEVBQUU7WUFDUEQsVUFBVUM7WUFDVixNQUFNLEVBQUVPLEdBQUd3QixFQUFFLEVBQUV2QixHQUFHd0IsRUFBRSxFQUFFdkIsR0FBR3dCLEVBQUUsRUFBRSxHQUFHLElBQUk7WUFDcEMsTUFBTSxFQUFFMUIsR0FBRzJCLEVBQUUsRUFBRTFCLEdBQUcyQixFQUFFLEVBQUUxQixHQUFHMkIsRUFBRSxFQUFFLEdBQUdwQztZQUNoQyxJQUFJMEMsS0FBS2pILEdBQUdvRixJQUFJLEVBQUU4QixLQUFLbEgsR0FBR29GLElBQUksRUFBRStCLEtBQUtuSCxHQUFHb0YsSUFBSSxFQUFFLGtCQUFrQjtZQUNoRSxNQUFNeEUsSUFBSVgsTUFBTVcsQ0FBQztZQUNqQixNQUFNb0csS0FBS2hILEdBQUd5RCxHQUFHLENBQUN4RCxNQUFNeEMsQ0FBQyxFQUFFd0I7WUFDM0IsSUFBSW1JLEtBQUtwSCxHQUFHeUQsR0FBRyxDQUFDNkMsSUFBSUcsS0FBSyxTQUFTO1lBQ2xDLElBQUlZLEtBQUtySCxHQUFHeUQsR0FBRyxDQUFDOEMsSUFBSUc7WUFDcEIsSUFBSVksS0FBS3RILEdBQUd5RCxHQUFHLENBQUMrQyxJQUFJRztZQUNwQixJQUFJWSxLQUFLdkgsR0FBRzBELEdBQUcsQ0FBQzRDLElBQUlDO1lBQ3BCLElBQUlrQixLQUFLekgsR0FBRzBELEdBQUcsQ0FBQytDLElBQUlDLEtBQUssU0FBUztZQUNsQ2EsS0FBS3ZILEdBQUd5RCxHQUFHLENBQUM4RCxJQUFJRTtZQUNoQkEsS0FBS3pILEdBQUcwRCxHQUFHLENBQUMwRCxJQUFJQztZQUNoQkUsS0FBS3ZILEdBQUd3SCxHQUFHLENBQUNELElBQUlFO1lBQ2hCQSxLQUFLekgsR0FBRzBELEdBQUcsQ0FBQzRDLElBQUlFO1lBQ2hCLElBQUlrQixLQUFLMUgsR0FBRzBELEdBQUcsQ0FBQytDLElBQUlFLEtBQUssVUFBVTtZQUNuQ2MsS0FBS3pILEdBQUd5RCxHQUFHLENBQUNnRSxJQUFJQztZQUNoQkEsS0FBSzFILEdBQUcwRCxHQUFHLENBQUMwRCxJQUFJRTtZQUNoQkcsS0FBS3pILEdBQUd3SCxHQUFHLENBQUNDLElBQUlDO1lBQ2hCQSxLQUFLMUgsR0FBRzBELEdBQUcsQ0FBQzZDLElBQUlDO1lBQ2hCUyxLQUFLakgsR0FBRzBELEdBQUcsQ0FBQ2dELElBQUlDLEtBQUssVUFBVTtZQUMvQmUsS0FBSzFILEdBQUd5RCxHQUFHLENBQUNpRSxJQUFJVDtZQUNoQkEsS0FBS2pILEdBQUcwRCxHQUFHLENBQUMyRCxJQUFJQztZQUNoQkksS0FBSzFILEdBQUd3SCxHQUFHLENBQUNFLElBQUlUO1lBQ2hCRSxLQUFLbkgsR0FBR3lELEdBQUcsQ0FBQzdDLEdBQUc2RztZQUNmUixLQUFLakgsR0FBR3lELEdBQUcsQ0FBQ3VELElBQUlNLEtBQUssVUFBVTtZQUMvQkgsS0FBS25ILEdBQUcwRCxHQUFHLENBQUN1RCxJQUFJRTtZQUNoQkYsS0FBS2pILEdBQUd3SCxHQUFHLENBQUNILElBQUlGO1lBQ2hCQSxLQUFLbkgsR0FBRzBELEdBQUcsQ0FBQzJELElBQUlGO1lBQ2hCRCxLQUFLbEgsR0FBR3lELEdBQUcsQ0FBQ3dELElBQUlFO1lBQ2hCRSxLQUFLckgsR0FBRzBELEdBQUcsQ0FBQzBELElBQUlBLEtBQUssVUFBVTtZQUMvQkMsS0FBS3JILEdBQUcwRCxHQUFHLENBQUMyRCxJQUFJRDtZQUNoQkUsS0FBS3RILEdBQUd5RCxHQUFHLENBQUM3QyxHQUFHMEc7WUFDZkcsS0FBS3pILEdBQUd5RCxHQUFHLENBQUN1RCxJQUFJUztZQUNoQkosS0FBS3JILEdBQUcwRCxHQUFHLENBQUMyRCxJQUFJQztZQUNoQkEsS0FBS3RILEdBQUd3SCxHQUFHLENBQUNKLElBQUlFLEtBQUssVUFBVTtZQUMvQkEsS0FBS3RILEdBQUd5RCxHQUFHLENBQUM3QyxHQUFHMEc7WUFDZkcsS0FBS3pILEdBQUcwRCxHQUFHLENBQUMrRCxJQUFJSDtZQUNoQkYsS0FBS3BILEdBQUd5RCxHQUFHLENBQUM0RCxJQUFJSTtZQUNoQlAsS0FBS2xILEdBQUcwRCxHQUFHLENBQUN3RCxJQUFJRTtZQUNoQkEsS0FBS3BILEdBQUd5RCxHQUFHLENBQUNpRSxJQUFJRCxLQUFLLFVBQVU7WUFDL0JSLEtBQUtqSCxHQUFHeUQsR0FBRyxDQUFDOEQsSUFBSU47WUFDaEJBLEtBQUtqSCxHQUFHd0gsR0FBRyxDQUFDUCxJQUFJRztZQUNoQkEsS0FBS3BILEdBQUd5RCxHQUFHLENBQUM4RCxJQUFJRjtZQUNoQkYsS0FBS25ILEdBQUd5RCxHQUFHLENBQUNpRSxJQUFJUDtZQUNoQkEsS0FBS25ILEdBQUcwRCxHQUFHLENBQUN5RCxJQUFJQyxLQUFLLFVBQVU7WUFDL0IsT0FBTyxJQUFJNUMsTUFBTXlDLElBQUlDLElBQUlDO1FBQzdCO1FBQ0FRLFNBQVNwRCxLQUFLLEVBQUU7WUFDWixPQUFPLElBQUksQ0FBQ2IsR0FBRyxDQUFDYSxNQUFNdUMsTUFBTTtRQUNoQztRQUNBbkcsTUFBTTtZQUNGLE9BQU8sSUFBSSxDQUFDMEYsTUFBTSxDQUFDN0IsTUFBTVksSUFBSTtRQUNqQztRQUNBOzs7Ozs7OztTQVFDLEdBQ0RnQixTQUFTd0IsTUFBTSxFQUFFO1lBQ2IsTUFBTSxFQUFFbkgsSUFBSSxFQUFFLEdBQUdYO1lBQ2pCLElBQUksQ0FBQ1YsR0FBR08sV0FBVyxDQUFDaUksU0FDaEIsTUFBTSxJQUFJdE0sTUFBTSxpQ0FBaUMsZUFBZTtZQUNwRSxJQUFJaUcsT0FBT3NHLE1BQU0sd0NBQXdDO1lBQ3pELE1BQU1wRSxNQUFNLENBQUNuSixJQUFNNEwsS0FBSzRCLE1BQU0sQ0FBQyxJQUFJLEVBQUV4TixHQUFHLENBQUNzSyxJQUFNdEwscURBQVVBLENBQUNrTCxPQUFPSTtZQUNqRSwwQ0FBMEMsR0FDMUMsSUFBSW5FLE1BQU07Z0JBQ04sTUFBTSxFQUFFMUYsS0FBSyxFQUFFRixFQUFFLEVBQUVJLEtBQUssRUFBRUgsRUFBRSxFQUFFLEdBQUcySixpQkFBaUJtRDtnQkFDbEQsTUFBTSxFQUFFaEQsR0FBR1ksR0FBRyxFQUFFdUMsR0FBR0MsR0FBRyxFQUFFLEdBQUd2RSxJQUFJNUk7Z0JBQy9CLE1BQU0sRUFBRStKLEdBQUdhLEdBQUcsRUFBRXNDLEdBQUdFLEdBQUcsRUFBRSxHQUFHeEUsSUFBSTNJO2dCQUMvQitNLE9BQU9HLElBQUl0RSxHQUFHLENBQUN1RTtnQkFDZjFHLFFBQVErRCxXQUFXN0UsS0FBS0ksSUFBSSxFQUFFMkUsS0FBS0MsS0FBSzFLLE9BQU9FO1lBQ25ELE9BQ0s7Z0JBQ0QsTUFBTSxFQUFFMkosQ0FBQyxFQUFFbUQsQ0FBQyxFQUFFLEdBQUd0RSxJQUFJbUU7Z0JBQ3JCckcsUUFBUXFEO2dCQUNSaUQsT0FBT0U7WUFDWDtZQUNBLDBEQUEwRDtZQUMxRCxPQUFPek8scURBQVVBLENBQUNrTCxPQUFPO2dCQUFDakQ7Z0JBQU9zRzthQUFLLENBQUMsQ0FBQyxFQUFFO1FBQzlDO1FBQ0E7Ozs7U0FJQyxHQUNESyxlQUFlQyxFQUFFLEVBQUU7WUFDZixNQUFNLEVBQUUxSCxJQUFJLEVBQUUsR0FBR1g7WUFDakIsTUFBTThFLElBQUksSUFBSTtZQUNkLElBQUksQ0FBQ3hGLEdBQUdvRCxPQUFPLENBQUMyRixLQUNaLE1BQU0sSUFBSTdNLE1BQU0saUNBQWlDLGFBQWE7WUFDbEUsSUFBSTZNLE9BQU9uTixPQUFPNEosRUFBRWpFLEdBQUcsSUFDbkIsT0FBTzZELE1BQU1ZLElBQUk7WUFDckIsSUFBSStDLE9BQU85TSxLQUNQLE9BQU91SixHQUFHLFlBQVk7WUFDMUIsSUFBSXNCLEtBQUtrQyxRQUFRLENBQUMsSUFBSSxHQUNsQixPQUFPLElBQUksQ0FBQ2hDLFFBQVEsQ0FBQytCO1lBQ3pCLElBQUkxSCxNQUFNO2dCQUNOLE1BQU0sRUFBRTFGLEtBQUssRUFBRUYsRUFBRSxFQUFFSSxLQUFLLEVBQUVILEVBQUUsRUFBRSxHQUFHMkosaUJBQWlCMEQ7Z0JBQ2xELE1BQU0sRUFBRUUsRUFBRSxFQUFFQyxFQUFFLEVBQUUsR0FBR2xQLHdEQUFhQSxDQUFDb0wsT0FBT0ksR0FBRy9KLElBQUlDLEtBQUssNEJBQTRCO2dCQUNoRixPQUFPd0ssV0FBVzdFLEtBQUtJLElBQUksRUFBRXdILElBQUlDLElBQUl2TixPQUFPRTtZQUNoRCxPQUNLO2dCQUNELE9BQU9pTCxLQUFLcUMsTUFBTSxDQUFDM0QsR0FBR3VEO1lBQzFCO1FBQ0o7UUFDQUsscUJBQXFCQyxDQUFDLEVBQUU3SCxDQUFDLEVBQUVuRCxDQUFDLEVBQUU7WUFDMUIsTUFBTWlMLE1BQU0sSUFBSSxDQUFDUixjQUFjLENBQUN0SCxHQUFHOEMsR0FBRyxDQUFDK0UsRUFBRVAsY0FBYyxDQUFDeks7WUFDeEQsT0FBT2lMLElBQUkvSCxHQUFHLEtBQUsxRSxZQUFZeU07UUFDbkM7UUFDQTs7O1NBR0MsR0FDRC9HLFNBQVNnSCxTQUFTLEVBQUU7WUFDaEIsT0FBT2hFLGFBQWEsSUFBSSxFQUFFZ0U7UUFDOUI7UUFDQTs7O1NBR0MsR0FDRHBJLGdCQUFnQjtZQUNaLE1BQU0sRUFBRUEsYUFBYSxFQUFFLEdBQUdUO1lBQzFCLElBQUlLLGFBQWE5RSxLQUNiLE9BQU87WUFDWCxJQUFJa0YsZUFDQSxPQUFPQSxjQUFjaUUsT0FBTyxJQUFJO1lBQ3BDLE9BQU8wQixLQUFLcUMsTUFBTSxDQUFDLElBQUksRUFBRW5JLGFBQWFPLEdBQUc7UUFDN0M7UUFDQUwsZ0JBQWdCO1lBQ1osTUFBTSxFQUFFQSxhQUFhLEVBQUUsR0FBR1I7WUFDMUIsSUFBSUssYUFBYTlFLEtBQ2IsT0FBTyxJQUFJLEVBQUUsWUFBWTtZQUM3QixJQUFJaUYsZUFDQSxPQUFPQSxjQUFja0UsT0FBTyxJQUFJO1lBQ3BDLE9BQU8sSUFBSSxDQUFDMEQsY0FBYyxDQUFDL0g7UUFDL0I7UUFDQXlJLGVBQWU7WUFDWCxtQ0FBbUM7WUFDbkMsT0FBTyxJQUFJLENBQUNWLGNBQWMsQ0FBQy9ILFVBQVVRLEdBQUc7UUFDNUM7UUFDQUgsUUFBUWdCLGVBQWUsSUFBSSxFQUFFO1lBQ3pCdkosa0RBQUtBLENBQUN1SixjQUFjO1lBQ3BCLElBQUksQ0FBQ3FFLGNBQWM7WUFDbkIsT0FBT3pDLFlBQVlvQixPQUFPLElBQUksRUFBRWhEO1FBQ3BDO1FBQ0FxSCxNQUFNckgsZUFBZSxJQUFJLEVBQUU7WUFDdkIsT0FBT2pKLHFEQUFVQSxDQUFDLElBQUksQ0FBQ2lJLE9BQU8sQ0FBQ2dCO1FBQ25DO1FBQ0FzSCxXQUFXO1lBQ1AsT0FBTyxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUNuSSxHQUFHLEtBQUssU0FBUyxJQUFJLENBQUNrSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO1FBQzFEO1FBQ0EsZUFBZTtRQUNmLElBQUlFLEtBQUs7WUFDTCxPQUFPLElBQUksQ0FBQ2pFLENBQUM7UUFDakI7UUFDQSxJQUFJa0UsS0FBSztZQUNMLE9BQU8sSUFBSSxDQUFDbEUsQ0FBQztRQUNqQjtRQUNBLElBQUltRSxLQUFLO1lBQ0wsT0FBTyxJQUFJLENBQUNqRSxDQUFDO1FBQ2pCO1FBQ0FrRSxXQUFXMUgsZUFBZSxJQUFJLEVBQUU7WUFDNUIsT0FBTyxJQUFJLENBQUNoQixPQUFPLENBQUNnQjtRQUN4QjtRQUNBMkgsZUFBZW5ELFVBQVUsRUFBRTtZQUN2QixJQUFJLENBQUNELFVBQVUsQ0FBQ0M7UUFDcEI7UUFDQSxPQUFPMU0sV0FBVzhQLE1BQU0sRUFBRTtZQUN0QixPQUFPOVAscURBQVVBLENBQUNrTCxPQUFPNEU7UUFDN0I7UUFDQSxPQUFPQyxJQUFJRCxNQUFNLEVBQUVFLE9BQU8sRUFBRTtZQUN4QixPQUFPL1Asb0RBQVNBLENBQUNpTCxPQUFPcEYsSUFBSWdLLFFBQVFFO1FBQ3hDO1FBQ0EsT0FBT0MsZUFBZUMsVUFBVSxFQUFFO1lBQzlCLE9BQU9oRixNQUFNaUYsSUFBSSxDQUFDckQsUUFBUSxDQUFDakgsZUFBZUMsSUFBSW9LO1FBQ2xEO0lBQ0o7SUFDQSx5QkFBeUI7SUFDekJoRixNQUFNaUYsSUFBSSxHQUFHLElBQUlqRixNQUFNdkUsTUFBTTZELEVBQUUsRUFBRTdELE1BQU04RCxFQUFFLEVBQUUvRCxHQUFHaUYsR0FBRztJQUNqRCxtQ0FBbUM7SUFDbkNULE1BQU1ZLElBQUksR0FBRyxJQUFJWixNQUFNeEUsR0FBR29GLElBQUksRUFBRXBGLEdBQUdpRixHQUFHLEVBQUVqRixHQUFHb0YsSUFBSSxHQUFHLFVBQVU7SUFDNUQsYUFBYTtJQUNiWixNQUFNeEUsRUFBRSxHQUFHQTtJQUNYLGVBQWU7SUFDZndFLE1BQU1wRixFQUFFLEdBQUdBO0lBQ1gsTUFBTXNLLE9BQU90SyxHQUFHdUssSUFBSTtJQUNwQixNQUFNekQsT0FBTyxJQUFJMU0sMkNBQUlBLENBQUNnTCxPQUFPMUUsVUFBVVcsSUFBSSxHQUFHdEYsS0FBS0MsSUFBSSxDQUFDc08sT0FBTyxLQUFLQTtJQUNwRWxGLE1BQU1pRixJQUFJLENBQUMxRCxVQUFVLENBQUMsSUFBSSxzRUFBc0U7SUFDaEcsT0FBT3ZCO0FBQ1g7QUFDQSw2REFBNkQ7QUFDN0QsU0FBUzFDLFFBQVFELFFBQVE7SUFDckIsT0FBT0UsV0FBV0MsRUFBRSxDQUFDSCxXQUFXLE9BQU87QUFDM0M7QUFDQTs7Ozs7Ozs7Q0FRQyxHQUNNLFNBQVMrSCxlQUFlNUosRUFBRSxFQUFFZ0YsQ0FBQztJQUNoQyx5QkFBeUI7SUFDekIsTUFBTTZFLElBQUk3SixHQUFHMEUsS0FBSztJQUNsQixJQUFJL0csSUFBSTNDO0lBQ1IsSUFBSyxJQUFJOE8sSUFBSUQsSUFBSXhPLEtBQUt5TyxJQUFJNVAsUUFBUWMsS0FBSzhPLEtBQUs1UCxJQUN4Q3lELEtBQUt0QztJQUNULE1BQU1WLEtBQUtnRCxHQUFHLDJEQUEyRDtJQUN6RSx5RUFBeUU7SUFDekUsMkJBQTJCO0lBQzNCLE1BQU1vTSxlQUFlN1AsT0FBUVMsS0FBS1UsTUFBTUE7SUFDeEMsTUFBTTJPLGFBQWFELGVBQWU3UDtJQUNsQyxNQUFNVSxLQUFLLENBQUNpUCxJQUFJeE8sR0FBRSxJQUFLMk8sWUFBWSxpREFBaUQ7SUFDcEYsTUFBTUMsS0FBSyxDQUFDclAsS0FBS1MsR0FBRSxJQUFLbkIsS0FBSyx1REFBdUQ7SUFDcEYsTUFBTWdRLEtBQUtGLGFBQWEzTyxLQUFLLHVEQUF1RDtJQUNwRixNQUFNOE8sS0FBS0osY0FBYywyREFBMkQ7SUFDcEYsTUFBTUssS0FBS3BLLEdBQUdpRSxHQUFHLENBQUNlLEdBQUdwSyxLQUFLLGVBQWU7SUFDekMsTUFBTXlQLEtBQUtySyxHQUFHaUUsR0FBRyxDQUFDZSxHQUFHLENBQUNwSyxLQUFLUyxHQUFFLElBQUtuQixNQUFNLDJCQUEyQjtJQUNuRSxJQUFJb1EsWUFBWSxDQUFDQyxHQUFHN007UUFDaEIsSUFBSThNLE1BQU1KLElBQUksY0FBYztRQUM1QixJQUFJSyxNQUFNekssR0FBR2lFLEdBQUcsQ0FBQ3ZHLEdBQUd3TSxLQUFLLGdCQUFnQjtRQUN6QyxJQUFJUSxNQUFNMUssR0FBR3VELEdBQUcsQ0FBQ2tILE1BQU0saUJBQWlCO1FBQ3hDQyxNQUFNMUssR0FBR3lELEdBQUcsQ0FBQ2lILEtBQUtoTixJQUFJLG1CQUFtQjtRQUN6QyxJQUFJaU4sTUFBTTNLLEdBQUd5RCxHQUFHLENBQUM4RyxHQUFHRyxNQUFNLG1CQUFtQjtRQUM3Q0MsTUFBTTNLLEdBQUdpRSxHQUFHLENBQUMwRyxLQUFLVixLQUFLLGtCQUFrQjtRQUN6Q1UsTUFBTTNLLEdBQUd5RCxHQUFHLENBQUNrSCxLQUFLRixNQUFNLHFCQUFxQjtRQUM3Q0EsTUFBTXpLLEdBQUd5RCxHQUFHLENBQUNrSCxLQUFLak4sSUFBSSxtQkFBbUI7UUFDekNnTixNQUFNMUssR0FBR3lELEdBQUcsQ0FBQ2tILEtBQUtKLElBQUksbUJBQW1CO1FBQ3pDLElBQUlLLE1BQU01SyxHQUFHeUQsR0FBRyxDQUFDaUgsS0FBS0QsTUFBTSxzQkFBc0I7UUFDbERFLE1BQU0zSyxHQUFHaUUsR0FBRyxDQUFDMkcsS0FBS1QsS0FBSyxtQkFBbUI7UUFDMUMsSUFBSVUsT0FBTzdLLEdBQUc2RCxHQUFHLENBQUM4RyxLQUFLM0ssR0FBR2lGLEdBQUcsR0FBRyxzQkFBc0I7UUFDdER3RixNQUFNekssR0FBR3lELEdBQUcsQ0FBQ2lILEtBQUtMLEtBQUsscUJBQXFCO1FBQzVDTSxNQUFNM0ssR0FBR3lELEdBQUcsQ0FBQ21ILEtBQUtKLE1BQU0sc0JBQXNCO1FBQzlDRSxNQUFNMUssR0FBRzhLLElBQUksQ0FBQ0wsS0FBS0MsS0FBS0csT0FBTyxpQ0FBaUM7UUFDaEVELE1BQU01SyxHQUFHOEssSUFBSSxDQUFDSCxLQUFLQyxLQUFLQyxPQUFPLGlDQUFpQztRQUNoRSxxQ0FBcUM7UUFDckMsSUFBSyxJQUFJRSxJQUFJcFEsSUFBSW9RLElBQUkxUCxLQUFLMFAsSUFBSztZQUMzQixJQUFJSixNQUFNSSxJQUFJN1EsS0FBSyxxQkFBcUI7WUFDeEN5USxNQUFNelEsT0FBUXlRLE1BQU10UCxLQUFNLHFCQUFxQjtZQUMvQyxJQUFJMlAsT0FBT2hMLEdBQUdpRSxHQUFHLENBQUMyRyxLQUFLRCxNQUFNLHVCQUF1QjtZQUNwRCxNQUFNTSxLQUFLakwsR0FBRzZELEdBQUcsQ0FBQ21ILE1BQU1oTCxHQUFHaUYsR0FBRyxHQUFHLHVCQUF1QjtZQUN4RHdGLE1BQU16SyxHQUFHeUQsR0FBRyxDQUFDaUgsS0FBS0YsTUFBTSx5QkFBeUI7WUFDakRBLE1BQU14SyxHQUFHeUQsR0FBRyxDQUFDK0csS0FBS0EsTUFBTSx5QkFBeUI7WUFDakRRLE9BQU9oTCxHQUFHeUQsR0FBRyxDQUFDbUgsS0FBS0osTUFBTSx5QkFBeUI7WUFDbERFLE1BQU0xSyxHQUFHOEssSUFBSSxDQUFDTCxLQUFLQyxLQUFLTyxLQUFLLGtDQUFrQztZQUMvREwsTUFBTTVLLEdBQUc4SyxJQUFJLENBQUNFLE1BQU1KLEtBQUtLLEtBQUssa0NBQWtDO1FBQ3BFO1FBQ0EsT0FBTztZQUFFekksU0FBU3FJO1lBQU1LLE9BQU9SO1FBQUk7SUFDdkM7SUFDQSxJQUFJMUssR0FBRzBFLEtBQUssR0FBR3hGLFFBQVFELEtBQUs7UUFDeEIseUJBQXlCO1FBQ3pCLE1BQU10RSxLQUFLLENBQUNxRixHQUFHMEUsS0FBSyxHQUFHekYsR0FBRSxJQUFLQyxLQUFLLCtDQUErQztRQUNsRixNQUFNdEUsS0FBS29GLEdBQUcyQyxJQUFJLENBQUMzQyxHQUFHaUQsR0FBRyxDQUFDK0IsS0FBSyxtQkFBbUI7UUFDbERzRixZQUFZLENBQUNDLEdBQUc3TTtZQUNaLElBQUk4TSxNQUFNeEssR0FBR3VELEdBQUcsQ0FBQzdGLElBQUksZUFBZTtZQUNwQyxNQUFNK00sTUFBTXpLLEdBQUd5RCxHQUFHLENBQUM4RyxHQUFHN00sSUFBSSxpQkFBaUI7WUFDM0M4TSxNQUFNeEssR0FBR3lELEdBQUcsQ0FBQytHLEtBQUtDLE1BQU0scUJBQXFCO1lBQzdDLElBQUlVLEtBQUtuTCxHQUFHaUUsR0FBRyxDQUFDdUcsS0FBSzdQLEtBQUssaUJBQWlCO1lBQzNDd1EsS0FBS25MLEdBQUd5RCxHQUFHLENBQUMwSCxJQUFJVixNQUFNLG1CQUFtQjtZQUN6QyxNQUFNaEksS0FBS3pDLEdBQUd5RCxHQUFHLENBQUMwSCxJQUFJdlEsS0FBSyxrQkFBa0I7WUFDN0MsTUFBTThQLE1BQU0xSyxHQUFHeUQsR0FBRyxDQUFDekQsR0FBR3VELEdBQUcsQ0FBQzRILEtBQUt6TixJQUFJLGtDQUFrQztZQUNyRSxNQUFNbU4sT0FBTzdLLEdBQUc2RCxHQUFHLENBQUM2RyxLQUFLSCxJQUFJLHFCQUFxQjtZQUNsRCxJQUFJN0ksSUFBSTFCLEdBQUc4SyxJQUFJLENBQUNySSxJQUFJMEksSUFBSU4sT0FBTyw2QkFBNkI7WUFDNUQsT0FBTztnQkFBRXJJLFNBQVNxSTtnQkFBTUssT0FBT3hKO1lBQUUsR0FBRyx1Q0FBdUM7UUFDL0U7SUFDSjtJQUNBLHNCQUFzQjtJQUN0QixrREFBa0Q7SUFDbEQsT0FBTzRJO0FBQ1g7QUFDQTs7O0NBR0MsR0FDTSxTQUFTYyxvQkFBb0JwTCxFQUFFLEVBQUVyRSxJQUFJO0lBQ3hDN0IsMERBQWFBLENBQUNrRztJQUNkLE1BQU0sRUFBRXFMLENBQUMsRUFBRUMsQ0FBQyxFQUFFdEcsQ0FBQyxFQUFFLEdBQUdySjtJQUNwQixJQUFJLENBQUNxRSxHQUFHd0MsT0FBTyxDQUFDNkksTUFBTSxDQUFDckwsR0FBR3dDLE9BQU8sQ0FBQzhJLE1BQU0sQ0FBQ3RMLEdBQUd3QyxPQUFPLENBQUN3QyxJQUNoRCxNQUFNLElBQUkxSixNQUFNO0lBQ3BCLE1BQU1nUCxZQUFZVixlQUFlNUosSUFBSWdGO0lBQ3JDLElBQUksQ0FBQ2hGLEdBQUdvQixLQUFLLEVBQ1QsTUFBTSxJQUFJOUYsTUFBTTtJQUNwQiw2QkFBNkI7SUFDN0IsZ0NBQWdDO0lBQ2hDLE9BQU8sQ0FBQ2lQO1FBQ0osa0JBQWtCO1FBQ2xCLElBQUlDLEtBQUtDLEtBQUtDLEtBQUtFLEtBQUtELEtBQUtZLEtBQUs5SixHQUFHQztRQUNyQzhJLE1BQU14SyxHQUFHdUQsR0FBRyxDQUFDZ0gsSUFBSSxnQkFBZ0I7UUFDakNDLE1BQU14SyxHQUFHeUQsR0FBRyxDQUFDK0csS0FBS3hGLElBQUksb0JBQW9CO1FBQzFDeUYsTUFBTXpLLEdBQUd1RCxHQUFHLENBQUNpSCxNQUFNLGtCQUFrQjtRQUNyQ0MsTUFBTXpLLEdBQUcwRCxHQUFHLENBQUMrRyxLQUFLRCxNQUFNLHNCQUFzQjtRQUM5Q0UsTUFBTTFLLEdBQUcwRCxHQUFHLENBQUMrRyxLQUFLekssR0FBR2lGLEdBQUcsR0FBRyxvQkFBb0I7UUFDL0N5RixNQUFNMUssR0FBR3lELEdBQUcsQ0FBQ2lILEtBQUtZLElBQUksb0JBQW9CO1FBQzFDVixNQUFNNUssR0FBRzhLLElBQUksQ0FBQzlGLEdBQUdoRixHQUFHaUQsR0FBRyxDQUFDd0gsTUFBTSxDQUFDekssR0FBRzZELEdBQUcsQ0FBQzRHLEtBQUt6SyxHQUFHb0YsSUFBSSxJQUFJLG9DQUFvQztRQUMxRndGLE1BQU01SyxHQUFHeUQsR0FBRyxDQUFDbUgsS0FBS1MsSUFBSSxvQkFBb0I7UUFDMUNaLE1BQU16SyxHQUFHdUQsR0FBRyxDQUFDbUgsTUFBTSxrQkFBa0I7UUFDckNhLE1BQU12TCxHQUFHdUQsR0FBRyxDQUFDcUgsTUFBTSxrQkFBa0I7UUFDckNELE1BQU0zSyxHQUFHeUQsR0FBRyxDQUFDOEgsS0FBS0YsSUFBSSxvQkFBb0I7UUFDMUNaLE1BQU16SyxHQUFHMEQsR0FBRyxDQUFDK0csS0FBS0UsTUFBTSxzQkFBc0I7UUFDOUNGLE1BQU16SyxHQUFHeUQsR0FBRyxDQUFDZ0gsS0FBS0MsTUFBTSxzQkFBc0I7UUFDOUNhLE1BQU12TCxHQUFHeUQsR0FBRyxDQUFDOEgsS0FBS1gsTUFBTSxzQkFBc0I7UUFDOUNELE1BQU0zSyxHQUFHeUQsR0FBRyxDQUFDOEgsS0FBS0QsSUFBSSxvQkFBb0I7UUFDMUNiLE1BQU16SyxHQUFHMEQsR0FBRyxDQUFDK0csS0FBS0UsTUFBTSxzQkFBc0I7UUFDOUNsSixJQUFJekIsR0FBR3lELEdBQUcsQ0FBQytHLEtBQUtFLE1BQU0sc0JBQXNCO1FBQzVDLE1BQU0sRUFBRWxJLE9BQU8sRUFBRTBJLEtBQUssRUFBRSxHQUFHWixVQUFVRyxLQUFLYyxNQUFNLGlEQUFpRDtRQUNqRzdKLElBQUkxQixHQUFHeUQsR0FBRyxDQUFDK0csS0FBS0QsSUFBSSxxQ0FBcUM7UUFDekQ3SSxJQUFJMUIsR0FBR3lELEdBQUcsQ0FBQy9CLEdBQUd3SixRQUFRLG1CQUFtQjtRQUN6Q3pKLElBQUl6QixHQUFHOEssSUFBSSxDQUFDckosR0FBR2lKLEtBQUtsSSxVQUFVLHdDQUF3QztRQUN0RWQsSUFBSTFCLEdBQUc4SyxJQUFJLENBQUNwSixHQUFHd0osT0FBTzFJLFVBQVUsdUNBQXVDO1FBQ3ZFLE1BQU15SSxLQUFLakwsR0FBR29CLEtBQUssQ0FBQ21KLE9BQU92SyxHQUFHb0IsS0FBSyxDQUFDTSxJQUFJLCtCQUErQjtRQUN2RUEsSUFBSTFCLEdBQUc4SyxJQUFJLENBQUM5SyxHQUFHaUQsR0FBRyxDQUFDdkIsSUFBSUEsR0FBR3VKLEtBQUssNEJBQTRCO1FBQzNELE1BQU1PLFVBQVU5UiwwREFBYUEsQ0FBQ3NHLElBQUk7WUFBQzRLO1NBQUksRUFBRSxLQUFLLENBQUMsRUFBRTtRQUNqRG5KLElBQUl6QixHQUFHeUQsR0FBRyxDQUFDaEMsR0FBRytKLFVBQVUsb0JBQW9CO1FBQzVDLE9BQU87WUFBRS9KO1lBQUdDO1FBQUU7SUFDbEI7QUFDSjtBQUNBLFNBQVNSLFlBQVlsQixFQUFFLEVBQUVaLEVBQUU7SUFDdkIsT0FBTztRQUNIcU0sV0FBV3JNLEdBQUdFLEtBQUs7UUFDbkI0QyxXQUFXLElBQUlsQyxHQUFHVixLQUFLO1FBQ3ZCOEMsdUJBQXVCLElBQUksSUFBSXBDLEdBQUdWLEtBQUs7UUFDdkNvTSxvQkFBb0I7UUFDcEJDLFdBQVcsSUFBSXZNLEdBQUdFLEtBQUs7SUFDM0I7QUFDSjtBQUNBOzs7Q0FHQyxHQUNNLFNBQVNzTSxLQUFLcEgsS0FBSyxFQUFFcUgsV0FBVyxDQUFDLENBQUM7SUFDckMsTUFBTSxFQUFFek0sRUFBRSxFQUFFLEdBQUdvRjtJQUNmLE1BQU1zSCxlQUFlRCxTQUFTNVMsV0FBVyxJQUFJQyxrREFBY0E7SUFDM0QsTUFBTStILFVBQVVsRixPQUFPZ1EsTUFBTSxDQUFDN0ssWUFBWXNELE1BQU14RSxFQUFFLEVBQUVaLEtBQUs7UUFBRTRNLE1BQU1yUyw2REFBZ0JBLENBQUN5RixHQUFHc0YsS0FBSztJQUFFO0lBQzVGLFNBQVN1SCxpQkFBaUJSLFNBQVM7UUFDL0IsSUFBSTtZQUNBLE9BQU8sQ0FBQyxDQUFDdE0sZUFBZUMsSUFBSXFNO1FBQ2hDLEVBQ0EsT0FBTy9MLE9BQU87WUFDVixPQUFPO1FBQ1g7SUFDSjtJQUNBLFNBQVN3TSxpQkFBaUJoSyxTQUFTLEVBQUVWLFlBQVk7UUFDN0MsTUFBTSxFQUFFVSxXQUFXQyxJQUFJLEVBQUVDLHFCQUFxQixFQUFFLEdBQUduQjtRQUNuRCxJQUFJO1lBQ0EsTUFBTXRELElBQUl1RSxVQUFVcEYsTUFBTTtZQUMxQixJQUFJMEUsaUJBQWlCLFFBQVE3RCxNQUFNd0UsTUFDL0IsT0FBTztZQUNYLElBQUlYLGlCQUFpQixTQUFTN0QsTUFBTXlFLHVCQUNoQyxPQUFPO1lBQ1gsT0FBTyxDQUFDLENBQUNvQyxNQUFNL0UsU0FBUyxDQUFDeUM7UUFDN0IsRUFDQSxPQUFPeEMsT0FBTztZQUNWLE9BQU87UUFDWDtJQUNKO0lBQ0E7OztLQUdDLEdBQ0QsU0FBU3lNLGdCQUFnQkgsT0FBT0YsYUFBYTdLLFFBQVErSyxJQUFJLENBQUM7UUFDdEQsT0FBT3BTLDJEQUFjQSxDQUFDekIsbURBQU1BLENBQUM2VCxNQUFNL0ssUUFBUStLLElBQUksRUFBRSxTQUFTNU0sR0FBR3NGLEtBQUs7SUFDdEU7SUFDQTs7OztLQUlDLEdBQ0QsU0FBUzBILGFBQWFYLFNBQVMsRUFBRWpLLGVBQWUsSUFBSTtRQUNoRCxPQUFPZ0QsTUFBTWlGLElBQUksQ0FBQ3JELFFBQVEsQ0FBQ2pILGVBQWVDLElBQUlxTSxZQUFZakwsT0FBTyxDQUFDZ0I7SUFDdEU7SUFDQSxTQUFTNkssT0FBT0wsSUFBSTtRQUNoQixNQUFNUCxZQUFZVSxnQkFBZ0JIO1FBQ2xDLE9BQU87WUFBRVA7WUFBV3ZKLFdBQVdrSyxhQUFhWDtRQUFXO0lBQzNEO0lBQ0E7O0tBRUMsR0FDRCxTQUFTYSxVQUFVQyxJQUFJO1FBQ25CLElBQUksT0FBT0EsU0FBUyxVQUNoQixPQUFPO1FBQ1gsSUFBSUEsZ0JBQWdCL0gsT0FDaEIsT0FBTztRQUNYLE1BQU0sRUFBRWlILFNBQVMsRUFBRXZKLFNBQVMsRUFBRUUscUJBQXFCLEVBQUUsR0FBR25CO1FBQ3hELElBQUk3QixHQUFHb04sY0FBYyxJQUFJZixjQUFjdkosV0FDbkMsT0FBT2pHO1FBQ1gsTUFBTTBCLElBQUloRixzREFBV0EsQ0FBQyxPQUFPNFQsTUFBTXpQLE1BQU07UUFDekMsT0FBT2EsTUFBTXVFLGFBQWF2RSxNQUFNeUU7SUFDcEM7SUFDQTs7Ozs7OztLQU9DLEdBQ0QsU0FBU3FLLGdCQUFnQkMsVUFBVSxFQUFFQyxVQUFVLEVBQUVuTCxlQUFlLElBQUk7UUFDaEUsSUFBSThLLFVBQVVJLGdCQUFnQixNQUMxQixNQUFNLElBQUlwUixNQUFNO1FBQ3BCLElBQUlnUixVQUFVSyxnQkFBZ0IsT0FDMUIsTUFBTSxJQUFJclIsTUFBTTtRQUNwQixNQUFNb0QsSUFBSVMsZUFBZUMsSUFBSXNOO1FBQzdCLE1BQU1qUCxJQUFJK0csTUFBTXNCLE9BQU8sQ0FBQzZHLGFBQWEsNEJBQTRCO1FBQ2pFLE9BQU9sUCxFQUFFMkksUUFBUSxDQUFDMUgsR0FBRzhCLE9BQU8sQ0FBQ2dCO0lBQ2pDO0lBQ0EsTUFBTW9MLFFBQVE7UUFDVlg7UUFDQUM7UUFDQUM7UUFDQSxlQUFlO1FBQ2ZVLG1CQUFtQlo7UUFDbkJhLGtCQUFrQlg7UUFDbEJZLHdCQUF3QixDQUFDMU4sTUFBUUYsZUFBZUMsSUFBSUM7UUFDcEQwRyxZQUFXQyxhQUFhLENBQUMsRUFBRXpFLFFBQVFpRCxNQUFNaUYsSUFBSTtZQUN6QyxPQUFPbEksTUFBTXdFLFVBQVUsQ0FBQ0MsWUFBWTtRQUN4QztJQUNKO0lBQ0EsT0FBT2pLLE9BQU8ySixNQUFNLENBQUM7UUFBRTBHO1FBQWNLO1FBQWlCSjtRQUFRN0g7UUFBT29JO1FBQU8zTDtJQUFRO0FBQ3hGO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBQ00sU0FBUytMLE1BQU14SSxLQUFLLEVBQUV5SSxJQUFJLEVBQUVDLFlBQVksQ0FBQyxDQUFDO0lBQzdDcFYsZ0RBQUtBLENBQUNtVjtJQUNObFYsMERBQWVBLENBQUNtVixXQUFXLENBQUMsR0FBRztRQUMzQnRWLE1BQU07UUFDTnNFLE1BQU07UUFDTmpELGFBQWE7UUFDYmtVLFVBQVU7UUFDVkMsZUFBZTtJQUNuQjtJQUNBLE1BQU1uVSxjQUFjaVUsVUFBVWpVLFdBQVcsSUFBSUMsa0RBQWNBO0lBQzNELE1BQU10QixPQUFPc1YsVUFBVXRWLElBQUksSUFDdEIsRUFBQ3lILEtBQUssR0FBR2dPLE9BQVN4ViwyREFBU0EsQ0FBQ29WLE1BQU01TixLQUFLNUcsc0RBQVdBLElBQUk0VSxNQUFLO0lBQ2hFLE1BQU0sRUFBRXJOLEVBQUUsRUFBRVosRUFBRSxFQUFFLEdBQUdvRjtJQUNuQixNQUFNLEVBQUVFLE9BQU90RSxXQUFXLEVBQUV1SixNQUFNMkQsTUFBTSxFQUFFLEdBQUdsTztJQUM3QyxNQUFNLEVBQUVpTixNQUFNLEVBQUVELFlBQVksRUFBRUssZUFBZSxFQUFFRyxLQUFLLEVBQUUzTCxPQUFPLEVBQUUsR0FBRzJLLEtBQUtwSCxPQUFPMEk7SUFDOUUsTUFBTUssaUJBQWlCO1FBQ25CcFIsU0FBUztRQUNURCxNQUFNLE9BQU9nUixVQUFVaFIsSUFBSSxLQUFLLFlBQVlnUixVQUFVaFIsSUFBSSxHQUFHO1FBQzdEVixRQUFRUztRQUNSdVIsY0FBYztJQUNsQjtJQUNBLE1BQU1DLHdCQUF3QjtJQUM5QixTQUFTQyxzQkFBc0JDLE1BQU07UUFDakMsTUFBTUMsT0FBT3hOLGVBQWUvRTtRQUM1QixPQUFPc1MsU0FBU0M7SUFDcEI7SUFDQSxTQUFTQyxXQUFXekosS0FBSyxFQUFFcEssR0FBRztRQUMxQixJQUFJLENBQUNvRixHQUFHTyxXQUFXLENBQUMzRixNQUNoQixNQUFNLElBQUlzQixNQUFNLENBQUMsa0JBQWtCLEVBQUU4SSxNQUFNLGdDQUFnQyxDQUFDO1FBQ2hGLE9BQU9wSztJQUNYO0lBQ0EsU0FBUzhULGtCQUFrQnRPLEtBQUssRUFBRWhFLE1BQU07UUFDcENELGtCQUFrQkM7UUFDbEIsTUFBTXVTLE9BQU85TSxRQUFRMEssU0FBUztRQUM5QixNQUFNcUMsUUFBUXhTLFdBQVcsWUFBWXVTLE9BQU92UyxXQUFXLGNBQWN1UyxPQUFPLElBQUk5UjtRQUNoRixPQUFPOUQsbURBQU1BLENBQUNxSCxPQUFPd08sT0FBTyxDQUFDLEVBQUV4UyxPQUFPLFVBQVUsQ0FBQztJQUNyRDtJQUNBOztLQUVDLEdBQ0QsTUFBTXlTO1FBQ0Y1UixZQUFZb0MsQ0FBQyxFQUFFQyxDQUFDLEVBQUV3UCxRQUFRLENBQUU7WUFDeEIsSUFBSSxDQUFDelAsQ0FBQyxHQUFHb1AsV0FBVyxLQUFLcFAsSUFBSSxpQkFBaUI7WUFDOUMsSUFBSSxDQUFDQyxDQUFDLEdBQUdtUCxXQUFXLEtBQUtuUCxJQUFJLGlCQUFpQjtZQUM5QyxJQUFJd1AsWUFBWSxNQUNaLElBQUksQ0FBQ0EsUUFBUSxHQUFHQTtZQUNwQm5TLE9BQU8ySixNQUFNLENBQUMsSUFBSTtRQUN0QjtRQUNBLE9BQU9qRyxVQUFVRCxLQUFLLEVBQUVoRSxTQUFTaVMscUJBQXFCLEVBQUU7WUFDcERLLGtCQUFrQnRPLE9BQU9oRTtZQUN6QixJQUFJMlM7WUFDSixJQUFJM1MsV0FBVyxPQUFPO2dCQUNsQixNQUFNLEVBQUVpRCxDQUFDLEVBQUVDLENBQUMsRUFBRSxHQUFHbkMsSUFBSXlCLEtBQUssQ0FBQzdGLG1EQUFNQSxDQUFDcUg7Z0JBQ2xDLE9BQU8sSUFBSXlPLFVBQVV4UCxHQUFHQztZQUM1QjtZQUNBLElBQUlsRCxXQUFXLGFBQWE7Z0JBQ3hCMlMsUUFBUTNPLEtBQUssQ0FBQyxFQUFFO2dCQUNoQmhFLFNBQVM7Z0JBQ1RnRSxRQUFRQSxNQUFNaEMsUUFBUSxDQUFDO1lBQzNCO1lBQ0EsTUFBTTBGLElBQUk5RCxHQUFHRSxLQUFLO1lBQ2xCLE1BQU1iLElBQUllLE1BQU1oQyxRQUFRLENBQUMsR0FBRzBGO1lBQzVCLE1BQU14RSxJQUFJYyxNQUFNaEMsUUFBUSxDQUFDMEYsR0FBR0EsSUFBSTtZQUNoQyxPQUFPLElBQUkrSyxVQUFVN08sR0FBR0ssU0FBUyxDQUFDaEIsSUFBSVcsR0FBR0ssU0FBUyxDQUFDZixJQUFJeVA7UUFDM0Q7UUFDQSxPQUFPckksUUFBUWpJLEdBQUcsRUFBRXJDLE1BQU0sRUFBRTtZQUN4QixPQUFPLElBQUksQ0FBQ2lFLFNBQVMsQ0FBQzdHLHFEQUFVQSxDQUFDaUYsTUFBTXJDO1FBQzNDO1FBQ0E0UyxlQUFlRixRQUFRLEVBQUU7WUFDckIsT0FBTyxJQUFJRCxVQUFVLElBQUksQ0FBQ3hQLENBQUMsRUFBRSxJQUFJLENBQUNDLENBQUMsRUFBRXdQO1FBQ3pDO1FBQ0FHLGlCQUFpQkMsV0FBVyxFQUFFO1lBQzFCLE1BQU1DLGNBQWN2TyxHQUFHMEUsS0FBSztZQUM1QixNQUFNLEVBQUVqRyxDQUFDLEVBQUVDLENBQUMsRUFBRXdQLFVBQVVNLEdBQUcsRUFBRSxHQUFHLElBQUk7WUFDcEMsSUFBSUEsT0FBTyxRQUFRLENBQUM7Z0JBQUM7Z0JBQUc7Z0JBQUc7Z0JBQUc7YUFBRSxDQUFDL1MsUUFBUSxDQUFDK1MsTUFDdEMsTUFBTSxJQUFJbFQsTUFBTTtZQUNwQixrREFBa0Q7WUFDbEQsNERBQTREO1lBQzVELHVFQUF1RTtZQUN2RSxnREFBZ0Q7WUFDaEQsMERBQTBEO1lBQzFELHNDQUFzQztZQUN0Qyx5REFBeUQ7WUFDekQsc0RBQXNEO1lBQ3RELE1BQU1tVCxjQUFjck8sY0FBY2xHLE1BQU1xVTtZQUN4QyxJQUFJRSxlQUFlRCxNQUFNLEdBQ3JCLE1BQU0sSUFBSWxULE1BQU07WUFDcEIsTUFBTW9ULE9BQU9GLFFBQVEsS0FBS0EsUUFBUSxJQUFJL1AsSUFBSTJCLGNBQWMzQjtZQUN4RCxJQUFJLENBQUN1QixHQUFHd0MsT0FBTyxDQUFDa00sT0FDWixNQUFNLElBQUlwVCxNQUFNO1lBQ3BCLE1BQU1tRyxJQUFJekIsR0FBR1EsT0FBTyxDQUFDa087WUFDckIsTUFBTUMsSUFBSW5LLE1BQU0vRSxTQUFTLENBQUNoSCxzREFBV0EsQ0FBQ3FKLFFBQVEsQ0FBQzBNLE1BQU0sT0FBTyxJQUFJL007WUFDaEUsTUFBTW1OLEtBQUt4UCxHQUFHOEYsR0FBRyxDQUFDd0osT0FBTyxPQUFPO1lBQ2hDLE1BQU14TyxJQUFJa04sY0FBY3pVLHNEQUFXQSxDQUFDLFdBQVcyVixlQUFlLGdCQUFnQjtZQUM5RSxNQUFNTyxLQUFLelAsR0FBRzBQLE1BQU0sQ0FBQyxDQUFDNU8sSUFBSTBPLEtBQUssU0FBUztZQUN4QyxNQUFNRyxLQUFLM1AsR0FBRzBQLE1BQU0sQ0FBQ3BRLElBQUlrUSxLQUFLLFFBQVE7WUFDdEMscUZBQXFGO1lBQ3JGLE1BQU1uRyxJQUFJakUsTUFBTWlGLElBQUksQ0FBQ3ZCLGNBQWMsQ0FBQzJHLElBQUluTCxHQUFHLENBQUNpTCxFQUFFekcsY0FBYyxDQUFDNkc7WUFDN0QsSUFBSXRHLEVBQUU5SCxHQUFHLElBQ0wsTUFBTSxJQUFJckYsTUFBTTtZQUNwQm1OLEVBQUU1QyxjQUFjO1lBQ2hCLE9BQU80QztRQUNYO1FBQ0EsdURBQXVEO1FBQ3ZEdUcsV0FBVztZQUNQLE9BQU90QixzQkFBc0IsSUFBSSxDQUFDaFAsQ0FBQztRQUN2QztRQUNBOEIsUUFBUWhGLFNBQVNpUyxxQkFBcUIsRUFBRTtZQUNwQ2xTLGtCQUFrQkM7WUFDbEIsSUFBSUEsV0FBVyxPQUNYLE9BQU81QyxxREFBVUEsQ0FBQzJELElBQUlvQyxVQUFVLENBQUMsSUFBSTtZQUN6QyxNQUFNRixJQUFJVyxHQUFHb0IsT0FBTyxDQUFDLElBQUksQ0FBQy9CLENBQUM7WUFDM0IsTUFBTUMsSUFBSVUsR0FBR29CLE9BQU8sQ0FBQyxJQUFJLENBQUM5QixDQUFDO1lBQzNCLElBQUlsRCxXQUFXLGFBQWE7Z0JBQ3hCLElBQUksSUFBSSxDQUFDMFMsUUFBUSxJQUFJLE1BQ2pCLE1BQU0sSUFBSTVTLE1BQU07Z0JBQ3BCLE9BQU83QyxzREFBV0EsQ0FBQ3NKLFdBQVdDLEVBQUUsQ0FBQyxJQUFJLENBQUNrTSxRQUFRLEdBQUd6UCxHQUFHQztZQUN4RDtZQUNBLE9BQU9qRyxzREFBV0EsQ0FBQ2dHLEdBQUdDO1FBQzFCO1FBQ0FtSyxNQUFNck4sTUFBTSxFQUFFO1lBQ1YsT0FBT2pELHFEQUFVQSxDQUFDLElBQUksQ0FBQ2lJLE9BQU8sQ0FBQ2hGO1FBQ25DO1FBQ0EsZUFBZTtRQUNmcUssaUJBQWlCLENBQUU7UUFDbkIsT0FBT29KLFlBQVlwUixHQUFHLEVBQUU7WUFDcEIsT0FBT29RLFVBQVV4TyxTQUFTLENBQUM5RyxzREFBV0EsQ0FBQyxPQUFPa0YsTUFBTTtRQUN4RDtRQUNBLE9BQU9xUixRQUFRclIsR0FBRyxFQUFFO1lBQ2hCLE9BQU9vUSxVQUFVeE8sU0FBUyxDQUFDOUcsc0RBQVdBLENBQUMsT0FBT2tGLE1BQU07UUFDeEQ7UUFDQXNSLGFBQWE7WUFDVCxPQUFPLElBQUksQ0FBQ0gsUUFBUSxLQUFLLElBQUlmLFVBQVUsSUFBSSxDQUFDeFAsQ0FBQyxFQUFFVyxHQUFHNkQsR0FBRyxDQUFDLElBQUksQ0FBQ3ZFLENBQUMsR0FBRyxJQUFJLENBQUN3UCxRQUFRLElBQUksSUFBSTtRQUN4RjtRQUNBa0IsZ0JBQWdCO1lBQ1osT0FBTyxJQUFJLENBQUM1TyxPQUFPLENBQUM7UUFDeEI7UUFDQTZPLFdBQVc7WUFDUCxPQUFPOVcscURBQVVBLENBQUMsSUFBSSxDQUFDaUksT0FBTyxDQUFDO1FBQ25DO1FBQ0E4TyxvQkFBb0I7WUFDaEIsT0FBTyxJQUFJLENBQUM5TyxPQUFPLENBQUM7UUFDeEI7UUFDQStPLGVBQWU7WUFDWCxPQUFPaFgscURBQVVBLENBQUMsSUFBSSxDQUFDaUksT0FBTyxDQUFDO1FBQ25DO0lBQ0o7SUFDQSxrR0FBa0c7SUFDbEcsMEZBQTBGO0lBQzFGLGtGQUFrRjtJQUNsRiwrRkFBK0Y7SUFDL0YsTUFBTTJNLFdBQVdELFVBQVVDLFFBQVEsSUFDL0IsU0FBU3FDLGFBQWFoUSxLQUFLO1FBQ3ZCLDhEQUE4RDtRQUM5RCxJQUFJQSxNQUFNMUMsTUFBTSxHQUFHLE1BQ2YsTUFBTSxJQUFJeEIsTUFBTTtRQUNwQix1RkFBdUY7UUFDdkYsa0VBQWtFO1FBQ2xFLE1BQU10QixNQUFNeEIsMERBQWVBLENBQUNnSCxRQUFRLDRCQUE0QjtRQUNoRSxNQUFNaVEsUUFBUWpRLE1BQU0xQyxNQUFNLEdBQUcsSUFBSXdRLFFBQVEsdUNBQXVDO1FBQ2hGLE9BQU9tQyxRQUFRLElBQUl6VixPQUFPZ0YsT0FBT3lRLFNBQVN6VjtJQUM5QztJQUNKLE1BQU1vVCxnQkFBZ0JGLFVBQVVFLGFBQWEsSUFDekMsU0FBU3NDLGtCQUFrQmxRLEtBQUs7UUFDNUIsT0FBT0osR0FBRzBQLE1BQU0sQ0FBQzNCLFNBQVMzTixTQUFTLGlDQUFpQztJQUN4RTtJQUNKLG9DQUFvQztJQUNwQyxNQUFNbVEsYUFBYXJYLGtEQUFPQSxDQUFDZ1Y7SUFDM0Isa0ZBQWtGLEdBQ2xGLFNBQVNzQyxXQUFXNVYsR0FBRztRQUNuQiwwRUFBMEU7UUFDMUU1QixtREFBUUEsQ0FBQyxhQUFha1YsUUFBUXRULEtBQUtnQixLQUFLMlU7UUFDeEMsT0FBT3ZRLEdBQUdvQixPQUFPLENBQUN4RztJQUN0QjtJQUNBLFNBQVM2VixtQkFBbUIvTSxPQUFPLEVBQUUzRyxPQUFPO1FBQ3hDaEUsbURBQU1BLENBQUMySyxTQUFTN0csV0FBVztRQUMzQixPQUFPRSxVQUFVaEUsbURBQU1BLENBQUM4VSxLQUFLbkssVUFBVTdHLFdBQVcsdUJBQXVCNkc7SUFDN0U7SUFDQTs7Ozs7OztLQU9DLEdBQ0QsU0FBU2dOLFFBQVFoTixPQUFPLEVBQUUwRyxVQUFVLEVBQUU3TixJQUFJO1FBQ3RDLElBQUk7WUFBQztZQUFhO1NBQVksQ0FBQ29VLElBQUksQ0FBQyxDQUFDM1YsSUFBTUEsS0FBS3VCLE9BQzVDLE1BQU0sSUFBSUwsTUFBTTtRQUNwQixNQUFNLEVBQUVZLElBQUksRUFBRUMsT0FBTyxFQUFFcVIsWUFBWSxFQUFFLEdBQUc5UixnQkFBZ0JDLE1BQU00UjtRQUM5RHpLLFVBQVUrTSxtQkFBbUIvTSxTQUFTM0csVUFBVSwyQkFBMkI7UUFDM0UsOEVBQThFO1FBQzlFLGdGQUFnRjtRQUNoRixnRUFBZ0U7UUFDaEUsTUFBTTZULFFBQVE1QyxjQUFjdEs7UUFDNUIsTUFBTW1OLElBQUk5USxlQUFlQyxJQUFJb0ssYUFBYSx5Q0FBeUM7UUFDbkYsTUFBTTBHLFdBQVc7WUFBQ04sV0FBV0s7WUFBSUwsV0FBV0k7U0FBTztRQUNuRCx1REFBdUQ7UUFDdkQsSUFBSXhDLGdCQUFnQixRQUFRQSxpQkFBaUIsT0FBTztZQUNoRCxrRUFBa0U7WUFDbEUsaUNBQWlDO1lBQ2pDLE1BQU0yQyxJQUFJM0MsaUJBQWlCLE9BQU92VSxZQUFZZ0ksUUFBUXdLLFNBQVMsSUFBSStCO1lBQ25FMEMsU0FBU0UsSUFBSSxDQUFDelgsc0RBQVdBLENBQUMsZ0JBQWdCd1gsS0FBSyx3QkFBd0I7UUFDM0U7UUFDQSxNQUFNbkUsT0FBT3ZULHNEQUFXQSxJQUFJeVgsV0FBVyx3QkFBd0I7UUFDL0QsTUFBTTVULElBQUkwVCxPQUFPLDhFQUE4RTtRQUMvRiwwRUFBMEU7UUFDMUUsK0JBQStCO1FBQy9CLFVBQVU7UUFDVixnQkFBZ0I7UUFDaEIseUJBQXlCO1FBQ3pCLHdFQUF3RTtRQUN4RSwyRkFBMkY7UUFDM0YsMEZBQTBGO1FBQzFGLFNBQVNLLE1BQU1DLE1BQU07WUFDakIsZ0RBQWdEO1lBQ2hELHNEQUFzRDtZQUN0RCxNQUFNbFcsSUFBSStTLFNBQVNtRCxTQUFTLG1CQUFtQjtZQUMvQyxJQUFJLENBQUNsUixHQUFHTyxXQUFXLENBQUN2RixJQUNoQixRQUFRLGdEQUFnRDtZQUM1RCxNQUFNbVcsS0FBS25SLEdBQUc4RixHQUFHLENBQUM5SyxJQUFJLGFBQWE7WUFDbkMsTUFBTXlQLElBQUlyRixNQUFNaUYsSUFBSSxDQUFDckQsUUFBUSxDQUFDaE0sR0FBR3VILFFBQVEsSUFBSSxVQUFVO1lBQ3ZELE1BQU1sRCxJQUFJVyxHQUFHMFAsTUFBTSxDQUFDakYsRUFBRXBJLENBQUMsR0FBRyxnQkFBZ0I7WUFDMUMsSUFBSWhELE1BQU16RCxLQUNOO1lBQ0osTUFBTTBELElBQUlVLEdBQUcwUCxNQUFNLENBQUN5QixLQUFLblIsR0FBRzBQLE1BQU0sQ0FBQ3hTLElBQUltQyxJQUFJd1IsS0FBSyw2Q0FBNkM7WUFDN0YsSUFBSXZSLE1BQU0xRCxLQUNOO1lBQ0osSUFBSWtULFdBQVcsQ0FBQ3JFLEVBQUVwSSxDQUFDLEtBQUtoRCxJQUFJLElBQUksS0FBS1gsT0FBTytMLEVBQUVuSSxDQUFDLEdBQUdyRyxNQUFNLHNDQUFzQztZQUM5RixJQUFJbVYsUUFBUTlSO1lBQ1osSUFBSXhDLFFBQVF3UixzQkFBc0JoUCxJQUFJO2dCQUNsQzhSLFFBQVFwUixHQUFHNkQsR0FBRyxDQUFDdkUsSUFBSSx5Q0FBeUM7Z0JBQzVEd1AsWUFBWSxHQUFHLDZCQUE2QjtZQUNoRDtZQUNBLE9BQU8sSUFBSUQsVUFBVXhQLEdBQUcrUixPQUFPdEMsV0FBVyxtQkFBbUI7UUFDakU7UUFDQSxPQUFPO1lBQUVsQztZQUFNcUU7UUFBTTtJQUN6QjtJQUNBOzs7Ozs7Ozs7O0tBVUMsR0FDRCxTQUFTSSxLQUFLM04sT0FBTyxFQUFFMkksU0FBUyxFQUFFOVAsT0FBTyxDQUFDLENBQUM7UUFDdkNtSCxVQUFVbkssc0RBQVdBLENBQUMsV0FBV21LO1FBQ2pDLE1BQU0sRUFBRWtKLElBQUksRUFBRXFFLEtBQUssRUFBRSxHQUFHUCxRQUFRaE4sU0FBUzJJLFdBQVc5UCxPQUFPLDZCQUE2QjtRQUN4RixNQUFNK1UsT0FBT2hZLHlEQUFjQSxDQUFDdVUsS0FBSzBELFNBQVMsRUFBRXZSLEdBQUdFLEtBQUssRUFBRTFIO1FBQ3RELE1BQU1nSCxNQUFNOFIsS0FBSzFFLE1BQU1xRSxRQUFRLHlCQUF5QjtRQUN4RCxPQUFPelI7SUFDWDtJQUNBLFNBQVNnUyxjQUFjQyxFQUFFO1FBQ3JCLHVCQUF1QjtRQUN2QixJQUFJalMsTUFBTTNDO1FBQ1YsTUFBTTZVLFFBQVEsT0FBT0QsT0FBTyxZQUFZL1gsa0RBQU9BLENBQUMrWDtRQUNoRCxNQUFNRSxRQUFRLENBQUNELFNBQ1hELE9BQU8sUUFDUCxPQUFPQSxPQUFPLFlBQ2QsT0FBT0EsR0FBR3BTLENBQUMsS0FBSyxZQUNoQixPQUFPb1MsR0FBR25TLENBQUMsS0FBSztRQUNwQixJQUFJLENBQUNvUyxTQUFTLENBQUNDLE9BQ1gsTUFBTSxJQUFJelYsTUFBTTtRQUNwQixJQUFJeVYsT0FBTztZQUNQblMsTUFBTSxJQUFJcVAsVUFBVTRDLEdBQUdwUyxDQUFDLEVBQUVvUyxHQUFHblMsQ0FBQztRQUNsQyxPQUNLLElBQUlvUyxPQUFPO1lBQ1osSUFBSTtnQkFDQWxTLE1BQU1xUCxVQUFVeE8sU0FBUyxDQUFDOUcsc0RBQVdBLENBQUMsT0FBT2tZLEtBQUs7WUFDdEQsRUFDQSxPQUFPRyxVQUFVO2dCQUNiLElBQUksQ0FBRUEsQ0FBQUEsb0JBQW9CelUsSUFBSUMsR0FBRyxHQUM3QixNQUFNd1U7WUFDZDtZQUNBLElBQUksQ0FBQ3BTLEtBQUs7Z0JBQ04sSUFBSTtvQkFDQUEsTUFBTXFQLFVBQVV4TyxTQUFTLENBQUM5RyxzREFBV0EsQ0FBQyxPQUFPa1ksS0FBSztnQkFDdEQsRUFDQSxPQUFPblIsT0FBTztvQkFDVixPQUFPO2dCQUNYO1lBQ0o7UUFDSjtRQUNBLElBQUksQ0FBQ2QsS0FDRCxPQUFPO1FBQ1gsT0FBT0E7SUFDWDtJQUNBOzs7Ozs7Ozs7Ozs7S0FZQyxHQUNELFNBQVNxUyxPQUFPdEYsU0FBUyxFQUFFN0ksT0FBTyxFQUFFWixTQUFTLEVBQUV2RyxPQUFPLENBQUMsQ0FBQztRQUNwRCxNQUFNLEVBQUVPLElBQUksRUFBRUMsT0FBTyxFQUFFWCxNQUFNLEVBQUUsR0FBR0UsZ0JBQWdCQyxNQUFNNFI7UUFDeERyTCxZQUFZdkosc0RBQVdBLENBQUMsYUFBYXVKO1FBQ3JDWSxVQUFVK00sbUJBQW1CbFgsc0RBQVdBLENBQUMsV0FBV21LLFVBQVUzRztRQUM5RCxJQUFJLFlBQVlSLE1BQ1osTUFBTSxJQUFJTCxNQUFNO1FBQ3BCLE1BQU1zRCxNQUFNcEQsV0FBV1MsWUFDakIyVSxjQUFjakYsYUFDZHNDLFVBQVV4TyxTQUFTLENBQUM5RyxzREFBV0EsQ0FBQyxPQUFPZ1QsWUFBWW5RO1FBQ3pELElBQUlvRCxRQUFRLE9BQ1IsT0FBTztRQUNYLElBQUk7WUFDQSxNQUFNZ0gsSUFBSXBCLE1BQU0vRSxTQUFTLENBQUN5QztZQUMxQixJQUFJaEcsUUFBUTBDLElBQUlvUSxRQUFRLElBQ3BCLE9BQU87WUFDWCxNQUFNLEVBQUV2USxDQUFDLEVBQUVDLENBQUMsRUFBRSxHQUFHRTtZQUNqQixNQUFNc0IsSUFBSWtOLGNBQWN0SyxVQUFVLG1CQUFtQjtZQUNyRCxNQUFNb08sS0FBSzlSLEdBQUc4RixHQUFHLENBQUN4RyxJQUFJLGFBQWE7WUFDbkMsTUFBTW1RLEtBQUt6UCxHQUFHMFAsTUFBTSxDQUFDNU8sSUFBSWdSLEtBQUssbUJBQW1CO1lBQ2pELE1BQU1uQyxLQUFLM1AsR0FBRzBQLE1BQU0sQ0FBQ3JRLElBQUl5UyxLQUFLLG1CQUFtQjtZQUNqRCxNQUFNdkMsSUFBSW5LLE1BQU1pRixJQUFJLENBQUN2QixjQUFjLENBQUMyRyxJQUFJbkwsR0FBRyxDQUFDa0MsRUFBRXNDLGNBQWMsQ0FBQzZHLE1BQU0sY0FBYztZQUNqRixJQUFJSixFQUFFaE8sR0FBRyxJQUNMLE9BQU87WUFDWCxNQUFNakQsSUFBSTBCLEdBQUcwUCxNQUFNLENBQUNILEVBQUVsTixDQUFDLEdBQUcsZ0JBQWdCO1lBQzFDLE9BQU8vRCxNQUFNZTtRQUNqQixFQUNBLE9BQU8wUixHQUFHO1lBQ04sT0FBTztRQUNYO0lBQ0o7SUFDQSxTQUFTOUIsaUJBQWlCMUMsU0FBUyxFQUFFN0ksT0FBTyxFQUFFbkgsT0FBTyxDQUFDLENBQUM7UUFDbkQsTUFBTSxFQUFFUSxPQUFPLEVBQUUsR0FBR1QsZ0JBQWdCQyxNQUFNNFI7UUFDMUN6SyxVQUFVK00sbUJBQW1CL00sU0FBUzNHO1FBQ3RDLE9BQU84UixVQUFVeE8sU0FBUyxDQUFDa00sV0FBVyxhQUFhMEMsZ0JBQWdCLENBQUN2TCxTQUFTdEMsT0FBTztJQUN4RjtJQUNBLE9BQU96RSxPQUFPMkosTUFBTSxDQUFDO1FBQ2pCMkc7UUFDQUQ7UUFDQUs7UUFDQUc7UUFDQTNMO1FBQ0F1RDtRQUNBaU07UUFDQVE7UUFDQTVDO1FBQ0FKO1FBQ0FoQjtJQUNKO0FBQ0o7QUFDQSxvREFBb0QsR0FDN0MsU0FBU2tFLGtCQUFrQkMsQ0FBQztJQUMvQixNQUFNLEVBQUVuUixLQUFLLEVBQUVvUixTQUFTLEVBQUUsR0FBR0MsZ0NBQWdDRjtJQUM3RCxNQUFNNU0sUUFBUTVFLGFBQWFLLE9BQU9vUjtJQUNsQyxPQUFPRSxrQ0FBa0NILEdBQUc1TTtBQUNoRDtBQUNBLFNBQVM4TSxnQ0FBZ0NGLENBQUM7SUFDdEMsTUFBTW5SLFFBQVE7UUFDVlcsR0FBR3dRLEVBQUV4USxDQUFDO1FBQ05uRCxHQUFHMlQsRUFBRTNULENBQUM7UUFDTm1ILEdBQUd3TSxFQUFFcFIsRUFBRSxDQUFDMEUsS0FBSztRQUNicEssR0FBRzhXLEVBQUU5VyxDQUFDO1FBQ040RixHQUFHa1IsRUFBRWxSLENBQUM7UUFDTjRELElBQUlzTixFQUFFdE4sRUFBRTtRQUNSQyxJQUFJcU4sRUFBRXJOLEVBQUU7SUFDWjtJQUNBLE1BQU0vRCxLQUFLb1IsRUFBRXBSLEVBQUU7SUFDZixJQUFJd00saUJBQWlCNEUsRUFBRUksd0JBQXdCLEdBQ3pDMVEsTUFBTTJRLElBQUksQ0FBQyxJQUFJQyxJQUFJTixFQUFFSSx3QkFBd0IsQ0FBQ0csR0FBRyxDQUFDLENBQUNoVSxJQUFNeEMsS0FBS0MsSUFBSSxDQUFDdUMsSUFBSSxRQUN2RTFCO0lBQ04sTUFBTW1ELEtBQUszRixrREFBS0EsQ0FBQ3dHLE1BQU0zRixDQUFDLEVBQUU7UUFDdEJxUCxNQUFNeUgsRUFBRVEsVUFBVTtRQUNsQnBGLGdCQUFnQkE7UUFDaEJxRixjQUFjVCxFQUFFMVEsY0FBYztJQUNsQztJQUNBLE1BQU0yUSxZQUFZO1FBQ2RyUjtRQUNBWjtRQUNBaUIsb0JBQW9CK1EsRUFBRS9RLGtCQUFrQjtRQUN4Q0ksTUFBTTJRLEVBQUUzUSxJQUFJO1FBQ1pGLGVBQWU2USxFQUFFN1EsYUFBYTtRQUM5QkQsZUFBZThRLEVBQUU5USxhQUFhO1FBQzlCYixXQUFXMlIsRUFBRTNSLFNBQVM7UUFDdEJlLFNBQVM0USxFQUFFNVEsT0FBTztJQUN0QjtJQUNBLE9BQU87UUFBRVA7UUFBT29SO0lBQVU7QUFDOUI7QUFDQSxTQUFTUywwQkFBMEJWLENBQUM7SUFDaEMsTUFBTSxFQUFFblIsS0FBSyxFQUFFb1IsU0FBUyxFQUFFLEdBQUdDLGdDQUFnQ0Y7SUFDN0QsTUFBTWxFLFlBQVk7UUFDZHRWLE1BQU13WixFQUFFeFosSUFBSTtRQUNacUIsYUFBYW1ZLEVBQUVuWSxXQUFXO1FBQzFCaUQsTUFBTWtWLEVBQUVsVixJQUFJO1FBQ1ppUixVQUFVaUUsRUFBRWpFLFFBQVE7UUFDcEJDLGVBQWVnRSxFQUFFaEUsYUFBYTtJQUNsQztJQUNBLE9BQU87UUFBRW5OO1FBQU9vUjtRQUFXcEUsTUFBTW1FLEVBQUVuRSxJQUFJO1FBQUVDO0lBQVU7QUFDdkQ7QUFDTyxTQUFTNkUsbUJBQW1CL1IsRUFBRSxFQUFFWSxDQUFDLEVBQUVuRCxDQUFDO0lBQ3ZDOzs7S0FHQyxHQUNELFNBQVNpRixvQkFBb0JqQixDQUFDO1FBQzFCLE1BQU02QixLQUFLdEQsR0FBR3VELEdBQUcsQ0FBQzlCLElBQUksUUFBUTtRQUM5QixNQUFNK0IsS0FBS3hELEdBQUd5RCxHQUFHLENBQUNILElBQUk3QixJQUFJLFNBQVM7UUFDbkMsT0FBT3pCLEdBQUcwRCxHQUFHLENBQUMxRCxHQUFHMEQsR0FBRyxDQUFDRixJQUFJeEQsR0FBR3lELEdBQUcsQ0FBQ2hDLEdBQUdiLEtBQUtuRCxJQUFJLGlCQUFpQjtJQUNqRTtJQUNBLE9BQU9pRjtBQUNYO0FBQ0EsU0FBUzZPLGtDQUFrQ0gsQ0FBQyxFQUFFNU0sS0FBSztJQUMvQyxNQUFNLEVBQUV4RSxFQUFFLEVBQUVaLEVBQUUsRUFBRSxHQUFHb0Y7SUFDbkIsU0FBU3dOLG1CQUFtQmhZLEdBQUc7UUFDM0IsT0FBT25CLGtEQUFPQSxDQUFDbUIsS0FBS3FCLEtBQUsrRCxHQUFHc0YsS0FBSztJQUNyQztJQUNBLE1BQU1oQyxzQkFBc0JxUCxtQkFBbUIvUixJQUFJb1IsRUFBRXhRLENBQUMsRUFBRXdRLEVBQUUzVCxDQUFDO0lBQzNELE9BQU8xQixPQUFPZ1EsTUFBTSxDQUFDLENBQUMsR0FBRztRQUNyQjlMLE9BQU9tUjtRQUNQNU0sT0FBT0E7UUFDUHlOLGlCQUFpQnpOO1FBQ2pCdUksd0JBQXdCLENBQUMxTixNQUFRRixlQUFlQyxJQUFJQztRQUNwRHFEO1FBQ0FzUDtJQUNKO0FBQ0o7QUFDQSxTQUFTRSw0QkFBNEJkLENBQUMsRUFBRWUsTUFBTTtJQUMxQyxNQUFNM04sUUFBUTJOLE9BQU8zTixLQUFLO0lBQzFCLE9BQU96SSxPQUFPZ1EsTUFBTSxDQUFDLENBQUMsR0FBR29HLFFBQVE7UUFDN0JGLGlCQUFpQnpOO1FBQ2pCdkUsT0FBT2xFLE9BQU9nUSxNQUFNLENBQUMsQ0FBQyxHQUFHcUYsR0FBR3ZYLG9EQUFPQSxDQUFDMkssTUFBTXBGLEVBQUUsQ0FBQ3NGLEtBQUssRUFBRUYsTUFBTXBGLEVBQUUsQ0FBQ3VLLElBQUk7SUFDckU7QUFDSjtBQUNBLGdCQUFnQjtBQUNULFNBQVN5SSxZQUFZaEIsQ0FBQztJQUN6QixNQUFNLEVBQUVuUixLQUFLLEVBQUVvUixTQUFTLEVBQUVwRSxJQUFJLEVBQUVDLFNBQVMsRUFBRSxHQUFHNEUsMEJBQTBCVjtJQUN4RSxNQUFNNU0sUUFBUTVFLGFBQWFLLE9BQU9vUjtJQUNsQyxNQUFNZ0IsUUFBUXJGLE1BQU14SSxPQUFPeUksTUFBTUM7SUFDakMsT0FBT2dGLDRCQUE0QmQsR0FBR2lCO0FBQzFDLEVBQ0EsdUNBQXVDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbm90YXNjYW0tcHJvdG9jb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjkuNy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanM/ZWUyMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNob3J0IFdlaWVyc3RyYXNzIGN1cnZlIG1ldGhvZHMuIFRoZSBmb3JtdWxhIGlzOiB5wrIgPSB4wrMgKyBheCArIGIuXG4gKlxuICogIyMjIERlc2lnbiByYXRpb25hbGUgZm9yIHR5cGVzXG4gKlxuICogKiBJbnRlcmFjdGlvbiBiZXR3ZWVuIGNsYXNzZXMgZnJvbSBkaWZmZXJlbnQgY3VydmVzIHNob3VsZCBmYWlsOlxuICogICBgazI1Ni5Qb2ludC5CQVNFLmFkZChwMjU2LlBvaW50LkJBU0UpYFxuICogKiBGb3IgdGhpcyBwdXJwb3NlIHdlIHdhbnQgdG8gdXNlIGBpbnN0YW5jZW9mYCBvcGVyYXRvciwgd2hpY2ggaXMgZmFzdCBhbmQgd29ya3MgZHVyaW5nIHJ1bnRpbWVcbiAqICogRGlmZmVyZW50IGNhbGxzIG9mIGBjdXJ2ZSgpYCB3b3VsZCByZXR1cm4gZGlmZmVyZW50IGNsYXNzZXMgLVxuICogICBgY3VydmUocGFyYW1zKSAhPT0gY3VydmUocGFyYW1zKWA6IGlmIHNvbWVib2R5IGRlY2lkZWQgdG8gbW9ua2V5LXBhdGNoIHRoZWlyIGN1cnZlLFxuICogICBpdCB3b24ndCBhZmZlY3Qgb3RoZXJzXG4gKlxuICogVHlwZVNjcmlwdCBjYW4ndCBpbmZlciB0eXBlcyBmb3IgY2xhc3NlcyBjcmVhdGVkIGluc2lkZSBhIGZ1bmN0aW9uLiBDbGFzc2VzIGlzIG9uZSBpbnN0YW5jZVxuICogb2Ygbm9taW5hdGl2ZSB0eXBlcyBpbiBUeXBlU2NyaXB0IGFuZCBpbnRlcmZhY2VzIG9ubHkgY2hlY2sgZm9yIHNoYXBlLCBzbyBpdCdzIGhhcmQgdG8gY3JlYXRlXG4gKiB1bmlxdWUgdHlwZSBmb3IgZXZlcnkgZnVuY3Rpb24gY2FsbC5cbiAqXG4gKiBXZSBjYW4gdXNlIGdlbmVyaWMgdHlwZXMgdmlhIHNvbWUgcGFyYW0sIGxpa2UgY3VydmUgb3B0cywgYnV0IHRoYXQgd291bGQ6XG4gKiAgICAgMS4gRW5hYmxlIGludGVyYWN0aW9uIGJldHdlZW4gYGN1cnZlKHBhcmFtcylgIGFuZCBgY3VydmUocGFyYW1zKWAgKGN1cnZlcyBvZiBzYW1lIHBhcmFtcylcbiAqICAgICB3aGljaCBpcyBoYXJkIHRvIGRlYnVnLlxuICogICAgIDIuIFBhcmFtcyBjYW4gYmUgZ2VuZXJpYyBhbmQgd2UgY2FuJ3QgZW5mb3JjZSB0aGVtIHRvIGJlIGNvbnN0YW50IHZhbHVlOlxuICogICAgIGlmIHNvbWVib2R5IGNyZWF0ZXMgY3VydmUgZnJvbSBub24tY29uc3RhbnQgcGFyYW1zLFxuICogICAgIGl0IHdvdWxkIGJlIGFsbG93ZWQgdG8gaW50ZXJhY3Qgd2l0aCBvdGhlciBjdXJ2ZXMgd2l0aCBub24tY29uc3RhbnQgcGFyYW1zXG4gKlxuICogQHRvZG8gaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svcmVsZWFzZS1ub3Rlcy90eXBlc2NyaXB0LTItNy5odG1sI3VuaXF1ZS1zeW1ib2xcbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgaG1hYyBhcyBub2JsZUhtYWMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL2htYWMuanMnO1xuaW1wb3J0IHsgYWhhc2ggfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCB7IF92YWxpZGF0ZU9iamVjdCwgX2Fib29sMiBhcyBhYm9vbCwgX2FieXRlczIgYXMgYWJ5dGVzLCBhSW5SYW5nZSwgYml0TGVuLCBiaXRNYXNrLCBieXRlc1RvSGV4LCBieXRlc1RvTnVtYmVyQkUsIGNvbmNhdEJ5dGVzLCBjcmVhdGVIbWFjRHJiZywgZW5zdXJlQnl0ZXMsIGhleFRvQnl0ZXMsIGluUmFuZ2UsIGlzQnl0ZXMsIG1lbW9pemVkLCBudW1iZXJUb0hleFVucGFkZGVkLCByYW5kb21CeXRlcyBhcyByYW5kb21CeXRlc1dlYiwgfSBmcm9tIFwiLi4vdXRpbHMuanNcIjtcbmltcG9ydCB7IF9jcmVhdGVDdXJ2ZUZpZWxkcywgbXVsRW5kb1Vuc2FmZSwgbmVnYXRlQ3QsIG5vcm1hbGl6ZVosIHBpcHBlbmdlciwgd05BRiwgfSBmcm9tIFwiLi9jdXJ2ZS5qc1wiO1xuaW1wb3J0IHsgRmllbGQsIEZwSW52ZXJ0QmF0Y2gsIGdldE1pbkhhc2hMZW5ndGgsIG1hcEhhc2hUb0ZpZWxkLCBuTGVuZ3RoLCB2YWxpZGF0ZUZpZWxkLCB9IGZyb20gXCIuL21vZHVsYXIuanNcIjtcbi8vIFdlIGNvbnN0cnVjdCBiYXNpcyBpbiBzdWNoIHdheSB0aGF0IGRlbiBpcyBhbHdheXMgcG9zaXRpdmUgYW5kIGVxdWFscyBuLCBidXQgbnVtIHNpZ24gZGVwZW5kcyBvbiBiYXNpcyAobm90IG9uIHNlY3JldCB2YWx1ZSlcbmNvbnN0IGRpdk5lYXJlc3QgPSAobnVtLCBkZW4pID0+IChudW0gKyAobnVtID49IDAgPyBkZW4gOiAtZGVuKSAvIF8ybikgLyBkZW47XG4vKipcbiAqIFNwbGl0cyBzY2FsYXIgZm9yIEdMViBlbmRvbW9ycGhpc20uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfc3BsaXRFbmRvU2NhbGFyKGssIGJhc2lzLCBuKSB7XG4gICAgLy8gU3BsaXQgc2NhbGFyIGludG8gdHdvIHN1Y2ggdGhhdCBwYXJ0IGlzIH5oYWxmIGJpdHM6IGBhYnMocGFydCkgPCBzcXJ0KE4pYFxuICAgIC8vIFNpbmNlIHBhcnQgY2FuIGJlIG5lZ2F0aXZlLCB3ZSBuZWVkIHRvIGRvIHRoaXMgb24gcG9pbnQuXG4gICAgLy8gVE9ETzogdmVyaWZ5U2NhbGFyIGZ1bmN0aW9uIHdoaWNoIGNvbnN1bWVzIGxhbWJkYVxuICAgIGNvbnN0IFtbYTEsIGIxXSwgW2EyLCBiMl1dID0gYmFzaXM7XG4gICAgY29uc3QgYzEgPSBkaXZOZWFyZXN0KGIyICogaywgbik7XG4gICAgY29uc3QgYzIgPSBkaXZOZWFyZXN0KC1iMSAqIGssIG4pO1xuICAgIC8vIHxrMXwvfGsyfCBpcyA8IHNxcnQoTiksIGJ1dCBjYW4gYmUgbmVnYXRpdmUuXG4gICAgLy8gSWYgd2UgZG8gYGsxIG1vZCBOYCwgd2UnbGwgZ2V0IGJpZyBzY2FsYXIgKGA+IHNxcnQoTilgKTogc28sIHdlIGRvIGNoZWFwZXIgbmVnYXRpb24gaW5zdGVhZC5cbiAgICBsZXQgazEgPSBrIC0gYzEgKiBhMSAtIGMyICogYTI7XG4gICAgbGV0IGsyID0gLWMxICogYjEgLSBjMiAqIGIyO1xuICAgIGNvbnN0IGsxbmVnID0gazEgPCBfMG47XG4gICAgY29uc3QgazJuZWcgPSBrMiA8IF8wbjtcbiAgICBpZiAoazFuZWcpXG4gICAgICAgIGsxID0gLWsxO1xuICAgIGlmIChrMm5lZylcbiAgICAgICAgazIgPSAtazI7XG4gICAgLy8gRG91YmxlIGNoZWNrIHRoYXQgcmVzdWx0aW5nIHNjYWxhciBsZXNzIHRoYW4gaGFsZiBiaXRzIG9mIE46IG90aGVyd2lzZSB3TkFGIHdpbGwgZmFpbC5cbiAgICAvLyBUaGlzIHNob3VsZCBvbmx5IGhhcHBlbiBvbiB3cm9uZyBiYXNpc2VzLiBBbHNvLCBtYXRoIGluc2lkZSBpcyB0b28gY29tcGxleCBhbmQgSSBkb24ndCB0cnVzdCBpdC5cbiAgICBjb25zdCBNQVhfTlVNID0gYml0TWFzayhNYXRoLmNlaWwoYml0TGVuKG4pIC8gMikpICsgXzFuOyAvLyBIYWxmIGJpdHMgb2YgTlxuICAgIGlmIChrMSA8IF8wbiB8fCBrMSA+PSBNQVhfTlVNIHx8IGsyIDwgXzBuIHx8IGsyID49IE1BWF9OVU0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzcGxpdFNjYWxhciAoZW5kb21vcnBoaXNtKTogZmFpbGVkLCBrPScgKyBrKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgazFuZWcsIGsxLCBrMm5lZywgazIgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlU2lnRm9ybWF0KGZvcm1hdCkge1xuICAgIGlmICghWydjb21wYWN0JywgJ3JlY292ZXJlZCcsICdkZXInXS5pbmNsdWRlcyhmb3JtYXQpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NpZ25hdHVyZSBmb3JtYXQgbXVzdCBiZSBcImNvbXBhY3RcIiwgXCJyZWNvdmVyZWRcIiwgb3IgXCJkZXJcIicpO1xuICAgIHJldHVybiBmb3JtYXQ7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVNpZ09wdHMob3B0cywgZGVmKSB7XG4gICAgY29uc3Qgb3B0c24gPSB7fTtcbiAgICBmb3IgKGxldCBvcHROYW1lIG9mIE9iamVjdC5rZXlzKGRlZikpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBvcHRzbltvcHROYW1lXSA9IG9wdHNbb3B0TmFtZV0gPT09IHVuZGVmaW5lZCA/IGRlZltvcHROYW1lXSA6IG9wdHNbb3B0TmFtZV07XG4gICAgfVxuICAgIGFib29sKG9wdHNuLmxvd1MsICdsb3dTJyk7XG4gICAgYWJvb2wob3B0c24ucHJlaGFzaCwgJ3ByZWhhc2gnKTtcbiAgICBpZiAob3B0c24uZm9ybWF0ICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHZhbGlkYXRlU2lnRm9ybWF0KG9wdHNuLmZvcm1hdCk7XG4gICAgcmV0dXJuIG9wdHNuO1xufVxuZXhwb3J0IGNsYXNzIERFUkVyciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtID0gJycpIHtcbiAgICAgICAgc3VwZXIobSk7XG4gICAgfVxufVxuLyoqXG4gKiBBU04uMSBERVIgZW5jb2RpbmcgdXRpbGl0aWVzLiBBU04gaXMgdmVyeSBjb21wbGV4ICYgZnJhZ2lsZS4gRm9ybWF0OlxuICpcbiAqICAgICBbMHgzMCAoU0VRVUVOQ0UpLCBieXRlbGVuZ3RoLCAweDAyIChJTlRFR0VSKSwgaW50TGVuZ3RoLCBSLCAweDAyIChJTlRFR0VSKSwgaW50TGVuZ3RoLCBTXVxuICpcbiAqIERvY3M6IGh0dHBzOi8vbGV0c2VuY3J5cHQub3JnL2RvY3MvYS13YXJtLXdlbGNvbWUtdG8tYXNuMS1hbmQtZGVyLywgaHR0cHM6Ly9sdWNhLm50b3Aub3JnL1RlYWNoaW5nL0FwcHVudGkvYXNuMS5odG1sXG4gKi9cbmV4cG9ydCBjb25zdCBERVIgPSB7XG4gICAgLy8gYXNuLjEgREVSIGVuY29kaW5nIHV0aWxzXG4gICAgRXJyOiBERVJFcnIsXG4gICAgLy8gQmFzaWMgYnVpbGRpbmcgYmxvY2sgaXMgVExWIChUYWctTGVuZ3RoLVZhbHVlKVxuICAgIF90bHY6IHtcbiAgICAgICAgZW5jb2RlOiAodGFnLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICAgICAgaWYgKHRhZyA8IDAgfHwgdGFnID4gMjU2KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZW5jb2RlOiB3cm9uZyB0YWcnKTtcbiAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCAmIDEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5lbmNvZGU6IHVucGFkZGVkIGRhdGEnKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGFMZW4gPSBkYXRhLmxlbmd0aCAvIDI7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBudW1iZXJUb0hleFVucGFkZGVkKGRhdGFMZW4pO1xuICAgICAgICAgICAgaWYgKChsZW4ubGVuZ3RoIC8gMikgJiAxMjgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5lbmNvZGU6IGxvbmcgZm9ybSBsZW5ndGggdG9vIGJpZycpO1xuICAgICAgICAgICAgLy8gbGVuZ3RoIG9mIGxlbmd0aCB3aXRoIGxvbmcgZm9ybSBmbGFnXG4gICAgICAgICAgICBjb25zdCBsZW5MZW4gPSBkYXRhTGVuID4gMTI3ID8gbnVtYmVyVG9IZXhVbnBhZGRlZCgobGVuLmxlbmd0aCAvIDIpIHwgMTI4KSA6ICcnO1xuICAgICAgICAgICAgY29uc3QgdCA9IG51bWJlclRvSGV4VW5wYWRkZWQodGFnKTtcbiAgICAgICAgICAgIHJldHVybiB0ICsgbGVuTGVuICsgbGVuICsgZGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gdiAtIHZhbHVlLCBsIC0gbGVmdCBieXRlcyAodW5wYXJzZWQpXG4gICAgICAgIGRlY29kZSh0YWcsIGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBERVI7XG4gICAgICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgICAgIGlmICh0YWcgPCAwIHx8IHRhZyA+IDI1NilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmVuY29kZTogd3JvbmcgdGFnJyk7XG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCAyIHx8IGRhdGFbcG9zKytdICE9PSB0YWcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGU6IHdyb25nIHRsdicpO1xuICAgICAgICAgICAgY29uc3QgZmlyc3QgPSBkYXRhW3BvcysrXTtcbiAgICAgICAgICAgIGNvbnN0IGlzTG9uZyA9ICEhKGZpcnN0ICYgMTI4KTsgLy8gRmlyc3QgYml0IG9mIGZpcnN0IGxlbmd0aCBieXRlIGlzIGZsYWcgZm9yIHNob3J0L2xvbmcgZm9ybVxuICAgICAgICAgICAgbGV0IGxlbmd0aCA9IDA7XG4gICAgICAgICAgICBpZiAoIWlzTG9uZylcbiAgICAgICAgICAgICAgICBsZW5ndGggPSBmaXJzdDtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIExvbmcgZm9ybTogW2xvbmdGbGFnKDFiaXQpLCBsZW5ndGhMZW5ndGgoN2JpdCksIGxlbmd0aCAoQkUpXVxuICAgICAgICAgICAgICAgIGNvbnN0IGxlbkxlbiA9IGZpcnN0ICYgMTI3O1xuICAgICAgICAgICAgICAgIGlmICghbGVuTGVuKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZShsb25nKTogaW5kZWZpbml0ZSBsZW5ndGggbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgICAgIGlmIChsZW5MZW4gPiA0KVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZShsb25nKTogYnl0ZSBsZW5ndGggaXMgdG9vIGJpZycpOyAvLyB0aGlzIHdpbGwgb3ZlcmZsb3cgdTMyIGluIGpzXG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoQnl0ZXMgPSBkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgbGVuTGVuKTtcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoQnl0ZXMubGVuZ3RoICE9PSBsZW5MZW4pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlOiBsZW5ndGggYnl0ZXMgbm90IGNvbXBsZXRlJyk7XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aEJ5dGVzWzBdID09PSAwKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZShsb25nKTogemVybyBsZWZ0bW9zdCBieXRlJyk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBiIG9mIGxlbmd0aEJ5dGVzKVxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSAobGVuZ3RoIDw8IDgpIHwgYjtcbiAgICAgICAgICAgICAgICBwb3MgKz0gbGVuTGVuO1xuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggPCAxMjgpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlKGxvbmcpOiBub3QgbWluaW1hbCBlbmNvZGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdiA9IGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyBsZW5ndGgpO1xuICAgICAgICAgICAgaWYgKHYubGVuZ3RoICE9PSBsZW5ndGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGU6IHdyb25nIHZhbHVlIGxlbmd0aCcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgdiwgbDogZGF0YS5zdWJhcnJheShwb3MgKyBsZW5ndGgpIH07XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICAvLyBodHRwczovL2NyeXB0by5zdGFja2V4Y2hhbmdlLmNvbS9hLzU3NzM0IExlZnRtb3N0IGJpdCBvZiBmaXJzdCBieXRlIGlzICduZWdhdGl2ZScgZmxhZyxcbiAgICAvLyBzaW5jZSB3ZSBhbHdheXMgdXNlIHBvc2l0aXZlIGludGVnZXJzIGhlcmUuIEl0IG11c3QgYWx3YXlzIGJlIGVtcHR5OlxuICAgIC8vIC0gYWRkIHplcm8gYnl0ZSBpZiBleGlzdHNcbiAgICAvLyAtIGlmIG5leHQgYnl0ZSBkb2Vzbid0IGhhdmUgYSBmbGFnLCBsZWFkaW5nIHplcm8gaXMgbm90IGFsbG93ZWQgKG1pbmltYWwgZW5jb2RpbmcpXG4gICAgX2ludDoge1xuICAgICAgICBlbmNvZGUobnVtKSB7XG4gICAgICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICAgICAgaWYgKG51bSA8IF8wbilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgnaW50ZWdlcjogbmVnYXRpdmUgaW50ZWdlcnMgYXJlIG5vdCBhbGxvd2VkJyk7XG4gICAgICAgICAgICBsZXQgaGV4ID0gbnVtYmVyVG9IZXhVbnBhZGRlZChudW0pO1xuICAgICAgICAgICAgLy8gUGFkIHdpdGggemVybyBieXRlIGlmIG5lZ2F0aXZlIGZsYWcgaXMgcHJlc2VudFxuICAgICAgICAgICAgaWYgKE51bWJlci5wYXJzZUludChoZXhbMF0sIDE2KSAmIDBiMTAwMClcbiAgICAgICAgICAgICAgICBoZXggPSAnMDAnICsgaGV4O1xuICAgICAgICAgICAgaWYgKGhleC5sZW5ndGggJiAxKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd1bmV4cGVjdGVkIERFUiBwYXJzaW5nIGFzc2VydGlvbjogdW5wYWRkZWQgaGV4Jyk7XG4gICAgICAgICAgICByZXR1cm4gaGV4O1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUoZGF0YSkge1xuICAgICAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgICAgIGlmIChkYXRhWzBdICYgMTI4KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiBuZWdhdGl2ZScpO1xuICAgICAgICAgICAgaWYgKGRhdGFbMF0gPT09IDB4MDAgJiYgIShkYXRhWzFdICYgMTI4KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgnaW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogdW5uZWNlc3NhcnkgbGVhZGluZyB6ZXJvJyk7XG4gICAgICAgICAgICByZXR1cm4gYnl0ZXNUb051bWJlckJFKGRhdGEpO1xuICAgICAgICB9LFxuICAgIH0sXG4gICAgdG9TaWcoaGV4KSB7XG4gICAgICAgIC8vIHBhcnNlIERFUiBzaWduYXR1cmVcbiAgICAgICAgY29uc3QgeyBFcnI6IEUsIF9pbnQ6IGludCwgX3RsdjogdGx2IH0gPSBERVI7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBlbnN1cmVCeXRlcygnc2lnbmF0dXJlJywgaGV4KTtcbiAgICAgICAgY29uc3QgeyB2OiBzZXFCeXRlcywgbDogc2VxTGVmdEJ5dGVzIH0gPSB0bHYuZGVjb2RlKDB4MzAsIGRhdGEpO1xuICAgICAgICBpZiAoc2VxTGVmdEJ5dGVzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgICAgIGNvbnN0IHsgdjogckJ5dGVzLCBsOiByTGVmdEJ5dGVzIH0gPSB0bHYuZGVjb2RlKDB4MDIsIHNlcUJ5dGVzKTtcbiAgICAgICAgY29uc3QgeyB2OiBzQnl0ZXMsIGw6IHNMZWZ0Qnl0ZXMgfSA9IHRsdi5kZWNvZGUoMHgwMiwgckxlZnRCeXRlcyk7XG4gICAgICAgIGlmIChzTGVmdEJ5dGVzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgICAgIHJldHVybiB7IHI6IGludC5kZWNvZGUockJ5dGVzKSwgczogaW50LmRlY29kZShzQnl0ZXMpIH07XG4gICAgfSxcbiAgICBoZXhGcm9tU2lnKHNpZykge1xuICAgICAgICBjb25zdCB7IF90bHY6IHRsdiwgX2ludDogaW50IH0gPSBERVI7XG4gICAgICAgIGNvbnN0IHJzID0gdGx2LmVuY29kZSgweDAyLCBpbnQuZW5jb2RlKHNpZy5yKSk7XG4gICAgICAgIGNvbnN0IHNzID0gdGx2LmVuY29kZSgweDAyLCBpbnQuZW5jb2RlKHNpZy5zKSk7XG4gICAgICAgIGNvbnN0IHNlcSA9IHJzICsgc3M7XG4gICAgICAgIHJldHVybiB0bHYuZW5jb2RlKDB4MzAsIHNlcSk7XG4gICAgfSxcbn07XG4vLyBCZSBmcmllbmRseSB0byBiYWQgRUNNQVNjcmlwdCBwYXJzZXJzIGJ5IG5vdCB1c2luZyBiaWdpbnQgbGl0ZXJhbHNcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpLCBfNG4gPSBCaWdJbnQoNCk7XG5leHBvcnQgZnVuY3Rpb24gX25vcm1GbkVsZW1lbnQoRm4sIGtleSkge1xuICAgIGNvbnN0IHsgQllURVM6IGV4cGVjdGVkIH0gPSBGbjtcbiAgICBsZXQgbnVtO1xuICAgIGlmICh0eXBlb2Yga2V5ID09PSAnYmlnaW50Jykge1xuICAgICAgICBudW0gPSBrZXk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgYnl0ZXMgPSBlbnN1cmVCeXRlcygncHJpdmF0ZSBrZXknLCBrZXkpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbnVtID0gRm4uZnJvbUJ5dGVzKGJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBwcml2YXRlIGtleTogZXhwZWN0ZWQgdWk4YSBvZiBzaXplICR7ZXhwZWN0ZWR9LCBnb3QgJHt0eXBlb2Yga2V5fWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghRm4uaXNWYWxpZE5vdDAobnVtKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHByaXZhdGUga2V5OiBvdXQgb2YgcmFuZ2UgWzEuLk4tMV0nKTtcbiAgICByZXR1cm4gbnVtO1xufVxuLyoqXG4gKiBDcmVhdGVzIHdlaWVyc3RyYXNzIFBvaW50IGNvbnN0cnVjdG9yLCBiYXNlZCBvbiBzcGVjaWZpZWQgY3VydmUgb3B0aW9ucy5cbiAqXG4gKiBAZXhhbXBsZVxuYGBganNcbmNvbnN0IG9wdHMgPSB7XG4gIHA6IEJpZ0ludCgnMHhmZmZmZmZmZjAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmJyksXG4gIG46IEJpZ0ludCgnMHhmZmZmZmZmZjAwMDAwMDAwZmZmZmZmZmZmZmZmZmZmZmJjZTZmYWFkYTcxNzllODRmM2I5Y2FjMmZjNjMyNTUxJyksXG4gIGg6IEJpZ0ludCgxKSxcbiAgYTogQmlnSW50KCcweGZmZmZmZmZmMDAwMDAwMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmMnKSxcbiAgYjogQmlnSW50KCcweDVhYzYzNWQ4YWEzYTkzZTdiM2ViYmQ1NTc2OTg4NmJjNjUxZDA2YjBjYzUzYjBmNjNiY2UzYzNlMjdkMjYwNGInKSxcbiAgR3g6IEJpZ0ludCgnMHg2YjE3ZDFmMmUxMmM0MjQ3ZjhiY2U2ZTU2M2E0NDBmMjc3MDM3ZDgxMmRlYjMzYTBmNGExMzk0NWQ4OThjMjk2JyksXG4gIEd5OiBCaWdJbnQoJzB4NGZlMzQyZTJmZTFhN2Y5YjhlZTdlYjRhN2MwZjllMTYyYmNlMzM1NzZiMzE1ZWNlY2JiNjQwNjgzN2JmNTFmNScpLFxufTtcbmNvbnN0IHAyNTZfUG9pbnQgPSB3ZWllcnN0cmFzcyhvcHRzKTtcbmBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3NOKHBhcmFtcywgZXh0cmFPcHRzID0ge30pIHtcbiAgICBjb25zdCB2YWxpZGF0ZWQgPSBfY3JlYXRlQ3VydmVGaWVsZHMoJ3dlaWVyc3RyYXNzJywgcGFyYW1zLCBleHRyYU9wdHMpO1xuICAgIGNvbnN0IHsgRnAsIEZuIH0gPSB2YWxpZGF0ZWQ7XG4gICAgbGV0IENVUlZFID0gdmFsaWRhdGVkLkNVUlZFO1xuICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIG46IENVUlZFX09SREVSIH0gPSBDVVJWRTtcbiAgICBfdmFsaWRhdGVPYmplY3QoZXh0cmFPcHRzLCB7fSwge1xuICAgICAgICBhbGxvd0luZmluaXR5UG9pbnQ6ICdib29sZWFuJyxcbiAgICAgICAgY2xlYXJDb2ZhY3RvcjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgaXNUb3JzaW9uRnJlZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgZnJvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICB0b0J5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICBlbmRvOiAnb2JqZWN0JyxcbiAgICAgICAgd3JhcFByaXZhdGVLZXk6ICdib29sZWFuJyxcbiAgICB9KTtcbiAgICBjb25zdCB7IGVuZG8gfSA9IGV4dHJhT3B0cztcbiAgICBpZiAoZW5kbykge1xuICAgICAgICAvLyB2YWxpZGF0ZU9iamVjdChlbmRvLCB7IGJldGE6ICdiaWdpbnQnLCBzcGxpdFNjYWxhcjogJ2Z1bmN0aW9uJyB9KTtcbiAgICAgICAgaWYgKCFGcC5pczAoQ1VSVkUuYSkgfHwgdHlwZW9mIGVuZG8uYmV0YSAhPT0gJ2JpZ2ludCcgfHwgIUFycmF5LmlzQXJyYXkoZW5kby5iYXNpc2VzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGVuZG86IGV4cGVjdGVkIFwiYmV0YVwiOiBiaWdpbnQgYW5kIFwiYmFzaXNlc1wiOiBhcnJheScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGxlbmd0aHMgPSBnZXRXTGVuZ3RocyhGcCwgRm4pO1xuICAgIGZ1bmN0aW9uIGFzc2VydENvbXByZXNzaW9uSXNTdXBwb3J0ZWQoKSB7XG4gICAgICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbXByZXNzaW9uIGlzIG5vdCBzdXBwb3J0ZWQ6IEZpZWxkIGRvZXMgbm90IGhhdmUgLmlzT2RkKCknKTtcbiAgICB9XG4gICAgLy8gSW1wbGVtZW50cyBJRUVFIFAxMzYzIHBvaW50IGVuY29kaW5nXG4gICAgZnVuY3Rpb24gcG9pbnRUb0J5dGVzKF9jLCBwb2ludCwgaXNDb21wcmVzc2VkKSB7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgY29uc3QgYnggPSBGcC50b0J5dGVzKHgpO1xuICAgICAgICBhYm9vbChpc0NvbXByZXNzZWQsICdpc0NvbXByZXNzZWQnKTtcbiAgICAgICAgaWYgKGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgYXNzZXJ0Q29tcHJlc3Npb25Jc1N1cHBvcnRlZCgpO1xuICAgICAgICAgICAgY29uc3QgaGFzRXZlblkgPSAhRnAuaXNPZGQoeSk7XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMocHByZWZpeChoYXNFdmVuWSksIGJ4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjb25jYXRCeXRlcyhVaW50OEFycmF5Lm9mKDB4MDQpLCBieCwgRnAudG9CeXRlcyh5KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcG9pbnRGcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgYWJ5dGVzKGJ5dGVzLCB1bmRlZmluZWQsICdQb2ludCcpO1xuICAgICAgICBjb25zdCB7IHB1YmxpY0tleTogY29tcCwgcHVibGljS2V5VW5jb21wcmVzc2VkOiB1bmNvbXAgfSA9IGxlbmd0aHM7IC8vIGUuZy4gZm9yIDMyLWJ5dGU6IDMzLCA2NVxuICAgICAgICBjb25zdCBsZW5ndGggPSBieXRlcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcbiAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAvLyBObyBhY3R1YWwgdmFsaWRhdGlvbiBpcyBkb25lIGhlcmU6IHVzZSAuYXNzZXJ0VmFsaWRpdHkoKVxuICAgICAgICBpZiAobGVuZ3RoID09PSBjb21wICYmIChoZWFkID09PSAweDAyIHx8IGhlYWQgPT09IDB4MDMpKSB7XG4gICAgICAgICAgICBjb25zdCB4ID0gRnAuZnJvbUJ5dGVzKHRhaWwpO1xuICAgICAgICAgICAgaWYgKCFGcC5pc1ZhbGlkKHgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBpcyBub3Qgb24gY3VydmUsIHdyb25nIHgnKTtcbiAgICAgICAgICAgIGNvbnN0IHkyID0gd2VpZXJzdHJhc3NFcXVhdGlvbih4KTsgLy8gecKyID0geMKzICsgYXggKyBiXG4gICAgICAgICAgICBsZXQgeTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgeSA9IEZwLnNxcnQoeTIpOyAvLyB5ID0gecKyIF4gKHArMSkvNFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKHNxcnRFcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IHNxcnRFcnJvciBpbnN0YW5jZW9mIEVycm9yID8gJzogJyArIHNxcnRFcnJvci5tZXNzYWdlIDogJyc7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IGlzIG5vdCBvbiBjdXJ2ZSwgc3FydCBlcnJvcicgKyBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0Q29tcHJlc3Npb25Jc1N1cHBvcnRlZCgpO1xuICAgICAgICAgICAgY29uc3QgaXNZT2RkID0gRnAuaXNPZGQoeSk7IC8vICh5ICYgXzFuKSA9PT0gXzFuO1xuICAgICAgICAgICAgY29uc3QgaXNIZWFkT2RkID0gKGhlYWQgJiAxKSA9PT0gMTsgLy8gRUNEU0Etc3BlY2lmaWNcbiAgICAgICAgICAgIGlmIChpc0hlYWRPZGQgIT09IGlzWU9kZClcbiAgICAgICAgICAgICAgICB5ID0gRnAubmVnKHkpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5jb21wICYmIGhlYWQgPT09IDB4MDQpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IG1vcmUgY2hlY2tzXG4gICAgICAgICAgICBjb25zdCBMID0gRnAuQllURVM7XG4gICAgICAgICAgICBjb25zdCB4ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoMCwgTCkpO1xuICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEwsIEwgKiAyKSk7XG4gICAgICAgICAgICBpZiAoIWlzVmFsaWRYWSh4LCB5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogaXMgbm90IG9uIGN1cnZlJyk7XG4gICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJhZCBwb2ludDogZ290IGxlbmd0aCAke2xlbmd0aH0sIGV4cGVjdGVkIGNvbXByZXNzZWQ9JHtjb21wfSBvciB1bmNvbXByZXNzZWQ9JHt1bmNvbXB9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZW5jb2RlUG9pbnQgPSBleHRyYU9wdHMudG9CeXRlcyB8fCBwb2ludFRvQnl0ZXM7XG4gICAgY29uc3QgZGVjb2RlUG9pbnQgPSBleHRyYU9wdHMuZnJvbUJ5dGVzIHx8IHBvaW50RnJvbUJ5dGVzO1xuICAgIGZ1bmN0aW9uIHdlaWVyc3RyYXNzRXF1YXRpb24oeCkge1xuICAgICAgICBjb25zdCB4MiA9IEZwLnNxcih4KTsgLy8geCAqIHhcbiAgICAgICAgY29uc3QgeDMgPSBGcC5tdWwoeDIsIHgpOyAvLyB4wrIgKiB4XG4gICAgICAgIHJldHVybiBGcC5hZGQoRnAuYWRkKHgzLCBGcC5tdWwoeCwgQ1VSVkUuYSkpLCBDVVJWRS5iKTsgLy8geMKzICsgYSAqIHggKyBiXG4gICAgfVxuICAgIC8vIFRPRE86IG1vdmUgdG9wLWxldmVsXG4gICAgLyoqIENoZWNrcyB3aGV0aGVyIGVxdWF0aW9uIGhvbGRzIGZvciBnaXZlbiB4LCB5OiB5wrIgPT0geMKzICsgYXggKyBiICovXG4gICAgZnVuY3Rpb24gaXNWYWxpZFhZKHgsIHkpIHtcbiAgICAgICAgY29uc3QgbGVmdCA9IEZwLnNxcih5KTsgLy8gecKyXG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gd2VpZXJzdHJhc3NFcXVhdGlvbih4KTsgLy8geMKzICsgYXggKyBiXG4gICAgICAgIHJldHVybiBGcC5lcWwobGVmdCwgcmlnaHQpO1xuICAgIH1cbiAgICAvLyBWYWxpZGF0ZSB3aGV0aGVyIHRoZSBwYXNzZWQgY3VydmUgcGFyYW1zIGFyZSB2YWxpZC5cbiAgICAvLyBUZXN0IDE6IGVxdWF0aW9uIHnCsiA9IHjCsyArIGF4ICsgYiBzaG91bGQgd29yayBmb3IgZ2VuZXJhdG9yIHBvaW50LlxuICAgIGlmICghaXNWYWxpZFhZKENVUlZFLkd4LCBDVVJWRS5HeSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIGN1cnZlIHBhcmFtczogZ2VuZXJhdG9yIHBvaW50Jyk7XG4gICAgLy8gVGVzdCAyOiBkaXNjcmltaW5hbnQgzpQgcGFydCBzaG91bGQgYmUgbm9uLXplcm86IDRhwrMgKyAyN2LCsiAhPSAwLlxuICAgIC8vIEd1YXJhbnRlZXMgY3VydmUgaXMgZ2VudXMtMSwgc21vb3RoIChub24tc2luZ3VsYXIpLlxuICAgIGNvbnN0IF80YTMgPSBGcC5tdWwoRnAucG93KENVUlZFLmEsIF8zbiksIF80bik7XG4gICAgY29uc3QgXzI3YjIgPSBGcC5tdWwoRnAuc3FyKENVUlZFLmIpLCBCaWdJbnQoMjcpKTtcbiAgICBpZiAoRnAuaXMwKEZwLmFkZChfNGEzLCBfMjdiMikpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBjdXJ2ZSBwYXJhbXM6IGEgb3IgYicpO1xuICAgIC8qKiBBc3NlcnRzIGNvb3JkaW5hdGUgaXMgdmFsaWQ6IDAgPD0gbiA8IEZwLk9SREVSLiAqL1xuICAgIGZ1bmN0aW9uIGFjb29yZCh0aXRsZSwgbiwgYmFuWmVybyA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghRnAuaXNWYWxpZChuKSB8fCAoYmFuWmVybyAmJiBGcC5pczAobikpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiYWQgcG9pbnQgY29vcmRpbmF0ZSAke3RpdGxlfWApO1xuICAgICAgICByZXR1cm4gbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gYXByanBvaW50KG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUG9pbnQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9qZWN0aXZlUG9pbnQgZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3BsaXRFbmRvU2NhbGFyTihrKSB7XG4gICAgICAgIGlmICghZW5kbyB8fCAhZW5kby5iYXNpc2VzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdubyBlbmRvJyk7XG4gICAgICAgIHJldHVybiBfc3BsaXRFbmRvU2NhbGFyKGssIGVuZG8uYmFzaXNlcywgRm4uT1JERVIpO1xuICAgIH1cbiAgICAvLyBNZW1vaXplZCB0b0FmZmluZSAvIHZhbGlkaXR5IGNoZWNrLiBUaGV5IGFyZSBoZWF2eS4gUG9pbnRzIGFyZSBpbW11dGFibGUuXG4gICAgLy8gQ29udmVydHMgUHJvamVjdGl2ZSBwb2ludCB0byBhZmZpbmUgKHgsIHkpIGNvb3JkaW5hdGVzLlxuICAgIC8vIENhbiBhY2NlcHQgcHJlY29tcHV0ZWQgWl4tMSAtIGZvciBleGFtcGxlLCBmcm9tIGludmVydEJhdGNoLlxuICAgIC8vIChYLCBZLCBaKSDiiIsgKHg9WC9aLCB5PVkvWilcbiAgICBjb25zdCB0b0FmZmluZU1lbW8gPSBtZW1vaXplZCgocCwgaXopID0+IHtcbiAgICAgICAgY29uc3QgeyBYLCBZLCBaIH0gPSBwO1xuICAgICAgICAvLyBGYXN0LXBhdGggZm9yIG5vcm1hbGl6ZWQgcG9pbnRzXG4gICAgICAgIGlmIChGcC5lcWwoWiwgRnAuT05FKSlcbiAgICAgICAgICAgIHJldHVybiB7IHg6IFgsIHk6IFkgfTtcbiAgICAgICAgY29uc3QgaXMwID0gcC5pczAoKTtcbiAgICAgICAgLy8gSWYgaW52WiB3YXMgMCwgd2UgcmV0dXJuIHplcm8gcG9pbnQuIEhvd2V2ZXIgd2Ugc3RpbGwgd2FudCB0byBleGVjdXRlXG4gICAgICAgIC8vIGFsbCBvcGVyYXRpb25zLCBzbyB3ZSByZXBsYWNlIGludlogd2l0aCBhIHJhbmRvbSBudW1iZXIsIDEuXG4gICAgICAgIGlmIChpeiA9PSBudWxsKVxuICAgICAgICAgICAgaXogPSBpczAgPyBGcC5PTkUgOiBGcC5pbnYoWik7XG4gICAgICAgIGNvbnN0IHggPSBGcC5tdWwoWCwgaXopO1xuICAgICAgICBjb25zdCB5ID0gRnAubXVsKFksIGl6KTtcbiAgICAgICAgY29uc3QgenogPSBGcC5tdWwoWiwgaXopO1xuICAgICAgICBpZiAoaXMwKVxuICAgICAgICAgICAgcmV0dXJuIHsgeDogRnAuWkVSTywgeTogRnAuWkVSTyB9O1xuICAgICAgICBpZiAoIUZwLmVxbCh6eiwgRnAuT05FKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52WiB3YXMgaW52YWxpZCcpO1xuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfSk7XG4gICAgLy8gTk9URTogb24gZXhjZXB0aW9uIHRoaXMgd2lsbCBjcmFzaCAnY2FjaGVkJyBhbmQgbm8gdmFsdWUgd2lsbCBiZSBzZXQuXG4gICAgLy8gT3RoZXJ3aXNlIHRydWUgd2lsbCBiZSByZXR1cm5cbiAgICBjb25zdCBhc3NlcnRWYWxpZE1lbW8gPSBtZW1vaXplZCgocCkgPT4ge1xuICAgICAgICBpZiAocC5pczAoKSkge1xuICAgICAgICAgICAgLy8gKDAsIDEsIDApIGFrYSBaRVJPIGlzIGludmFsaWQgaW4gbW9zdCBjb250ZXh0cy5cbiAgICAgICAgICAgIC8vIEluIEJMUywgWkVSTyBjYW4gYmUgc2VyaWFsaXplZCwgc28gd2UgYWxsb3cgaXQuXG4gICAgICAgICAgICAvLyAoMCwgMCwgMCkgaXMgaW52YWxpZCByZXByZXNlbnRhdGlvbiBvZiBaRVJPLlxuICAgICAgICAgICAgaWYgKGV4dHJhT3B0cy5hbGxvd0luZmluaXR5UG9pbnQgJiYgIUZwLmlzMChwLlkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBaRVJPJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29tZSAzcmQtcGFydHkgdGVzdCB2ZWN0b3JzIHJlcXVpcmUgZGlmZmVyZW50IHdvcmRpbmcgYmV0d2VlbiBoZXJlICYgYGZyb21Db21wcmVzc2VkSGV4YFxuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAudG9BZmZpbmUoKTtcbiAgICAgICAgaWYgKCFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IHggb3IgeSBub3QgZmllbGQgZWxlbWVudHMnKTtcbiAgICAgICAgaWYgKCFpc1ZhbGlkWFkoeCwgeSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCcpO1xuICAgICAgICBpZiAoIXAuaXNUb3JzaW9uRnJlZSgpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IG5vdCBpbiBwcmltZS1vcmRlciBzdWJncm91cCcpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBmaW5pc2hFbmRvKGVuZG9CZXRhLCBrMXAsIGsycCwgazFuZWcsIGsybmVnKSB7XG4gICAgICAgIGsycCA9IG5ldyBQb2ludChGcC5tdWwoazJwLlgsIGVuZG9CZXRhKSwgazJwLlksIGsycC5aKTtcbiAgICAgICAgazFwID0gbmVnYXRlQ3QoazFuZWcsIGsxcCk7XG4gICAgICAgIGsycCA9IG5lZ2F0ZUN0KGsybmVnLCBrMnApO1xuICAgICAgICByZXR1cm4gazFwLmFkZChrMnApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9qZWN0aXZlIFBvaW50IHdvcmtzIGluIDNkIC8gcHJvamVjdGl2ZSAoaG9tb2dlbmVvdXMpIGNvb3JkaW5hdGVzOihYLCBZLCBaKSDiiIsgKHg9WC9aLCB5PVkvWikuXG4gICAgICogRGVmYXVsdCBQb2ludCB3b3JrcyBpbiAyZCAvIGFmZmluZSBjb29yZGluYXRlczogKHgsIHkpLlxuICAgICAqIFdlJ3JlIGRvaW5nIGNhbGN1bGF0aW9ucyBpbiBwcm9qZWN0aXZlLCBiZWNhdXNlIGl0cyBvcGVyYXRpb25zIGRvbid0IHJlcXVpcmUgY29zdGx5IGludmVyc2lvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBQb2ludCB7XG4gICAgICAgIC8qKiBEb2VzIE5PVCB2YWxpZGF0ZSBpZiB0aGUgcG9pbnQgaXMgdmFsaWQuIFVzZSBgLmFzc2VydFZhbGlkaXR5KClgLiAqL1xuICAgICAgICBjb25zdHJ1Y3RvcihYLCBZLCBaKSB7XG4gICAgICAgICAgICB0aGlzLlggPSBhY29vcmQoJ3gnLCBYKTtcbiAgICAgICAgICAgIHRoaXMuWSA9IGFjb29yZCgneScsIFksIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5aID0gYWNvb3JkKCd6JywgWik7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBDVVJWRSgpIHtcbiAgICAgICAgICAgIHJldHVybiBDVVJWRTtcbiAgICAgICAgfVxuICAgICAgICAvKiogRG9lcyBOT1QgdmFsaWRhdGUgaWYgdGhlIHBvaW50IGlzIHZhbGlkLiBVc2UgYC5hc3NlcnRWYWxpZGl0eSgpYC4gKi9cbiAgICAgICAgc3RhdGljIGZyb21BZmZpbmUocCkge1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBwIHx8IHt9O1xuICAgICAgICAgICAgaWYgKCFwIHx8ICFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhZmZpbmUgcG9pbnQnKTtcbiAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9qZWN0aXZlIHBvaW50IG5vdCBhbGxvd2VkJyk7XG4gICAgICAgICAgICAvLyAoMCwgMCkgd291bGQndmUgcHJvZHVjZWQgKDAsIDAsIDEpIC0gaW5zdGVhZCwgd2UgbmVlZCAoMCwgMSwgMClcbiAgICAgICAgICAgIGlmIChGcC5pczAoeCkgJiYgRnAuaXMwKHkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBQb2ludC5aRVJPO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5LCBGcC5PTkUpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBmcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKGRlY29kZVBvaW50KGFieXRlcyhieXRlcywgdW5kZWZpbmVkLCAncG9pbnQnKSkpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgICAgICAgICByZXR1cm4gUG9pbnQuZnJvbUJ5dGVzKGVuc3VyZUJ5dGVzKCdwb2ludEhleCcsIGhleCkpO1xuICAgICAgICB9XG4gICAgICAgIGdldCB4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS54O1xuICAgICAgICB9XG4gICAgICAgIGdldCB5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS55O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gd2luZG93U2l6ZVxuICAgICAgICAgKiBAcGFyYW0gaXNMYXp5IHRydWUgd2lsbCBkZWZlciB0YWJsZSBjb21wdXRhdGlvbiB1bnRpbCB0aGUgZmlyc3QgbXVsdGlwbGljYXRpb25cbiAgICAgICAgICogQHJldHVybnNcbiAgICAgICAgICovXG4gICAgICAgIHByZWNvbXB1dGUod2luZG93U2l6ZSA9IDgsIGlzTGF6eSA9IHRydWUpIHtcbiAgICAgICAgICAgIHduYWYuY3JlYXRlQ2FjaGUodGhpcywgd2luZG93U2l6ZSk7XG4gICAgICAgICAgICBpZiAoIWlzTGF6eSlcbiAgICAgICAgICAgICAgICB0aGlzLm11bHRpcGx5KF8zbik7IC8vIHJhbmRvbSBudW1iZXJcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IHJldHVybiBgdGhpc2BcbiAgICAgICAgLyoqIEEgcG9pbnQgb24gY3VydmUgaXMgdmFsaWQgaWYgaXQgY29uZm9ybXMgdG8gZXF1YXRpb24uICovXG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgYXNzZXJ0VmFsaWRNZW1vKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGhhc0V2ZW5ZKCkge1xuICAgICAgICAgICAgY29uc3QgeyB5IH0gPSB0aGlzLnRvQWZmaW5lKCk7XG4gICAgICAgICAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpZWxkIGRvZXNuJ3Qgc3VwcG9ydCBpc09kZFwiKTtcbiAgICAgICAgICAgIHJldHVybiAhRnAuaXNPZGQoeSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIENvbXBhcmUgb25lIHBvaW50IHRvIGFub3RoZXIuICovXG4gICAgICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICAgICAgYXByanBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgWDogWDEsIFk6IFkxLCBaOiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgWDogWDIsIFk6IFkyLCBaOiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBjb25zdCBVMSA9IEZwLmVxbChGcC5tdWwoWDEsIFoyKSwgRnAubXVsKFgyLCBaMSkpO1xuICAgICAgICAgICAgY29uc3QgVTIgPSBGcC5lcWwoRnAubXVsKFkxLCBaMiksIEZwLm11bChZMiwgWjEpKTtcbiAgICAgICAgICAgIHJldHVybiBVMSAmJiBVMjtcbiAgICAgICAgfVxuICAgICAgICAvKiogRmxpcHMgcG9pbnQgdG8gb25lIGNvcnJlc3BvbmRpbmcgdG8gKHgsIC15KSBpbiBBZmZpbmUgY29vcmRpbmF0ZXMuICovXG4gICAgICAgIG5lZ2F0ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQodGhpcy5YLCBGcC5uZWcodGhpcy5ZKSwgdGhpcy5aKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgZG91YmxpbmcgZm9ybXVsYS5cbiAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAzXG4gICAgICAgIC8vIENvc3Q6IDhNICsgM1MgKyAzKmEgKyAyKmIzICsgMTVhZGQuXG4gICAgICAgIGRvdWJsZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYSwgYiB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBjb25zdCBiMyA9IEZwLm11bChiLCBfM24pO1xuICAgICAgICAgICAgY29uc3QgeyBYOiBYMSwgWTogWTEsIFo6IFoxIH0gPSB0aGlzO1xuICAgICAgICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgbGV0IHQwID0gRnAubXVsKFgxLCBYMSk7IC8vIHN0ZXAgMVxuICAgICAgICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMSk7XG4gICAgICAgICAgICBsZXQgdDIgPSBGcC5tdWwoWjEsIFoxKTtcbiAgICAgICAgICAgIGxldCB0MyA9IEZwLm11bChYMSwgWTEpO1xuICAgICAgICAgICAgdDMgPSBGcC5hZGQodDMsIHQzKTsgLy8gc3RlcCA1XG4gICAgICAgICAgICBaMyA9IEZwLm11bChYMSwgWjEpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKGEsIFozKTtcbiAgICAgICAgICAgIFkzID0gRnAubXVsKGIzLCB0Mik7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChYMywgWTMpOyAvLyBzdGVwIDEwXG4gICAgICAgICAgICBYMyA9IEZwLnN1Yih0MSwgWTMpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQodDEsIFkzKTtcbiAgICAgICAgICAgIFkzID0gRnAubXVsKFgzLCBZMyk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bCh0MywgWDMpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwoYjMsIFozKTsgLy8gc3RlcCAxNVxuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDMgPSBGcC5zdWIodDAsIHQyKTtcbiAgICAgICAgICAgIHQzID0gRnAubXVsKGEsIHQzKTtcbiAgICAgICAgICAgIHQzID0gRnAuYWRkKHQzLCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZCh0MCwgdDApOyAvLyBzdGVwIDIwXG4gICAgICAgICAgICB0MCA9IEZwLmFkZChaMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5hZGQodDAsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQwLCB0Myk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgICAgICAgdDIgPSBGcC5tdWwoWTEsIFoxKTsgLy8gc3RlcCAyNVxuICAgICAgICAgICAgdDIgPSBGcC5hZGQodDIsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQyLCB0Myk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1YihYMywgdDApO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwodDIsIHQxKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7IC8vIHN0ZXAgMzBcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmVzLUNvc3RlbGxvLUJhdGluYSBleGNlcHRpb24tZnJlZSBhZGRpdGlvbiBmb3JtdWxhLlxuICAgICAgICAvLyBUaGVyZSBpcyAzMCUgZmFzdGVyIEphY29iaWFuIGZvcm11bGEsIGJ1dCBpdCBpcyBub3QgY29tcGxldGUuXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTUvMTA2MCwgYWxnb3JpdGhtIDFcbiAgICAgICAgLy8gQ29zdDogMTJNICsgMFMgKyAzKmEgKyAzKmIzICsgMjNhZGQuXG4gICAgICAgIGFkZChvdGhlcikge1xuICAgICAgICAgICAgYXByanBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgWDogWDEsIFk6IFkxLCBaOiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgWDogWDIsIFk6IFkyLCBaOiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBhID0gQ1VSVkUuYTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKENVUlZFLmIsIF8zbik7XG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgyKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkyKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjIpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAuYWRkKFgxLCBZMSk7XG4gICAgICAgICAgICBsZXQgdDQgPSBGcC5hZGQoWDIsIFkyKTsgLy8gc3RlcCA1XG4gICAgICAgICAgICB0MyA9IEZwLm11bCh0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDAsIHQxKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQzLCB0NCk7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZChYMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQ1ID0gRnAuYWRkKFgyLCBaMik7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5zdWIodDQsIHQ1KTtcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKFkxLCBaMSk7XG4gICAgICAgICAgICBYMyA9IEZwLmFkZChZMiwgWjIpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0NSA9IEZwLm11bCh0NSwgWDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQ1ID0gRnAuc3ViKHQ1LCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChhLCB0NCk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChiMywgdDIpOyAvLyBzdGVwIDIwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChYMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQxLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWjMpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyNVxuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKGIzLCB0NCk7XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MSwgdDIpO1xuICAgICAgICAgICAgdDIgPSBGcC5zdWIodDAsIHQyKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDQsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQxLCB0NCk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDUsIHQ0KTsgLy8gc3RlcCAzNVxuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MywgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwodDUsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCB0MCk7IC8vIHN0ZXAgNDBcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaXMwKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKFBvaW50LlpFUk8pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdGFudCB0aW1lIG11bHRpcGxpY2F0aW9uLlxuICAgICAgICAgKiBVc2VzIHdOQUYgbWV0aG9kLiBXaW5kb3dlZCBtZXRob2QgbWF5IGJlIDEwJSBmYXN0ZXIsXG4gICAgICAgICAqIGJ1dCB0YWtlcyAyeCBsb25nZXIgdG8gZ2VuZXJhdGUgYW5kIGNvbnN1bWVzIDJ4IG1lbW9yeS5cbiAgICAgICAgICogVXNlcyBwcmVjb21wdXRlcyB3aGVuIGF2YWlsYWJsZS5cbiAgICAgICAgICogVXNlcyBlbmRvbW9ycGhpc20gZm9yIEtvYmxpdHogY3VydmVzLlxuICAgICAgICAgKiBAcGFyYW0gc2NhbGFyIGJ5IHdoaWNoIHRoZSBwb2ludCB3b3VsZCBiZSBtdWx0aXBsaWVkXG4gICAgICAgICAqIEByZXR1cm5zIE5ldyBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHkoc2NhbGFyKSB7XG4gICAgICAgICAgICBjb25zdCB7IGVuZG8gfSA9IGV4dHJhT3B0cztcbiAgICAgICAgICAgIGlmICghRm4uaXNWYWxpZE5vdDAoc2NhbGFyKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2NhbGFyOiBvdXQgb2YgcmFuZ2UnKTsgLy8gMCBpcyBpbnZhbGlkXG4gICAgICAgICAgICBsZXQgcG9pbnQsIGZha2U7IC8vIEZha2UgcG9pbnQgaXMgdXNlZCB0byBjb25zdC10aW1lIG11bHRcbiAgICAgICAgICAgIGNvbnN0IG11bCA9IChuKSA9PiB3bmFmLmNhY2hlZCh0aGlzLCBuLCAocCkgPT4gbm9ybWFsaXplWihQb2ludCwgcCkpO1xuICAgICAgICAgICAgLyoqIFNlZSBkb2NzIGZvciB7QGxpbmsgRW5kb21vcnBoaXNtT3B0c30gKi9cbiAgICAgICAgICAgIGlmIChlbmRvKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gc3BsaXRFbmRvU2NhbGFyTihzY2FsYXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcDogazFwLCBmOiBrMWYgfSA9IG11bChrMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwOiBrMnAsIGY6IGsyZiB9ID0gbXVsKGsyKTtcbiAgICAgICAgICAgICAgICBmYWtlID0gazFmLmFkZChrMmYpO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gZmluaXNoRW5kbyhlbmRvLmJldGEsIGsxcCwgazJwLCBrMW5lZywgazJuZWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwLCBmIH0gPSBtdWwoc2NhbGFyKTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IHA7XG4gICAgICAgICAgICAgICAgZmFrZSA9IGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgYHpgIGZvciBib3RoIHBvaW50cywgYnV0IHJldHVybiBvbmx5IHJlYWwgb25lXG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplWihQb2ludCwgW3BvaW50LCBmYWtlXSlbMF07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vbi1jb25zdGFudC10aW1lIG11bHRpcGxpY2F0aW9uLiBVc2VzIGRvdWJsZS1hbmQtYWRkIGFsZ29yaXRobS5cbiAgICAgICAgICogSXQncyBmYXN0ZXIsIGJ1dCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4geW91IGRvbid0IGNhcmUgYWJvdXRcbiAgICAgICAgICogYW4gZXhwb3NlZCBzZWNyZXQga2V5IGUuZy4gc2lnIHZlcmlmaWNhdGlvbiwgd2hpY2ggd29ya3Mgb3ZlciAqcHVibGljKiBrZXlzLlxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlVbnNhZmUoc2MpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbyB9ID0gZXh0cmFPcHRzO1xuICAgICAgICAgICAgY29uc3QgcCA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIUZuLmlzVmFsaWQoc2MpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzY2FsYXI6IG91dCBvZiByYW5nZScpOyAvLyAwIGlzIHZhbGlkXG4gICAgICAgICAgICBpZiAoc2MgPT09IF8wbiB8fCBwLmlzMCgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBQb2ludC5aRVJPO1xuICAgICAgICAgICAgaWYgKHNjID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHA7IC8vIGZhc3QtcGF0aFxuICAgICAgICAgICAgaWYgKHduYWYuaGFzQ2FjaGUodGhpcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHkoc2MpO1xuICAgICAgICAgICAgaWYgKGVuZG8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH0gPSBzcGxpdEVuZG9TY2FsYXJOKHNjKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHAxLCBwMiB9ID0gbXVsRW5kb1Vuc2FmZShQb2ludCwgcCwgazEsIGsyKTsgLy8gMzAlIGZhc3RlciB2cyB3bmFmLnVuc2FmZVxuICAgICAgICAgICAgICAgIHJldHVybiBmaW5pc2hFbmRvKGVuZG8uYmV0YSwgcDEsIHAyLCBrMW5lZywgazJuZWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHduYWYudW5zYWZlKHAsIHNjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBtdWx0aXBseUFuZEFkZFVuc2FmZShRLCBhLCBiKSB7XG4gICAgICAgICAgICBjb25zdCBzdW0gPSB0aGlzLm11bHRpcGx5VW5zYWZlKGEpLmFkZChRLm11bHRpcGx5VW5zYWZlKGIpKTtcbiAgICAgICAgICAgIHJldHVybiBzdW0uaXMwKCkgPyB1bmRlZmluZWQgOiBzdW07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIFByb2plY3RpdmUgcG9pbnQgdG8gYWZmaW5lICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAgICAgICogQHBhcmFtIGludmVydGVkWiBaXi0xIChpbnZlcnRlZCB6ZXJvKSAtIG9wdGlvbmFsLCBwcmVjb21wdXRhdGlvbiBpcyB1c2VmdWwgZm9yIGludmVydEJhdGNoXG4gICAgICAgICAqL1xuICAgICAgICB0b0FmZmluZShpbnZlcnRlZFopIHtcbiAgICAgICAgICAgIHJldHVybiB0b0FmZmluZU1lbW8odGhpcywgaW52ZXJ0ZWRaKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2tzIHdoZXRoZXIgUG9pbnQgaXMgZnJlZSBvZiB0b3JzaW9uIGVsZW1lbnRzIChpcyBpbiBwcmltZSBzdWJncm91cCkuXG4gICAgICAgICAqIEFsd2F5cyB0b3JzaW9uLWZyZWUgZm9yIGNvZmFjdG9yPTEgY3VydmVzLlxuICAgICAgICAgKi9cbiAgICAgICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaXNUb3JzaW9uRnJlZSB9ID0gZXh0cmFPcHRzO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoaXNUb3JzaW9uRnJlZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNUb3JzaW9uRnJlZShQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gd25hZi51bnNhZmUodGhpcywgQ1VSVkVfT1JERVIpLmlzMCgpO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyQ29mYWN0b3IoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGNsZWFyQ29mYWN0b3IgfSA9IGV4dHJhT3B0cztcbiAgICAgICAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBGYXN0LXBhdGhcbiAgICAgICAgICAgIGlmIChjbGVhckNvZmFjdG9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBjbGVhckNvZmFjdG9yKFBvaW50LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKGNvZmFjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBpc1NtYWxsT3JkZXIoKSB7XG4gICAgICAgICAgICAvLyBjYW4gd2UgdXNlIHRoaXMuY2xlYXJDb2ZhY3RvcigpP1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlVbnNhZmUoY29mYWN0b3IpLmlzMCgpO1xuICAgICAgICB9XG4gICAgICAgIHRvQnl0ZXMoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgYWJvb2woaXNDb21wcmVzc2VkLCAnaXNDb21wcmVzc2VkJyk7XG4gICAgICAgICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlUG9pbnQoUG9pbnQsIHRoaXMsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9IZXgoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzVG9IZXgodGhpcy50b0J5dGVzKGlzQ29tcHJlc3NlZCkpO1xuICAgICAgICB9XG4gICAgICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIGA8UG9pbnQgJHt0aGlzLmlzMCgpID8gJ1pFUk8nIDogdGhpcy50b0hleCgpfT5gO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IHJlbW92ZVxuICAgICAgICBnZXQgcHgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5YO1xuICAgICAgICB9XG4gICAgICAgIGdldCBweSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLlg7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHB6KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuWjtcbiAgICAgICAgfVxuICAgICAgICB0b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICAgICAgfVxuICAgICAgICBfc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKSB7XG4gICAgICAgICAgICB0aGlzLnByZWNvbXB1dGUod2luZG93U2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIG5vcm1hbGl6ZVoocG9pbnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9ybWFsaXplWihQb2ludCwgcG9pbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgbXNtKHBvaW50cywgc2NhbGFycykge1xuICAgICAgICAgICAgcmV0dXJuIHBpcHBlbmdlcihQb2ludCwgRm4sIHBvaW50cywgc2NhbGFycyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5CQVNFLm11bHRpcGx5KF9ub3JtRm5FbGVtZW50KEZuLCBwcml2YXRlS2V5KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYmFzZSAvIGdlbmVyYXRvciBwb2ludFxuICAgIFBvaW50LkJBU0UgPSBuZXcgUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5LCBGcC5PTkUpO1xuICAgIC8vIHplcm8gLyBpbmZpbml0eSAvIGlkZW50aXR5IHBvaW50XG4gICAgUG9pbnQuWkVSTyA9IG5ldyBQb2ludChGcC5aRVJPLCBGcC5PTkUsIEZwLlpFUk8pOyAvLyAwLCAxLCAwXG4gICAgLy8gbWF0aCBmaWVsZFxuICAgIFBvaW50LkZwID0gRnA7XG4gICAgLy8gc2NhbGFyIGZpZWxkXG4gICAgUG9pbnQuRm4gPSBGbjtcbiAgICBjb25zdCBiaXRzID0gRm4uQklUUztcbiAgICBjb25zdCB3bmFmID0gbmV3IHdOQUYoUG9pbnQsIGV4dHJhT3B0cy5lbmRvID8gTWF0aC5jZWlsKGJpdHMgLyAyKSA6IGJpdHMpO1xuICAgIFBvaW50LkJBU0UucHJlY29tcHV0ZSg4KTsgLy8gRW5hYmxlIHByZWNvbXB1dGVzLiBTbG93cyBkb3duIGZpcnN0IHB1YmxpY0tleSBjb21wdXRhdGlvbiBieSAyMG1zLlxuICAgIHJldHVybiBQb2ludDtcbn1cbi8vIFBvaW50cyBzdGFydCB3aXRoIGJ5dGUgMHgwMiB3aGVuIHkgaXMgZXZlbjsgb3RoZXJ3aXNlIDB4MDNcbmZ1bmN0aW9uIHBwcmVmaXgoaGFzRXZlblkpIHtcbiAgICByZXR1cm4gVWludDhBcnJheS5vZihoYXNFdmVuWSA/IDB4MDIgOiAweDAzKTtcbn1cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFNoYWxsdWUgYW5kIHZhbiBkZSBXb2VzdGlqbmUgbWV0aG9kIGZvciBhbnkgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBUT0RPOiBjaGVjayBpZiB0aGVyZSBpcyBhIHdheSB0byBtZXJnZSB0aGlzIHdpdGggdXZSYXRpbyBpbiBFZHdhcmRzOyBtb3ZlIHRvIG1vZHVsYXIuXG4gKiBiID0gVHJ1ZSBhbmQgeSA9IHNxcnQodSAvIHYpIGlmICh1IC8gdikgaXMgc3F1YXJlIGluIEYsIGFuZFxuICogYiA9IEZhbHNlIGFuZCB5ID0gc3FydChaICogKHUgLyB2KSkgb3RoZXJ3aXNlLlxuICogQHBhcmFtIEZwXG4gKiBAcGFyYW0gWlxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFNXVUZwU3FydFJhdGlvKEZwLCBaKSB7XG4gICAgLy8gR2VuZXJpYyBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHEgPSBGcC5PUkRFUjtcbiAgICBsZXQgbCA9IF8wbjtcbiAgICBmb3IgKGxldCBvID0gcSAtIF8xbjsgbyAlIF8ybiA9PT0gXzBuOyBvIC89IF8ybilcbiAgICAgICAgbCArPSBfMW47XG4gICAgY29uc3QgYzEgPSBsOyAvLyAxLiBjMSwgdGhlIGxhcmdlc3QgaW50ZWdlciBzdWNoIHRoYXQgMl5jMSBkaXZpZGVzIHEgLSAxLlxuICAgIC8vIFdlIG5lZWQgMm4gKiogYzEgYW5kIDJuICoqIChjMS0xKS4gV2UgY2FuJ3QgdXNlICoqOyBidXQgd2UgY2FuIHVzZSA8PC5cbiAgICAvLyAybiAqKiBjMSA9PSAybiA8PCAoYzEtMSlcbiAgICBjb25zdCBfMm5fcG93X2MxXzEgPSBfMm4gPDwgKGMxIC0gXzFuIC0gXzFuKTtcbiAgICBjb25zdCBfMm5fcG93X2MxID0gXzJuX3Bvd19jMV8xICogXzJuO1xuICAgIGNvbnN0IGMyID0gKHEgLSBfMW4pIC8gXzJuX3Bvd19jMTsgLy8gMi4gYzIgPSAocSAtIDEpIC8gKDJeYzEpICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGMzID0gKGMyIC0gXzFuKSAvIF8ybjsgLy8gMy4gYzMgPSAoYzIgLSAxKSAvIDIgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM0ID0gXzJuX3Bvd19jMSAtIF8xbjsgLy8gNC4gYzQgPSAyXmMxIC0gMSAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM1ID0gXzJuX3Bvd19jMV8xOyAvLyA1LiBjNSA9IDJeKGMxIC0gMSkgICAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM2ID0gRnAucG93KFosIGMyKTsgLy8gNi4gYzYgPSBaXmMyXG4gICAgY29uc3QgYzcgPSBGcC5wb3coWiwgKGMyICsgXzFuKSAvIF8ybik7IC8vIDcuIGM3ID0gWl4oKGMyICsgMSkgLyAyKVxuICAgIGxldCBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICBsZXQgdHYxID0gYzY7IC8vIDEuIHR2MSA9IGM2XG4gICAgICAgIGxldCB0djIgPSBGcC5wb3codiwgYzQpOyAvLyAyLiB0djIgPSB2XmM0XG4gICAgICAgIGxldCB0djMgPSBGcC5zcXIodHYyKTsgLy8gMy4gdHYzID0gdHYyXjJcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgdik7IC8vIDQuIHR2MyA9IHR2MyAqIHZcbiAgICAgICAgbGV0IHR2NSA9IEZwLm11bCh1LCB0djMpOyAvLyA1LiB0djUgPSB1ICogdHYzXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djUsIGMzKTsgLy8gNi4gdHY1ID0gdHY1XmMzXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djUsIHR2Mik7IC8vIDcuIHR2NSA9IHR2NSAqIHR2MlxuICAgICAgICB0djIgPSBGcC5tdWwodHY1LCB2KTsgLy8gOC4gdHYyID0gdHY1ICogdlxuICAgICAgICB0djMgPSBGcC5tdWwodHY1LCB1KTsgLy8gOS4gdHYzID0gdHY1ICogdVxuICAgICAgICBsZXQgdHY0ID0gRnAubXVsKHR2MywgdHYyKTsgLy8gMTAuIHR2NCA9IHR2MyAqIHR2MlxuICAgICAgICB0djUgPSBGcC5wb3codHY0LCBjNSk7IC8vIDExLiB0djUgPSB0djReYzVcbiAgICAgICAgbGV0IGlzUVIgPSBGcC5lcWwodHY1LCBGcC5PTkUpOyAvLyAxMi4gaXNRUiA9IHR2NSA9PSAxXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djMsIGM3KTsgLy8gMTMuIHR2MiA9IHR2MyAqIGM3XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDE0LiB0djUgPSB0djQgKiB0djFcbiAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgaXNRUik7IC8vIDE1LiB0djMgPSBDTU9WKHR2MiwgdHYzLCBpc1FSKVxuICAgICAgICB0djQgPSBGcC5jbW92KHR2NSwgdHY0LCBpc1FSKTsgLy8gMTYuIHR2NCA9IENNT1YodHY1LCB0djQsIGlzUVIpXG4gICAgICAgIC8vIDE3LiBmb3IgaSBpbiAoYzEsIGMxIC0gMSwgLi4uLCAyKTpcbiAgICAgICAgZm9yIChsZXQgaSA9IGMxOyBpID4gXzFuOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB0djUgPSBpIC0gXzJuOyAvLyAxOC4gICAgdHY1ID0gaSAtIDJcbiAgICAgICAgICAgIHR2NSA9IF8ybiA8PCAodHY1IC0gXzFuKTsgLy8gMTkuICAgIHR2NSA9IDJedHY1XG4gICAgICAgICAgICBsZXQgdHZ2NSA9IEZwLnBvdyh0djQsIHR2NSk7IC8vIDIwLiAgICB0djUgPSB0djRedHY1XG4gICAgICAgICAgICBjb25zdCBlMSA9IEZwLmVxbCh0dnY1LCBGcC5PTkUpOyAvLyAyMS4gICAgZTEgPSB0djUgPT0gMVxuICAgICAgICAgICAgdHYyID0gRnAubXVsKHR2MywgdHYxKTsgLy8gMjIuICAgIHR2MiA9IHR2MyAqIHR2MVxuICAgICAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYxKTsgLy8gMjMuICAgIHR2MSA9IHR2MSAqIHR2MVxuICAgICAgICAgICAgdHZ2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDI0LiAgICB0djUgPSB0djQgKiB0djFcbiAgICAgICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGUxKTsgLy8gMjUuICAgIHR2MyA9IENNT1YodHYyLCB0djMsIGUxKVxuICAgICAgICAgICAgdHY0ID0gRnAuY21vdih0dnY1LCB0djQsIGUxKTsgLy8gMjYuICAgIHR2NCA9IENNT1YodHY1LCB0djQsIGUxKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGlzUVIsIHZhbHVlOiB0djMgfTtcbiAgICB9O1xuICAgIGlmIChGcC5PUkRFUiAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIHNxcnRfcmF0aW9fM21vZDQodSwgdilcbiAgICAgICAgY29uc3QgYzEgPSAoRnAuT1JERVIgLSBfM24pIC8gXzRuOyAvLyAxLiBjMSA9IChxIC0gMykgLyA0ICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICBjb25zdCBjMiA9IEZwLnNxcnQoRnAubmVnKFopKTsgLy8gMi4gYzIgPSBzcXJ0KC1aKVxuICAgICAgICBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICAgICAgbGV0IHR2MSA9IEZwLnNxcih2KTsgLy8gMS4gdHYxID0gdl4yXG4gICAgICAgICAgICBjb25zdCB0djIgPSBGcC5tdWwodSwgdik7IC8vIDIuIHR2MiA9IHUgKiB2XG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djIpOyAvLyAzLiB0djEgPSB0djEgKiB0djJcbiAgICAgICAgICAgIGxldCB5MSA9IEZwLnBvdyh0djEsIGMxKTsgLy8gNC4geTEgPSB0djFeYzFcbiAgICAgICAgICAgIHkxID0gRnAubXVsKHkxLCB0djIpOyAvLyA1LiB5MSA9IHkxICogdHYyXG4gICAgICAgICAgICBjb25zdCB5MiA9IEZwLm11bCh5MSwgYzIpOyAvLyA2LiB5MiA9IHkxICogYzJcbiAgICAgICAgICAgIGNvbnN0IHR2MyA9IEZwLm11bChGcC5zcXIoeTEpLCB2KTsgLy8gNy4gdHYzID0geTFeMjsgOC4gdHYzID0gdHYzICogdlxuICAgICAgICAgICAgY29uc3QgaXNRUiA9IEZwLmVxbCh0djMsIHUpOyAvLyA5LiBpc1FSID0gdHYzID09IHVcbiAgICAgICAgICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGlzUVIpOyAvLyAxMC4geSA9IENNT1YoeTIsIHkxLCBpc1FSKVxuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHkgfTsgLy8gMTEuIHJldHVybiAoaXNRUiwgeSkgaXNRUiA/IHkgOiB5KmMyXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIE5vIGN1cnZlcyB1c2VzIHRoYXRcbiAgICAvLyBpZiAoRnAuT1JERVIgJSBfOG4gPT09IF81bikgLy8gc3FydF9yYXRpb181bW9kOFxuICAgIHJldHVybiBzcXJ0UmF0aW87XG59XG4vKipcbiAqIFNpbXBsaWZpZWQgU2hhbGx1ZS12YW4gZGUgV29lc3Rpam5lLVVsYXMgTWV0aG9kXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTYuNi4yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCBvcHRzKSB7XG4gICAgdmFsaWRhdGVGaWVsZChGcCk7XG4gICAgY29uc3QgeyBBLCBCLCBaIH0gPSBvcHRzO1xuICAgIGlmICghRnAuaXNWYWxpZChBKSB8fCAhRnAuaXNWYWxpZChCKSB8fCAhRnAuaXNWYWxpZChaKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlU2ltcGxlU1dVOiBpbnZhbGlkIG9wdHMnKTtcbiAgICBjb25zdCBzcXJ0UmF0aW8gPSBTV1VGcFNxcnRSYXRpbyhGcCwgWik7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWVsZCBkb2VzIG5vdCBoYXZlIC5pc09kZCgpJyk7XG4gICAgLy8gSW5wdXQ6IHUsIGFuIGVsZW1lbnQgb2YgRi5cbiAgICAvLyBPdXRwdXQ6ICh4LCB5KSwgYSBwb2ludCBvbiBFLlxuICAgIHJldHVybiAodSkgPT4ge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgbGV0IHR2MSwgdHYyLCB0djMsIHR2NCwgdHY1LCB0djYsIHgsIHk7XG4gICAgICAgIHR2MSA9IEZwLnNxcih1KTsgLy8gMS4gIHR2MSA9IHVeMlxuICAgICAgICB0djEgPSBGcC5tdWwodHYxLCBaKTsgLy8gMi4gIHR2MSA9IFogKiB0djFcbiAgICAgICAgdHYyID0gRnAuc3FyKHR2MSk7IC8vIDMuICB0djIgPSB0djFeMlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djEpOyAvLyA0LiAgdHYyID0gdHYyICsgdHYxXG4gICAgICAgIHR2MyA9IEZwLmFkZCh0djIsIEZwLk9ORSk7IC8vIDUuICB0djMgPSB0djIgKyAxXG4gICAgICAgIHR2MyA9IEZwLm11bCh0djMsIEIpOyAvLyA2LiAgdHYzID0gQiAqIHR2M1xuICAgICAgICB0djQgPSBGcC5jbW92KFosIEZwLm5lZyh0djIpLCAhRnAuZXFsKHR2MiwgRnAuWkVSTykpOyAvLyA3LiAgdHY0ID0gQ01PVihaLCAtdHYyLCB0djIgIT0gMClcbiAgICAgICAgdHY0ID0gRnAubXVsKHR2NCwgQSk7IC8vIDguICB0djQgPSBBICogdHY0XG4gICAgICAgIHR2MiA9IEZwLnNxcih0djMpOyAvLyA5LiAgdHYyID0gdHYzXjJcbiAgICAgICAgdHY2ID0gRnAuc3FyKHR2NCk7IC8vIDEwLiB0djYgPSB0djReMlxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBBKTsgLy8gMTEuIHR2NSA9IEEgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTIuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB0djIgPSBGcC5tdWwodHYyLCB0djMpOyAvLyAxMy4gdHYyID0gdHYyICogdHYzXG4gICAgICAgIHR2NiA9IEZwLm11bCh0djYsIHR2NCk7IC8vIDE0LiB0djYgPSB0djYgKiB0djRcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NiwgQik7IC8vIDE1LiB0djUgPSBCICogdHY2XG4gICAgICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2NSk7IC8vIDE2LiB0djIgPSB0djIgKyB0djVcbiAgICAgICAgeCA9IEZwLm11bCh0djEsIHR2Myk7IC8vIDE3LiAgIHggPSB0djEgKiB0djNcbiAgICAgICAgY29uc3QgeyBpc1ZhbGlkLCB2YWx1ZSB9ID0gc3FydFJhdGlvKHR2MiwgdHY2KTsgLy8gMTguIChpc19neDFfc3F1YXJlLCB5MSkgPSBzcXJ0X3JhdGlvKHR2MiwgdHY2KVxuICAgICAgICB5ID0gRnAubXVsKHR2MSwgdSk7IC8vIDE5LiAgIHkgPSB0djEgKiB1ICAtPiBaICogdV4zICogeTFcbiAgICAgICAgeSA9IEZwLm11bCh5LCB2YWx1ZSk7IC8vIDIwLiAgIHkgPSB5ICogeTFcbiAgICAgICAgeCA9IEZwLmNtb3YoeCwgdHYzLCBpc1ZhbGlkKTsgLy8gMjEuICAgeCA9IENNT1YoeCwgdHYzLCBpc19neDFfc3F1YXJlKVxuICAgICAgICB5ID0gRnAuY21vdih5LCB2YWx1ZSwgaXNWYWxpZCk7IC8vIDIyLiAgIHkgPSBDTU9WKHksIHkxLCBpc19neDFfc3F1YXJlKVxuICAgICAgICBjb25zdCBlMSA9IEZwLmlzT2RkKHUpID09PSBGcC5pc09kZCh5KTsgLy8gMjMuICBlMSA9IHNnbjAodSkgPT0gc2duMCh5KVxuICAgICAgICB5ID0gRnAuY21vdihGcC5uZWcoeSksIHksIGUxKTsgLy8gMjQuICAgeSA9IENNT1YoLXksIHksIGUxKVxuICAgICAgICBjb25zdCB0djRfaW52ID0gRnBJbnZlcnRCYXRjaChGcCwgW3R2NF0sIHRydWUpWzBdO1xuICAgICAgICB4ID0gRnAubXVsKHgsIHR2NF9pbnYpOyAvLyAyNS4gICB4ID0geCAvIHR2NFxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFdMZW5ndGhzKEZwLCBGbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNlY3JldEtleTogRm4uQllURVMsXG4gICAgICAgIHB1YmxpY0tleTogMSArIEZwLkJZVEVTLFxuICAgICAgICBwdWJsaWNLZXlVbmNvbXByZXNzZWQ6IDEgKyAyICogRnAuQllURVMsXG4gICAgICAgIHB1YmxpY0tleUhhc1ByZWZpeDogdHJ1ZSxcbiAgICAgICAgc2lnbmF0dXJlOiAyICogRm4uQllURVMsXG4gICAgfTtcbn1cbi8qKlxuICogU29tZXRpbWVzIHVzZXJzIG9ubHkgbmVlZCBnZXRQdWJsaWNLZXksIGdldFNoYXJlZFNlY3JldCwgYW5kIHNlY3JldCBrZXkgaGFuZGxpbmcuXG4gKiBUaGlzIGhlbHBlciBlbnN1cmVzIG5vIHNpZ25hdHVyZSBmdW5jdGlvbmFsaXR5IGlzIHByZXNlbnQuIExlc3MgY29kZSwgc21hbGxlciBidW5kbGUgc2l6ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVjZGgoUG9pbnQsIGVjZGhPcHRzID0ge30pIHtcbiAgICBjb25zdCB7IEZuIH0gPSBQb2ludDtcbiAgICBjb25zdCByYW5kb21CeXRlc18gPSBlY2RoT3B0cy5yYW5kb21CeXRlcyB8fCByYW5kb21CeXRlc1dlYjtcbiAgICBjb25zdCBsZW5ndGhzID0gT2JqZWN0LmFzc2lnbihnZXRXTGVuZ3RocyhQb2ludC5GcCwgRm4pLCB7IHNlZWQ6IGdldE1pbkhhc2hMZW5ndGgoRm4uT1JERVIpIH0pO1xuICAgIGZ1bmN0aW9uIGlzVmFsaWRTZWNyZXRLZXkoc2VjcmV0S2V5KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gISFfbm9ybUZuRWxlbWVudChGbiwgc2VjcmV0S2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpc1ZhbGlkUHVibGljS2V5KHB1YmxpY0tleSwgaXNDb21wcmVzc2VkKSB7XG4gICAgICAgIGNvbnN0IHsgcHVibGljS2V5OiBjb21wLCBwdWJsaWNLZXlVbmNvbXByZXNzZWQgfSA9IGxlbmd0aHM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBsID0gcHVibGljS2V5Lmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChpc0NvbXByZXNzZWQgPT09IHRydWUgJiYgbCAhPT0gY29tcClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBpZiAoaXNDb21wcmVzc2VkID09PSBmYWxzZSAmJiBsICE9PSBwdWJsaWNLZXlVbmNvbXByZXNzZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuICEhUG9pbnQuZnJvbUJ5dGVzKHB1YmxpY0tleSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvZHVjZXMgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHNlY3JldCBrZXkgZnJvbSByYW5kb20gb2Ygc2l6ZVxuICAgICAqIChncm91cExlbiArIGNlaWwoZ3JvdXBMZW4gLyAyKSkgd2l0aCBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJhbmRvbVNlY3JldEtleShzZWVkID0gcmFuZG9tQnl0ZXNfKGxlbmd0aHMuc2VlZCkpIHtcbiAgICAgICAgcmV0dXJuIG1hcEhhc2hUb0ZpZWxkKGFieXRlcyhzZWVkLCBsZW5ndGhzLnNlZWQsICdzZWVkJyksIEZuLk9SREVSKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgcHVibGljIGtleSBmb3IgYSBzZWNyZXQga2V5LiBDaGVja3MgZm9yIHZhbGlkaXR5IG9mIHRoZSBzZWNyZXQga2V5LlxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgUHVibGljIGtleSwgZnVsbCB3aGVuIGlzQ29tcHJlc3NlZD1mYWxzZTsgc2hvcnQgd2hlbiBpc0NvbXByZXNzZWQ9dHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFB1YmxpY0tleShzZWNyZXRLZXksIGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIFBvaW50LkJBU0UubXVsdGlwbHkoX25vcm1GbkVsZW1lbnQoRm4sIHNlY3JldEtleSkpLnRvQnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgZnVuY3Rpb24ga2V5Z2VuKHNlZWQpIHtcbiAgICAgICAgY29uc3Qgc2VjcmV0S2V5ID0gcmFuZG9tU2VjcmV0S2V5KHNlZWQpO1xuICAgICAgICByZXR1cm4geyBzZWNyZXRLZXksIHB1YmxpY0tleTogZ2V0UHVibGljS2V5KHNlY3JldEtleSkgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVpY2sgYW5kIGRpcnR5IGNoZWNrIGZvciBpdGVtIGJlaW5nIHB1YmxpYyBrZXkuIERvZXMgbm90IHZhbGlkYXRlIGhleCwgb3IgYmVpbmcgb24tY3VydmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQcm9iUHViKGl0ZW0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSAnYmlnaW50JylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjb25zdCB7IHNlY3JldEtleSwgcHVibGljS2V5LCBwdWJsaWNLZXlVbmNvbXByZXNzZWQgfSA9IGxlbmd0aHM7XG4gICAgICAgIGlmIChGbi5hbGxvd2VkTGVuZ3RocyB8fCBzZWNyZXRLZXkgPT09IHB1YmxpY0tleSlcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGwgPSBlbnN1cmVCeXRlcygna2V5JywgaXRlbSkubGVuZ3RoO1xuICAgICAgICByZXR1cm4gbCA9PT0gcHVibGljS2V5IHx8IGwgPT09IHB1YmxpY0tleVVuY29tcHJlc3NlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRUNESCAoRWxsaXB0aWMgQ3VydmUgRGlmZmllIEhlbGxtYW4pLlxuICAgICAqIENvbXB1dGVzIHNoYXJlZCBwdWJsaWMga2V5IGZyb20gc2VjcmV0IGtleSBBIGFuZCBwdWJsaWMga2V5IEIuXG4gICAgICogQ2hlY2tzOiAxKSBzZWNyZXQga2V5IHZhbGlkaXR5IDIpIHNoYXJlZCBrZXkgaXMgb24tY3VydmUuXG4gICAgICogRG9lcyBOT1QgaGFzaCB0aGUgcmVzdWx0LlxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgc2hhcmVkIHB1YmxpYyBrZXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTaGFyZWRTZWNyZXQoc2VjcmV0S2V5QSwgcHVibGljS2V5QiwgaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICBpZiAoaXNQcm9iUHViKHNlY3JldEtleUEpID09PSB0cnVlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmcgbXVzdCBiZSBwcml2YXRlIGtleScpO1xuICAgICAgICBpZiAoaXNQcm9iUHViKHB1YmxpY0tleUIpID09PSBmYWxzZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2Vjb25kIGFyZyBtdXN0IGJlIHB1YmxpYyBrZXknKTtcbiAgICAgICAgY29uc3QgcyA9IF9ub3JtRm5FbGVtZW50KEZuLCBzZWNyZXRLZXlBKTtcbiAgICAgICAgY29uc3QgYiA9IFBvaW50LmZyb21IZXgocHVibGljS2V5Qik7IC8vIGNoZWNrcyBmb3IgYmVpbmcgb24tY3VydmVcbiAgICAgICAgcmV0dXJuIGIubXVsdGlwbHkocykudG9CeXRlcyhpc0NvbXByZXNzZWQpO1xuICAgIH1cbiAgICBjb25zdCB1dGlscyA9IHtcbiAgICAgICAgaXNWYWxpZFNlY3JldEtleSxcbiAgICAgICAgaXNWYWxpZFB1YmxpY0tleSxcbiAgICAgICAgcmFuZG9tU2VjcmV0S2V5LFxuICAgICAgICAvLyBUT0RPOiByZW1vdmVcbiAgICAgICAgaXNWYWxpZFByaXZhdGVLZXk6IGlzVmFsaWRTZWNyZXRLZXksXG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6IHJhbmRvbVNlY3JldEtleSxcbiAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcjogKGtleSkgPT4gX25vcm1GbkVsZW1lbnQoRm4sIGtleSksXG4gICAgICAgIHByZWNvbXB1dGUod2luZG93U2l6ZSA9IDgsIHBvaW50ID0gUG9pbnQuQkFTRSkge1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50LnByZWNvbXB1dGUod2luZG93U2l6ZSwgZmFsc2UpO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyBnZXRQdWJsaWNLZXksIGdldFNoYXJlZFNlY3JldCwga2V5Z2VuLCBQb2ludCwgdXRpbHMsIGxlbmd0aHMgfSk7XG59XG4vKipcbiAqIENyZWF0ZXMgRUNEU0Egc2lnbmluZyBpbnRlcmZhY2UgZm9yIGdpdmVuIGVsbGlwdGljIGN1cnZlIGBQb2ludGAgYW5kIGBoYXNoYCBmdW5jdGlvbi5cbiAqIFdlIG5lZWQgYGhhc2hgIGZvciAyIGZlYXR1cmVzOlxuICogMS4gTWVzc2FnZSBwcmVoYXNoLWluZy4gTk9UIHVzZWQgaWYgYHNpZ25gIC8gYHZlcmlmeWAgYXJlIGNhbGxlZCB3aXRoIGBwcmVoYXNoOiBmYWxzZWBcbiAqIDIuIGsgZ2VuZXJhdGlvbiBpbiBgc2lnbmAsIHVzaW5nIEhNQUMtZHJiZyhoYXNoKVxuICpcbiAqIEVDRFNBT3B0cyBhcmUgb25seSByYXJlbHkgbmVlZGVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogY29uc3QgcDI1Nl9Qb2ludCA9IHdlaWVyc3RyYXNzKC4uLik7XG4gKiBjb25zdCBwMjU2X3NoYTI1NiA9IGVjZHNhKHAyNTZfUG9pbnQsIHNoYTI1Nik7XG4gKiBjb25zdCBwMjU2X3NoYTIyNCA9IGVjZHNhKHAyNTZfUG9pbnQsIHNoYTIyNCk7XG4gKiBjb25zdCBwMjU2X3NoYTIyNF9yID0gZWNkc2EocDI1Nl9Qb2ludCwgc2hhMjI0LCB7IHJhbmRvbUJ5dGVzOiAobGVuZ3RoKSA9PiB7IC4uLiB9IH0pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlY2RzYShQb2ludCwgaGFzaCwgZWNkc2FPcHRzID0ge30pIHtcbiAgICBhaGFzaChoYXNoKTtcbiAgICBfdmFsaWRhdGVPYmplY3QoZWNkc2FPcHRzLCB7fSwge1xuICAgICAgICBobWFjOiAnZnVuY3Rpb24nLFxuICAgICAgICBsb3dTOiAnYm9vbGVhbicsXG4gICAgICAgIHJhbmRvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgICAgICBiaXRzMmludDogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYml0czJpbnRfbW9kTjogJ2Z1bmN0aW9uJyxcbiAgICB9KTtcbiAgICBjb25zdCByYW5kb21CeXRlcyA9IGVjZHNhT3B0cy5yYW5kb21CeXRlcyB8fCByYW5kb21CeXRlc1dlYjtcbiAgICBjb25zdCBobWFjID0gZWNkc2FPcHRzLmhtYWMgfHxcbiAgICAgICAgKChrZXksIC4uLm1zZ3MpID0+IG5vYmxlSG1hYyhoYXNoLCBrZXksIGNvbmNhdEJ5dGVzKC4uLm1zZ3MpKSk7XG4gICAgY29uc3QgeyBGcCwgRm4gfSA9IFBvaW50O1xuICAgIGNvbnN0IHsgT1JERVI6IENVUlZFX09SREVSLCBCSVRTOiBmbkJpdHMgfSA9IEZuO1xuICAgIGNvbnN0IHsga2V5Z2VuLCBnZXRQdWJsaWNLZXksIGdldFNoYXJlZFNlY3JldCwgdXRpbHMsIGxlbmd0aHMgfSA9IGVjZGgoUG9pbnQsIGVjZHNhT3B0cyk7XG4gICAgY29uc3QgZGVmYXVsdFNpZ09wdHMgPSB7XG4gICAgICAgIHByZWhhc2g6IGZhbHNlLFxuICAgICAgICBsb3dTOiB0eXBlb2YgZWNkc2FPcHRzLmxvd1MgPT09ICdib29sZWFuJyA/IGVjZHNhT3B0cy5sb3dTIDogZmFsc2UsXG4gICAgICAgIGZvcm1hdDogdW5kZWZpbmVkLCAvLydjb21wYWN0JyBhcyBFQ0RTQVNpZ0Zvcm1hdCxcbiAgICAgICAgZXh0cmFFbnRyb3B5OiBmYWxzZSxcbiAgICB9O1xuICAgIGNvbnN0IGRlZmF1bHRTaWdPcHRzX2Zvcm1hdCA9ICdjb21wYWN0JztcbiAgICBmdW5jdGlvbiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIobnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IEhBTEYgPSBDVVJWRV9PUkRFUiA+PiBfMW47XG4gICAgICAgIHJldHVybiBudW1iZXIgPiBIQUxGO1xuICAgIH1cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVJTKHRpdGxlLCBudW0pIHtcbiAgICAgICAgaWYgKCFGbi5pc1ZhbGlkTm90MChudW0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHNpZ25hdHVyZSAke3RpdGxlfTogb3V0IG9mIHJhbmdlIDEuLlBvaW50LkZuLk9SREVSYCk7XG4gICAgICAgIHJldHVybiBudW07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlU2lnTGVuZ3RoKGJ5dGVzLCBmb3JtYXQpIHtcbiAgICAgICAgdmFsaWRhdGVTaWdGb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGxlbmd0aHMuc2lnbmF0dXJlO1xuICAgICAgICBjb25zdCBzaXplciA9IGZvcm1hdCA9PT0gJ2NvbXBhY3QnID8gc2l6ZSA6IGZvcm1hdCA9PT0gJ3JlY292ZXJlZCcgPyBzaXplICsgMSA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGFieXRlcyhieXRlcywgc2l6ZXIsIGAke2Zvcm1hdH0gc2lnbmF0dXJlYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVDRFNBIHNpZ25hdHVyZSB3aXRoIGl0cyAociwgcykgcHJvcGVydGllcy4gU3VwcG9ydHMgY29tcGFjdCwgcmVjb3ZlcmVkICYgREVSIHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKi9cbiAgICBjbGFzcyBTaWduYXR1cmUge1xuICAgICAgICBjb25zdHJ1Y3RvcihyLCBzLCByZWNvdmVyeSkge1xuICAgICAgICAgICAgdGhpcy5yID0gdmFsaWRhdGVSUygncicsIHIpOyAvLyByIGluIFsxLi5OLTFdO1xuICAgICAgICAgICAgdGhpcy5zID0gdmFsaWRhdGVSUygncycsIHMpOyAvLyBzIGluIFsxLi5OLTFdO1xuICAgICAgICAgICAgaWYgKHJlY292ZXJ5ICE9IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvdmVyeSA9IHJlY292ZXJ5O1xuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZnJvbUJ5dGVzKGJ5dGVzLCBmb3JtYXQgPSBkZWZhdWx0U2lnT3B0c19mb3JtYXQpIHtcbiAgICAgICAgICAgIHZhbGlkYXRlU2lnTGVuZ3RoKGJ5dGVzLCBmb3JtYXQpO1xuICAgICAgICAgICAgbGV0IHJlY2lkO1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RlcicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IERFUi50b1NpZyhhYnl0ZXMoYnl0ZXMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShyLCBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdyZWNvdmVyZWQnKSB7XG4gICAgICAgICAgICAgICAgcmVjaWQgPSBieXRlc1swXTtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSAnY29tcGFjdCc7XG4gICAgICAgICAgICAgICAgYnl0ZXMgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IEwgPSBGbi5CWVRFUztcbiAgICAgICAgICAgIGNvbnN0IHIgPSBieXRlcy5zdWJhcnJheSgwLCBMKTtcbiAgICAgICAgICAgIGNvbnN0IHMgPSBieXRlcy5zdWJhcnJheShMLCBMICogMik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShGbi5mcm9tQnl0ZXMociksIEZuLmZyb21CeXRlcyhzKSwgcmVjaWQpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBmcm9tSGV4KGhleCwgZm9ybWF0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mcm9tQnl0ZXMoaGV4VG9CeXRlcyhoZXgpLCBmb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIGFkZFJlY292ZXJ5Qml0KHJlY292ZXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIHRoaXMucywgcmVjb3ZlcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJlY292ZXJQdWJsaWNLZXkobWVzc2FnZUhhc2gpIHtcbiAgICAgICAgICAgIGNvbnN0IEZJRUxEX09SREVSID0gRnAuT1JERVI7XG4gICAgICAgICAgICBjb25zdCB7IHIsIHMsIHJlY292ZXJ5OiByZWMgfSA9IHRoaXM7XG4gICAgICAgICAgICBpZiAocmVjID09IG51bGwgfHwgIVswLCAxLCAyLCAzXS5pbmNsdWRlcyhyZWMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgaW52YWxpZCcpO1xuICAgICAgICAgICAgLy8gRUNEU0EgcmVjb3ZlcnkgaXMgaGFyZCBmb3IgY29mYWN0b3IgPiAxIGN1cnZlcy5cbiAgICAgICAgICAgIC8vIEluIHNpZ24sIGByID0gcS54IG1vZCBuYCwgYW5kIGhlcmUgd2UgcmVjb3ZlciBxLnggZnJvbSByLlxuICAgICAgICAgICAgLy8gV2hpbGUgcmVjb3ZlcmluZyBxLnggPj0gbiwgd2UgbmVlZCB0byBhZGQgcituIGZvciBjb2ZhY3Rvcj0xIGN1cnZlcy5cbiAgICAgICAgICAgIC8vIEhvd2V2ZXIsIGZvciBjb2ZhY3Rvcj4xLCByK24gbWF5IG5vdCBnZXQgcS54OlxuICAgICAgICAgICAgLy8gcituKmkgd291bGQgbmVlZCB0byBiZSBkb25lIGluc3RlYWQgd2hlcmUgaSBpcyB1bmtub3duLlxuICAgICAgICAgICAgLy8gVG8gZWFzaWx5IGdldCBpLCB3ZSBlaXRoZXIgbmVlZCB0bzpcbiAgICAgICAgICAgIC8vIGEuIGluY3JlYXNlIGFtb3VudCBvZiB2YWxpZCByZWNpZCB2YWx1ZXMgKDQsIDUuLi4pOyBPUlxuICAgICAgICAgICAgLy8gYi4gcHJvaGliaXQgbm9uLXByaW1lLW9yZGVyIHNpZ25hdHVyZXMgKHJlY2lkID4gMSkuXG4gICAgICAgICAgICBjb25zdCBoYXNDb2ZhY3RvciA9IENVUlZFX09SREVSICogXzJuIDwgRklFTERfT1JERVI7XG4gICAgICAgICAgICBpZiAoaGFzQ29mYWN0b3IgJiYgcmVjID4gMSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIGlzIGFtYmlndW91cyBmb3IgaD4xIGN1cnZlJyk7XG4gICAgICAgICAgICBjb25zdCByYWRqID0gcmVjID09PSAyIHx8IHJlYyA9PT0gMyA/IHIgKyBDVVJWRV9PUkRFUiA6IHI7XG4gICAgICAgICAgICBpZiAoIUZwLmlzVmFsaWQocmFkaikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBpZCAyIG9yIDMgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgeCA9IEZwLnRvQnl0ZXMocmFkaik7XG4gICAgICAgICAgICBjb25zdCBSID0gUG9pbnQuZnJvbUJ5dGVzKGNvbmNhdEJ5dGVzKHBwcmVmaXgoKHJlYyAmIDEpID09PSAwKSwgeCkpO1xuICAgICAgICAgICAgY29uc3QgaXIgPSBGbi5pbnYocmFkaik7IC8vIHJeLTFcbiAgICAgICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbWVzc2FnZUhhc2gpKTsgLy8gVHJ1bmNhdGUgaGFzaFxuICAgICAgICAgICAgY29uc3QgdTEgPSBGbi5jcmVhdGUoLWggKiBpcik7IC8vIC1ocl4tMVxuICAgICAgICAgICAgY29uc3QgdTIgPSBGbi5jcmVhdGUocyAqIGlyKTsgLy8gc3JeLTFcbiAgICAgICAgICAgIC8vIChzcl4tMSlSLShocl4tMSlHID0gLShocl4tMSlHICsgKHNyXi0xKS4gdW5zYWZlIGlzIGZpbmU6IHRoZXJlIGlzIG5vIHByaXZhdGUgZGF0YS5cbiAgICAgICAgICAgIGNvbnN0IFEgPSBQb2ludC5CQVNFLm11bHRpcGx5VW5zYWZlKHUxKS5hZGQoUi5tdWx0aXBseVVuc2FmZSh1MikpO1xuICAgICAgICAgICAgaWYgKFEuaXMwKCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2ludCBhdCBpbmZpbmlmeScpO1xuICAgICAgICAgICAgUS5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2lnbmF0dXJlcyBzaG91bGQgYmUgbG93LXMsIHRvIHByZXZlbnQgbWFsbGVhYmlsaXR5LlxuICAgICAgICBoYXNIaWdoUygpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgICAgICB0b0J5dGVzKGZvcm1hdCA9IGRlZmF1bHRTaWdPcHRzX2Zvcm1hdCkge1xuICAgICAgICAgICAgdmFsaWRhdGVTaWdGb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdkZXInKVxuICAgICAgICAgICAgICAgIHJldHVybiBoZXhUb0J5dGVzKERFUi5oZXhGcm9tU2lnKHRoaXMpKTtcbiAgICAgICAgICAgIGNvbnN0IHIgPSBGbi50b0J5dGVzKHRoaXMucik7XG4gICAgICAgICAgICBjb25zdCBzID0gRm4udG9CeXRlcyh0aGlzLnMpO1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ3JlY292ZXJlZCcpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWNvdmVyeSA9PSBudWxsKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGJpdCBtdXN0IGJlIHByZXNlbnQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMoVWludDhBcnJheS5vZih0aGlzLnJlY292ZXJ5KSwgciwgcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29uY2F0Qnl0ZXMociwgcyk7XG4gICAgICAgIH1cbiAgICAgICAgdG9IZXgoZm9ybWF0KSB7XG4gICAgICAgICAgICByZXR1cm4gYnl0ZXNUb0hleCh0aGlzLnRvQnl0ZXMoZm9ybWF0KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlXG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkgeyB9XG4gICAgICAgIHN0YXRpYyBmcm9tQ29tcGFjdChoZXgpIHtcbiAgICAgICAgICAgIHJldHVybiBTaWduYXR1cmUuZnJvbUJ5dGVzKGVuc3VyZUJ5dGVzKCdzaWcnLCBoZXgpLCAnY29tcGFjdCcpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBmcm9tREVSKGhleCkge1xuICAgICAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5mcm9tQnl0ZXMoZW5zdXJlQnl0ZXMoJ3NpZycsIGhleCksICdkZXInKTtcbiAgICAgICAgfVxuICAgICAgICBub3JtYWxpemVTKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzSGlnaFMoKSA/IG5ldyBTaWduYXR1cmUodGhpcy5yLCBGbi5uZWcodGhpcy5zKSwgdGhpcy5yZWNvdmVyeSkgOiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHRvREVSUmF3Qnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0J5dGVzKCdkZXInKTtcbiAgICAgICAgfVxuICAgICAgICB0b0RFUkhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBieXRlc1RvSGV4KHRoaXMudG9CeXRlcygnZGVyJykpO1xuICAgICAgICB9XG4gICAgICAgIHRvQ29tcGFjdFJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9CeXRlcygnY29tcGFjdCcpO1xuICAgICAgICB9XG4gICAgICAgIHRvQ29tcGFjdEhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBieXRlc1RvSGV4KHRoaXMudG9CeXRlcygnY29tcGFjdCcpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSRkM2OTc5OiBlbnN1cmUgRUNEU0EgbXNnIGlzIFggYnl0ZXMgYW5kIDwgTi4gUkZDIHN1Z2dlc3RzIG9wdGlvbmFsIHRydW5jYXRpbmcgdmlhIGJpdHMyb2N0ZXRzLlxuICAgIC8vIEZJUFMgMTg2LTQgNC42IHN1Z2dlc3RzIHRoZSBsZWZ0bW9zdCBtaW4obkJpdExlbiwgb3V0TGVuKSBiaXRzLCB3aGljaCBtYXRjaGVzIGJpdHMyaW50LlxuICAgIC8vIGJpdHMyaW50IGNhbiBwcm9kdWNlIHJlcz5OLCB3ZSBjYW4gZG8gbW9kKHJlcywgTikgc2luY2UgdGhlIGJpdExlbiBpcyB0aGUgc2FtZS5cbiAgICAvLyBpbnQyb2N0ZXRzIGNhbid0IGJlIHVzZWQ7IHBhZHMgc21hbGwgbXNncyB3aXRoIDA6IHVuYWNjZXB0YXRibGUgZm9yIHRydW5jIGFzIHBlciBSRkMgdmVjdG9yc1xuICAgIGNvbnN0IGJpdHMyaW50ID0gZWNkc2FPcHRzLmJpdHMyaW50IHx8XG4gICAgICAgIGZ1bmN0aW9uIGJpdHMyaW50X2RlZihieXRlcykge1xuICAgICAgICAgICAgLy8gT3VyIGN1c3RvbSBjaGVjayBcImp1c3QgaW4gY2FzZVwiLCBmb3IgcHJvdGVjdGlvbiBhZ2FpbnN0IERvU1xuICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA+IDgxOTIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBpcyB0b28gbGFyZ2UnKTtcbiAgICAgICAgICAgIC8vIEZvciBjdXJ2ZXMgd2l0aCBuQml0TGVuZ3RoICUgOCAhPT0gMDogYml0czJvY3RldHMoYml0czJvY3RldHMobSkpICE9PSBiaXRzMm9jdGV0cyhtKVxuICAgICAgICAgICAgLy8gZm9yIHNvbWUgY2FzZXMsIHNpbmNlIGJ5dGVzLmxlbmd0aCAqIDggaXMgbm90IGFjdHVhbCBiaXRMZW5ndGguXG4gICAgICAgICAgICBjb25zdCBudW0gPSBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpOyAvLyBjaGVjayBmb3IgPT0gdTggZG9uZSBoZXJlXG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGJ5dGVzLmxlbmd0aCAqIDggLSBmbkJpdHM7IC8vIHRydW5jYXRlIHRvIG5CaXRMZW5ndGggbGVmdG1vc3QgYml0c1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhID4gMCA/IG51bSA+PiBCaWdJbnQoZGVsdGEpIDogbnVtO1xuICAgICAgICB9O1xuICAgIGNvbnN0IGJpdHMyaW50X21vZE4gPSBlY2RzYU9wdHMuYml0czJpbnRfbW9kTiB8fFxuICAgICAgICBmdW5jdGlvbiBiaXRzMmludF9tb2ROX2RlZihieXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIEZuLmNyZWF0ZShiaXRzMmludChieXRlcykpOyAvLyBjYW4ndCB1c2UgYnl0ZXNUb051bWJlckJFIGhlcmVcbiAgICAgICAgfTtcbiAgICAvLyBQYWRzIG91dHB1dCB3aXRoIHplcm8gYXMgcGVyIHNwZWNcbiAgICBjb25zdCBPUkRFUl9NQVNLID0gYml0TWFzayhmbkJpdHMpO1xuICAgIC8qKiBDb252ZXJ0cyB0byBieXRlcy4gQ2hlY2tzIGlmIG51bSBpbiBgWzAuLk9SREVSX01BU0stMV1gIGUuZy46IGBbMC4uMl4yNTYtMV1gLiAqL1xuICAgIGZ1bmN0aW9uIGludDJvY3RldHMobnVtKSB7XG4gICAgICAgIC8vIElNUE9SVEFOVDogdGhlIGNoZWNrIGVuc3VyZXMgd29ya2luZyBmb3IgY2FzZSBgRm4uQllURVMgIT0gRm4uQklUUyAqIDhgXG4gICAgICAgIGFJblJhbmdlKCdudW0gPCAyXicgKyBmbkJpdHMsIG51bSwgXzBuLCBPUkRFUl9NQVNLKTtcbiAgICAgICAgcmV0dXJuIEZuLnRvQnl0ZXMobnVtKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVNc2dBbmRIYXNoKG1lc3NhZ2UsIHByZWhhc2gpIHtcbiAgICAgICAgYWJ5dGVzKG1lc3NhZ2UsIHVuZGVmaW5lZCwgJ21lc3NhZ2UnKTtcbiAgICAgICAgcmV0dXJuIHByZWhhc2ggPyBhYnl0ZXMoaGFzaChtZXNzYWdlKSwgdW5kZWZpbmVkLCAncHJlaGFzaGVkIG1lc3NhZ2UnKSA6IG1lc3NhZ2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjIuXG4gICAgICogQ3JlYXRlcyBSRkM2OTc5IHNlZWQ7IGNvbnZlcnRzIG1zZy9wcml2S2V5IHRvIG51bWJlcnMuXG4gICAgICogVXNlZCBvbmx5IGluIHNpZ24sIG5vdCBpbiB2ZXJpZnkuXG4gICAgICpcbiAgICAgKiBXYXJuaW5nOiB3ZSBjYW5ub3QgYXNzdW1lIGhlcmUgdGhhdCBtZXNzYWdlIGhhcyBzYW1lIGFtb3VudCBvZiBieXRlcyBhcyBjdXJ2ZSBvcmRlcixcbiAgICAgKiB0aGlzIHdpbGwgYmUgaW52YWxpZCBhdCBsZWFzdCBmb3IgUDUyMS4gQWxzbyBpdCBjYW4gYmUgYmlnZ2VyIGZvciBQMjI0ICsgU0hBMjU2LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByZXBTaWcobWVzc2FnZSwgcHJpdmF0ZUtleSwgb3B0cykge1xuICAgICAgICBpZiAoWydyZWNvdmVyZWQnLCAnY2Fub25pY2FsJ10uc29tZSgoaykgPT4gayBpbiBvcHRzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbigpIGxlZ2FjeSBvcHRpb25zIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgY29uc3QgeyBsb3dTLCBwcmVoYXNoLCBleHRyYUVudHJvcHkgfSA9IHZhbGlkYXRlU2lnT3B0cyhvcHRzLCBkZWZhdWx0U2lnT3B0cyk7XG4gICAgICAgIG1lc3NhZ2UgPSB2YWxpZGF0ZU1zZ0FuZEhhc2gobWVzc2FnZSwgcHJlaGFzaCk7IC8vIFJGQzY5NzkgMy4yIEE6IGgxID0gSChtKVxuICAgICAgICAvLyBXZSBjYW4ndCBsYXRlciBjYWxsIGJpdHMyb2N0ZXRzLCBzaW5jZSBuZXN0ZWQgYml0czJpbnQgaXMgYnJva2VuIGZvciBjdXJ2ZXNcbiAgICAgICAgLy8gd2l0aCBmbkJpdHMgJSA4ICE9PSAwLiBCZWNhdXNlIG9mIHRoYXQsIHdlIHVud3JhcCBpdCBoZXJlIGFzIGludDJvY3RldHMgY2FsbC5cbiAgICAgICAgLy8gY29uc3QgYml0czJvY3RldHMgPSAoYml0cykgPT4gaW50Mm9jdGV0cyhiaXRzMmludF9tb2ROKGJpdHMpKVxuICAgICAgICBjb25zdCBoMWludCA9IGJpdHMyaW50X21vZE4obWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IGQgPSBfbm9ybUZuRWxlbWVudChGbiwgcHJpdmF0ZUtleSk7IC8vIHZhbGlkYXRlIHNlY3JldCBrZXksIGNvbnZlcnQgdG8gYmlnaW50XG4gICAgICAgIGNvbnN0IHNlZWRBcmdzID0gW2ludDJvY3RldHMoZCksIGludDJvY3RldHMoaDFpbnQpXTtcbiAgICAgICAgLy8gZXh0cmFFbnRyb3B5LiBSRkM2OTc5IDMuNjogYWRkaXRpb25hbCBrJyAob3B0aW9uYWwpLlxuICAgICAgICBpZiAoZXh0cmFFbnRyb3B5ICE9IG51bGwgJiYgZXh0cmFFbnRyb3B5ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gSyA9IEhNQUNfSyhWIHx8IDB4MDAgfHwgaW50Mm9jdGV0cyh4KSB8fCBiaXRzMm9jdGV0cyhoMSkgfHwgaycpXG4gICAgICAgICAgICAvLyBnZW4gcmFuZG9tIGJ5dGVzIE9SIHBhc3MgYXMtaXNcbiAgICAgICAgICAgIGNvbnN0IGUgPSBleHRyYUVudHJvcHkgPT09IHRydWUgPyByYW5kb21CeXRlcyhsZW5ndGhzLnNlY3JldEtleSkgOiBleHRyYUVudHJvcHk7XG4gICAgICAgICAgICBzZWVkQXJncy5wdXNoKGVuc3VyZUJ5dGVzKCdleHRyYUVudHJvcHknLCBlKSk7IC8vIGNoZWNrIGZvciBiZWluZyBieXRlc1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZWQgPSBjb25jYXRCeXRlcyguLi5zZWVkQXJncyk7IC8vIFN0ZXAgRCBvZiBSRkM2OTc5IDMuMlxuICAgICAgICBjb25zdCBtID0gaDFpbnQ7IC8vIE5PVEU6IG5vIG5lZWQgdG8gY2FsbCBiaXRzMmludCBzZWNvbmQgdGltZSBoZXJlLCBpdCBpcyBpbnNpZGUgdHJ1bmNhdGVIYXNoIVxuICAgICAgICAvLyBDb252ZXJ0cyBzaWduYXR1cmUgcGFyYW1zIGludG8gcG9pbnQgdyByL3MsIGNoZWNrcyByZXN1bHQgZm9yIHZhbGlkaXR5LlxuICAgICAgICAvLyBUbyB0cmFuc2Zvcm0gayA9PiBTaWduYXR1cmU6XG4gICAgICAgIC8vIHEgPSBr4ouFR1xuICAgICAgICAvLyByID0gcS54IG1vZCBuXG4gICAgICAgIC8vIHMgPSBrXi0xKG0gKyByZCkgbW9kIG5cbiAgICAgICAgLy8gQ2FuIHVzZSBzY2FsYXIgYmxpbmRpbmcgYl4tMShibSArIGJkcikgd2hlcmUgYiDiiIggWzEsceKIkjFdIGFjY29yZGluZyB0b1xuICAgICAgICAvLyBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvNzMzNy82NTA5LiBXZSd2ZSBkZWNpZGVkIGFnYWluc3QgaXQ6XG4gICAgICAgIC8vIGEpIGRlcGVuZGVuY3kgb24gQ1NQUk5HIGIpIDE1JSBzbG93ZG93biBjKSBkb2Vzbid0IHJlYWxseSBoZWxwIHNpbmNlIGJpZ2ludHMgYXJlIG5vdCBDVFxuICAgICAgICBmdW5jdGlvbiBrMnNpZyhrQnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIFJGQyA2OTc5IFNlY3Rpb24gMy4yLCBzdGVwIDM6IGsgPSBiaXRzMmludChUKVxuICAgICAgICAgICAgLy8gSW1wb3J0YW50OiBhbGwgbW9kKCkgY2FsbHMgaGVyZSBtdXN0IGJlIGRvbmUgb3ZlciBOXG4gICAgICAgICAgICBjb25zdCBrID0gYml0czJpbnQoa0J5dGVzKTsgLy8gbW9kIG4sIG5vdCBtb2QgcFxuICAgICAgICAgICAgaWYgKCFGbi5pc1ZhbGlkTm90MChrKSlcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIFZhbGlkIHNjYWxhcnMgKGluY2x1ZGluZyBrKSBtdXN0IGJlIGluIDEuLk4tMVxuICAgICAgICAgICAgY29uc3QgaWsgPSBGbi5pbnYoayk7IC8vIGteLTEgbW9kIG5cbiAgICAgICAgICAgIGNvbnN0IHEgPSBQb2ludC5CQVNFLm11bHRpcGx5KGspLnRvQWZmaW5lKCk7IC8vIHEgPSBr4ouFR1xuICAgICAgICAgICAgY29uc3QgciA9IEZuLmNyZWF0ZShxLngpOyAvLyByID0gcS54IG1vZCBuXG4gICAgICAgICAgICBpZiAociA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHMgPSBGbi5jcmVhdGUoaWsgKiBGbi5jcmVhdGUobSArIHIgKiBkKSk7IC8vIE5vdCB1c2luZyBibGluZGluZyBoZXJlLCBzZWUgY29tbWVudCBhYm92ZVxuICAgICAgICAgICAgaWYgKHMgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgcmVjb3ZlcnkgPSAocS54ID09PSByID8gMCA6IDIpIHwgTnVtYmVyKHEueSAmIF8xbik7IC8vIHJlY292ZXJ5IGJpdCAoMiBvciAzLCB3aGVuIHEueCA+IG4pXG4gICAgICAgICAgICBsZXQgbm9ybVMgPSBzO1xuICAgICAgICAgICAgaWYgKGxvd1MgJiYgaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHMpKSB7XG4gICAgICAgICAgICAgICAgbm9ybVMgPSBGbi5uZWcocyk7IC8vIGlmIGxvd1Mgd2FzIHBhc3NlZCwgZW5zdXJlIHMgaXMgYWx3YXlzXG4gICAgICAgICAgICAgICAgcmVjb3ZlcnkgXj0gMTsgLy8gLy8gaW4gdGhlIGJvdHRvbSBoYWxmIG9mIE5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIG5vcm1TLCByZWNvdmVyeSk7IC8vIHVzZSBub3JtUywgbm90IHNcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzZWVkLCBrMnNpZyB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaWducyBtZXNzYWdlIGhhc2ggd2l0aCBhIHNlY3JldCBrZXkuXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBzaWduKG0sIGQpIHdoZXJlXG4gICAgICogICBrID0gcmZjNjk3OV9obWFjX2RyYmcobSwgZClcbiAgICAgKiAgICh4LCB5KSA9IEcgw5cga1xuICAgICAqICAgciA9IHggbW9kIG5cbiAgICAgKiAgIHMgPSAobSArIGRyKSAvIGsgbW9kIG5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaWduKG1lc3NhZ2UsIHNlY3JldEtleSwgb3B0cyA9IHt9KSB7XG4gICAgICAgIG1lc3NhZ2UgPSBlbnN1cmVCeXRlcygnbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgICAgICBjb25zdCB7IHNlZWQsIGsyc2lnIH0gPSBwcmVwU2lnKG1lc3NhZ2UsIHNlY3JldEtleSwgb3B0cyk7IC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjIuXG4gICAgICAgIGNvbnN0IGRyYmcgPSBjcmVhdGVIbWFjRHJiZyhoYXNoLm91dHB1dExlbiwgRm4uQllURVMsIGhtYWMpO1xuICAgICAgICBjb25zdCBzaWcgPSBkcmJnKHNlZWQsIGsyc2lnKTsgLy8gU3RlcHMgQiwgQywgRCwgRSwgRiwgR1xuICAgICAgICByZXR1cm4gc2lnO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cnlQYXJzaW5nU2lnKHNnKSB7XG4gICAgICAgIC8vIFRyeSB0byBkZWR1Y2UgZm9ybWF0XG4gICAgICAgIGxldCBzaWcgPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGlzSGV4ID0gdHlwZW9mIHNnID09PSAnc3RyaW5nJyB8fCBpc0J5dGVzKHNnKTtcbiAgICAgICAgY29uc3QgaXNPYmogPSAhaXNIZXggJiZcbiAgICAgICAgICAgIHNnICE9PSBudWxsICYmXG4gICAgICAgICAgICB0eXBlb2Ygc2cgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICB0eXBlb2Ygc2cuciA9PT0gJ2JpZ2ludCcgJiZcbiAgICAgICAgICAgIHR5cGVvZiBzZy5zID09PSAnYmlnaW50JztcbiAgICAgICAgaWYgKCFpc0hleCAmJiAhaXNPYmopXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgc2lnbmF0dXJlLCBleHBlY3RlZCBVaW50OEFycmF5LCBoZXggc3RyaW5nIG9yIFNpZ25hdHVyZSBpbnN0YW5jZScpO1xuICAgICAgICBpZiAoaXNPYmopIHtcbiAgICAgICAgICAgIHNpZyA9IG5ldyBTaWduYXR1cmUoc2cuciwgc2cucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNIZXgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc2lnID0gU2lnbmF0dXJlLmZyb21CeXRlcyhlbnN1cmVCeXRlcygnc2lnJywgc2cpLCAnZGVyJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoIShkZXJFcnJvciBpbnN0YW5jZW9mIERFUi5FcnIpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBkZXJFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2lnKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc2lnID0gU2lnbmF0dXJlLmZyb21CeXRlcyhlbnN1cmVCeXRlcygnc2lnJywgc2cpLCAnY29tcGFjdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNpZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHNpZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgYSBzaWduYXR1cmUgYWdhaW5zdCBtZXNzYWdlIGFuZCBwdWJsaWMga2V5LlxuICAgICAqIFJlamVjdHMgbG93UyBzaWduYXR1cmVzIGJ5IGRlZmF1bHQ6IHNlZSB7QGxpbmsgRUNEU0FWZXJpZnlPcHRzfS5cbiAgICAgKiBJbXBsZW1lbnRzIHNlY3Rpb24gNC4xLjQgZnJvbSBodHRwczovL3d3dy5zZWNnLm9yZy9zZWMxLXYyLnBkZjpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHZlcmlmeShyLCBzLCBoLCBQKSB3aGVyZVxuICAgICAqICAgdTEgPSBoc14tMSBtb2QgblxuICAgICAqICAgdTIgPSByc14tMSBtb2QgblxuICAgICAqICAgUiA9IHUx4ouFRyArIHUy4ouFUFxuICAgICAqICAgbW9kKFIueCwgbikgPT0gclxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSwgb3B0cyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgbG93UywgcHJlaGFzaCwgZm9ybWF0IH0gPSB2YWxpZGF0ZVNpZ09wdHMob3B0cywgZGVmYXVsdFNpZ09wdHMpO1xuICAgICAgICBwdWJsaWNLZXkgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5KTtcbiAgICAgICAgbWVzc2FnZSA9IHZhbGlkYXRlTXNnQW5kSGFzaChlbnN1cmVCeXRlcygnbWVzc2FnZScsIG1lc3NhZ2UpLCBwcmVoYXNoKTtcbiAgICAgICAgaWYgKCdzdHJpY3QnIGluIG9wdHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMuc3RyaWN0IHdhcyByZW5hbWVkIHRvIGxvd1MnKTtcbiAgICAgICAgY29uc3Qgc2lnID0gZm9ybWF0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gdHJ5UGFyc2luZ1NpZyhzaWduYXR1cmUpXG4gICAgICAgICAgICA6IFNpZ25hdHVyZS5mcm9tQnl0ZXMoZW5zdXJlQnl0ZXMoJ3NpZycsIHNpZ25hdHVyZSksIGZvcm1hdCk7XG4gICAgICAgIGlmIChzaWcgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21CeXRlcyhwdWJsaWNLZXkpO1xuICAgICAgICAgICAgaWYgKGxvd1MgJiYgc2lnLmhhc0hpZ2hTKCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgeyByLCBzIH0gPSBzaWc7XG4gICAgICAgICAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTihtZXNzYWdlKTsgLy8gbW9kIG4sIG5vdCBtb2QgcFxuICAgICAgICAgICAgY29uc3QgaXMgPSBGbi5pbnYocyk7IC8vIHNeLTEgbW9kIG5cbiAgICAgICAgICAgIGNvbnN0IHUxID0gRm4uY3JlYXRlKGggKiBpcyk7IC8vIHUxID0gaHNeLTEgbW9kIG5cbiAgICAgICAgICAgIGNvbnN0IHUyID0gRm4uY3JlYXRlKHIgKiBpcyk7IC8vIHUyID0gcnNeLTEgbW9kIG5cbiAgICAgICAgICAgIGNvbnN0IFIgPSBQb2ludC5CQVNFLm11bHRpcGx5VW5zYWZlKHUxKS5hZGQoUC5tdWx0aXBseVVuc2FmZSh1MikpOyAvLyB1MeKLhUcgKyB1MuKLhVBcbiAgICAgICAgICAgIGlmIChSLmlzMCgpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBGbi5jcmVhdGUoUi54KTsgLy8gdiA9IHIueCBtb2QgblxuICAgICAgICAgICAgcmV0dXJuIHYgPT09IHI7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWNvdmVyUHVibGljS2V5KHNpZ25hdHVyZSwgbWVzc2FnZSwgb3B0cyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgcHJlaGFzaCB9ID0gdmFsaWRhdGVTaWdPcHRzKG9wdHMsIGRlZmF1bHRTaWdPcHRzKTtcbiAgICAgICAgbWVzc2FnZSA9IHZhbGlkYXRlTXNnQW5kSGFzaChtZXNzYWdlLCBwcmVoYXNoKTtcbiAgICAgICAgcmV0dXJuIFNpZ25hdHVyZS5mcm9tQnl0ZXMoc2lnbmF0dXJlLCAncmVjb3ZlcmVkJykucmVjb3ZlclB1YmxpY0tleShtZXNzYWdlKS50b0J5dGVzKCk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAga2V5Z2VuLFxuICAgICAgICBnZXRQdWJsaWNLZXksXG4gICAgICAgIGdldFNoYXJlZFNlY3JldCxcbiAgICAgICAgdXRpbHMsXG4gICAgICAgIGxlbmd0aHMsXG4gICAgICAgIFBvaW50LFxuICAgICAgICBzaWduLFxuICAgICAgICB2ZXJpZnksXG4gICAgICAgIHJlY292ZXJQdWJsaWNLZXksXG4gICAgICAgIFNpZ25hdHVyZSxcbiAgICAgICAgaGFzaCxcbiAgICB9KTtcbn1cbi8qKiBAZGVwcmVjYXRlZCB1c2UgYHdlaWVyc3RyYXNzYCBpbiBuZXdlciByZWxlYXNlcyAqL1xuZXhwb3J0IGZ1bmN0aW9uIHdlaWVyc3RyYXNzUG9pbnRzKGMpIHtcbiAgICBjb25zdCB7IENVUlZFLCBjdXJ2ZU9wdHMgfSA9IF93ZWllcnN0cmFzc19sZWdhY3lfb3B0c190b19uZXcoYyk7XG4gICAgY29uc3QgUG9pbnQgPSB3ZWllcnN0cmFzc04oQ1VSVkUsIGN1cnZlT3B0cyk7XG4gICAgcmV0dXJuIF93ZWllcnN0cmFzc19uZXdfb3V0cHV0X3RvX2xlZ2FjeShjLCBQb2ludCk7XG59XG5mdW5jdGlvbiBfd2VpZXJzdHJhc3NfbGVnYWN5X29wdHNfdG9fbmV3KGMpIHtcbiAgICBjb25zdCBDVVJWRSA9IHtcbiAgICAgICAgYTogYy5hLFxuICAgICAgICBiOiBjLmIsXG4gICAgICAgIHA6IGMuRnAuT1JERVIsXG4gICAgICAgIG46IGMubixcbiAgICAgICAgaDogYy5oLFxuICAgICAgICBHeDogYy5HeCxcbiAgICAgICAgR3k6IGMuR3ksXG4gICAgfTtcbiAgICBjb25zdCBGcCA9IGMuRnA7XG4gICAgbGV0IGFsbG93ZWRMZW5ndGhzID0gYy5hbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHNcbiAgICAgICAgPyBBcnJheS5mcm9tKG5ldyBTZXQoYy5hbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHMubWFwKChsKSA9PiBNYXRoLmNlaWwobCAvIDIpKSkpXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IEZuID0gRmllbGQoQ1VSVkUubiwge1xuICAgICAgICBCSVRTOiBjLm5CaXRMZW5ndGgsXG4gICAgICAgIGFsbG93ZWRMZW5ndGhzOiBhbGxvd2VkTGVuZ3RocyxcbiAgICAgICAgbW9kRnJvbUJ5dGVzOiBjLndyYXBQcml2YXRlS2V5LFxuICAgIH0pO1xuICAgIGNvbnN0IGN1cnZlT3B0cyA9IHtcbiAgICAgICAgRnAsXG4gICAgICAgIEZuLFxuICAgICAgICBhbGxvd0luZmluaXR5UG9pbnQ6IGMuYWxsb3dJbmZpbml0eVBvaW50LFxuICAgICAgICBlbmRvOiBjLmVuZG8sXG4gICAgICAgIGlzVG9yc2lvbkZyZWU6IGMuaXNUb3JzaW9uRnJlZSxcbiAgICAgICAgY2xlYXJDb2ZhY3RvcjogYy5jbGVhckNvZmFjdG9yLFxuICAgICAgICBmcm9tQnl0ZXM6IGMuZnJvbUJ5dGVzLFxuICAgICAgICB0b0J5dGVzOiBjLnRvQnl0ZXMsXG4gICAgfTtcbiAgICByZXR1cm4geyBDVVJWRSwgY3VydmVPcHRzIH07XG59XG5mdW5jdGlvbiBfZWNkc2FfbGVnYWN5X29wdHNfdG9fbmV3KGMpIHtcbiAgICBjb25zdCB7IENVUlZFLCBjdXJ2ZU9wdHMgfSA9IF93ZWllcnN0cmFzc19sZWdhY3lfb3B0c190b19uZXcoYyk7XG4gICAgY29uc3QgZWNkc2FPcHRzID0ge1xuICAgICAgICBobWFjOiBjLmhtYWMsXG4gICAgICAgIHJhbmRvbUJ5dGVzOiBjLnJhbmRvbUJ5dGVzLFxuICAgICAgICBsb3dTOiBjLmxvd1MsXG4gICAgICAgIGJpdHMyaW50OiBjLmJpdHMyaW50LFxuICAgICAgICBiaXRzMmludF9tb2ROOiBjLmJpdHMyaW50X21vZE4sXG4gICAgfTtcbiAgICByZXR1cm4geyBDVVJWRSwgY3VydmVPcHRzLCBoYXNoOiBjLmhhc2gsIGVjZHNhT3B0cyB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIF9sZWdhY3lIZWxwZXJFcXVhdChGcCwgYSwgYikge1xuICAgIC8qKlxuICAgICAqIHnCsiA9IHjCsyArIGF4ICsgYjogU2hvcnQgd2VpZXJzdHJhc3MgY3VydmUgZm9ybXVsYS4gVGFrZXMgeCwgcmV0dXJucyB5wrIuXG4gICAgICogQHJldHVybnMgecKyXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2VpZXJzdHJhc3NFcXVhdGlvbih4KSB7XG4gICAgICAgIGNvbnN0IHgyID0gRnAuc3FyKHgpOyAvLyB4ICogeFxuICAgICAgICBjb25zdCB4MyA9IEZwLm11bCh4MiwgeCk7IC8vIHjCsiAqIHhcbiAgICAgICAgcmV0dXJuIEZwLmFkZChGcC5hZGQoeDMsIEZwLm11bCh4LCBhKSksIGIpOyAvLyB4wrMgKyBhICogeCArIGJcbiAgICB9XG4gICAgcmV0dXJuIHdlaWVyc3RyYXNzRXF1YXRpb247XG59XG5mdW5jdGlvbiBfd2VpZXJzdHJhc3NfbmV3X291dHB1dF90b19sZWdhY3koYywgUG9pbnQpIHtcbiAgICBjb25zdCB7IEZwLCBGbiB9ID0gUG9pbnQ7XG4gICAgZnVuY3Rpb24gaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkge1xuICAgICAgICByZXR1cm4gaW5SYW5nZShudW0sIF8xbiwgRm4uT1JERVIpO1xuICAgIH1cbiAgICBjb25zdCB3ZWllcnN0cmFzc0VxdWF0aW9uID0gX2xlZ2FjeUhlbHBlckVxdWF0KEZwLCBjLmEsIGMuYik7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgICAgQ1VSVkU6IGMsXG4gICAgICAgIFBvaW50OiBQb2ludCxcbiAgICAgICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludCxcbiAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcjogKGtleSkgPT4gX25vcm1GbkVsZW1lbnQoRm4sIGtleSksXG4gICAgICAgIHdlaWVyc3RyYXNzRXF1YXRpb24sXG4gICAgICAgIGlzV2l0aGluQ3VydmVPcmRlcixcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIF9lY2RzYV9uZXdfb3V0cHV0X3RvX2xlZ2FjeShjLCBfZWNkc2EpIHtcbiAgICBjb25zdCBQb2ludCA9IF9lY2RzYS5Qb2ludDtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgX2VjZHNhLCB7XG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIENVUlZFOiBPYmplY3QuYXNzaWduKHt9LCBjLCBuTGVuZ3RoKFBvaW50LkZuLk9SREVSLCBQb2ludC5Gbi5CSVRTKSksXG4gICAgfSk7XG59XG4vLyBfZWNkc2FfbGVnYWN5XG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3MoYykge1xuICAgIGNvbnN0IHsgQ1VSVkUsIGN1cnZlT3B0cywgaGFzaCwgZWNkc2FPcHRzIH0gPSBfZWNkc2FfbGVnYWN5X29wdHNfdG9fbmV3KGMpO1xuICAgIGNvbnN0IFBvaW50ID0gd2VpZXJzdHJhc3NOKENVUlZFLCBjdXJ2ZU9wdHMpO1xuICAgIGNvbnN0IHNpZ25zID0gZWNkc2EoUG9pbnQsIGhhc2gsIGVjZHNhT3B0cyk7XG4gICAgcmV0dXJuIF9lY2RzYV9uZXdfb3V0cHV0X3RvX2xlZ2FjeShjLCBzaWducyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWllcnN0cmFzcy5qcy5tYXAiXSwibmFtZXMiOlsiaG1hYyIsIm5vYmxlSG1hYyIsImFoYXNoIiwiX3ZhbGlkYXRlT2JqZWN0IiwiX2Fib29sMiIsImFib29sIiwiX2FieXRlczIiLCJhYnl0ZXMiLCJhSW5SYW5nZSIsImJpdExlbiIsImJpdE1hc2siLCJieXRlc1RvSGV4IiwiYnl0ZXNUb051bWJlckJFIiwiY29uY2F0Qnl0ZXMiLCJjcmVhdGVIbWFjRHJiZyIsImVuc3VyZUJ5dGVzIiwiaGV4VG9CeXRlcyIsImluUmFuZ2UiLCJpc0J5dGVzIiwibWVtb2l6ZWQiLCJudW1iZXJUb0hleFVucGFkZGVkIiwicmFuZG9tQnl0ZXMiLCJyYW5kb21CeXRlc1dlYiIsIl9jcmVhdGVDdXJ2ZUZpZWxkcyIsIm11bEVuZG9VbnNhZmUiLCJuZWdhdGVDdCIsIm5vcm1hbGl6ZVoiLCJwaXBwZW5nZXIiLCJ3TkFGIiwiRmllbGQiLCJGcEludmVydEJhdGNoIiwiZ2V0TWluSGFzaExlbmd0aCIsIm1hcEhhc2hUb0ZpZWxkIiwibkxlbmd0aCIsInZhbGlkYXRlRmllbGQiLCJkaXZOZWFyZXN0IiwibnVtIiwiZGVuIiwiXzJuIiwiX3NwbGl0RW5kb1NjYWxhciIsImsiLCJiYXNpcyIsIm4iLCJhMSIsImIxIiwiYTIiLCJiMiIsImMxIiwiYzIiLCJrMSIsImsyIiwiazFuZWciLCJfMG4iLCJrMm5lZyIsIk1BWF9OVU0iLCJNYXRoIiwiY2VpbCIsIl8xbiIsIkVycm9yIiwidmFsaWRhdGVTaWdGb3JtYXQiLCJmb3JtYXQiLCJpbmNsdWRlcyIsInZhbGlkYXRlU2lnT3B0cyIsIm9wdHMiLCJkZWYiLCJvcHRzbiIsIm9wdE5hbWUiLCJPYmplY3QiLCJrZXlzIiwidW5kZWZpbmVkIiwibG93UyIsInByZWhhc2giLCJERVJFcnIiLCJjb25zdHJ1Y3RvciIsIm0iLCJERVIiLCJFcnIiLCJfdGx2IiwiZW5jb2RlIiwidGFnIiwiZGF0YSIsIkUiLCJsZW5ndGgiLCJkYXRhTGVuIiwibGVuIiwibGVuTGVuIiwidCIsImRlY29kZSIsInBvcyIsImZpcnN0IiwiaXNMb25nIiwibGVuZ3RoQnl0ZXMiLCJzdWJhcnJheSIsImIiLCJ2IiwibCIsIl9pbnQiLCJoZXgiLCJOdW1iZXIiLCJwYXJzZUludCIsInRvU2lnIiwiaW50IiwidGx2Iiwic2VxQnl0ZXMiLCJzZXFMZWZ0Qnl0ZXMiLCJyQnl0ZXMiLCJyTGVmdEJ5dGVzIiwic0J5dGVzIiwic0xlZnRCeXRlcyIsInIiLCJzIiwiaGV4RnJvbVNpZyIsInNpZyIsInJzIiwic3MiLCJzZXEiLCJCaWdJbnQiLCJfM24iLCJfNG4iLCJfbm9ybUZuRWxlbWVudCIsIkZuIiwia2V5IiwiQllURVMiLCJleHBlY3RlZCIsImJ5dGVzIiwiZnJvbUJ5dGVzIiwiZXJyb3IiLCJpc1ZhbGlkTm90MCIsIndlaWVyc3RyYXNzTiIsInBhcmFtcyIsImV4dHJhT3B0cyIsInZhbGlkYXRlZCIsIkZwIiwiQ1VSVkUiLCJoIiwiY29mYWN0b3IiLCJDVVJWRV9PUkRFUiIsImFsbG93SW5maW5pdHlQb2ludCIsImNsZWFyQ29mYWN0b3IiLCJpc1RvcnNpb25GcmVlIiwidG9CeXRlcyIsImVuZG8iLCJ3cmFwUHJpdmF0ZUtleSIsImlzMCIsImEiLCJiZXRhIiwiQXJyYXkiLCJpc0FycmF5IiwiYmFzaXNlcyIsImxlbmd0aHMiLCJnZXRXTGVuZ3RocyIsImFzc2VydENvbXByZXNzaW9uSXNTdXBwb3J0ZWQiLCJpc09kZCIsInBvaW50VG9CeXRlcyIsIl9jIiwicG9pbnQiLCJpc0NvbXByZXNzZWQiLCJ4IiwieSIsInRvQWZmaW5lIiwiYngiLCJoYXNFdmVuWSIsInBwcmVmaXgiLCJVaW50OEFycmF5Iiwib2YiLCJwb2ludEZyb21CeXRlcyIsInB1YmxpY0tleSIsImNvbXAiLCJwdWJsaWNLZXlVbmNvbXByZXNzZWQiLCJ1bmNvbXAiLCJoZWFkIiwidGFpbCIsImlzVmFsaWQiLCJ5MiIsIndlaWVyc3RyYXNzRXF1YXRpb24iLCJzcXJ0Iiwic3FydEVycm9yIiwiZXJyIiwibWVzc2FnZSIsImlzWU9kZCIsImlzSGVhZE9kZCIsIm5lZyIsIkwiLCJpc1ZhbGlkWFkiLCJlbmNvZGVQb2ludCIsImRlY29kZVBvaW50IiwieDIiLCJzcXIiLCJ4MyIsIm11bCIsImFkZCIsImxlZnQiLCJyaWdodCIsImVxbCIsIkd4IiwiR3kiLCJfNGEzIiwicG93IiwiXzI3YjIiLCJhY29vcmQiLCJ0aXRsZSIsImJhblplcm8iLCJhcHJqcG9pbnQiLCJvdGhlciIsIlBvaW50Iiwic3BsaXRFbmRvU2NhbGFyTiIsIk9SREVSIiwidG9BZmZpbmVNZW1vIiwicCIsIml6IiwiWCIsIlkiLCJaIiwiT05FIiwiaW52IiwienoiLCJaRVJPIiwiYXNzZXJ0VmFsaWRNZW1vIiwiZmluaXNoRW5kbyIsImVuZG9CZXRhIiwiazFwIiwiazJwIiwiZnJlZXplIiwiZnJvbUFmZmluZSIsIlAiLCJhc3NlcnRWYWxpZGl0eSIsImZyb21IZXgiLCJwcmVjb21wdXRlIiwid2luZG93U2l6ZSIsImlzTGF6eSIsInduYWYiLCJjcmVhdGVDYWNoZSIsIm11bHRpcGx5IiwiZXF1YWxzIiwiWDEiLCJZMSIsIloxIiwiWDIiLCJZMiIsIloyIiwiVTEiLCJVMiIsIm5lZ2F0ZSIsImRvdWJsZSIsImIzIiwiWDMiLCJZMyIsIlozIiwidDAiLCJ0MSIsInQyIiwidDMiLCJzdWIiLCJ0NCIsInQ1Iiwic3VidHJhY3QiLCJzY2FsYXIiLCJmYWtlIiwiY2FjaGVkIiwiZiIsImsxZiIsImsyZiIsIm11bHRpcGx5VW5zYWZlIiwic2MiLCJoYXNDYWNoZSIsInAxIiwicDIiLCJ1bnNhZmUiLCJtdWx0aXBseUFuZEFkZFVuc2FmZSIsIlEiLCJzdW0iLCJpbnZlcnRlZFoiLCJpc1NtYWxsT3JkZXIiLCJ0b0hleCIsInRvU3RyaW5nIiwicHgiLCJweSIsInB6IiwidG9SYXdCeXRlcyIsIl9zZXRXaW5kb3dTaXplIiwicG9pbnRzIiwibXNtIiwic2NhbGFycyIsImZyb21Qcml2YXRlS2V5IiwicHJpdmF0ZUtleSIsIkJBU0UiLCJiaXRzIiwiQklUUyIsIlNXVUZwU3FydFJhdGlvIiwicSIsIm8iLCJfMm5fcG93X2MxXzEiLCJfMm5fcG93X2MxIiwiYzMiLCJjNCIsImM1IiwiYzYiLCJjNyIsInNxcnRSYXRpbyIsInUiLCJ0djEiLCJ0djIiLCJ0djMiLCJ0djUiLCJ0djQiLCJpc1FSIiwiY21vdiIsImkiLCJ0dnY1IiwiZTEiLCJ2YWx1ZSIsInkxIiwibWFwVG9DdXJ2ZVNpbXBsZVNXVSIsIkEiLCJCIiwidHY2IiwidHY0X2ludiIsInNlY3JldEtleSIsInB1YmxpY0tleUhhc1ByZWZpeCIsInNpZ25hdHVyZSIsImVjZGgiLCJlY2RoT3B0cyIsInJhbmRvbUJ5dGVzXyIsImFzc2lnbiIsInNlZWQiLCJpc1ZhbGlkU2VjcmV0S2V5IiwiaXNWYWxpZFB1YmxpY0tleSIsInJhbmRvbVNlY3JldEtleSIsImdldFB1YmxpY0tleSIsImtleWdlbiIsImlzUHJvYlB1YiIsIml0ZW0iLCJhbGxvd2VkTGVuZ3RocyIsImdldFNoYXJlZFNlY3JldCIsInNlY3JldEtleUEiLCJwdWJsaWNLZXlCIiwidXRpbHMiLCJpc1ZhbGlkUHJpdmF0ZUtleSIsInJhbmRvbVByaXZhdGVLZXkiLCJub3JtUHJpdmF0ZUtleVRvU2NhbGFyIiwiZWNkc2EiLCJoYXNoIiwiZWNkc2FPcHRzIiwiYml0czJpbnQiLCJiaXRzMmludF9tb2ROIiwibXNncyIsImZuQml0cyIsImRlZmF1bHRTaWdPcHRzIiwiZXh0cmFFbnRyb3B5IiwiZGVmYXVsdFNpZ09wdHNfZm9ybWF0IiwiaXNCaWdnZXJUaGFuSGFsZk9yZGVyIiwibnVtYmVyIiwiSEFMRiIsInZhbGlkYXRlUlMiLCJ2YWxpZGF0ZVNpZ0xlbmd0aCIsInNpemUiLCJzaXplciIsIlNpZ25hdHVyZSIsInJlY292ZXJ5IiwicmVjaWQiLCJhZGRSZWNvdmVyeUJpdCIsInJlY292ZXJQdWJsaWNLZXkiLCJtZXNzYWdlSGFzaCIsIkZJRUxEX09SREVSIiwicmVjIiwiaGFzQ29mYWN0b3IiLCJyYWRqIiwiUiIsImlyIiwidTEiLCJjcmVhdGUiLCJ1MiIsImhhc0hpZ2hTIiwiZnJvbUNvbXBhY3QiLCJmcm9tREVSIiwibm9ybWFsaXplUyIsInRvREVSUmF3Qnl0ZXMiLCJ0b0RFUkhleCIsInRvQ29tcGFjdFJhd0J5dGVzIiwidG9Db21wYWN0SGV4IiwiYml0czJpbnRfZGVmIiwiZGVsdGEiLCJiaXRzMmludF9tb2ROX2RlZiIsIk9SREVSX01BU0siLCJpbnQyb2N0ZXRzIiwidmFsaWRhdGVNc2dBbmRIYXNoIiwicHJlcFNpZyIsInNvbWUiLCJoMWludCIsImQiLCJzZWVkQXJncyIsImUiLCJwdXNoIiwiazJzaWciLCJrQnl0ZXMiLCJpayIsIm5vcm1TIiwic2lnbiIsImRyYmciLCJvdXRwdXRMZW4iLCJ0cnlQYXJzaW5nU2lnIiwic2ciLCJpc0hleCIsImlzT2JqIiwiZGVyRXJyb3IiLCJ2ZXJpZnkiLCJpcyIsIndlaWVyc3RyYXNzUG9pbnRzIiwiYyIsImN1cnZlT3B0cyIsIl93ZWllcnN0cmFzc19sZWdhY3lfb3B0c190b19uZXciLCJfd2VpZXJzdHJhc3NfbmV3X291dHB1dF90b19sZWdhY3kiLCJhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHMiLCJmcm9tIiwiU2V0IiwibWFwIiwibkJpdExlbmd0aCIsIm1vZEZyb21CeXRlcyIsIl9lY2RzYV9sZWdhY3lfb3B0c190b19uZXciLCJfbGVnYWN5SGVscGVyRXF1YXQiLCJpc1dpdGhpbkN1cnZlT3JkZXIiLCJQcm9qZWN0aXZlUG9pbnQiLCJfZWNkc2FfbmV3X291dHB1dF90b19sZWdhY3kiLCJfZWNkc2EiLCJ3ZWllcnN0cmFzcyIsInNpZ25zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/weierstrass.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/bls12-381.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/bls12-381.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bls12_381: () => (/* binding */ bls12_381),\n/* harmony export */   bls12_381_Fr: () => (/* binding */ bls12_381_Fr)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/sha2.js */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/sha2.js\");\n/* harmony import */ var _abstract_bls_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/bls.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/bls.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./abstract/modular.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/utils.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _abstract_tower_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/tower.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/tower.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/**\n * bls12-381 is pairing-friendly Barreto-Lynn-Scott elliptic curve construction allowing to:\n\n* Construct zk-SNARKs at the ~120-bit security, as per [Barbulescu-Duquesne 2017](https://hal.science/hal-01534101/file/main.pdf)\n* Efficiently verify N aggregate signatures with 1 pairing and N ec additions:\nthe Boneh-Lynn-Shacham signature scheme is orders of magnitude more efficient than Schnorr\n\nBLS can mean 2 different things:\n\n* Barreto-Lynn-Scott: BLS12, a Pairing Friendly Elliptic Curve\n* Boneh-Lynn-Shacham: A Signature Scheme.\n\n### Summary\n\n1. BLS Relies on expensive bilinear pairing\n2. Secret Keys: 32 bytes\n3. Public Keys: 48 OR 96 bytes - big-endian x coordinate of point on G1 OR G2 curve\n4. Signatures: 96 OR 48 bytes - big-endian x coordinate of point on G2 OR G1 curve\n5. The 12 stands for the Embedding degree.\n\nModes of operation:\n\n* Long signatures:  48-byte keys + 96-byte sigs (G1 keys + G2 sigs).\n* Short signatures: 96-byte keys + 48-byte sigs (G2 keys + G1 sigs).\n\n### Formulas\n\n- `P = pk x G` - public keys\n- `S = pk x H(m)` - signing, uses hash-to-curve on m\n- `e(P, H(m)) == e(G, S)` - verification using pairings\n- `e(G, S) = e(G, SUM(n)(Si)) = MUL(n)(e(G, Si))` - signature aggregation\n\n### Curves\n\nG1 is ordinary elliptic curve. G2 is extension field curve, think \"over complex numbers\".\n\n- G1: y² = x³ + 4\n- G2: y² = x³ + 4(u + 1) where u = √−1; r-order subgroup of E'(Fp²), M-type twist\n\n### Towers\n\nPairing G1 + G2 produces element in Fp₁₂, 12-degree polynomial.\nFp₁₂ is usually implemented using tower of lower-degree polynomials for speed.\n\n- Fp₁₂ = Fp₆² => Fp₂³\n- Fp(u) / (u² - β) where β = -1\n- Fp₂(v) / (v³ - ξ) where ξ = u + 1\n- Fp₆(w) / (w² - γ) where γ = v\n- Fp²[u] = Fp/u²+1\n- Fp⁶[v] = Fp²/v³-1-u\n- Fp¹²[w] = Fp⁶/w²-v\n\n### Params\n\n* Embedding degree (k): 12\n* Seed is sometimes named x or t\n* t = -15132376222941642752\n* p = (t-1)² * (t⁴-t²+1)/3 + t\n* r = t⁴-t²+1\n* Ate loop size: X\n\nTo verify curve parameters, see\n[pairing-friendly-curves spec](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11).\nBasic math is done over finite fields over p.\nMore complicated math is done over polynominal extension fields.\n\n### Compatibility and notes\n1. It is compatible with Algorand, Chia, Dfinity, Ethereum, Filecoin, ZEC.\nFilecoin uses little endian byte arrays for secret keys - make sure to reverse byte order.\n2. Make sure to correctly select mode: \"long signature\" or \"short signature\".\n3. Compatible with specs:\n   RFC 9380,\n   [cfrg-pairing-friendly-curves-11](https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-pairing-friendly-curves-11),\n   [cfrg-bls-signature-05](https://datatracker.ietf.org/doc/draft-irtf-cfrg-bls-signature/).\n\n *\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n\n// Types\n\n\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\n// To verify math:\n// https://tools.ietf.org/html/draft-irtf-cfrg-pairing-friendly-curves-11\n// The BLS parameter x (seed) for BLS12-381. NOTE: it is negative!\n// x = -2^63 - 2^62 - 2^60 - 2^57 - 2^48 - 2^16\nconst BLS_X = BigInt(\"0xd201000000010000\");\n// t = x (called differently in different places)\n// const t = -BLS_X;\nconst BLS_X_LEN = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitLen)(BLS_X);\n// a=0, b=4\n// P is characteristic of field Fp, in which curve calculations are done.\n// p = (t-1)² * (t⁴-t²+1)/3 + t\n// bls12_381_Fp = (t-1n)**2n * (t**4n - t**2n + 1n) / 3n + t\n// r*h is curve order, amount of points on curve,\n// where r is order of prime subgroup and h is cofactor.\n// r = t⁴-t²+1\n// r = (t**4n - t**2n + 1n)\n// cofactor h of G1: (t - 1)²/3\n// cofactorG1 = (t-1n)**2n/3n\n// x = 3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507\n// y = 1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569\nconst bls12_381_CURVE_G1 = {\n    p: BigInt(\"0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab\"),\n    n: BigInt(\"0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\"),\n    h: BigInt(\"0x396c8c005555e1568c00aaab0000aaab\"),\n    a: _0n,\n    b: _4n,\n    Gx: BigInt(\"0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb\"),\n    Gy: BigInt(\"0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1\")\n};\n// CURVE FIELDS\nconst bls12_381_Fr = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_1__.Field)(bls12_381_CURVE_G1.n, {\n    modFromBytes: true,\n    isLE: true\n});\nconst { Fp, Fp2, Fp6, Fp12 } = (0,_abstract_tower_js__WEBPACK_IMPORTED_MODULE_2__.tower12)({\n    ORDER: bls12_381_CURVE_G1.p,\n    X_LEN: BLS_X_LEN,\n    // Finite extension field over irreducible polynominal.\n    // Fp(u) / (u² - β) where β = -1\n    FP2_NONRESIDUE: [\n        _1n,\n        _1n\n    ],\n    Fp2mulByB: ({ c0, c1 })=>{\n        const t0 = Fp.mul(c0, _4n); // 4 * c0\n        const t1 = Fp.mul(c1, _4n); // 4 * c1\n        // (T0-T1) + (T0+T1)*i\n        return {\n            c0: Fp.sub(t0, t1),\n            c1: Fp.add(t0, t1)\n        };\n    },\n    Fp12finalExponentiate: (num)=>{\n        const x = BLS_X;\n        // this^(q⁶) / this\n        const t0 = Fp12.div(Fp12.frobeniusMap(num, 6), num);\n        // t0^(q²) * t0\n        const t1 = Fp12.mul(Fp12.frobeniusMap(t0, 2), t0);\n        const t2 = Fp12.conjugate(Fp12._cyclotomicExp(t1, x));\n        const t3 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicSquare(t1)), t2);\n        const t4 = Fp12.conjugate(Fp12._cyclotomicExp(t3, x));\n        const t5 = Fp12.conjugate(Fp12._cyclotomicExp(t4, x));\n        const t6 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicExp(t5, x)), Fp12._cyclotomicSquare(t2));\n        const t7 = Fp12.conjugate(Fp12._cyclotomicExp(t6, x));\n        const t2_t5_pow_q2 = Fp12.frobeniusMap(Fp12.mul(t2, t5), 2);\n        const t4_t1_pow_q3 = Fp12.frobeniusMap(Fp12.mul(t4, t1), 3);\n        const t6_t1c_pow_q1 = Fp12.frobeniusMap(Fp12.mul(t6, Fp12.conjugate(t1)), 1);\n        const t7_t3c_t1 = Fp12.mul(Fp12.mul(t7, Fp12.conjugate(t3)), t1);\n        // (t2 * t5)^(q²) * (t4 * t1)^(q³) * (t6 * t1.conj)^(q^1) * t7 * t3.conj * t1\n        return Fp12.mul(Fp12.mul(Fp12.mul(t2_t5_pow_q2, t4_t1_pow_q3), t6_t1c_pow_q1), t7_t3c_t1);\n    }\n});\n// GLV endomorphism Ψ(P), for fast cofactor clearing\nconst { G2psi, G2psi2 } = (0,_abstract_tower_js__WEBPACK_IMPORTED_MODULE_2__.psiFrobenius)(Fp, Fp2, Fp2.div(Fp2.ONE, Fp2.NONRESIDUE)); // 1/(u+1)\n/**\n * Default hash_to_field / hash-to-curve for BLS.\n * m: 1 for G1, 2 for G2\n * k: target security level in bits\n * hash: any function, e.g. BBS+ uses BLAKE2: see [github](https://github.com/hyperledger/aries-framework-go/issues/2247).\n * Parameter values come from [section 8.8.2 of RFC 9380](https://www.rfc-editor.org/rfc/rfc9380#section-8.8.2).\n */ const htfDefaults = Object.freeze({\n    DST: \"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_\",\n    encodeDST: \"BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_\",\n    p: Fp.ORDER,\n    m: 2,\n    k: 128,\n    expand: \"xmd\",\n    hash: _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_3__.sha256\n});\n// a=0, b=4\n// cofactor h of G2\n// (t^8 - 4t^7 + 5t^6 - 4t^4 + 6t^3 - 4t^2 - 4t + 13)/9\n// cofactorG2 = (t**8n - 4n*t**7n + 5n*t**6n - 4n*t**4n + 6n*t**3n - 4n*t**2n - 4n*t+13n)/9n\n// x = 3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758*u + 352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160\n// y = 927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582*u + 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905\nconst bls12_381_CURVE_G2 = {\n    p: Fp2.ORDER,\n    n: bls12_381_CURVE_G1.n,\n    h: BigInt(\"0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5\"),\n    a: Fp2.ZERO,\n    b: Fp2.fromBigTuple([\n        _4n,\n        _4n\n    ]),\n    Gx: Fp2.fromBigTuple([\n        BigInt(\"0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8\"),\n        BigInt(\"0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e\")\n    ]),\n    Gy: Fp2.fromBigTuple([\n        BigInt(\"0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801\"),\n        BigInt(\"0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be\")\n    ])\n};\n// Encoding utils\n// Compressed point of infinity\n// Set compressed & point-at-infinity bits\nconst COMPZERO = setMask(Fp.toBytes(_0n), {\n    infinity: true,\n    compressed: true\n});\nfunction parseMask(bytes) {\n    // Copy, so we can remove mask data. It will be removed also later, when Fp.create will call modulo.\n    bytes = bytes.slice();\n    const mask = bytes[0] & 224;\n    const compressed = !!(mask >> 7 & 1); // compression bit (0b1000_0000)\n    const infinity = !!(mask >> 6 & 1); // point at infinity bit (0b0100_0000)\n    const sort = !!(mask >> 5 & 1); // sort bit (0b0010_0000)\n    bytes[0] &= 31; // clear mask (zero first 3 bits)\n    return {\n        compressed,\n        infinity,\n        sort,\n        value: bytes\n    };\n}\nfunction setMask(bytes, mask) {\n    if (bytes[0] & 224) throw new Error(\"setMask: non-empty mask\");\n    if (mask.compressed) bytes[0] |= 128;\n    if (mask.infinity) bytes[0] |= 64;\n    if (mask.sort) bytes[0] |= 32;\n    return bytes;\n}\nfunction pointG1ToBytes(_c, point, isComp) {\n    const { BYTES: L, ORDER: P } = Fp;\n    const is0 = point.is0();\n    const { x, y } = point.toAffine();\n    if (isComp) {\n        if (is0) return COMPZERO.slice();\n        const sort = Boolean(y * _2n / P);\n        return setMask((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(x, L), {\n            compressed: true,\n            sort\n        });\n    } else {\n        if (is0) {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.concatBytes)(Uint8Array.of(0x40), new Uint8Array(2 * L - 1));\n        } else {\n            return (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(x, L), (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(y, L));\n        }\n    }\n}\nfunction signatureG1ToBytes(point) {\n    point.assertValidity();\n    const { BYTES: L, ORDER: P } = Fp;\n    const { x, y } = point.toAffine();\n    if (point.is0()) return COMPZERO.slice();\n    const sort = Boolean(y * _2n / P);\n    return setMask((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(x, L), {\n        compressed: true,\n        sort\n    });\n}\nfunction pointG1FromBytes(bytes) {\n    const { compressed, infinity, sort, value } = parseMask(bytes);\n    const { BYTES: L, ORDER: P } = Fp;\n    if (value.length === 48 && compressed) {\n        const compressedValue = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(value);\n        // Zero\n        const x = Fp.create(compressedValue & (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(Fp.BITS));\n        if (infinity) {\n            if (x !== _0n) throw new Error(\"invalid G1 point: non-empty, at infinity, with compression\");\n            return {\n                x: _0n,\n                y: _0n\n            };\n        }\n        const right = Fp.add(Fp.pow(x, _3n), Fp.create(bls12_381_CURVE_G1.b)); // y² = x³ + b\n        let y = Fp.sqrt(right);\n        if (!y) throw new Error(\"invalid G1 point: compressed point\");\n        if (y * _2n / P !== BigInt(sort)) y = Fp.neg(y);\n        return {\n            x: Fp.create(x),\n            y: Fp.create(y)\n        };\n    } else if (value.length === 96 && !compressed) {\n        // Check if the infinity flag is set\n        const x = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(value.subarray(0, L));\n        const y = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(value.subarray(L));\n        if (infinity) {\n            if (x !== _0n || y !== _0n) throw new Error(\"G1: non-empty point at infinity\");\n            return bls12_381.G1.Point.ZERO.toAffine();\n        }\n        return {\n            x: Fp.create(x),\n            y: Fp.create(y)\n        };\n    } else {\n        throw new Error(\"invalid G1 point: expected 48/96 bytes\");\n    }\n}\nfunction signatureG1FromBytes(hex) {\n    const { infinity, sort, value } = parseMask((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"signatureHex\", hex, 48));\n    const P = Fp.ORDER;\n    const Point = bls12_381.G1.Point;\n    const compressedValue = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(value);\n    // Zero\n    if (infinity) return Point.ZERO;\n    const x = Fp.create(compressedValue & (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(Fp.BITS));\n    const right = Fp.add(Fp.pow(x, _3n), Fp.create(bls12_381_CURVE_G1.b)); // y² = x³ + b\n    let y = Fp.sqrt(right);\n    if (!y) throw new Error(\"invalid G1 point: compressed\");\n    const aflag = BigInt(sort);\n    if (y * _2n / P !== aflag) y = Fp.neg(y);\n    const point = Point.fromAffine({\n        x,\n        y\n    });\n    point.assertValidity();\n    return point;\n}\nfunction pointG2ToBytes(_c, point, isComp) {\n    const { BYTES: L, ORDER: P } = Fp;\n    const is0 = point.is0();\n    const { x, y } = point.toAffine();\n    if (isComp) {\n        if (is0) return (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.concatBytes)(COMPZERO, (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(_0n, L));\n        const flag = Boolean(y.c1 === _0n ? y.c0 * _2n / P : y.c1 * _2n / P);\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.concatBytes)(setMask((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(x.c1, L), {\n            compressed: true,\n            sort: flag\n        }), (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(x.c0, L));\n    } else {\n        if (is0) return (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.concatBytes)(Uint8Array.of(0x40), new Uint8Array(4 * L - 1));\n        const { re: x0, im: x1 } = Fp2.reim(x);\n        const { re: y0, im: y1 } = Fp2.reim(y);\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(x1, L), (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(x0, L), (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(y1, L), (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(y0, L));\n    }\n}\nfunction signatureG2ToBytes(point) {\n    point.assertValidity();\n    const { BYTES: L } = Fp;\n    if (point.is0()) return (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.concatBytes)(COMPZERO, (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(_0n, L));\n    const { x, y } = point.toAffine();\n    const { re: x0, im: x1 } = Fp2.reim(x);\n    const { re: y0, im: y1 } = Fp2.reim(y);\n    const tmp = y1 > _0n ? y1 * _2n : y0 * _2n;\n    const sort = Boolean(tmp / Fp.ORDER & _1n);\n    const z2 = x0;\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.concatBytes)(setMask((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(x1, L), {\n        sort,\n        compressed: true\n    }), (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(z2, L));\n}\nfunction pointG2FromBytes(bytes) {\n    const { BYTES: L, ORDER: P } = Fp;\n    const { compressed, infinity, sort, value } = parseMask(bytes);\n    if (!compressed && !infinity && sort || // 00100000\n    !compressed && infinity && sort || // 01100000\n    sort && infinity && compressed // 11100000\n    ) {\n        throw new Error(\"invalid encoding flag: \" + (bytes[0] & 224));\n    }\n    const slc = (b, from, to)=>(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(b.slice(from, to));\n    if (value.length === 96 && compressed) {\n        if (infinity) {\n            // check that all bytes are 0\n            if (value.reduce((p, c)=>p !== 0 ? c + 1 : c, 0) > 0) {\n                throw new Error(\"invalid G2 point: compressed\");\n            }\n            return {\n                x: Fp2.ZERO,\n                y: Fp2.ZERO\n            };\n        }\n        const x_1 = slc(value, 0, L);\n        const x_0 = slc(value, L, 2 * L);\n        const x = Fp2.create({\n            c0: Fp.create(x_0),\n            c1: Fp.create(x_1)\n        });\n        const right = Fp2.add(Fp2.pow(x, _3n), bls12_381_CURVE_G2.b); // y² = x³ + 4 * (u+1) = x³ + b\n        let y = Fp2.sqrt(right);\n        const Y_bit = y.c1 === _0n ? y.c0 * _2n / P : y.c1 * _2n / P ? _1n : _0n;\n        y = sort && Y_bit > 0 ? y : Fp2.neg(y);\n        return {\n            x,\n            y\n        };\n    } else if (value.length === 192 && !compressed) {\n        if (infinity) {\n            if (value.reduce((p, c)=>p !== 0 ? c + 1 : c, 0) > 0) {\n                throw new Error(\"invalid G2 point: uncompressed\");\n            }\n            return {\n                x: Fp2.ZERO,\n                y: Fp2.ZERO\n            };\n        }\n        const x1 = slc(value, 0 * L, 1 * L);\n        const x0 = slc(value, 1 * L, 2 * L);\n        const y1 = slc(value, 2 * L, 3 * L);\n        const y0 = slc(value, 3 * L, 4 * L);\n        return {\n            x: Fp2.fromBigTuple([\n                x0,\n                x1\n            ]),\n            y: Fp2.fromBigTuple([\n                y0,\n                y1\n            ])\n        };\n    } else {\n        throw new Error(\"invalid G2 point: expected 96/192 bytes\");\n    }\n}\nfunction signatureG2FromBytes(hex) {\n    const { ORDER: P } = Fp;\n    // TODO: Optimize, it's very slow because of sqrt.\n    const { infinity, sort, value } = parseMask((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)(\"signatureHex\", hex));\n    const Point = bls12_381.G2.Point;\n    const half = value.length / 2;\n    if (half !== 48 && half !== 96) throw new Error(\"invalid compressed signature length, expected 96/192 bytes\");\n    const z1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(value.slice(0, half));\n    const z2 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(value.slice(half));\n    // Indicates the infinity point\n    if (infinity) return Point.ZERO;\n    const x1 = Fp.create(z1 & (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(Fp.BITS));\n    const x2 = Fp.create(z2);\n    const x = Fp2.create({\n        c0: x2,\n        c1: x1\n    });\n    const y2 = Fp2.add(Fp2.pow(x, _3n), bls12_381_CURVE_G2.b); // y² = x³ + 4\n    // The slow part\n    let y = Fp2.sqrt(y2);\n    if (!y) throw new Error(\"Failed to find a square root\");\n    // Choose the y whose leftmost bit of the imaginary part is equal to the a_flag1\n    // If y1 happens to be zero, then use the bit of y0\n    const { re: y0, im: y1 } = Fp2.reim(y);\n    const aflag1 = BigInt(sort);\n    const isGreater = y1 > _0n && y1 * _2n / P !== aflag1;\n    const is0 = y1 === _0n && y0 * _2n / P !== aflag1;\n    if (isGreater || is0) y = Fp2.neg(y);\n    const point = Point.fromAffine({\n        x,\n        y\n    });\n    point.assertValidity();\n    return point;\n}\n/**\n * bls12-381 pairing-friendly curve.\n * @example\n * import { bls12_381 as bls } from '@noble/curves/bls12-381';\n * // G1 keys, G2 signatures\n * const privateKey = '67d53f170b908cabb9eb326c3c337762d59289a8fec79f7bc9254b584b73265c';\n * const message = '64726e3da8';\n * const publicKey = bls.getPublicKey(privateKey);\n * const signature = bls.sign(message, privateKey);\n * const isValid = bls.verify(signature, message, publicKey);\n */ const bls12_381 = (0,_abstract_bls_js__WEBPACK_IMPORTED_MODULE_5__.bls)({\n    // Fields\n    fields: {\n        Fp,\n        Fp2,\n        Fp6,\n        Fp12,\n        Fr: bls12_381_Fr\n    },\n    // G1: y² = x³ + 4\n    G1: {\n        ...bls12_381_CURVE_G1,\n        Fp,\n        htfDefaults: {\n            ...htfDefaults,\n            m: 1,\n            DST: \"BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_\"\n        },\n        wrapPrivateKey: true,\n        allowInfinityPoint: true,\n        // Checks is the point resides in prime-order subgroup.\n        // point.isTorsionFree() should return true for valid points\n        // It returns false for shitty points.\n        // https://eprint.iacr.org/2021/1130.pdf\n        isTorsionFree: (c, point)=>{\n            // GLV endomorphism ψ(P)\n            const beta = BigInt(\"0x5f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe\");\n            const phi = new c(Fp.mul(point.X, beta), point.Y, point.Z);\n            // TODO: unroll\n            const xP = point.multiplyUnsafe(BLS_X).negate(); // [x]P\n            const u2P = xP.multiplyUnsafe(BLS_X); // [u2]P\n            return u2P.equals(phi);\n        },\n        // Clear cofactor of G1\n        // https://eprint.iacr.org/2019/403\n        clearCofactor: (_c, point)=>{\n            // return this.multiplyUnsafe(CURVE.h);\n            return point.multiplyUnsafe(BLS_X).add(point); // x*P + P\n        },\n        mapToCurve: mapToG1,\n        fromBytes: pointG1FromBytes,\n        toBytes: pointG1ToBytes,\n        ShortSignature: {\n            fromBytes (bytes) {\n                (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.abytes)(bytes);\n                return signatureG1FromBytes(bytes);\n            },\n            fromHex (hex) {\n                return signatureG1FromBytes(hex);\n            },\n            toBytes (point) {\n                return signatureG1ToBytes(point);\n            },\n            toRawBytes (point) {\n                return signatureG1ToBytes(point);\n            },\n            toHex (point) {\n                return (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.bytesToHex)(signatureG1ToBytes(point));\n            }\n        }\n    },\n    G2: {\n        ...bls12_381_CURVE_G2,\n        Fp: Fp2,\n        // https://datatracker.ietf.org/doc/html/rfc9380#name-clearing-the-cofactor\n        // https://datatracker.ietf.org/doc/html/rfc9380#name-cofactor-clearing-for-bls12\n        hEff: BigInt(\"0xbc69f08f2ee75b3584c6a0ea91b352888e2a8e9145ad7689986ff031508ffe1329c2f178731db956d82bf015d1212b02ec0ec69d7477c1ae954cbc06689f6a359894c0adebbf6b4e8020005aaa95551\"),\n        htfDefaults: {\n            ...htfDefaults\n        },\n        wrapPrivateKey: true,\n        allowInfinityPoint: true,\n        mapToCurve: mapToG2,\n        // Checks is the point resides in prime-order subgroup.\n        // point.isTorsionFree() should return true for valid points\n        // It returns false for shitty points.\n        // https://eprint.iacr.org/2021/1130.pdf\n        // Older version: https://eprint.iacr.org/2019/814.pdf\n        isTorsionFree: (c, P)=>{\n            return P.multiplyUnsafe(BLS_X).negate().equals(G2psi(c, P)); // ψ(P) == [u](P)\n        },\n        // Maps the point into the prime-order subgroup G2.\n        // clear_cofactor_bls12381_g2 from RFC 9380.\n        // https://eprint.iacr.org/2017/419.pdf\n        // prettier-ignore\n        clearCofactor: (c, P)=>{\n            const x = BLS_X;\n            let t1 = P.multiplyUnsafe(x).negate(); // [-x]P\n            let t2 = G2psi(c, P); // Ψ(P)\n            let t3 = P.double(); // 2P\n            t3 = G2psi2(c, t3); // Ψ²(2P)\n            t3 = t3.subtract(t2); // Ψ²(2P) - Ψ(P)\n            t2 = t1.add(t2); // [-x]P + Ψ(P)\n            t2 = t2.multiplyUnsafe(x).negate(); // [x²]P - [x]Ψ(P)\n            t3 = t3.add(t2); // Ψ²(2P) - Ψ(P) + [x²]P - [x]Ψ(P)\n            t3 = t3.subtract(t1); // Ψ²(2P) - Ψ(P) + [x²]P - [x]Ψ(P) + [x]P\n            const Q = t3.subtract(P); // Ψ²(2P) - Ψ(P) + [x²]P - [x]Ψ(P) + [x]P - 1P\n            return Q; // [x²-x-1]P + [x-1]Ψ(P) + Ψ²(2P)\n        },\n        fromBytes: pointG2FromBytes,\n        toBytes: pointG2ToBytes,\n        Signature: {\n            fromBytes (bytes) {\n                (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.abytes)(bytes);\n                return signatureG2FromBytes(bytes);\n            },\n            fromHex (hex) {\n                return signatureG2FromBytes(hex);\n            },\n            toBytes (point) {\n                return signatureG2ToBytes(point);\n            },\n            toRawBytes (point) {\n                return signatureG2ToBytes(point);\n            },\n            toHex (point) {\n                return (0,_utils_js__WEBPACK_IMPORTED_MODULE_4__.bytesToHex)(signatureG2ToBytes(point));\n            }\n        }\n    },\n    params: {\n        ateLoopSize: BLS_X,\n        r: bls12_381_CURVE_G1.n,\n        xNegative: true,\n        twistType: \"multiplicative\"\n    },\n    htfDefaults,\n    hash: _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_3__.sha256\n});\n// 3-isogeny map from E' to E https://www.rfc-editor.org/rfc/rfc9380#appendix-E.3\nconst isogenyMapG2 = (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_6__.isogenyMap)(Fp2, [\n    // xNum\n    [\n        [\n            \"0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6\",\n            \"0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6\"\n        ],\n        [\n            \"0x0\",\n            \"0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71a\"\n        ],\n        [\n            \"0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71e\",\n            \"0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38d\"\n        ],\n        [\n            \"0x171d6541fa38ccfaed6dea691f5fb614cb14b4e7f4e810aa22d6108f142b85757098e38d0f671c7188e2aaaaaaaa5ed1\",\n            \"0x0\"\n        ]\n    ],\n    // xDen\n    [\n        [\n            \"0x0\",\n            \"0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa63\"\n        ],\n        [\n            \"0xc\",\n            \"0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa9f\"\n        ],\n        [\n            \"0x1\",\n            \"0x0\"\n        ]\n    ],\n    // yNum\n    [\n        [\n            \"0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706\",\n            \"0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706\"\n        ],\n        [\n            \"0x0\",\n            \"0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97be\"\n        ],\n        [\n            \"0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71c\",\n            \"0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38f\"\n        ],\n        [\n            \"0x124c9ad43b6cf79bfbf7043de3811ad0761b0f37a1e26286b0e977c69aa274524e79097a56dc4bd9e1b371c71c718b10\",\n            \"0x0\"\n        ]\n    ],\n    // yDen\n    [\n        [\n            \"0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb\",\n            \"0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb\"\n        ],\n        [\n            \"0x0\",\n            \"0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa9d3\"\n        ],\n        [\n            \"0x12\",\n            \"0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa99\"\n        ],\n        [\n            \"0x1\",\n            \"0x0\"\n        ]\n    ]\n].map((i)=>i.map((pair)=>Fp2.fromBigTuple(pair.map(BigInt)))));\n// 11-isogeny map from E' to E\nconst isogenyMapG1 = (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_6__.isogenyMap)(Fp, [\n    // xNum\n    [\n        \"0x11a05f2b1e833340b809101dd99815856b303e88a2d7005ff2627b56cdb4e2c85610c2d5f2e62d6eaeac1662734649b7\",\n        \"0x17294ed3e943ab2f0588bab22147a81c7c17e75b2f6a8417f565e33c70d1e86b4838f2a6f318c356e834eef1b3cb83bb\",\n        \"0xd54005db97678ec1d1048c5d10a9a1bce032473295983e56878e501ec68e25c958c3e3d2a09729fe0179f9dac9edcb0\",\n        \"0x1778e7166fcc6db74e0609d307e55412d7f5e4656a8dbf25f1b33289f1b330835336e25ce3107193c5b388641d9b6861\",\n        \"0xe99726a3199f4436642b4b3e4118e5499db995a1257fb3f086eeb65982fac18985a286f301e77c451154ce9ac8895d9\",\n        \"0x1630c3250d7313ff01d1201bf7a74ab5db3cb17dd952799b9ed3ab9097e68f90a0870d2dcae73d19cd13c1c66f652983\",\n        \"0xd6ed6553fe44d296a3726c38ae652bfb11586264f0f8ce19008e218f9c86b2a8da25128c1052ecaddd7f225a139ed84\",\n        \"0x17b81e7701abdbe2e8743884d1117e53356de5ab275b4db1a682c62ef0f2753339b7c8f8c8f475af9ccb5618e3f0c88e\",\n        \"0x80d3cf1f9a78fc47b90b33563be990dc43b756ce79f5574a2c596c928c5d1de4fa295f296b74e956d71986a8497e317\",\n        \"0x169b1f8e1bcfa7c42e0c37515d138f22dd2ecb803a0c5c99676314baf4bb1b7fa3190b2edc0327797f241067be390c9e\",\n        \"0x10321da079ce07e272d8ec09d2565b0dfa7dccdde6787f96d50af36003b14866f69b771f8c285decca67df3f1605fb7b\",\n        \"0x6e08c248e260e70bd1e962381edee3d31d79d7e22c837bc23c0bf1bc24c6b68c24b1b80b64d391fa9c8ba2e8ba2d229\"\n    ],\n    // xDen\n    [\n        \"0x8ca8d548cff19ae18b2e62f4bd3fa6f01d5ef4ba35b48ba9c9588617fc8ac62b558d681be343df8993cf9fa40d21b1c\",\n        \"0x12561a5deb559c4348b4711298e536367041e8ca0cf0800c0126c2588c48bf5713daa8846cb026e9e5c8276ec82b3bff\",\n        \"0xb2962fe57a3225e8137e629bff2991f6f89416f5a718cd1fca64e00b11aceacd6a3d0967c94fedcfcc239ba5cb83e19\",\n        \"0x3425581a58ae2fec83aafef7c40eb545b08243f16b1655154cca8abc28d6fd04976d5243eecf5c4130de8938dc62cd8\",\n        \"0x13a8e162022914a80a6f1d5f43e7a07dffdfc759a12062bb8d6b44e833b306da9bd29ba81f35781d539d395b3532a21e\",\n        \"0xe7355f8e4e667b955390f7f0506c6e9395735e9ce9cad4d0a43bcef24b8982f7400d24bc4228f11c02df9a29f6304a5\",\n        \"0x772caacf16936190f3e0c63e0596721570f5799af53a1894e2e073062aede9cea73b3538f0de06cec2574496ee84a3a\",\n        \"0x14a7ac2a9d64a8b230b3f5b074cf01996e7f63c21bca68a81996e1cdf9822c580fa5b9489d11e2d311f7d99bbdcc5a5e\",\n        \"0xa10ecf6ada54f825e920b3dafc7a3cce07f8d1d7161366b74100da67f39883503826692abba43704776ec3a79a1d641\",\n        \"0x95fc13ab9e92ad4476d6e3eb3a56680f682b4ee96f7d03776df533978f31c1593174e4b4b7865002d6384d168ecdd0a\",\n        \"0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001\"\n    ],\n    // yNum\n    [\n        \"0x90d97c81ba24ee0259d1f094980dcfa11ad138e48a869522b52af6c956543d3cd0c7aee9b3ba3c2be9845719707bb33\",\n        \"0x134996a104ee5811d51036d776fb46831223e96c254f383d0f906343eb67ad34d6c56711962fa8bfe097e75a2e41c696\",\n        \"0xcc786baa966e66f4a384c86a3b49942552e2d658a31ce2c344be4b91400da7d26d521628b00523b8dfe240c72de1f6\",\n        \"0x1f86376e8981c217898751ad8746757d42aa7b90eeb791c09e4a3ec03251cf9de405aba9ec61deca6355c77b0e5f4cb\",\n        \"0x8cc03fdefe0ff135caf4fe2a21529c4195536fbe3ce50b879833fd221351adc2ee7f8dc099040a841b6daecf2e8fedb\",\n        \"0x16603fca40634b6a2211e11db8f0a6a074a7d0d4afadb7bd76505c3d3ad5544e203f6326c95a807299b23ab13633a5f0\",\n        \"0x4ab0b9bcfac1bbcb2c977d027796b3ce75bb8ca2be184cb5231413c4d634f3747a87ac2460f415ec961f8855fe9d6f2\",\n        \"0x987c8d5333ab86fde9926bd2ca6c674170a05bfe3bdd81ffd038da6c26c842642f64550fedfe935a15e4ca31870fb29\",\n        \"0x9fc4018bd96684be88c9e221e4da1bb8f3abd16679dc26c1e8b6e6a1f20cabe69d65201c78607a360370e577bdba587\",\n        \"0xe1bba7a1186bdb5223abde7ada14a23c42a0ca7915af6fe06985e7ed1e4d43b9b3f7055dd4eba6f2bafaaebca731c30\",\n        \"0x19713e47937cd1be0dfd0b8f1d43fb93cd2fcbcb6caf493fd1183e416389e61031bf3a5cce3fbafce813711ad011c132\",\n        \"0x18b46a908f36f6deb918c143fed2edcc523559b8aaf0c2462e6bfe7f911f643249d9cdf41b44d606ce07c8a4d0074d8e\",\n        \"0xb182cac101b9399d155096004f53f447aa7b12a3426b08ec02710e807b4633f06c851c1919211f20d4c04f00b971ef8\",\n        \"0x245a394ad1eca9b72fc00ae7be315dc757b3b080d4c158013e6632d3c40659cc6cf90ad1c232a6442d9d3f5db980133\",\n        \"0x5c129645e44cf1102a159f748c4a3fc5e673d81d7e86568d9ab0f5d396a7ce46ba1049b6579afb7866b1e715475224b\",\n        \"0x15e6be4e990f03ce4ea50b3b42df2eb5cb181d8f84965a3957add4fa95af01b2b665027efec01c7704b456be69c8b604\"\n    ],\n    // yDen\n    [\n        \"0x16112c4c3a9c98b252181140fad0eae9601a6de578980be6eec3232b5be72e7a07f3688ef60c206d01479253b03663c1\",\n        \"0x1962d75c2381201e1a0cbd6c43c348b885c84ff731c4d59ca4a10356f453e01f78a4260763529e3532f6102c2e49a03d\",\n        \"0x58df3306640da276faaae7d6e8eb15778c4855551ae7f310c35a5dd279cd2eca6757cd636f96f891e2538b53dbf67f2\",\n        \"0x16b7d288798e5395f20d23bf89edb4d1d115c5dbddbcd30e123da489e726af41727364f2c28297ada8d26d98445f5416\",\n        \"0xbe0e079545f43e4b00cc912f8228ddcc6d19c9f0f69bbb0542eda0fc9dec916a20b15dc0fd2ededda39142311a5001d\",\n        \"0x8d9e5297186db2d9fb266eaac783182b70152c65550d881c5ecd87b6f0f5a6449f38db9dfa9cce202c6477faaf9b7ac\",\n        \"0x166007c08a99db2fc3ba8734ace9824b5eecfdfa8d0cf8ef5dd365bc400a0051d5fa9c01a58b1fb93d1a1399126a775c\",\n        \"0x16a3ef08be3ea7ea03bcddfabba6ff6ee5a4375efa1f4fd7feb34fd206357132b920f5b00801dee460ee415a15812ed9\",\n        \"0x1866c8ed336c61231a1be54fd1d74cc4f9fb0ce4c6af5920abc5750c4bf39b4852cfe2f7bb9248836b233d9d55535d4a\",\n        \"0x167a55cda70a6e1cea820597d94a84903216f763e13d87bb5308592e7ea7d4fbc7385ea3d529b35e346ef48bb8913f55\",\n        \"0x4d2f259eea405bd48f010a01ad2911d9c6dd039bb61a6290e591b36e636a5c871a5c29f4f83060400f8b49cba8f6aa8\",\n        \"0xaccbb67481d033ff5852c1e48c50c477f94ff8aefce42d28c0f9a88cea7913516f968986f7ebbea9684b529e2561092\",\n        \"0xad6b9514c767fe3c3613144b45f1496543346d98adf02267d5ceef9a00d9b8693000763e3b90ac11e99b138573345cc\",\n        \"0x2660400eb2e4f3b628bdd0d53cd76f2bf565b94e72927c1cb748df27942480e420517bd8714cc80d1fadc1326ed06f7\",\n        \"0xe0fa1d816ddc03e6b24255e0d7819c171c40f65e273b853324efcd6356caa205ca2f570f13497804415473a1d634b8f\",\n        \"0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001\"\n    ]\n].map((i)=>i.map((j)=>BigInt(j))));\n// Optimized SWU Map - Fp to G1\nconst G1_SWU = (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_7__.mapToCurveSimpleSWU)(Fp, {\n    A: Fp.create(BigInt(\"0x144698a3b8e9433d693a02c96d4982b0ea985383ee66a8d8e8981aefd881ac98936f8da0e0f97f5cf428082d584c1d\")),\n    B: Fp.create(BigInt(\"0x12e2908d11688030018b12e8753eee3b2016c1f0f24f4070a0b9c14fcef35ef55a23215a316ceaa5d1cc48e98e172be0\")),\n    Z: Fp.create(BigInt(11))\n});\n// SWU Map - Fp2 to G2': y² = x³ + 240i * x + 1012 + 1012i\nconst G2_SWU = (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_7__.mapToCurveSimpleSWU)(Fp2, {\n    A: Fp2.create({\n        c0: Fp.create(_0n),\n        c1: Fp.create(BigInt(240))\n    }),\n    B: Fp2.create({\n        c0: Fp.create(BigInt(1012)),\n        c1: Fp.create(BigInt(1012))\n    }),\n    Z: Fp2.create({\n        c0: Fp.create(BigInt(-2)),\n        c1: Fp.create(BigInt(-1))\n    })\n});\nfunction mapToG1(scalars) {\n    const { x, y } = G1_SWU(Fp.create(scalars[0]));\n    return isogenyMapG1(x, y);\n}\nfunction mapToG2(scalars) {\n    const { x, y } = G2_SWU(Fp2.fromBigTuple(scalars));\n    return isogenyMapG2(x, y);\n} //# sourceMappingURL=bls12-381.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjkuNy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYmxzMTItMzgxLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Q0E2RUMsR0FDRCxvRUFBb0UsR0FDckI7QUFDUDtBQUNNO0FBQ2dGO0FBQzlILFFBQVE7QUFDaUQ7QUFDRztBQUNLO0FBQ2pFLHFFQUFxRTtBQUNyRSxrQkFBa0I7QUFDbEIsTUFBTWUsTUFBTUMsT0FBTyxJQUFJQyxNQUFNRCxPQUFPLElBQUlFLE1BQU1GLE9BQU8sSUFBSUcsTUFBTUgsT0FBTyxJQUFJSSxNQUFNSixPQUFPO0FBQ3ZGLGtCQUFrQjtBQUNsQix5RUFBeUU7QUFDekUsa0VBQWtFO0FBQ2xFLCtDQUErQztBQUMvQyxNQUFNSyxRQUFRTCxPQUFPO0FBQ3JCLGlEQUFpRDtBQUNqRCxvQkFBb0I7QUFDcEIsTUFBTU0sWUFBWWxCLGlEQUFNQSxDQUFDaUI7QUFDekIsV0FBVztBQUNYLHlFQUF5RTtBQUN6RSwrQkFBK0I7QUFDL0IsNERBQTREO0FBQzVELGlEQUFpRDtBQUNqRCx3REFBd0Q7QUFDeEQsY0FBYztBQUNkLDJCQUEyQjtBQUMzQiwrQkFBK0I7QUFDL0IsNkJBQTZCO0FBQzdCLDBIQUEwSDtBQUMxSCwwSEFBMEg7QUFDMUgsTUFBTUUscUJBQXFCO0lBQ3ZCQyxHQUFHUixPQUFPO0lBQ1ZTLEdBQUdULE9BQU87SUFDVlUsR0FBR1YsT0FBTztJQUNWVyxHQUFHWjtJQUNIYSxHQUFHUjtJQUNIUyxJQUFJYixPQUFPO0lBQ1hjLElBQUlkLE9BQU87QUFDZjtBQUNBLGVBQWU7QUFDUixNQUFNZSxlQUFlN0IsMkRBQUtBLENBQUNxQixtQkFBbUJFLENBQUMsRUFBRTtJQUNwRE8sY0FBYztJQUNkQyxN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QVksQ0FBQ3NIO0lBQ3pDLE9BQU9WLGFBQWEzSSxHQUFHb0Q7QUFDM0IsRUFDQSxxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3Rhc2NhbS1wcm90b2NvbC8uL25vZGVfbW9kdWxlcy8ucG5wbS9Abm9ibGUrY3VydmVzQDEuOS43L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9ibHMxMi0zODEuanM/ZjYyMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIGJsczEyLTM4MSBpcyBwYWlyaW5nLWZyaWVuZGx5IEJhcnJldG8tTHlubi1TY290dCBlbGxpcHRpYyBjdXJ2ZSBjb25zdHJ1Y3Rpb24gYWxsb3dpbmcgdG86XG5cbiogQ29uc3RydWN0IHprLVNOQVJLcyBhdCB0aGUgfjEyMC1iaXQgc2VjdXJpdHksIGFzIHBlciBbQmFyYnVsZXNjdS1EdXF1ZXNuZSAyMDE3XShodHRwczovL2hhbC5zY2llbmNlL2hhbC0wMTUzNDEwMS9maWxlL21haW4ucGRmKVxuKiBFZmZpY2llbnRseSB2ZXJpZnkgTiBhZ2dyZWdhdGUgc2lnbmF0dXJlcyB3aXRoIDEgcGFpcmluZyBhbmQgTiBlYyBhZGRpdGlvbnM6XG50aGUgQm9uZWgtTHlubi1TaGFjaGFtIHNpZ25hdHVyZSBzY2hlbWUgaXMgb3JkZXJzIG9mIG1hZ25pdHVkZSBtb3JlIGVmZmljaWVudCB0aGFuIFNjaG5vcnJcblxuQkxTIGNhbiBtZWFuIDIgZGlmZmVyZW50IHRoaW5nczpcblxuKiBCYXJyZXRvLUx5bm4tU2NvdHQ6IEJMUzEyLCBhIFBhaXJpbmcgRnJpZW5kbHkgRWxsaXB0aWMgQ3VydmVcbiogQm9uZWgtTHlubi1TaGFjaGFtOiBBIFNpZ25hdHVyZSBTY2hlbWUuXG5cbiMjIyBTdW1tYXJ5XG5cbjEuIEJMUyBSZWxpZXMgb24gZXhwZW5zaXZlIGJpbGluZWFyIHBhaXJpbmdcbjIuIFNlY3JldCBLZXlzOiAzMiBieXRlc1xuMy4gUHVibGljIEtleXM6IDQ4IE9SIDk2IGJ5dGVzIC0gYmlnLWVuZGlhbiB4IGNvb3JkaW5hdGUgb2YgcG9pbnQgb24gRzEgT1IgRzIgY3VydmVcbjQuIFNpZ25hdHVyZXM6IDk2IE9SIDQ4IGJ5dGVzIC0gYmlnLWVuZGlhbiB4IGNvb3JkaW5hdGUgb2YgcG9pbnQgb24gRzIgT1IgRzEgY3VydmVcbjUuIFRoZSAxMiBzdGFuZHMgZm9yIHRoZSBFbWJlZGRpbmcgZGVncmVlLlxuXG5Nb2RlcyBvZiBvcGVyYXRpb246XG5cbiogTG9uZyBzaWduYXR1cmVzOiAgNDgtYnl0ZSBrZXlzICsgOTYtYnl0ZSBzaWdzIChHMSBrZXlzICsgRzIgc2lncykuXG4qIFNob3J0IHNpZ25hdHVyZXM6IDk2LWJ5dGUga2V5cyArIDQ4LWJ5dGUgc2lncyAoRzIga2V5cyArIEcxIHNpZ3MpLlxuXG4jIyMgRm9ybXVsYXNcblxuLSBgUCA9IHBrIHggR2AgLSBwdWJsaWMga2V5c1xuLSBgUyA9IHBrIHggSChtKWAgLSBzaWduaW5nLCB1c2VzIGhhc2gtdG8tY3VydmUgb24gbVxuLSBgZShQLCBIKG0pKSA9PSBlKEcsIFMpYCAtIHZlcmlmaWNhdGlvbiB1c2luZyBwYWlyaW5nc1xuLSBgZShHLCBTKSA9IGUoRywgU1VNKG4pKFNpKSkgPSBNVUwobikoZShHLCBTaSkpYCAtIHNpZ25hdHVyZSBhZ2dyZWdhdGlvblxuXG4jIyMgQ3VydmVzXG5cbkcxIGlzIG9yZGluYXJ5IGVsbGlwdGljIGN1cnZlLiBHMiBpcyBleHRlbnNpb24gZmllbGQgY3VydmUsIHRoaW5rIFwib3ZlciBjb21wbGV4IG51bWJlcnNcIi5cblxuLSBHMTogecKyID0geMKzICsgNFxuLSBHMjogecKyID0geMKzICsgNCh1ICsgMSkgd2hlcmUgdSA9IOKImuKIkjE7IHItb3JkZXIgc3ViZ3JvdXAgb2YgRScoRnDCsiksIE0tdHlwZSB0d2lzdFxuXG4jIyMgVG93ZXJzXG5cblBhaXJpbmcgRzEgKyBHMiBwcm9kdWNlcyBlbGVtZW50IGluIEZw4oKB4oKCLCAxMi1kZWdyZWUgcG9seW5vbWlhbC5cbkZw4oKB4oKCIGlzIHVzdWFsbHkgaW1wbGVtZW50ZWQgdXNpbmcgdG93ZXIgb2YgbG93ZXItZGVncmVlIHBvbHlub21pYWxzIGZvciBzcGVlZC5cblxuLSBGcOKCgeKCgiA9IEZw4oKGwrIgPT4gRnDigoLCs1xuLSBGcCh1KSAvICh1wrIgLSDOsikgd2hlcmUgzrIgPSAtMVxuLSBGcOKCgih2KSAvICh2wrMgLSDOvikgd2hlcmUgzr4gPSB1ICsgMVxuLSBGcOKChih3KSAvICh3wrIgLSDOsykgd2hlcmUgzrMgPSB2XG4tIEZwwrJbdV0gPSBGcC91wrIrMVxuLSBGcOKBtlt2XSA9IEZwwrIvdsKzLTEtdVxuLSBGcMK5wrJbd10gPSBGcOKBti93wrItdlxuXG4jIyMgUGFyYW1zXG5cbiogRW1iZWRkaW5nIGRlZ3JlZSAoayk6IDEyXG4qIFNlZWQgaXMgc29tZXRpbWVzIG5hbWVkIHggb3IgdFxuKiB0ID0gLTE1MTMyMzc2MjIyOTQxNjQyNzUyXG4qIHAgPSAodC0xKcKyICogKHTigbQtdMKyKzEpLzMgKyB0XG4qIHIgPSB04oG0LXTCsisxXG4qIEF0ZSBsb29wIHNpemU6IFhcblxuVG8gdmVyaWZ5IGN1cnZlIHBhcmFtZXRlcnMsIHNlZVxuW3BhaXJpbmctZnJpZW5kbHktY3VydmVzIHNwZWNdKGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaXJ0Zi1jZnJnLXBhaXJpbmctZnJpZW5kbHktY3VydmVzLTExKS5cbkJhc2ljIG1hdGggaXMgZG9uZSBvdmVyIGZpbml0ZSBmaWVsZHMgb3ZlciBwLlxuTW9yZSBjb21wbGljYXRlZCBtYXRoIGlzIGRvbmUgb3ZlciBwb2x5bm9taW5hbCBleHRlbnNpb24gZmllbGRzLlxuXG4jIyMgQ29tcGF0aWJpbGl0eSBhbmQgbm90ZXNcbjEuIEl0IGlzIGNvbXBhdGlibGUgd2l0aCBBbGdvcmFuZCwgQ2hpYSwgRGZpbml0eSwgRXRoZXJldW0sIEZpbGVjb2luLCBaRUMuXG5GaWxlY29pbiB1c2VzIGxpdHRsZSBlbmRpYW4gYnl0ZSBhcnJheXMgZm9yIHNlY3JldCBrZXlzIC0gbWFrZSBzdXJlIHRvIHJldmVyc2UgYnl0ZSBvcmRlci5cbjIuIE1ha2Ugc3VyZSB0byBjb3JyZWN0bHkgc2VsZWN0IG1vZGU6IFwibG9uZyBzaWduYXR1cmVcIiBvciBcInNob3J0IHNpZ25hdHVyZVwiLlxuMy4gQ29tcGF0aWJsZSB3aXRoIHNwZWNzOlxuICAgUkZDIDkzODAsXG4gICBbY2ZyZy1wYWlyaW5nLWZyaWVuZGx5LWN1cnZlcy0xMV0oaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pcnRmLWNmcmctcGFpcmluZy1mcmllbmRseS1jdXJ2ZXMtMTEpLFxuICAgW2NmcmctYmxzLXNpZ25hdHVyZS0wNV0oaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvZHJhZnQtaXJ0Zi1jZnJnLWJscy1zaWduYXR1cmUvKS5cblxuICpcbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyLmpzJztcbmltcG9ydCB7IGJscyB9IGZyb20gXCIuL2Fic3RyYWN0L2Jscy5qc1wiO1xuaW1wb3J0IHsgRmllbGQgfSBmcm9tIFwiLi9hYnN0cmFjdC9tb2R1bGFyLmpzXCI7XG5pbXBvcnQgeyBhYnl0ZXMsIGJpdExlbiwgYml0TWFzaywgYnl0ZXNUb0hleCwgYnl0ZXNUb051bWJlckJFLCBjb25jYXRCeXRlcywgZW5zdXJlQnl0ZXMsIG51bWJlclRvQnl0ZXNCRSwgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuLy8gVHlwZXNcbmltcG9ydCB7IGlzb2dlbnlNYXAgfSBmcm9tIFwiLi9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzXCI7XG5pbXBvcnQgeyBwc2lGcm9iZW5pdXMsIHRvd2VyMTIgfSBmcm9tIFwiLi9hYnN0cmFjdC90b3dlci5qc1wiO1xuaW1wb3J0IHsgbWFwVG9DdXJ2ZVNpbXBsZVNXVSwgfSBmcm9tIFwiLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qc1wiO1xuLy8gQmUgZnJpZW5kbHkgdG8gYmFkIEVDTUFTY3JpcHQgcGFyc2VycyBieSBub3QgdXNpbmcgYmlnaW50IGxpdGVyYWxzXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKSwgXzRuID0gQmlnSW50KDQpO1xuLy8gVG8gdmVyaWZ5IG1hdGg6XG4vLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtaXJ0Zi1jZnJnLXBhaXJpbmctZnJpZW5kbHktY3VydmVzLTExXG4vLyBUaGUgQkxTIHBhcmFtZXRlciB4IChzZWVkKSBmb3IgQkxTMTItMzgxLiBOT1RFOiBpdCBpcyBuZWdhdGl2ZSFcbi8vIHggPSAtMl42MyAtIDJeNjIgLSAyXjYwIC0gMl41NyAtIDJeNDggLSAyXjE2XG5jb25zdCBCTFNfWCA9IEJpZ0ludCgnMHhkMjAxMDAwMDAwMDEwMDAwJyk7XG4vLyB0ID0geCAoY2FsbGVkIGRpZmZlcmVudGx5IGluIGRpZmZlcmVudCBwbGFjZXMpXG4vLyBjb25zdCB0ID0gLUJMU19YO1xuY29uc3QgQkxTX1hfTEVOID0gYml0TGVuKEJMU19YKTtcbi8vIGE9MCwgYj00XG4vLyBQIGlzIGNoYXJhY3RlcmlzdGljIG9mIGZpZWxkIEZwLCBpbiB3aGljaCBjdXJ2ZSBjYWxjdWxhdGlvbnMgYXJlIGRvbmUuXG4vLyBwID0gKHQtMSnCsiAqICh04oG0LXTCsisxKS8zICsgdFxuLy8gYmxzMTJfMzgxX0ZwID0gKHQtMW4pKioybiAqICh0Kio0biAtIHQqKjJuICsgMW4pIC8gM24gKyB0XG4vLyByKmggaXMgY3VydmUgb3JkZXIsIGFtb3VudCBvZiBwb2ludHMgb24gY3VydmUsXG4vLyB3aGVyZSByIGlzIG9yZGVyIG9mIHByaW1lIHN1Ymdyb3VwIGFuZCBoIGlzIGNvZmFjdG9yLlxuLy8gciA9IHTigbQtdMKyKzFcbi8vIHIgPSAodCoqNG4gLSB0KioybiArIDFuKVxuLy8gY29mYWN0b3IgaCBvZiBHMTogKHQgLSAxKcKyLzNcbi8vIGNvZmFjdG9yRzEgPSAodC0xbikqKjJuLzNuXG4vLyB4ID0gMzY4NTQxNjc1MzcxMzM4NzAxNjc4MTA4ODMxNTE4MzA3Nzc1Nzk2MTYyMDc5NTc4MjU0NjQwOTg5NDU3ODM3ODY4ODYwNzU5MjM3ODM3NjMxODgzNjA1NDk0NzY3NjM0NTgyMTU0ODEwNDE4NTQ2NDUwN1xuLy8geSA9IDEzMzk1MDY1NDQ5NDQ0NzY0NzMwMjA0NzEzNzk5NDE5MjEyMjE1ODQ5MzM4NzU5MzgzNDk2MjA0MjY1NDM3MzY0MTY1MTE0MjM5NTYzMzM1MDY0NzI3MjQ2NTUzNTMzNjY1MzQ5OTIzOTE3NTY0NDE1NjlcbmNvbnN0IGJsczEyXzM4MV9DVVJWRV9HMSA9IHtcbiAgICBwOiBCaWdJbnQoJzB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYWFiJyksXG4gICAgbjogQmlnSW50KCcweDczZWRhNzUzMjk5ZDdkNDgzMzM5ZDgwODA5YTFkODA1NTNiZGE0MDJmZmZlNWJmZWZmZmZmZmZmMDAwMDAwMDEnKSxcbiAgICBoOiBCaWdJbnQoJzB4Mzk2YzhjMDA1NTU1ZTE1NjhjMDBhYWFiMDAwMGFhYWInKSxcbiAgICBhOiBfMG4sXG4gICAgYjogXzRuLFxuICAgIEd4OiBCaWdJbnQoJzB4MTdmMWQzYTczMTk3ZDc5NDI2OTU2MzhjNGZhOWFjMGZjMzY4OGM0Zjk3NzRiOTA1YTE0ZTNhM2YxNzFiYWM1ODZjNTVlODNmZjk3YTFhZWZmYjNhZjAwYWRiMjJjNmJiJyksXG4gICAgR3k6IEJpZ0ludCgnMHgwOGIzZjQ4MWUzYWFhMGYxYTA5ZTMwZWQ3NDFkOGFlNGZjZjVlMDk1ZDVkMDBhZjYwMGRiMThjYjJjMDRiM2VkZDAzY2M3NDRhMjg4OGFlNDBjYWEyMzI5NDZjNWU3ZTEnKSxcbn07XG4vLyBDVVJWRSBGSUVMRFNcbmV4cG9ydCBjb25zdCBibHMxMl8zODFfRnIgPSBGaWVsZChibHMxMl8zODFfQ1VSVkVfRzEubiwge1xuICAgIG1vZEZyb21CeXRlczogdHJ1ZSxcbiAgICBpc0xFOiB0cnVlLFxufSk7XG5jb25zdCB7IEZwLCBGcDIsIEZwNiwgRnAxMiB9ID0gdG93ZXIxMih7XG4gICAgT1JERVI6IGJsczEyXzM4MV9DVVJWRV9HMS5wLFxuICAgIFhfTEVOOiBCTFNfWF9MRU4sXG4gICAgLy8gRmluaXRlIGV4dGVuc2lvbiBmaWVsZCBvdmVyIGlycmVkdWNpYmxlIHBvbHlub21pbmFsLlxuICAgIC8vIEZwKHUpIC8gKHXCsiAtIM6yKSB3aGVyZSDOsiA9IC0xXG4gICAgRlAyX05PTlJFU0lEVUU6IFtfMW4sIF8xbl0sXG4gICAgRnAybXVsQnlCOiAoeyBjMCwgYzEgfSkgPT4ge1xuICAgICAgICBjb25zdCB0MCA9IEZwLm11bChjMCwgXzRuKTsgLy8gNCAqIGMwXG4gICAgICAgIGNvbnN0IHQxID0gRnAubXVsKGMxLCBfNG4pOyAvLyA0ICogYzFcbiAgICAgICAgLy8gKFQwLVQxKSArIChUMCtUMSkqaVxuICAgICAgICByZXR1cm4geyBjMDogRnAuc3ViKHQwLCB0MSksIGMxOiBGcC5hZGQodDAsIHQxKSB9O1xuICAgIH0sXG4gICAgRnAxMmZpbmFsRXhwb25lbnRpYXRlOiAobnVtKSA9PiB7XG4gICAgICAgIGNvbnN0IHggPSBCTFNfWDtcbiAgICAgICAgLy8gdGhpc14oceKBtikgLyB0aGlzXG4gICAgICAgIGNvbnN0IHQwID0gRnAxMi5kaXYoRnAxMi5mcm9iZW5pdXNNYXAobnVtLCA2KSwgbnVtKTtcbiAgICAgICAgLy8gdDBeKHHCsikgKiB0MFxuICAgICAgICBjb25zdCB0MSA9IEZwMTIubXVsKEZwMTIuZnJvYmVuaXVzTWFwKHQwLCAyKSwgdDApO1xuICAgICAgICBjb25zdCB0MiA9IEZwMTIuY29uanVnYXRlKEZwMTIuX2N5Y2xvdG9taWNFeHAodDEsIHgpKTtcbiAgICAgICAgY29uc3QgdDMgPSBGcDEyLm11bChGcDEyLmNvbmp1Z2F0ZShGcDEyLl9jeWNsb3RvbWljU3F1YXJlKHQxKSksIHQyKTtcbiAgICAgICAgY29uc3QgdDQgPSBGcDEyLmNvbmp1Z2F0ZShGcDEyLl9jeWNsb3RvbWljRXhwKHQzLCB4KSk7XG4gICAgICAgIGNvbnN0IHQ1ID0gRnAxMi5jb25qdWdhdGUoRnAxMi5fY3ljbG90b21pY0V4cCh0NCwgeCkpO1xuICAgICAgICBjb25zdCB0NiA9IEZwMTIubXVsKEZwMTIuY29uanVnYXRlKEZwMTIuX2N5Y2xvdG9taWNFeHAodDUsIHgpKSwgRnAxMi5fY3ljbG90b21pY1NxdWFyZSh0MikpO1xuICAgICAgICBjb25zdCB0NyA9IEZwMTIuY29uanVnYXRlKEZwMTIuX2N5Y2xvdG9taWNFeHAodDYsIHgpKTtcbiAgICAgICAgY29uc3QgdDJfdDVfcG93X3EyID0gRnAxMi5mcm9iZW5pdXNNYXAoRnAxMi5tdWwodDIsIHQ1KSwgMik7XG4gICAgICAgIGNvbnN0IHQ0X3QxX3Bvd19xMyA9IEZwMTIuZnJvYmVuaXVzTWFwKEZwMTIubXVsKHQ0LCB0MSksIDMpO1xuICAgICAgICBjb25zdCB0Nl90MWNfcG93X3ExID0gRnAxMi5mcm9iZW5pdXNNYXAoRnAxMi5tdWwodDYsIEZwMTIuY29uanVnYXRlKHQxKSksIDEpO1xuICAgICAgICBjb25zdCB0N190M2NfdDEgPSBGcDEyLm11bChGcDEyLm11bCh0NywgRnAxMi5jb25qdWdhdGUodDMpKSwgdDEpO1xuICAgICAgICAvLyAodDIgKiB0NSleKHHCsikgKiAodDQgKiB0MSleKHHCsykgKiAodDYgKiB0MS5jb25qKV4ocV4xKSAqIHQ3ICogdDMuY29uaiAqIHQxXG4gICAgICAgIHJldHVybiBGcDEyLm11bChGcDEyLm11bChGcDEyLm11bCh0Ml90NV9wb3dfcTIsIHQ0X3QxX3Bvd19xMyksIHQ2X3QxY19wb3dfcTEpLCB0N190M2NfdDEpO1xuICAgIH0sXG59KTtcbi8vIEdMViBlbmRvbW9ycGhpc20gzqgoUCksIGZvciBmYXN0IGNvZmFjdG9yIGNsZWFyaW5nXG5jb25zdCB7IEcycHNpLCBHMnBzaTIgfSA9IHBzaUZyb2Jlbml1cyhGcCwgRnAyLCBGcDIuZGl2KEZwMi5PTkUsIEZwMi5OT05SRVNJRFVFKSk7IC8vIDEvKHUrMSlcbi8qKlxuICogRGVmYXVsdCBoYXNoX3RvX2ZpZWxkIC8gaGFzaC10by1jdXJ2ZSBmb3IgQkxTLlxuICogbTogMSBmb3IgRzEsIDIgZm9yIEcyXG4gKiBrOiB0YXJnZXQgc2VjdXJpdHkgbGV2ZWwgaW4gYml0c1xuICogaGFzaDogYW55IGZ1bmN0aW9uLCBlLmcuIEJCUysgdXNlcyBCTEFLRTI6IHNlZSBbZ2l0aHViXShodHRwczovL2dpdGh1Yi5jb20vaHlwZXJsZWRnZXIvYXJpZXMtZnJhbWV3b3JrLWdvL2lzc3Vlcy8yMjQ3KS5cbiAqIFBhcmFtZXRlciB2YWx1ZXMgY29tZSBmcm9tIFtzZWN0aW9uIDguOC4yIG9mIFJGQyA5MzgwXShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTguOC4yKS5cbiAqL1xuY29uc3QgaHRmRGVmYXVsdHMgPSBPYmplY3QuZnJlZXplKHtcbiAgICBEU1Q6ICdCTFNfU0lHX0JMUzEyMzgxRzJfWE1EOlNIQS0yNTZfU1NXVV9ST19OVUxfJyxcbiAgICBlbmNvZGVEU1Q6ICdCTFNfU0lHX0JMUzEyMzgxRzJfWE1EOlNIQS0yNTZfU1NXVV9ST19OVUxfJyxcbiAgICBwOiBGcC5PUkRFUixcbiAgICBtOiAyLFxuICAgIGs6IDEyOCxcbiAgICBleHBhbmQ6ICd4bWQnLFxuICAgIGhhc2g6IHNoYTI1Nixcbn0pO1xuLy8gYT0wLCBiPTRcbi8vIGNvZmFjdG9yIGggb2YgRzJcbi8vICh0XjggLSA0dF43ICsgNXReNiAtIDR0XjQgKyA2dF4zIC0gNHReMiAtIDR0ICsgMTMpLzlcbi8vIGNvZmFjdG9yRzIgPSAodCoqOG4gLSA0bip0Kio3biArIDVuKnQqKjZuIC0gNG4qdCoqNG4gKyA2bip0KiozbiAtIDRuKnQqKjJuIC0gNG4qdCsxM24pLzluXG4vLyB4ID0gMzA1OTE0NDM0NDI0NDIxMzcwOTk3MTI1OTgxNDc1Mzc4MTYzNjk4NjQ3MDMyNTQ3NjY0NzU1ODY1OTM3MzIwNjI5MTYzNTMyNDc2ODk1ODQzMjQzMzUwOTU2MzEwNDM0NzAxNzgzNzg4NTc2MzM2NTc1OCp1ICsgMzUyNzAxMDY5NTg3NDY2NjE4MTg3MTM5MTE2MDExMDYwMTQ0ODkwMDI5OTUyNzkyNzc1MjQwMjE5OTA4NjQ0MjM5NzkzNzg1NzM1NzE1MDI2ODczMzQ3NjAwMzQzODY1MTc1OTUyNzYxOTI2MzAzMTYwXG4vLyB5ID0gOTI3NTUzNjY1NDkyMzMyNDU1NzQ3MjAxOTY1Nzc2MDM3ODgwNzU3NzQwMTkzNDUzNTkyOTcwMDI1MDI3OTc4NzkzOTc2ODc3MDAyNjc1NTY0OTgwOTQ5Mjg5NzI3OTU3NTY1NTc1NDMzMzQ0MjE5NTgyKnUgKyAxOTg1MTUwNjAyMjg3MjkxOTM1NTY4MDU0NTIxMTc3MTcxNjM4MzAwODY4OTc4MjE1NjU1NzMwODU5Mzc4NjY1MDY2MzQ0NzI2MzczODIzNzE4NDIzODY5MTA0MjYzMzMzOTg0NjQxNDk0MzQwMzQ3OTA1XG5jb25zdCBibHMxMl8zODFfQ1VSVkVfRzIgPSB7XG4gICAgcDogRnAyLk9SREVSLFxuICAgIG46IGJsczEyXzM4MV9DVVJWRV9HMS5uLFxuICAgIGg6IEJpZ0ludCgnMHg1ZDU0M2E5NTQxNGU3ZjEwOTFkNTA3OTI4NzZhMjAyY2Q5MWRlNDU0NzA4NWFiYWE2OGEyMDViMmU1YTdkZGZhNjI4ZjFjYjRkOWU4MmVmMjE1MzdlMjkzYTY2OTFhZTE2MTZlYzZlNzg2ZjBjNzBjZjFjMzhlMzFjNzIzOGU1JyksXG4gICAgYTogRnAyLlpFUk8sXG4gICAgYjogRnAyLmZyb21CaWdUdXBsZShbXzRuLCBfNG5dKSxcbiAgICBHeDogRnAyLmZyb21CaWdUdXBsZShbXG4gICAgICAgIEJpZ0ludCgnMHgwMjRhYTJiMmYwOGYwYTkxMjYwODA1MjcyZGM1MTA1MWM2ZTQ3YWQ0ZmE0MDNiMDJiNDUxMGI2NDdhZTNkMTc3MGJhYzAzMjZhODA1YmJlZmQ0ODA1NmM4YzEyMWJkYjgnKSxcbiAgICAgICAgQmlnSW50KCcweDEzZTAyYjYwNTI3MTlmNjA3ZGFjZDNhMDg4Mjc0ZjY1NTk2YmQwZDA5OTIwYjYxYWI1ZGE2MWJiZGM3ZjUwNDkzMzRjZjExMjEzOTQ1ZDU3ZTVhYzdkMDU1ZDA0MmI3ZScpLFxuICAgIF0pLFxuICAgIEd5OiBGcDIuZnJvbUJpZ1R1cGxlKFtcbiAgICAgICAgQmlnSW50KCcweDBjZTVkNTI3NzI3ZDZlMTE4Y2M5Y2RjNmRhMmUzNTFhYWRmZDliYWE4Y2JkZDNhNzZkNDI5YTY5NTE2MGQxMmM5MjNhYzljYzNiYWNhMjg5ZTE5MzU0ODYwOGI4MjgwMScpLFxuICAgICAgICBCaWdJbnQoJzB4MDYwNmM0YTAyZWE3MzRjYzMyYWNkMmIwMmJjMjhiOTljYjNlMjg3ZTg1YTc2M2FmMjY3NDkyYWI1NzJlOTlhYjNmMzcwZDI3NWNlYzFkYTFhYWE5MDc1ZmYwNWY3OWJlJyksXG4gICAgXSksXG59O1xuLy8gRW5jb2RpbmcgdXRpbHNcbi8vIENvbXByZXNzZWQgcG9pbnQgb2YgaW5maW5pdHlcbi8vIFNldCBjb21wcmVzc2VkICYgcG9pbnQtYXQtaW5maW5pdHkgYml0c1xuY29uc3QgQ09NUFpFUk8gPSBzZXRNYXNrKEZwLnRvQnl0ZXMoXzBuKSwgeyBpbmZpbml0eTogdHJ1ZSwgY29tcHJlc3NlZDogdHJ1ZSB9KTtcbmZ1bmN0aW9uIHBhcnNlTWFzayhieXRlcykge1xuICAgIC8vIENvcHksIHNvIHdlIGNhbiByZW1vdmUgbWFzayBkYXRhLiBJdCB3aWxsIGJlIHJlbW92ZWQgYWxzbyBsYXRlciwgd2hlbiBGcC5jcmVhdGUgd2lsbCBjYWxsIG1vZHVsby5cbiAgICBieXRlcyA9IGJ5dGVzLnNsaWNlKCk7XG4gICAgY29uc3QgbWFzayA9IGJ5dGVzWzBdICYgMjI0O1xuICAgIGNvbnN0IGNvbXByZXNzZWQgPSAhISgobWFzayA+PiA3KSAmIDEpOyAvLyBjb21wcmVzc2lvbiBiaXQgKDBiMTAwMF8wMDAwKVxuICAgIGNvbnN0IGluZmluaXR5ID0gISEoKG1hc2sgPj4gNikgJiAxKTsgLy8gcG9pbnQgYXQgaW5maW5pdHkgYml0ICgwYjAxMDBfMDAwMClcbiAgICBjb25zdCBzb3J0ID0gISEoKG1hc2sgPj4gNSkgJiAxKTsgLy8gc29ydCBiaXQgKDBiMDAxMF8wMDAwKVxuICAgIGJ5dGVzWzBdICY9IDMxOyAvLyBjbGVhciBtYXNrICh6ZXJvIGZpcnN0IDMgYml0cylcbiAgICByZXR1cm4geyBjb21wcmVzc2VkLCBpbmZpbml0eSwgc29ydCwgdmFsdWU6IGJ5dGVzIH07XG59XG5mdW5jdGlvbiBzZXRNYXNrKGJ5dGVzLCBtYXNrKSB7XG4gICAgaWYgKGJ5dGVzWzBdICYgMjI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldE1hc2s6IG5vbi1lbXB0eSBtYXNrJyk7XG4gICAgaWYgKG1hc2suY29tcHJlc3NlZClcbiAgICAgICAgYnl0ZXNbMF0gfD0gMTI4O1xuICAgIGlmIChtYXNrLmluZmluaXR5KVxuICAgICAgICBieXRlc1swXSB8PSA2NDtcbiAgICBpZiAobWFzay5zb3J0KVxuICAgICAgICBieXRlc1swXSB8PSAzMjtcbiAgICByZXR1cm4gYnl0ZXM7XG59XG5mdW5jdGlvbiBwb2ludEcxVG9CeXRlcyhfYywgcG9pbnQsIGlzQ29tcCkge1xuICAgIGNvbnN0IHsgQllURVM6IEwsIE9SREVSOiBQIH0gPSBGcDtcbiAgICBjb25zdCBpczAgPSBwb2ludC5pczAoKTtcbiAgICBjb25zdCB7IHgsIHkgfSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgaWYgKGlzQ29tcCkge1xuICAgICAgICBpZiAoaXMwKVxuICAgICAgICAgICAgcmV0dXJuIENPTVBaRVJPLnNsaWNlKCk7XG4gICAgICAgIGNvbnN0IHNvcnQgPSBCb29sZWFuKCh5ICogXzJuKSAvIFApO1xuICAgICAgICByZXR1cm4gc2V0TWFzayhudW1iZXJUb0J5dGVzQkUoeCwgTCksIHsgY29tcHJlc3NlZDogdHJ1ZSwgc29ydCB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChpczApIHtcbiAgICAgICAgICAgIHJldHVybiBjb25jYXRCeXRlcyhVaW50OEFycmF5Lm9mKDB4NDApLCBuZXcgVWludDhBcnJheSgyICogTCAtIDEpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjb25jYXRCeXRlcyhudW1iZXJUb0J5dGVzQkUoeCwgTCksIG51bWJlclRvQnl0ZXNCRSh5LCBMKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBzaWduYXR1cmVHMVRvQnl0ZXMocG9pbnQpIHtcbiAgICBwb2ludC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIGNvbnN0IHsgQllURVM6IEwsIE9SREVSOiBQIH0gPSBGcDtcbiAgICBjb25zdCB7IHgsIHkgfSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgaWYgKHBvaW50LmlzMCgpKVxuICAgICAgICByZXR1cm4gQ09NUFpFUk8uc2xpY2UoKTtcbiAgICBjb25zdCBzb3J0ID0gQm9vbGVhbigoeSAqIF8ybikgLyBQKTtcbiAgICByZXR1cm4gc2V0TWFzayhudW1iZXJUb0J5dGVzQkUoeCwgTCksIHsgY29tcHJlc3NlZDogdHJ1ZSwgc29ydCB9KTtcbn1cbmZ1bmN0aW9uIHBvaW50RzFGcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICBjb25zdCB7IGNvbXByZXNzZWQsIGluZmluaXR5LCBzb3J0LCB2YWx1ZSB9ID0gcGFyc2VNYXNrKGJ5dGVzKTtcbiAgICBjb25zdCB7IEJZVEVTOiBMLCBPUkRFUjogUCB9ID0gRnA7XG4gICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gNDggJiYgY29tcHJlc3NlZCkge1xuICAgICAgICBjb25zdCBjb21wcmVzc2VkVmFsdWUgPSBieXRlc1RvTnVtYmVyQkUodmFsdWUpO1xuICAgICAgICAvLyBaZXJvXG4gICAgICAgIGNvbnN0IHggPSBGcC5jcmVhdGUoY29tcHJlc3NlZFZhbHVlICYgYml0TWFzayhGcC5CSVRTKSk7XG4gICAgICAgIGlmIChpbmZpbml0eSkge1xuICAgICAgICAgICAgaWYgKHggIT09IF8wbilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgRzEgcG9pbnQ6IG5vbi1lbXB0eSwgYXQgaW5maW5pdHksIHdpdGggY29tcHJlc3Npb24nKTtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IF8wbiwgeTogXzBuIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmlnaHQgPSBGcC5hZGQoRnAucG93KHgsIF8zbiksIEZwLmNyZWF0ZShibHMxMl8zODFfQ1VSVkVfRzEuYikpOyAvLyB5wrIgPSB4wrMgKyBiXG4gICAgICAgIGxldCB5ID0gRnAuc3FydChyaWdodCk7XG4gICAgICAgIGlmICgheSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBHMSBwb2ludDogY29tcHJlc3NlZCBwb2ludCcpO1xuICAgICAgICBpZiAoKHkgKiBfMm4pIC8gUCAhPT0gQmlnSW50KHNvcnQpKVxuICAgICAgICAgICAgeSA9IEZwLm5lZyh5KTtcbiAgICAgICAgcmV0dXJuIHsgeDogRnAuY3JlYXRlKHgpLCB5OiBGcC5jcmVhdGUoeSkgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUubGVuZ3RoID09PSA5NiAmJiAhY29tcHJlc3NlZCkge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgaW5maW5pdHkgZmxhZyBpcyBzZXRcbiAgICAgICAgY29uc3QgeCA9IGJ5dGVzVG9OdW1iZXJCRSh2YWx1ZS5zdWJhcnJheSgwLCBMKSk7XG4gICAgICAgIGNvbnN0IHkgPSBieXRlc1RvTnVtYmVyQkUodmFsdWUuc3ViYXJyYXkoTCkpO1xuICAgICAgICBpZiAoaW5maW5pdHkpIHtcbiAgICAgICAgICAgIGlmICh4ICE9PSBfMG4gfHwgeSAhPT0gXzBuKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRzE6IG5vbi1lbXB0eSBwb2ludCBhdCBpbmZpbml0eScpO1xuICAgICAgICAgICAgcmV0dXJuIGJsczEyXzM4MS5HMS5Qb2ludC5aRVJPLnRvQWZmaW5lKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgeDogRnAuY3JlYXRlKHgpLCB5OiBGcC5jcmVhdGUoeSkgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBHMSBwb2ludDogZXhwZWN0ZWQgNDgvOTYgYnl0ZXMnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzaWduYXR1cmVHMUZyb21CeXRlcyhoZXgpIHtcbiAgICBjb25zdCB7IGluZmluaXR5LCBzb3J0LCB2YWx1ZSB9ID0gcGFyc2VNYXNrKGVuc3VyZUJ5dGVzKCdzaWduYXR1cmVIZXgnLCBoZXgsIDQ4KSk7XG4gICAgY29uc3QgUCA9IEZwLk9SREVSO1xuICAgIGNvbnN0IFBvaW50ID0gYmxzMTJfMzgxLkcxLlBvaW50O1xuICAgIGNvbnN0IGNvbXByZXNzZWRWYWx1ZSA9IGJ5dGVzVG9OdW1iZXJCRSh2YWx1ZSk7XG4gICAgLy8gWmVyb1xuICAgIGlmIChpbmZpbml0eSlcbiAgICAgICAgcmV0dXJuIFBvaW50LlpFUk87XG4gICAgY29uc3QgeCA9IEZwLmNyZWF0ZShjb21wcmVzc2VkVmFsdWUgJiBiaXRNYXNrKEZwLkJJVFMpKTtcbiAgICBjb25zdCByaWdodCA9IEZwLmFkZChGcC5wb3coeCwgXzNuKSwgRnAuY3JlYXRlKGJsczEyXzM4MV9DVVJWRV9HMS5iKSk7IC8vIHnCsiA9IHjCsyArIGJcbiAgICBsZXQgeSA9IEZwLnNxcnQocmlnaHQpO1xuICAgIGlmICgheSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIEcxIHBvaW50OiBjb21wcmVzc2VkJyk7XG4gICAgY29uc3QgYWZsYWcgPSBCaWdJbnQoc29ydCk7XG4gICAgaWYgKCh5ICogXzJuKSAvIFAgIT09IGFmbGFnKVxuICAgICAgICB5ID0gRnAubmVnKHkpO1xuICAgIGNvbnN0IHBvaW50ID0gUG9pbnQuZnJvbUFmZmluZSh7IHgsIHkgfSk7XG4gICAgcG9pbnQuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICByZXR1cm4gcG9pbnQ7XG59XG5mdW5jdGlvbiBwb2ludEcyVG9CeXRlcyhfYywgcG9pbnQsIGlzQ29tcCkge1xuICAgIGNvbnN0IHsgQllURVM6IEwsIE9SREVSOiBQIH0gPSBGcDtcbiAgICBjb25zdCBpczAgPSBwb2ludC5pczAoKTtcbiAgICBjb25zdCB7IHgsIHkgfSA9IHBvaW50LnRvQWZmaW5lKCk7XG4gICAgaWYgKGlzQ29tcCkge1xuICAgICAgICBpZiAoaXMwKVxuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdEJ5dGVzKENPTVBaRVJPLCBudW1iZXJUb0J5dGVzQkUoXzBuLCBMKSk7XG4gICAgICAgIGNvbnN0IGZsYWcgPSBCb29sZWFuKHkuYzEgPT09IF8wbiA/ICh5LmMwICogXzJuKSAvIFAgOiAoeS5jMSAqIF8ybikgLyBQKTtcbiAgICAgICAgcmV0dXJuIGNvbmNhdEJ5dGVzKHNldE1hc2sobnVtYmVyVG9CeXRlc0JFKHguYzEsIEwpLCB7IGNvbXByZXNzZWQ6IHRydWUsIHNvcnQ6IGZsYWcgfSksIG51bWJlclRvQnl0ZXNCRSh4LmMwLCBMKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoaXMwKVxuICAgICAgICAgICAgcmV0dXJuIGNvbmNhdEJ5dGVzKFVpbnQ4QXJyYXkub2YoMHg0MCksIG5ldyBVaW50OEFycmF5KDQgKiBMIC0gMSkpO1xuICAgICAgICBjb25zdCB7IHJlOiB4MCwgaW06IHgxIH0gPSBGcDIucmVpbSh4KTtcbiAgICAgICAgY29uc3QgeyByZTogeTAsIGltOiB5MSB9ID0gRnAyLnJlaW0oeSk7XG4gICAgICAgIHJldHVybiBjb25jYXRCeXRlcyhudW1iZXJUb0J5dGVzQkUoeDEsIEwpLCBudW1iZXJUb0J5dGVzQkUoeDAsIEwpLCBudW1iZXJUb0J5dGVzQkUoeTEsIEwpLCBudW1iZXJUb0J5dGVzQkUoeTAsIEwpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzaWduYXR1cmVHMlRvQnl0ZXMocG9pbnQpIHtcbiAgICBwb2ludC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIGNvbnN0IHsgQllURVM6IEwgfSA9IEZwO1xuICAgIGlmIChwb2ludC5pczAoKSlcbiAgICAgICAgcmV0dXJuIGNvbmNhdEJ5dGVzKENPTVBaRVJPLCBudW1iZXJUb0J5dGVzQkUoXzBuLCBMKSk7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBwb2ludC50b0FmZmluZSgpO1xuICAgIGNvbnN0IHsgcmU6IHgwLCBpbTogeDEgfSA9IEZwMi5yZWltKHgpO1xuICAgIGNvbnN0IHsgcmU6IHkwLCBpbTogeTEgfSA9IEZwMi5yZWltKHkpO1xuICAgIGNvbnN0IHRtcCA9IHkxID4gXzBuID8geTEgKiBfMm4gOiB5MCAqIF8ybjtcbiAgICBjb25zdCBzb3J0ID0gQm9vbGVhbigodG1wIC8gRnAuT1JERVIpICYgXzFuKTtcbiAgICBjb25zdCB6MiA9IHgwO1xuICAgIHJldHVybiBjb25jYXRCeXRlcyhzZXRNYXNrKG51bWJlclRvQnl0ZXNCRSh4MSwgTCksIHsgc29ydCwgY29tcHJlc3NlZDogdHJ1ZSB9KSwgbnVtYmVyVG9CeXRlc0JFKHoyLCBMKSk7XG59XG5mdW5jdGlvbiBwb2ludEcyRnJvbUJ5dGVzKGJ5dGVzKSB7XG4gICAgY29uc3QgeyBCWVRFUzogTCwgT1JERVI6IFAgfSA9IEZwO1xuICAgIGNvbnN0IHsgY29tcHJlc3NlZCwgaW5maW5pdHksIHNvcnQsIHZhbHVlIH0gPSBwYXJzZU1hc2soYnl0ZXMpO1xuICAgIGlmICgoIWNvbXByZXNzZWQgJiYgIWluZmluaXR5ICYmIHNvcnQpIHx8IC8vIDAwMTAwMDAwXG4gICAgICAgICghY29tcHJlc3NlZCAmJiBpbmZpbml0eSAmJiBzb3J0KSB8fCAvLyAwMTEwMDAwMFxuICAgICAgICAoc29ydCAmJiBpbmZpbml0eSAmJiBjb21wcmVzc2VkKSAvLyAxMTEwMDAwMFxuICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZW5jb2RpbmcgZmxhZzogJyArIChieXRlc1swXSAmIDIyNCkpO1xuICAgIH1cbiAgICBjb25zdCBzbGMgPSAoYiwgZnJvbSwgdG8pID0+IGJ5dGVzVG9OdW1iZXJCRShiLnNsaWNlKGZyb20sIHRvKSk7XG4gICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gOTYgJiYgY29tcHJlc3NlZCkge1xuICAgICAgICBpZiAoaW5maW5pdHkpIHtcbiAgICAgICAgICAgIC8vIGNoZWNrIHRoYXQgYWxsIGJ5dGVzIGFyZSAwXG4gICAgICAgICAgICBpZiAodmFsdWUucmVkdWNlKChwLCBjKSA9PiAocCAhPT0gMCA/IGMgKyAxIDogYyksIDApID4gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBHMiBwb2ludDogY29tcHJlc3NlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgeDogRnAyLlpFUk8sIHk6IEZwMi5aRVJPIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeF8xID0gc2xjKHZhbHVlLCAwLCBMKTtcbiAgICAgICAgY29uc3QgeF8wID0gc2xjKHZhbHVlLCBMLCAyICogTCk7XG4gICAgICAgIGNvbnN0IHggPSBGcDIuY3JlYXRlKHsgYzA6IEZwLmNyZWF0ZSh4XzApLCBjMTogRnAuY3JlYXRlKHhfMSkgfSk7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gRnAyLmFkZChGcDIucG93KHgsIF8zbiksIGJsczEyXzM4MV9DVVJWRV9HMi5iKTsgLy8gecKyID0geMKzICsgNCAqICh1KzEpID0geMKzICsgYlxuICAgICAgICBsZXQgeSA9IEZwMi5zcXJ0KHJpZ2h0KTtcbiAgICAgICAgY29uc3QgWV9iaXQgPSB5LmMxID09PSBfMG4gPyAoeS5jMCAqIF8ybikgLyBQIDogKHkuYzEgKiBfMm4pIC8gUCA/IF8xbiA6IF8wbjtcbiAgICAgICAgeSA9IHNvcnQgJiYgWV9iaXQgPiAwID8geSA6IEZwMi5uZWcoeSk7XG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUubGVuZ3RoID09PSAxOTIgJiYgIWNvbXByZXNzZWQpIHtcbiAgICAgICAgaWYgKGluZmluaXR5KSB7XG4gICAgICAgICAgICBpZiAodmFsdWUucmVkdWNlKChwLCBjKSA9PiAocCAhPT0gMCA/IGMgKyAxIDogYyksIDApID4gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBHMiBwb2ludDogdW5jb21wcmVzc2VkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyB4OiBGcDIuWkVSTywgeTogRnAyLlpFUk8gfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4MSA9IHNsYyh2YWx1ZSwgMCAqIEwsIDEgKiBMKTtcbiAgICAgICAgY29uc3QgeDAgPSBzbGModmFsdWUsIDEgKiBMLCAyICogTCk7XG4gICAgICAgIGNvbnN0IHkxID0gc2xjKHZhbHVlLCAyICogTCwgMyAqIEwpO1xuICAgICAgICBjb25zdCB5MCA9IHNsYyh2YWx1ZSwgMyAqIEwsIDQgKiBMKTtcbiAgICAgICAgcmV0dXJuIHsgeDogRnAyLmZyb21CaWdUdXBsZShbeDAsIHgxXSksIHk6IEZwMi5mcm9tQmlnVHVwbGUoW3kwLCB5MV0pIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgRzIgcG9pbnQ6IGV4cGVjdGVkIDk2LzE5MiBieXRlcycpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNpZ25hdHVyZUcyRnJvbUJ5dGVzKGhleCkge1xuICAgIGNvbnN0IHsgT1JERVI6IFAgfSA9IEZwO1xuICAgIC8vIFRPRE86IE9wdGltaXplLCBpdCdzIHZlcnkgc2xvdyBiZWNhdXNlIG9mIHNxcnQuXG4gICAgY29uc3QgeyBpbmZpbml0eSwgc29ydCwgdmFsdWUgfSA9IHBhcnNlTWFzayhlbnN1cmVCeXRlcygnc2lnbmF0dXJlSGV4JywgaGV4KSk7XG4gICAgY29uc3QgUG9pbnQgPSBibHMxMl8zODEuRzIuUG9pbnQ7XG4gICAgY29uc3QgaGFsZiA9IHZhbHVlLmxlbmd0aCAvIDI7XG4gICAgaWYgKGhhbGYgIT09IDQ4ICYmIGhhbGYgIT09IDk2KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgY29tcHJlc3NlZCBzaWduYXR1cmUgbGVuZ3RoLCBleHBlY3RlZCA5Ni8xOTIgYnl0ZXMnKTtcbiAgICBjb25zdCB6MSA9IGJ5dGVzVG9OdW1iZXJCRSh2YWx1ZS5zbGljZSgwLCBoYWxmKSk7XG4gICAgY29uc3QgejIgPSBieXRlc1RvTnVtYmVyQkUodmFsdWUuc2xpY2UoaGFsZikpO1xuICAgIC8vIEluZGljYXRlcyB0aGUgaW5maW5pdHkgcG9pbnRcbiAgICBpZiAoaW5maW5pdHkpXG4gICAgICAgIHJldHVybiBQb2ludC5aRVJPO1xuICAgIGNvbnN0IHgxID0gRnAuY3JlYXRlKHoxICYgYml0TWFzayhGcC5CSVRTKSk7XG4gICAgY29uc3QgeDIgPSBGcC5jcmVhdGUoejIpO1xuICAgIGNvbnN0IHggPSBGcDIuY3JlYXRlKHsgYzA6IHgyLCBjMTogeDEgfSk7XG4gICAgY29uc3QgeTIgPSBGcDIuYWRkKEZwMi5wb3coeCwgXzNuKSwgYmxzMTJfMzgxX0NVUlZFX0cyLmIpOyAvLyB5wrIgPSB4wrMgKyA0XG4gICAgLy8gVGhlIHNsb3cgcGFydFxuICAgIGxldCB5ID0gRnAyLnNxcnQoeTIpO1xuICAgIGlmICgheSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZmluZCBhIHNxdWFyZSByb290Jyk7XG4gICAgLy8gQ2hvb3NlIHRoZSB5IHdob3NlIGxlZnRtb3N0IGJpdCBvZiB0aGUgaW1hZ2luYXJ5IHBhcnQgaXMgZXF1YWwgdG8gdGhlIGFfZmxhZzFcbiAgICAvLyBJZiB5MSBoYXBwZW5zIHRvIGJlIHplcm8sIHRoZW4gdXNlIHRoZSBiaXQgb2YgeTBcbiAgICBjb25zdCB7IHJlOiB5MCwgaW06IHkxIH0gPSBGcDIucmVpbSh5KTtcbiAgICBjb25zdCBhZmxhZzEgPSBCaWdJbnQoc29ydCk7XG4gICAgY29uc3QgaXNHcmVhdGVyID0geTEgPiBfMG4gJiYgKHkxICogXzJuKSAvIFAgIT09IGFmbGFnMTtcbiAgICBjb25zdCBpczAgPSB5MSA9PT0gXzBuICYmICh5MCAqIF8ybikgLyBQICE9PSBhZmxhZzE7XG4gICAgaWYgKGlzR3JlYXRlciB8fCBpczApXG4gICAgICAgIHkgPSBGcDIubmVnKHkpO1xuICAgIGNvbnN0IHBvaW50ID0gUG9pbnQuZnJvbUFmZmluZSh7IHgsIHkgfSk7XG4gICAgcG9pbnQuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICByZXR1cm4gcG9pbnQ7XG59XG4vKipcbiAqIGJsczEyLTM4MSBwYWlyaW5nLWZyaWVuZGx5IGN1cnZlLlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IGJsczEyXzM4MSBhcyBibHMgfSBmcm9tICdAbm9ibGUvY3VydmVzL2JsczEyLTM4MSc7XG4gKiAvLyBHMSBrZXlzLCBHMiBzaWduYXR1cmVzXG4gKiBjb25zdCBwcml2YXRlS2V5ID0gJzY3ZDUzZjE3MGI5MDhjYWJiOWViMzI2YzNjMzM3NzYyZDU5Mjg5YThmZWM3OWY3YmM5MjU0YjU4NGI3MzI2NWMnO1xuICogY29uc3QgbWVzc2FnZSA9ICc2NDcyNmUzZGE4JztcbiAqIGNvbnN0IHB1YmxpY0tleSA9IGJscy5nZXRQdWJsaWNLZXkocHJpdmF0ZUtleSk7XG4gKiBjb25zdCBzaWduYXR1cmUgPSBibHMuc2lnbihtZXNzYWdlLCBwcml2YXRlS2V5KTtcbiAqIGNvbnN0IGlzVmFsaWQgPSBibHMudmVyaWZ5KHNpZ25hdHVyZSwgbWVzc2FnZSwgcHVibGljS2V5KTtcbiAqL1xuZXhwb3J0IGNvbnN0IGJsczEyXzM4MSA9IGJscyh7XG4gICAgLy8gRmllbGRzXG4gICAgZmllbGRzOiB7XG4gICAgICAgIEZwLFxuICAgICAgICBGcDIsXG4gICAgICAgIEZwNixcbiAgICAgICAgRnAxMixcbiAgICAgICAgRnI6IGJsczEyXzM4MV9GcixcbiAgICB9LFxuICAgIC8vIEcxOiB5wrIgPSB4wrMgKyA0XG4gICAgRzE6IHtcbiAgICAgICAgLi4uYmxzMTJfMzgxX0NVUlZFX0cxLFxuICAgICAgICBGcCxcbiAgICAgICAgaHRmRGVmYXVsdHM6IHsgLi4uaHRmRGVmYXVsdHMsIG06IDEsIERTVDogJ0JMU19TSUdfQkxTMTIzODFHMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPX05VTF8nIH0sXG4gICAgICAgIHdyYXBQcml2YXRlS2V5OiB0cnVlLFxuICAgICAgICBhbGxvd0luZmluaXR5UG9pbnQ6IHRydWUsXG4gICAgICAgIC8vIENoZWNrcyBpcyB0aGUgcG9pbnQgcmVzaWRlcyBpbiBwcmltZS1vcmRlciBzdWJncm91cC5cbiAgICAgICAgLy8gcG9pbnQuaXNUb3JzaW9uRnJlZSgpIHNob3VsZCByZXR1cm4gdHJ1ZSBmb3IgdmFsaWQgcG9pbnRzXG4gICAgICAgIC8vIEl0IHJldHVybnMgZmFsc2UgZm9yIHNoaXR0eSBwb2ludHMuXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMjEvMTEzMC5wZGZcbiAgICAgICAgaXNUb3JzaW9uRnJlZTogKGMsIHBvaW50KSA9PiB7XG4gICAgICAgICAgICAvLyBHTFYgZW5kb21vcnBoaXNtIM+IKFApXG4gICAgICAgICAgICBjb25zdCBiZXRhID0gQmlnSW50KCcweDVmMTk2NzJmZGY3NmNlNTFiYTY5YzYwNzZhMGY3N2VhZGRiM2E5M2JlNmY4OTY4OGRlMTdkODEzNjIwYTAwMDIyZTAxZmZmZmZmZmVmZmZlJyk7XG4gICAgICAgICAgICBjb25zdCBwaGkgPSBuZXcgYyhGcC5tdWwocG9pbnQuWCwgYmV0YSksIHBvaW50LlksIHBvaW50LlopO1xuICAgICAgICAgICAgLy8gVE9ETzogdW5yb2xsXG4gICAgICAgICAgICBjb25zdCB4UCA9IHBvaW50Lm11bHRpcGx5VW5zYWZlKEJMU19YKS5uZWdhdGUoKTsgLy8gW3hdUFxuICAgICAgICAgICAgY29uc3QgdTJQID0geFAubXVsdGlwbHlVbnNhZmUoQkxTX1gpOyAvLyBbdTJdUFxuICAgICAgICAgICAgcmV0dXJuIHUyUC5lcXVhbHMocGhpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQ2xlYXIgY29mYWN0b3Igb2YgRzFcbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxOS80MDNcbiAgICAgICAgY2xlYXJDb2ZhY3RvcjogKF9jLCBwb2ludCkgPT4ge1xuICAgICAgICAgICAgLy8gcmV0dXJuIHRoaXMubXVsdGlwbHlVbnNhZmUoQ1VSVkUuaCk7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnQubXVsdGlwbHlVbnNhZmUoQkxTX1gpLmFkZChwb2ludCk7IC8vIHgqUCArIFBcbiAgICAgICAgfSxcbiAgICAgICAgbWFwVG9DdXJ2ZTogbWFwVG9HMSxcbiAgICAgICAgZnJvbUJ5dGVzOiBwb2ludEcxRnJvbUJ5dGVzLFxuICAgICAgICB0b0J5dGVzOiBwb2ludEcxVG9CeXRlcyxcbiAgICAgICAgU2hvcnRTaWduYXR1cmU6IHtcbiAgICAgICAgICAgIGZyb21CeXRlcyhieXRlcykge1xuICAgICAgICAgICAgICAgIGFieXRlcyhieXRlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25hdHVyZUcxRnJvbUJ5dGVzKGJ5dGVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9tSGV4KGhleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaWduYXR1cmVHMUZyb21CeXRlcyhoZXgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvQnl0ZXMocG9pbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmF0dXJlRzFUb0J5dGVzKHBvaW50KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b1Jhd0J5dGVzKHBvaW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25hdHVyZUcxVG9CeXRlcyhwb2ludCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9IZXgocG9pbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnl0ZXNUb0hleChzaWduYXR1cmVHMVRvQnl0ZXMocG9pbnQpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBHMjoge1xuICAgICAgICAuLi5ibHMxMl8zODFfQ1VSVkVfRzIsXG4gICAgICAgIEZwOiBGcDIsXG4gICAgICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjOTM4MCNuYW1lLWNsZWFyaW5nLXRoZS1jb2ZhY3RvclxuICAgICAgICAvLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzkzODAjbmFtZS1jb2ZhY3Rvci1jbGVhcmluZy1mb3ItYmxzMTJcbiAgICAgICAgaEVmZjogQmlnSW50KCcweGJjNjlmMDhmMmVlNzViMzU4NGM2YTBlYTkxYjM1Mjg4OGUyYThlOTE0NWFkNzY4OTk4NmZmMDMxNTA4ZmZlMTMyOWMyZjE3ODczMWRiOTU2ZDgyYmYwMTVkMTIxMmIwMmVjMGVjNjlkNzQ3N2MxYWU5NTRjYmMwNjY4OWY2YTM1OTg5NGMwYWRlYmJmNmI0ZTgwMjAwMDVhYWE5NTU1MScpLFxuICAgICAgICBodGZEZWZhdWx0czogeyAuLi5odGZEZWZhdWx0cyB9LFxuICAgICAgICB3cmFwUHJpdmF0ZUtleTogdHJ1ZSxcbiAgICAgICAgYWxsb3dJbmZpbml0eVBvaW50OiB0cnVlLFxuICAgICAgICBtYXBUb0N1cnZlOiBtYXBUb0cyLFxuICAgICAgICAvLyBDaGVja3MgaXMgdGhlIHBvaW50IHJlc2lkZXMgaW4gcHJpbWUtb3JkZXIgc3ViZ3JvdXAuXG4gICAgICAgIC8vIHBvaW50LmlzVG9yc2lvbkZyZWUoKSBzaG91bGQgcmV0dXJuIHRydWUgZm9yIHZhbGlkIHBvaW50c1xuICAgICAgICAvLyBJdCByZXR1cm5zIGZhbHNlIGZvciBzaGl0dHkgcG9pbnRzLlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDIxLzExMzAucGRmXG4gICAgICAgIC8vIE9sZGVyIHZlcnNpb246IGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTkvODE0LnBkZlxuICAgICAgICBpc1RvcnNpb25GcmVlOiAoYywgUCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFAubXVsdGlwbHlVbnNhZmUoQkxTX1gpLm5lZ2F0ZSgpLmVxdWFscyhHMnBzaShjLCBQKSk7IC8vIM+IKFApID09IFt1XShQKVxuICAgICAgICB9LFxuICAgICAgICAvLyBNYXBzIHRoZSBwb2ludCBpbnRvIHRoZSBwcmltZS1vcmRlciBzdWJncm91cCBHMi5cbiAgICAgICAgLy8gY2xlYXJfY29mYWN0b3JfYmxzMTIzODFfZzIgZnJvbSBSRkMgOTM4MC5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNy80MTkucGRmXG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBjbGVhckNvZmFjdG9yOiAoYywgUCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeCA9IEJMU19YO1xuICAgICAgICAgICAgbGV0IHQxID0gUC5tdWx0aXBseVVuc2FmZSh4KS5uZWdhdGUoKTsgLy8gWy14XVBcbiAgICAgICAgICAgIGxldCB0MiA9IEcycHNpKGMsIFApOyAvLyDOqChQKVxuICAgICAgICAgICAgbGV0IHQzID0gUC5kb3VibGUoKTsgLy8gMlBcbiAgICAgICAgICAgIHQzID0gRzJwc2kyKGMsIHQzKTsgLy8gzqjCsigyUClcbiAgICAgICAgICAgIHQzID0gdDMuc3VidHJhY3QodDIpOyAvLyDOqMKyKDJQKSAtIM6oKFApXG4gICAgICAgICAgICB0MiA9IHQxLmFkZCh0Mik7IC8vIFsteF1QICsgzqgoUClcbiAgICAgICAgICAgIHQyID0gdDIubXVsdGlwbHlVbnNhZmUoeCkubmVnYXRlKCk7IC8vIFt4wrJdUCAtIFt4Xc6oKFApXG4gICAgICAgICAgICB0MyA9IHQzLmFkZCh0Mik7IC8vIM6owrIoMlApIC0gzqgoUCkgKyBbeMKyXVAgLSBbeF3OqChQKVxuICAgICAgICAgICAgdDMgPSB0My5zdWJ0cmFjdCh0MSk7IC8vIM6owrIoMlApIC0gzqgoUCkgKyBbeMKyXVAgLSBbeF3OqChQKSArIFt4XVBcbiAgICAgICAgICAgIGNvbnN0IFEgPSB0My5zdWJ0cmFjdChQKTsgLy8gzqjCsigyUCkgLSDOqChQKSArIFt4wrJdUCAtIFt4Xc6oKFApICsgW3hdUCAtIDFQXG4gICAgICAgICAgICByZXR1cm4gUTsgLy8gW3jCsi14LTFdUCArIFt4LTFdzqgoUCkgKyDOqMKyKDJQKVxuICAgICAgICB9LFxuICAgICAgICBmcm9tQnl0ZXM6IHBvaW50RzJGcm9tQnl0ZXMsXG4gICAgICAgIHRvQnl0ZXM6IHBvaW50RzJUb0J5dGVzLFxuICAgICAgICBTaWduYXR1cmU6IHtcbiAgICAgICAgICAgIGZyb21CeXRlcyhieXRlcykge1xuICAgICAgICAgICAgICAgIGFieXRlcyhieXRlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25hdHVyZUcyRnJvbUJ5dGVzKGJ5dGVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9tSGV4KGhleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaWduYXR1cmVHMkZyb21CeXRlcyhoZXgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvQnl0ZXMocG9pbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmF0dXJlRzJUb0J5dGVzKHBvaW50KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b1Jhd0J5dGVzKHBvaW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25hdHVyZUcyVG9CeXRlcyhwb2ludCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9IZXgocG9pbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnl0ZXNUb0hleChzaWduYXR1cmVHMlRvQnl0ZXMocG9pbnQpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgfSxcbiAgICBwYXJhbXM6IHtcbiAgICAgICAgYXRlTG9vcFNpemU6IEJMU19YLCAvLyBUaGUgQkxTIHBhcmFtZXRlciB4IGZvciBCTFMxMi0zODFcbiAgICAgICAgcjogYmxzMTJfMzgxX0NVUlZFX0cxLm4sIC8vIG9yZGVyOyB64oG0IOKIkiB6wrIgKyAxOyBDVVJWRS5uIGZyb20gb3RoZXIgY3VydmVzXG4gICAgICAgIHhOZWdhdGl2ZTogdHJ1ZSxcbiAgICAgICAgdHdpc3RUeXBlOiAnbXVsdGlwbGljYXRpdmUnLFxuICAgIH0sXG4gICAgaHRmRGVmYXVsdHMsXG4gICAgaGFzaDogc2hhMjU2LFxufSk7XG4vLyAzLWlzb2dlbnkgbWFwIGZyb20gRScgdG8gRSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNhcHBlbmRpeC1FLjNcbmNvbnN0IGlzb2dlbnlNYXBHMiA9IGlzb2dlbnlNYXAoRnAyLCBbXG4gICAgLy8geE51bVxuICAgIFtcbiAgICAgICAgW1xuICAgICAgICAgICAgJzB4NWM3NTk1MDdlOGUzMzNlYmI1YjdhOWE0N2Q3ZWQ4NTMyYzUyZDM5ZmQzYTA0MmE4OGI1ODQyM2M1MGFlMTVkNWMyNjM4ZTM0M2Q5YzcxYzYyMzhhYWFhYWFhYTk3ZDYnLFxuICAgICAgICAgICAgJzB4NWM3NTk1MDdlOGUzMzNlYmI1YjdhOWE0N2Q3ZWQ4NTMyYzUyZDM5ZmQzYTA0MmE4OGI1ODQyM2M1MGFlMTVkNWMyNjM4ZTM0M2Q5YzcxYzYyMzhhYWFhYWFhYTk3ZDYnLFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICAnMHgwJyxcbiAgICAgICAgICAgICcweDExNTYwYmYxN2JhYTk5YmMzMjEyNmZjZWQ3ODdjODhmOTg0Zjg3YWRmN2FlMGM3ZjlhMjA4YzZiNGYyMGE0MTgxNDcyYWFhOWNiOGQ1NTU1MjZhOWZmZmZmZmZmYzcxYScsXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICAgICcweDExNTYwYmYxN2JhYTk5YmMzMjEyNmZjZWQ3ODdjODhmOTg0Zjg3YWRmN2FlMGM3ZjlhMjA4YzZiNGYyMGE0MTgxNDcyYWFhOWNiOGQ1NTU1MjZhOWZmZmZmZmZmYzcxZScsXG4gICAgICAgICAgICAnMHg4YWIwNWY4YmRkNTRjZGUxOTA5MzdlNzZiYzNlNDQ3Y2MyN2MzZDZmYmQ3MDYzZmNkMTA0NjM1YTc5MDUyMGMwYTM5NTU1NGU1YzZhYWFhOTM1NGZmZmZmZmZmZTM4ZCcsXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICAgICcweDE3MWQ2NTQxZmEzOGNjZmFlZDZkZWE2OTFmNWZiNjE0Y2IxNGI0ZTdmNGU4MTBhYTIyZDYxMDhmMTQyYjg1NzU3MDk4ZTM4ZDBmNjcxYzcxODhlMmFhYWFhYWFhNWVkMScsXG4gICAgICAgICAgICAnMHgwJyxcbiAgICAgICAgXSxcbiAgICBdLFxuICAgIC8vIHhEZW5cbiAgICBbXG4gICAgICAgIFtcbiAgICAgICAgICAgICcweDAnLFxuICAgICAgICAgICAgJzB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYTYzJyxcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgJzB4YycsXG4gICAgICAgICAgICAnMHgxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmFhOWYnLFxuICAgICAgICBdLFxuICAgICAgICBbJzB4MScsICcweDAnXSwgLy8gTEFTVCAxXG4gICAgXSxcbiAgICAvLyB5TnVtXG4gICAgW1xuICAgICAgICBbXG4gICAgICAgICAgICAnMHgxNTMwNDc3YzdhYjQxMTNiNTlhNGMxOGIwNzZkMTE5MzBmN2RhNWQ0YTA3ZjY0OWJmNTQ0MzlkODdkMjdlNTAwZmM4YzI1ZWJmOGM5MmY2ODEyY2ZjNzFjNzFjNmQ3MDYnLFxuICAgICAgICAgICAgJzB4MTUzMDQ3N2M3YWI0MTEzYjU5YTRjMThiMDc2ZDExOTMwZjdkYTVkNGEwN2Y2NDliZjU0NDM5ZDg3ZDI3ZTUwMGZjOGMyNWViZjhjOTJmNjgxMmNmYzcxYzcxYzZkNzA2JyxcbiAgICAgICAgXSxcbiAgICAgICAgW1xuICAgICAgICAgICAgJzB4MCcsXG4gICAgICAgICAgICAnMHg1Yzc1OTUwN2U4ZTMzM2ViYjViN2E5YTQ3ZDdlZDg1MzJjNTJkMzlmZDNhMDQyYTg4YjU4NDIzYzUwYWUxNWQ1YzI2MzhlMzQzZDljNzFjNjIzOGFhYWFhYWFhOTdiZScsXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICAgICcweDExNTYwYmYxN2JhYTk5YmMzMjEyNmZjZWQ3ODdjODhmOTg0Zjg3YWRmN2FlMGM3ZjlhMjA4YzZiNGYyMGE0MTgxNDcyYWFhOWNiOGQ1NTU1MjZhOWZmZmZmZmZmYzcxYycsXG4gICAgICAgICAgICAnMHg4YWIwNWY4YmRkNTRjZGUxOTA5MzdlNzZiYzNlNDQ3Y2MyN2MzZDZmYmQ3MDYzZmNkMTA0NjM1YTc5MDUyMGMwYTM5NTU1NGU1YzZhYWFhOTM1NGZmZmZmZmZmZTM4ZicsXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICAgICcweDEyNGM5YWQ0M2I2Y2Y3OWJmYmY3MDQzZGUzODExYWQwNzYxYjBmMzdhMWUyNjI4NmIwZTk3N2M2OWFhMjc0NTI0ZTc5MDk3YTU2ZGM0YmQ5ZTFiMzcxYzcxYzcxOGIxMCcsXG4gICAgICAgICAgICAnMHgwJyxcbiAgICAgICAgXSxcbiAgICBdLFxuICAgIC8vIHlEZW5cbiAgICBbXG4gICAgICAgIFtcbiAgICAgICAgICAgICcweDFhMDExMWVhMzk3ZmU2OWE0YjFiYTdiNjQzNGJhY2Q3NjQ3NzRiODRmMzg1MTJiZjY3MzBkMmEwZjZiMGY2MjQxZWFiZmZmZWIxNTNmZmZmYjlmZWZmZmZmZmZmYThmYicsXG4gICAgICAgICAgICAnMHgxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmE4ZmInLFxuICAgICAgICBdLFxuICAgICAgICBbXG4gICAgICAgICAgICAnMHgwJyxcbiAgICAgICAgICAgICcweDFhMDExMWVhMzk3ZmU2OWE0YjFiYTdiNjQzNGJhY2Q3NjQ3NzRiODRmMzg1MTJiZjY3MzBkMmEwZjZiMGY2MjQxZWFiZmZmZWIxNTNmZmZmYjlmZWZmZmZmZmZmYTlkMycsXG4gICAgICAgIF0sXG4gICAgICAgIFtcbiAgICAgICAgICAgICcweDEyJyxcbiAgICAgICAgICAgICcweDFhMDExMWVhMzk3ZmU2OWE0YjFiYTdiNjQzNGJhY2Q3NjQ3NzRiODRmMzg1MTJiZjY3MzBkMmEwZjZiMGY2MjQxZWFiZmZmZWIxNTNmZmZmYjlmZWZmZmZmZmZmYWE5OScsXG4gICAgICAgIF0sXG4gICAgICAgIFsnMHgxJywgJzB4MCddLCAvLyBMQVNUIDFcbiAgICBdLFxuXS5tYXAoKGkpID0+IGkubWFwKChwYWlyKSA9PiBGcDIuZnJvbUJpZ1R1cGxlKHBhaXIubWFwKEJpZ0ludCkpKSkpO1xuLy8gMTEtaXNvZ2VueSBtYXAgZnJvbSBFJyB0byBFXG5jb25zdCBpc29nZW55TWFwRzEgPSBpc29nZW55TWFwKEZwLCBbXG4gICAgLy8geE51bVxuICAgIFtcbiAgICAgICAgJzB4MTFhMDVmMmIxZTgzMzM0MGI4MDkxMDFkZDk5ODE1ODU2YjMwM2U4OGEyZDcwMDVmZjI2MjdiNTZjZGI0ZTJjODU2MTBjMmQ1ZjJlNjJkNmVhZWFjMTY2MjczNDY0OWI3JyxcbiAgICAgICAgJzB4MTcyOTRlZDNlOTQzYWIyZjA1ODhiYWIyMjE0N2E4MWM3YzE3ZTc1YjJmNmE4NDE3ZjU2NWUzM2M3MGQxZTg2YjQ4MzhmMmE2ZjMxOGMzNTZlODM0ZWVmMWIzY2I4M2JiJyxcbiAgICAgICAgJzB4ZDU0MDA1ZGI5NzY3OGVjMWQxMDQ4YzVkMTBhOWExYmNlMDMyNDczMjk1OTgzZTU2ODc4ZTUwMWVjNjhlMjVjOTU4YzNlM2QyYTA5NzI5ZmUwMTc5ZjlkYWM5ZWRjYjAnLFxuICAgICAgICAnMHgxNzc4ZTcxNjZmY2M2ZGI3NGUwNjA5ZDMwN2U1NTQxMmQ3ZjVlNDY1NmE4ZGJmMjVmMWIzMzI4OWYxYjMzMDgzNTMzNmUyNWNlMzEwNzE5M2M1YjM4ODY0MWQ5YjY4NjEnLFxuICAgICAgICAnMHhlOTk3MjZhMzE5OWY0NDM2NjQyYjRiM2U0MTE4ZTU0OTlkYjk5NWExMjU3ZmIzZjA4NmVlYjY1OTgyZmFjMTg5ODVhMjg2ZjMwMWU3N2M0NTExNTRjZTlhYzg4OTVkOScsXG4gICAgICAgICcweDE2MzBjMzI1MGQ3MzEzZmYwMWQxMjAxYmY3YTc0YWI1ZGIzY2IxN2RkOTUyNzk5YjllZDNhYjkwOTdlNjhmOTBhMDg3MGQyZGNhZTczZDE5Y2QxM2MxYzY2ZjY1Mjk4MycsXG4gICAgICAgICcweGQ2ZWQ2NTUzZmU0NGQyOTZhMzcyNmMzOGFlNjUyYmZiMTE1ODYyNjRmMGY4Y2UxOTAwOGUyMThmOWM4NmIyYThkYTI1MTI4YzEwNTJlY2FkZGQ3ZjIyNWExMzllZDg0JyxcbiAgICAgICAgJzB4MTdiODFlNzcwMWFiZGJlMmU4NzQzODg0ZDExMTdlNTMzNTZkZTVhYjI3NWI0ZGIxYTY4MmM2MmVmMGYyNzUzMzM5YjdjOGY4YzhmNDc1YWY5Y2NiNTYxOGUzZjBjODhlJyxcbiAgICAgICAgJzB4ODBkM2NmMWY5YTc4ZmM0N2I5MGIzMzU2M2JlOTkwZGM0M2I3NTZjZTc5ZjU1NzRhMmM1OTZjOTI4YzVkMWRlNGZhMjk1ZjI5NmI3NGU5NTZkNzE5ODZhODQ5N2UzMTcnLFxuICAgICAgICAnMHgxNjliMWY4ZTFiY2ZhN2M0MmUwYzM3NTE1ZDEzOGYyMmRkMmVjYjgwM2EwYzVjOTk2NzYzMTRiYWY0YmIxYjdmYTMxOTBiMmVkYzAzMjc3OTdmMjQxMDY3YmUzOTBjOWUnLFxuICAgICAgICAnMHgxMDMyMWRhMDc5Y2UwN2UyNzJkOGVjMDlkMjU2NWIwZGZhN2RjY2RkZTY3ODdmOTZkNTBhZjM2MDAzYjE0ODY2ZjY5Yjc3MWY4YzI4NWRlY2NhNjdkZjNmMTYwNWZiN2InLFxuICAgICAgICAnMHg2ZTA4YzI0OGUyNjBlNzBiZDFlOTYyMzgxZWRlZTNkMzFkNzlkN2UyMmM4MzdiYzIzYzBiZjFiYzI0YzZiNjhjMjRiMWI4MGI2NGQzOTFmYTljOGJhMmU4YmEyZDIyOScsXG4gICAgXSxcbiAgICAvLyB4RGVuXG4gICAgW1xuICAgICAgICAnMHg4Y2E4ZDU0OGNmZjE5YWUxOGIyZTYyZjRiZDNmYTZmMDFkNWVmNGJhMzViNDhiYTljOTU4ODYxN2ZjOGFjNjJiNTU4ZDY4MWJlMzQzZGY4OTkzY2Y5ZmE0MGQyMWIxYycsXG4gICAgICAgICcweDEyNTYxYTVkZWI1NTljNDM0OGI0NzExMjk4ZTUzNjM2NzA0MWU4Y2EwY2YwODAwYzAxMjZjMjU4OGM0OGJmNTcxM2RhYTg4NDZjYjAyNmU5ZTVjODI3NmVjODJiM2JmZicsXG4gICAgICAgICcweGIyOTYyZmU1N2EzMjI1ZTgxMzdlNjI5YmZmMjk5MWY2Zjg5NDE2ZjVhNzE4Y2QxZmNhNjRlMDBiMTFhY2VhY2Q2YTNkMDk2N2M5NGZlZGNmY2MyMzliYTVjYjgzZTE5JyxcbiAgICAgICAgJzB4MzQyNTU4MWE1OGFlMmZlYzgzYWFmZWY3YzQwZWI1NDViMDgyNDNmMTZiMTY1NTE1NGNjYThhYmMyOGQ2ZmQwNDk3NmQ1MjQzZWVjZjVjNDEzMGRlODkzOGRjNjJjZDgnLFxuICAgICAgICAnMHgxM2E4ZTE2MjAyMjkxNGE4MGE2ZjFkNWY0M2U3YTA3ZGZmZGZjNzU5YTEyMDYyYmI4ZDZiNDRlODMzYjMwNmRhOWJkMjliYTgxZjM1NzgxZDUzOWQzOTViMzUzMmEyMWUnLFxuICAgICAgICAnMHhlNzM1NWY4ZTRlNjY3Yjk1NTM5MGY3ZjA1MDZjNmU5Mzk1NzM1ZTljZTljYWQ0ZDBhNDNiY2VmMjRiODk4MmY3NDAwZDI0YmM0MjI4ZjExYzAyZGY5YTI5ZjYzMDRhNScsXG4gICAgICAgICcweDc3MmNhYWNmMTY5MzYxOTBmM2UwYzYzZTA1OTY3MjE1NzBmNTc5OWFmNTNhMTg5NGUyZTA3MzA2MmFlZGU5Y2VhNzNiMzUzOGYwZGUwNmNlYzI1NzQ0OTZlZTg0YTNhJyxcbiAgICAgICAgJzB4MTRhN2FjMmE5ZDY0YThiMjMwYjNmNWIwNzRjZjAxOTk2ZTdmNjNjMjFiY2E2OGE4MTk5NmUxY2RmOTgyMmM1ODBmYTViOTQ4OWQxMWUyZDMxMWY3ZDk5YmJkY2M1YTVlJyxcbiAgICAgICAgJzB4YTEwZWNmNmFkYTU0ZjgyNWU5MjBiM2RhZmM3YTNjY2UwN2Y4ZDFkNzE2MTM2NmI3NDEwMGRhNjdmMzk4ODM1MDM4MjY2OTJhYmJhNDM3MDQ3NzZlYzNhNzlhMWQ2NDEnLFxuICAgICAgICAnMHg5NWZjMTNhYjllOTJhZDQ0NzZkNmUzZWIzYTU2NjgwZjY4MmI0ZWU5NmY3ZDAzNzc2ZGY1MzM5NzhmMzFjMTU5MzE3NGU0YjRiNzg2NTAwMmQ2Mzg0ZDE2OGVjZGQwYScsXG4gICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIC8vIExBU1QgMVxuICAgIF0sXG4gICAgLy8geU51bVxuICAgIFtcbiAgICAgICAgJzB4OTBkOTdjODFiYTI0ZWUwMjU5ZDFmMDk0OTgwZGNmYTExYWQxMzhlNDhhODY5NTIyYjUyYWY2Yzk1NjU0M2QzY2QwYzdhZWU5YjNiYTNjMmJlOTg0NTcxOTcwN2JiMzMnLFxuICAgICAgICAnMHgxMzQ5OTZhMTA0ZWU1ODExZDUxMDM2ZDc3NmZiNDY4MzEyMjNlOTZjMjU0ZjM4M2QwZjkwNjM0M2ViNjdhZDM0ZDZjNTY3MTE5NjJmYThiZmUwOTdlNzVhMmU0MWM2OTYnLFxuICAgICAgICAnMHhjYzc4NmJhYTk2NmU2NmY0YTM4NGM4NmEzYjQ5OTQyNTUyZTJkNjU4YTMxY2UyYzM0NGJlNGI5MTQwMGRhN2QyNmQ1MjE2MjhiMDA1MjNiOGRmZTI0MGM3MmRlMWY2JyxcbiAgICAgICAgJzB4MWY4NjM3NmU4OTgxYzIxNzg5ODc1MWFkODc0Njc1N2Q0MmFhN2I5MGVlYjc5MWMwOWU0YTNlYzAzMjUxY2Y5ZGU0MDVhYmE5ZWM2MWRlY2E2MzU1Yzc3YjBlNWY0Y2InLFxuICAgICAgICAnMHg4Y2MwM2ZkZWZlMGZmMTM1Y2FmNGZlMmEyMTUyOWM0MTk1NTM2ZmJlM2NlNTBiODc5ODMzZmQyMjEzNTFhZGMyZWU3ZjhkYzA5OTA0MGE4NDFiNmRhZWNmMmU4ZmVkYicsXG4gICAgICAgICcweDE2NjAzZmNhNDA2MzRiNmEyMjExZTExZGI4ZjBhNmEwNzRhN2QwZDRhZmFkYjdiZDc2NTA1YzNkM2FkNTU0NGUyMDNmNjMyNmM5NWE4MDcyOTliMjNhYjEzNjMzYTVmMCcsXG4gICAgICAgICcweDRhYjBiOWJjZmFjMWJiY2IyYzk3N2QwMjc3OTZiM2NlNzViYjhjYTJiZTE4NGNiNTIzMTQxM2M0ZDYzNGYzNzQ3YTg3YWMyNDYwZjQxNWVjOTYxZjg4NTVmZTlkNmYyJyxcbiAgICAgICAgJzB4OTg3YzhkNTMzM2FiODZmZGU5OTI2YmQyY2E2YzY3NDE3MGEwNWJmZTNiZGQ4MWZmZDAzOGRhNmMyNmM4NDI2NDJmNjQ1NTBmZWRmZTkzNWExNWU0Y2EzMTg3MGZiMjknLFxuICAgICAgICAnMHg5ZmM0MDE4YmQ5NjY4NGJlODhjOWUyMjFlNGRhMWJiOGYzYWJkMTY2NzlkYzI2YzFlOGI2ZTZhMWYyMGNhYmU2OWQ2NTIwMWM3ODYwN2EzNjAzNzBlNTc3YmRiYTU4NycsXG4gICAgICAgICcweGUxYmJhN2ExMTg2YmRiNTIyM2FiZGU3YWRhMTRhMjNjNDJhMGNhNzkxNWFmNmZlMDY5ODVlN2VkMWU0ZDQzYjliM2Y3MDU1ZGQ0ZWJhNmYyYmFmYWFlYmNhNzMxYzMwJyxcbiAgICAgICAgJzB4MTk3MTNlNDc5MzdjZDFiZTBkZmQwYjhmMWQ0M2ZiOTNjZDJmY2JjYjZjYWY0OTNmZDExODNlNDE2Mzg5ZTYxMDMxYmYzYTVjY2UzZmJhZmNlODEzNzExYWQwMTFjMTMyJyxcbiAgICAgICAgJzB4MThiNDZhOTA4ZjM2ZjZkZWI5MThjMTQzZmVkMmVkY2M1MjM1NTliOGFhZjBjMjQ2MmU2YmZlN2Y5MTFmNjQzMjQ5ZDljZGY0MWI0NGQ2MDZjZTA3YzhhNGQwMDc0ZDhlJyxcbiAgICAgICAgJzB4YjE4MmNhYzEwMWI5Mzk5ZDE1NTA5NjAwNGY1M2Y0NDdhYTdiMTJhMzQyNmIwOGVjMDI3MTBlODA3YjQ2MzNmMDZjODUxYzE5MTkyMTFmMjBkNGMwNGYwMGI5NzFlZjgnLFxuICAgICAgICAnMHgyNDVhMzk0YWQxZWNhOWI3MmZjMDBhZTdiZTMxNWRjNzU3YjNiMDgwZDRjMTU4MDEzZTY2MzJkM2M0MDY1OWNjNmNmOTBhZDFjMjMyYTY0NDJkOWQzZjVkYjk4MDEzMycsXG4gICAgICAgICcweDVjMTI5NjQ1ZTQ0Y2YxMTAyYTE1OWY3NDhjNGEzZmM1ZTY3M2Q4MWQ3ZTg2NTY4ZDlhYjBmNWQzOTZhN2NlNDZiYTEwNDliNjU3OWFmYjc4NjZiMWU3MTU0NzUyMjRiJyxcbiAgICAgICAgJzB4MTVlNmJlNGU5OTBmMDNjZTRlYTUwYjNiNDJkZjJlYjVjYjE4MWQ4Zjg0OTY1YTM5NTdhZGQ0ZmE5NWFmMDFiMmI2NjUwMjdlZmVjMDFjNzcwNGI0NTZiZTY5YzhiNjA0JyxcbiAgICBdLFxuICAgIC8vIHlEZW5cbiAgICBbXG4gICAgICAgICcweDE2MTEyYzRjM2E5Yzk4YjI1MjE4MTE0MGZhZDBlYWU5NjAxYTZkZTU3ODk4MGJlNmVlYzMyMzJiNWJlNzJlN2EwN2YzNjg4ZWY2MGMyMDZkMDE0NzkyNTNiMDM2NjNjMScsXG4gICAgICAgICcweDE5NjJkNzVjMjM4MTIwMWUxYTBjYmQ2YzQzYzM0OGI4ODVjODRmZjczMWM0ZDU5Y2E0YTEwMzU2ZjQ1M2UwMWY3OGE0MjYwNzYzNTI5ZTM1MzJmNjEwMmMyZTQ5YTAzZCcsXG4gICAgICAgICcweDU4ZGYzMzA2NjQwZGEyNzZmYWFhZTdkNmU4ZWIxNTc3OGM0ODU1NTUxYWU3ZjMxMGMzNWE1ZGQyNzljZDJlY2E2NzU3Y2Q2MzZmOTZmODkxZTI1MzhiNTNkYmY2N2YyJyxcbiAgICAgICAgJzB4MTZiN2QyODg3OThlNTM5NWYyMGQyM2JmODllZGI0ZDFkMTE1YzVkYmRkYmNkMzBlMTIzZGE0ODllNzI2YWY0MTcyNzM2NGYyYzI4Mjk3YWRhOGQyNmQ5ODQ0NWY1NDE2JyxcbiAgICAgICAgJzB4YmUwZTA3OTU0NWY0M2U0YjAwY2M5MTJmODIyOGRkY2M2ZDE5YzlmMGY2OWJiYjA1NDJlZGEwZmM5ZGVjOTE2YTIwYjE1ZGMwZmQyZWRlZGRhMzkxNDIzMTFhNTAwMWQnLFxuICAgICAgICAnMHg4ZDllNTI5NzE4NmRiMmQ5ZmIyNjZlYWFjNzgzMTgyYjcwMTUyYzY1NTUwZDg4MWM1ZWNkODdiNmYwZjVhNjQ0OWYzOGRiOWRmYTljY2UyMDJjNjQ3N2ZhYWY5YjdhYycsXG4gICAgICAgICcweDE2NjAwN2MwOGE5OWRiMmZjM2JhODczNGFjZTk4MjRiNWVlY2ZkZmE4ZDBjZjhlZjVkZDM2NWJjNDAwYTAwNTFkNWZhOWMwMWE1OGIxZmI5M2QxYTEzOTkxMjZhNzc1YycsXG4gICAgICAgICcweDE2YTNlZjA4YmUzZWE3ZWEwM2JjZGRmYWJiYTZmZjZlZTVhNDM3NWVmYTFmNGZkN2ZlYjM0ZmQyMDYzNTcxMzJiOTIwZjViMDA4MDFkZWU0NjBlZTQxNWExNTgxMmVkOScsXG4gICAgICAgICcweDE4NjZjOGVkMzM2YzYxMjMxYTFiZTU0ZmQxZDc0Y2M0ZjlmYjBjZTRjNmFmNTkyMGFiYzU3NTBjNGJmMzliNDg1MmNmZTJmN2JiOTI0ODgzNmIyMzNkOWQ1NTUzNWQ0YScsXG4gICAgICAgICcweDE2N2E1NWNkYTcwYTZlMWNlYTgyMDU5N2Q5NGE4NDkwMzIxNmY3NjNlMTNkODdiYjUzMDg1OTJlN2VhN2Q0ZmJjNzM4NWVhM2Q1MjliMzVlMzQ2ZWY0OGJiODkxM2Y1NScsXG4gICAgICAgICcweDRkMmYyNTllZWE0MDViZDQ4ZjAxMGEwMWFkMjkxMWQ5YzZkZDAzOWJiNjFhNjI5MGU1OTFiMzZlNjM2YTVjODcxYTVjMjlmNGY4MzA2MDQwMGY4YjQ5Y2JhOGY2YWE4JyxcbiAgICAgICAgJzB4YWNjYmI2NzQ4MWQwMzNmZjU4NTJjMWU0OGM1MGM0NzdmOTRmZjhhZWZjZTQyZDI4YzBmOWE4OGNlYTc5MTM1MTZmOTY4OTg2ZjdlYmJlYTk2ODRiNTI5ZTI1NjEwOTInLFxuICAgICAgICAnMHhhZDZiOTUxNGM3NjdmZTNjMzYxMzE0NGI0NWYxNDk2NTQzMzQ2ZDk4YWRmMDIyNjdkNWNlZWY5YTAwZDliODY5MzAwMDc2M2UzYjkwYWMxMWU5OWIxMzg1NzMzNDVjYycsXG4gICAgICAgICcweDI2NjA0MDBlYjJlNGYzYjYyOGJkZDBkNTNjZDc2ZjJiZjU2NWI5NGU3MjkyN2MxY2I3NDhkZjI3OTQyNDgwZTQyMDUxN2JkODcxNGNjODBkMWZhZGMxMzI2ZWQwNmY3JyxcbiAgICAgICAgJzB4ZTBmYTFkODE2ZGRjMDNlNmIyNDI1NWUwZDc4MTljMTcxYzQwZjY1ZTI3M2I4NTMzMjRlZmNkNjM1NmNhYTIwNWNhMmY1NzBmMTM0OTc4MDQ0MTU0NzNhMWQ2MzRiOGYnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCAvLyBMQVNUIDFcbiAgICBdLFxuXS5tYXAoKGkpID0+IGkubWFwKChqKSA9PiBCaWdJbnQoaikpKSk7XG4vLyBPcHRpbWl6ZWQgU1dVIE1hcCAtIEZwIHRvIEcxXG5jb25zdCBHMV9TV1UgPSBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCB7XG4gICAgQTogRnAuY3JlYXRlKEJpZ0ludCgnMHgxNDQ2OThhM2I4ZTk0MzNkNjkzYTAyYzk2ZDQ5ODJiMGVhOTg1MzgzZWU2NmE4ZDhlODk4MWFlZmQ4ODFhYzk4OTM2ZjhkYTBlMGY5N2Y1Y2Y0MjgwODJkNTg0YzFkJykpLFxuICAgIEI6IEZwLmNyZWF0ZShCaWdJbnQoJzB4MTJlMjkwOGQxMTY4ODAzMDAxOGIxMmU4NzUzZWVlM2IyMDE2YzFmMGYyNGY0MDcwYTBiOWMxNGZjZWYzNWVmNTVhMjMyMTVhMzE2Y2VhYTVkMWNjNDhlOThlMTcyYmUwJykpLFxuICAgIFo6IEZwLmNyZWF0ZShCaWdJbnQoMTEpKSxcbn0pO1xuLy8gU1dVIE1hcCAtIEZwMiB0byBHMic6IHnCsiA9IHjCsyArIDI0MGkgKiB4ICsgMTAxMiArIDEwMTJpXG5jb25zdCBHMl9TV1UgPSBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwMiwge1xuICAgIEE6IEZwMi5jcmVhdGUoeyBjMDogRnAuY3JlYXRlKF8wbiksIGMxOiBGcC5jcmVhdGUoQmlnSW50KDI0MCkpIH0pLCAvLyBBJyA9IDI0MCAqIElcbiAgICBCOiBGcDIuY3JlYXRlKHsgYzA6IEZwLmNyZWF0ZShCaWdJbnQoMTAxMikpLCBjMTogRnAuY3JlYXRlKEJpZ0ludCgxMDEyKSkgfSksIC8vIEInID0gMTAxMiAqICgxICsgSSlcbiAgICBaOiBGcDIuY3JlYXRlKHsgYzA6IEZwLmNyZWF0ZShCaWdJbnQoLTIpKSwgYzE6IEZwLmNyZWF0ZShCaWdJbnQoLTEpKSB9KSwgLy8gWjogLSgyICsgSSlcbn0pO1xuZnVuY3Rpb24gbWFwVG9HMShzY2FsYXJzKSB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBHMV9TV1UoRnAuY3JlYXRlKHNjYWxhcnNbMF0pKTtcbiAgICByZXR1cm4gaXNvZ2VueU1hcEcxKHgsIHkpO1xufVxuZnVuY3Rpb24gbWFwVG9HMihzY2FsYXJzKSB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBHMl9TV1UoRnAyLmZyb21CaWdUdXBsZShzY2FsYXJzKSk7XG4gICAgcmV0dXJuIGlzb2dlbnlNYXBHMih4LCB5KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJsczEyLTM4MS5qcy5tYXAiXSwibmFtZXMiOlsic2hhMjU2IiwiYmxzIiwiRmllbGQiLCJhYnl0ZXMiLCJiaXRMZW4iLCJiaXRNYXNrIiwiYnl0ZXNUb0hleCIsImJ5dGVzVG9OdW1iZXJCRSIsImNvbmNhdEJ5dGVzIiwiZW5zdXJlQnl0ZXMiLCJudW1iZXJUb0J5dGVzQkUiLCJpc29nZW55TWFwIiwicHNpRnJvYmVuaXVzIiwidG93ZXIxMiIsIm1hcFRvQ3VydmVTaW1wbGVTV1UiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJfM24iLCJfNG4iLCJCTFNfWCIsIkJMU19YX0xFTiIsImJsczEyXzM4MV9DVVJWRV9HMSIsInAiLCJuIiwiaCIsImEiLCJiIiwiR3giLCJHeSIsImJsczEyXzM4MV9GciIsIm1vZEZyb21CeXRlcyIsImlzTEUiLCJGcCIsIkZwMiIsIkZwNiIsIkZwMTIiLCJPUkRFUiIsIlhfTEVOIiwiRlAyX05PTlJFU0lEVUUiLCJGcDJtdWxCeUIiLCJjMCIsImMxIiwidDAiLCJtdWwiLCJ0MSIsInN1YiIsImFkZCIsIkZwMTJmaW5hbEV4cG9uZW50aWF0ZSIsIm51bSIsIngiLCJkaXYiLCJmcm9iZW5pdXNNYXAiLCJ0MiIsImNvbmp1Z2F0ZSIsIl9jeWNsb3RvbWljRXhwIiwidDMiLCJfY3ljbG90b21pY1NxdWFyZSIsInQ0IiwidDUiLCJ0NiIsInQ3IiwidDJfdDVfcG93X3EyIiwidDRfdDFfcG93X3EzIiwidDZfdDFjX3Bvd19xMSIsInQ3X3QzY190MSIsIkcycHNpIiwiRzJwc2kyIiwiT05FIiwiTk9OUkVTSURVRSIsImh0ZkRlZmF1bHRzIiwiT2JqZWN0IiwiZnJlZXplIiwiRFNUIiwiZW5jb2RlRFNUIiwibSIsImsiLCJleHBhbmQiLCJoYXNoIiwiYmxzMTJfMzgxX0NVUlZFX0cyIiwiWkVSTyIsImZyb21CaWdUdXBsZSIsIkNPTVBaRVJPIiwic2V0TWFzayIsInRvQnl0ZXMiLCJpbmZpbml0eSIsImNvbXByZXNzZWQiLCJwYXJzZU1hc2siLCJieXRlcyIsInNsaWNlIiwibWFzayIsInNvcnQiLCJ2YWx1ZSIsIkVycm9yIiwicG9pbnRHMVRvQnl0ZXMiLCJfYyIsInBvaW50IiwiaXNDb21wIiwiQllURVMiLCJMIiwiUCIsImlzMCIsInkiLCJ0b0FmZmluZSIsIkJvb2xlYW4iLCJVaW50OEFycmF5Iiwib2YiLCJzaWduYXR1cmVHMVRvQnl0ZXMiLCJhc3NlcnRWYWxpZGl0eSIsInBvaW50RzFGcm9tQnl0ZXMiLCJsZW5ndGgiLCJjb21wcmVzc2VkVmFsdWUiLCJjcmVhdGUiLCJCSVRTIiwicmlnaHQiLCJwb3ciLCJzcXJ0IiwibmVnIiwic3ViYXJyYXkiLCJibHMxMl8zODEiLCJHMSIsIlBvaW50Iiwic2lnbmF0dXJlRzFGcm9tQnl0ZXMiLCJoZXgiLCJhZmxhZyIsImZyb21BZmZpbmUiLCJwb2ludEcyVG9CeXRlcyIsImZsYWciLCJyZSIsIngwIiwiaW0iLCJ4MSIsInJlaW0iLCJ5MCIsInkxIiwic2lnbmF0dXJlRzJUb0J5dGVzIiwidG1wIiwiejIiLCJwb2ludEcyRnJvbUJ5dGVzIiwic2xjIiwiZnJvbSIsInRvIiwicmVkdWNlIiwiYyIsInhfMSIsInhfMCIsIllfYml0Iiwic2lnbmF0dXJlRzJGcm9tQnl0ZXMiLCJHMiIsImhhbGYiLCJ6MSIsIngyIiwieTIiLCJhZmxhZzEiLCJpc0dyZWF0ZXIiLCJmaWVsZHMiLCJGciIsIndyYXBQcml2YXRlS2V5IiwiYWxsb3dJbmZpbml0eVBvaW50IiwiaXNUb3JzaW9uRnJlZSIsImJldGEiLCJwaGkiLCJYIiwiWSIsIloiLCJ4UCIsIm11bHRpcGx5VW5zYWZlIiwibmVnYXRlIiwidTJQIiwiZXF1YWxzIiwiY2xlYXJDb2ZhY3RvciIsIm1hcFRvQ3VydmUiLCJtYXBUb0cxIiwiZnJvbUJ5dGVzIiwiU2hvcnRTaWduYXR1cmUiLCJmcm9tSGV4IiwidG9SYXdCeXRlcyIsInRvSGV4IiwiaEVmZiIsIm1hcFRvRzIiLCJkb3VibGUiLCJzdWJ0cmFjdCIsIlEiLCJTaWduYXR1cmUiLCJwYXJhbXMiLCJhdGVMb29wU2l6ZSIsInIiLCJ4TmVnYXRpdmUiLCJ0d2lzdFR5cGUiLCJpc29nZW55TWFwRzIiLCJtYXAiLCJpIiwicGFpciIsImlzb2dlbnlNYXBHMSIsImoiLCJHMV9TV1UiLCJBIiwiQiIsIkcyX1NXVSIsInNjYWxhcnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/bls12-381.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/ed25519.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/ed25519.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ED25519_TORSION_SUBGROUP: () => (/* binding */ ED25519_TORSION_SUBGROUP),\n/* harmony export */   RistrettoPoint: () => (/* binding */ RistrettoPoint),\n/* harmony export */   ed25519: () => (/* binding */ ed25519),\n/* harmony export */   ed25519_hasher: () => (/* binding */ ed25519_hasher),\n/* harmony export */   ed25519ctx: () => (/* binding */ ed25519ctx),\n/* harmony export */   ed25519ph: () => (/* binding */ ed25519ph),\n/* harmony export */   edwardsToMontgomery: () => (/* binding */ edwardsToMontgomery),\n/* harmony export */   edwardsToMontgomeryPriv: () => (/* binding */ edwardsToMontgomeryPriv),\n/* harmony export */   edwardsToMontgomeryPub: () => (/* binding */ edwardsToMontgomeryPub),\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   hashToRistretto255: () => (/* binding */ hashToRistretto255),\n/* harmony export */   hash_to_ristretto255: () => (/* binding */ hash_to_ristretto255),\n/* harmony export */   ristretto255: () => (/* binding */ ristretto255),\n/* harmony export */   ristretto255_hasher: () => (/* binding */ ristretto255_hasher),\n/* harmony export */   x25519: () => (/* binding */ x25519)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/sha2.js */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/sha2.js\");\n/* harmony import */ var _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/utils.js */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_curve_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./abstract/curve.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/curve.js\");\n/* harmony import */ var _abstract_edwards_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/edwards.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/edwards.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_montgomery_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abstract/montgomery.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/montgomery.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/utils.js\");\n/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n\n\n\n\n\n// prettier-ignore\nconst _0n = /* @__PURE__ */ BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _5n = BigInt(5), _8n = BigInt(8);\n// P = 2n**255n-19n\nconst ed25519_CURVE_p = BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed\");\n// N = 2n**252n + 27742317777372353535851937790883648493n\n// a = Fp.create(BigInt(-1))\n// d = -121665/121666 a.k.a. Fp.neg(121665 * Fp.inv(121666))\nconst ed25519_CURVE = /* @__PURE__ */ (()=>({\n        p: ed25519_CURVE_p,\n        n: BigInt(\"0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed\"),\n        h: _8n,\n        a: BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec\"),\n        d: BigInt(\"0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3\"),\n        Gx: BigInt(\"0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a\"),\n        Gy: BigInt(\"0x6666666666666666666666666666666666666666666666666666666666666658\")\n    }))();\nfunction ed25519_pow_2_252_3(x) {\n    // prettier-ignore\n    const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\n    const P = ed25519_CURVE_p;\n    const x2 = x * x % P;\n    const b2 = x2 * x % P; // x^3, 11\n    const b4 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b2, _2n, P) * b2 % P; // x^15, 1111\n    const b5 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b4, _1n, P) * x % P; // x^31\n    const b10 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b5, _5n, P) * b5 % P;\n    const b20 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b10, _10n, P) * b10 % P;\n    const b40 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b20, _20n, P) * b20 % P;\n    const b80 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b40, _40n, P) * b40 % P;\n    const b160 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b80, _80n, P) * b80 % P;\n    const b240 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b160, _80n, P) * b80 % P;\n    const b250 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b240, _10n, P) * b10 % P;\n    const pow_p_5_8 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b250, _2n, P) * x % P;\n    // ^ To pow to (p+3)/8, multiply it by x.\n    return {\n        pow_p_5_8,\n        b2\n    };\n}\nfunction adjustScalarBytes(bytes) {\n    // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n    // set the three least significant bits of the first byte\n    bytes[0] &= 248; // 0b1111_1000\n    // and the most significant bit of the last to zero,\n    bytes[31] &= 127; // 0b0111_1111\n    // set the second most significant bit of the last byte to 1\n    bytes[31] |= 64; // 0b0100_0000\n    return bytes;\n}\n// √(-1) aka √(a) aka 2^((p-1)/4)\n// Fp.sqrt(Fp.neg(1))\nconst ED25519_SQRT_M1 = /* @__PURE__ */ BigInt(\"19681161376707505956807079304988542015446066515923890162744021073123829784752\");\n// sqrt(u/v)\nfunction uvRatio(u, v) {\n    const P = ed25519_CURVE_p;\n    const v3 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v * v * v, P); // v³\n    const v7 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v3 * v3 * v, P); // v⁷\n    // (p+3)/8 and (p-5)/8\n    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n    let x = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(u * v3 * pow, P); // (uv³)(uv⁷)^(p-5)/8\n    const vx2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v * x * x, P); // vx²\n    const root1 = x; // First root candidate\n    const root2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x * ED25519_SQRT_M1, P); // Second root candidate\n    const useRoot1 = vx2 === u; // If vx² = u (mod p), x is a square root\n    const useRoot2 = vx2 === (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-u, P); // If vx² = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-u * ED25519_SQRT_M1, P); // There is no valid root, vx² = -u√(-1)\n    if (useRoot1) x = root1;\n    if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time\n    if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(x, P)) x = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-x, P);\n    return {\n        isValid: useRoot1 || useRoot2,\n        value: x\n    };\n}\nconst Fp = /* @__PURE__ */ (()=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(ed25519_CURVE.p, {\n        isLE: true\n    }))();\nconst Fn = /* @__PURE__ */ (()=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(ed25519_CURVE.n, {\n        isLE: true\n    }))();\nconst ed25519Defaults = /* @__PURE__ */ (()=>({\n        ...ed25519_CURVE,\n        Fp,\n        hash: _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_1__.sha512,\n        adjustScalarBytes,\n        // dom2\n        // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n        // Constant-time, u/√v\n        uvRatio\n    }))();\n/**\n * ed25519 curve with EdDSA signatures.\n * @example\n * import { ed25519 } from '@noble/curves/ed25519';\n * const { secretKey, publicKey } = ed25519.keygen();\n * const msg = new TextEncoder().encode('hello');\n * const sig = ed25519.sign(msg, priv);\n * ed25519.verify(sig, msg, pub); // Default mode: follows ZIP215\n * ed25519.verify(sig, msg, pub, { zip215: false }); // RFC8032 / FIPS 186-5\n */ const ed25519 = /* @__PURE__ */ (()=>(0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_2__.twistedEdwards)(ed25519Defaults))();\nfunction ed25519_domain(data, ctx, phflag) {\n    if (ctx.length > 255) throw new Error(\"Context is too big\");\n    return (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)((0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_3__.utf8ToBytes)(\"SigEd25519 no Ed25519 collisions\"), new Uint8Array([\n        phflag ? 1 : 0,\n        ctx.length\n    ]), ctx, data);\n}\n/** Context of ed25519. Uses context for domain separation. */ const ed25519ctx = /* @__PURE__ */ (()=>(0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_2__.twistedEdwards)({\n        ...ed25519Defaults,\n        domain: ed25519_domain\n    }))();\n/** Prehashed version of ed25519. Accepts already-hashed messages in sign() and verify(). */ const ed25519ph = /* @__PURE__ */ (()=>(0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_2__.twistedEdwards)(Object.assign({}, ed25519Defaults, {\n        domain: ed25519_domain,\n        prehash: _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_1__.sha512\n    })))();\n/**\n * ECDH using curve25519 aka x25519.\n * @example\n * import { x25519 } from '@noble/curves/ed25519';\n * const priv = 'a546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4';\n * const pub = 'e6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c';\n * x25519.getSharedSecret(priv, pub) === x25519.scalarMult(priv, pub); // aliases\n * x25519.getPublicKey(priv) === x25519.scalarMultBase(priv);\n * x25519.getPublicKey(x25519.utils.randomSecretKey());\n */ const x25519 = /* @__PURE__ */ (()=>{\n    const P = Fp.ORDER;\n    return (0,_abstract_montgomery_js__WEBPACK_IMPORTED_MODULE_4__.montgomery)({\n        P,\n        type: \"x25519\",\n        powPminus2: (x)=>{\n            // x^(p-2) aka x^(2^255-21)\n            const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n            return (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(pow_p_5_8, _3n, P) * b2, P);\n        },\n        adjustScalarBytes\n    });\n})();\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\nconst ELL2_C1 = /* @__PURE__ */ (()=>(ed25519_CURVE_p + _3n) / _8n)(); // 1. c1 = (q + 3) / 8       # Integer arithmetic\nconst ELL2_C2 = /* @__PURE__ */ (()=>Fp.pow(_2n, ELL2_C1))(); // 2. c2 = 2^c1\nconst ELL2_C3 = /* @__PURE__ */ (()=>Fp.sqrt(Fp.neg(Fp.ONE)))(); // 3. c3 = sqrt(-1)\n// prettier-ignore\nfunction map_to_curve_elligator2_curve25519(u) {\n    const ELL2_C4 = (ed25519_CURVE_p - _5n) / _8n; // 4. c4 = (q - 5) / 8       # Integer arithmetic\n    const ELL2_J = BigInt(486662);\n    let tv1 = Fp.sqr(u); //  1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, _2n); //  2.  tv1 = 2 * tv1\n    let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n    let x1n = Fp.neg(ELL2_J); //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n    let tv2 = Fp.sqr(xd); //  5.  tv2 = xd^2\n    let gxd = Fp.mul(tv2, xd); //  6.  gxd = tv2 * xd        # gxd = xd^3\n    let gx1 = Fp.mul(tv1, ELL2_J); //  7.  gx1 = J * tv1         # x1n + J * xd\n    gx1 = Fp.mul(gx1, x1n); //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n    gx1 = Fp.add(gx1, tv2); //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n    gx1 = Fp.mul(gx1, x1n); //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n    let tv3 = Fp.sqr(gxd); //  11. tv3 = gxd^2\n    tv2 = Fp.sqr(tv3); //  12. tv2 = tv3^2           # gxd^4\n    tv3 = Fp.mul(tv3, gxd); //  13. tv3 = tv3 * gxd       # gxd^3\n    tv3 = Fp.mul(tv3, gx1); //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n    tv2 = Fp.mul(tv2, tv3); //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n    let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n    y11 = Fp.mul(y11, tv3); //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n    let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n    tv2 = Fp.sqr(y11); //  19. tv2 = y11^2\n    tv2 = Fp.mul(tv2, gxd); //  20. tv2 = tv2 * gxd\n    let e1 = Fp.eql(tv2, gx1); //  21.  e1 = tv2 == gx1\n    let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n    let x2n = Fp.mul(x1n, tv1); //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n    let y21 = Fp.mul(y11, u); //  24. y21 = y11 * u\n    y21 = Fp.mul(y21, ELL2_C2); //  25. y21 = y21 * c2\n    let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n    let gx2 = Fp.mul(gx1, tv1); //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n    tv2 = Fp.sqr(y21); //  28. tv2 = y21^2\n    tv2 = Fp.mul(tv2, gxd); //  29. tv2 = tv2 * gxd\n    let e2 = Fp.eql(tv2, gx2); //  30.  e2 = tv2 == gx2\n    let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n    tv2 = Fp.sqr(y1); //  32. tv2 = y1^2\n    tv2 = Fp.mul(tv2, gxd); //  33. tv2 = tv2 * gxd\n    let e3 = Fp.eql(tv2, gx1); //  34.  e3 = tv2 == gx1\n    let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n    let y = Fp.cmov(y2, y1, e3); //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n    let e4 = Fp.isOdd(y); //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n    y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n    return {\n        xMn: xn,\n        xMd: xd,\n        yMn: y,\n        yMd: _1n\n    }; //  39. return (xn, xd, y, 1)\n}\nconst ELL2_C1_EDWARDS = /* @__PURE__ */ (()=>(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))))(); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u) {\n    const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n    // map_to_curve_elligator2_curve25519(u)\n    let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n    xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n    let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n    let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n    let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n    let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n    let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n    xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n    xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n    yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n    yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n    const [xd_inv, yd_inv] = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpInvertBatch)(Fp, [\n        xd,\n        yd\n    ], true); // batch division\n    return {\n        x: Fp.mul(xn, xd_inv),\n        y: Fp.mul(yn, yd_inv)\n    }; //  13. return (xn, xd, yn, yd)\n}\n/** Hashing to ed25519 points / field. RFC 9380 methods. */ const ed25519_hasher = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(ed25519.Point, (scalars)=>map_to_curve_elligator2_edwards25519(scalars[0]), {\n        DST: \"edwards25519_XMD:SHA-512_ELL2_RO_\",\n        encodeDST: \"edwards25519_XMD:SHA-512_ELL2_NU_\",\n        p: ed25519_CURVE_p,\n        m: 1,\n        k: 128,\n        expand: \"xmd\",\n        hash: _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_1__.sha512\n    }))();\n// √(-1) aka √(a) aka 2^((p-1)/4)\nconst SQRT_M1 = ED25519_SQRT_M1;\n// √(ad - 1)\nconst SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt(\"25063068953384623474111414158702152701244531502492656460079210482610430750235\");\n// 1 / √(a-d)\nconst INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt(\"54469307008909316920995813868745141605393597292927456921205312896311721017578\");\n// 1-d²\nconst ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt(\"1159843021668779879193775521855586647937357759715417654439879720876111806838\");\n// (d-1)²\nconst D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt(\"40440834346308536858101042469323190826248399146238708352240133220865137265952\");\n// Calculates 1/√(number)\nconst invertSqrt = (number)=>uvRatio(_1n, number);\nconst MAX_255B = /* @__PURE__ */ BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nconst bytes255ToNumberLE = (bytes)=>ed25519.Point.Fp.create((0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.bytesToNumberLE)(bytes) & MAX_255B);\n/**\n * Computes Elligator map for Ristretto255.\n * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on\n * the [website](https://ristretto.group/formulas/elligator.html).\n */ function calcElligatorRistrettoMap(r0) {\n    const { d } = ed25519_CURVE;\n    const P = ed25519_CURVE_p;\n    const mod = (n)=>Fp.create(n);\n    const r = mod(SQRT_M1 * r0 * r0); // 1\n    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n    let c = BigInt(-1); // 3\n    const D = mod((c - d * r) * mod(r + d)); // 4\n    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n    let s_ = mod(s * r0); // 6\n    if (!(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s_, P)) s_ = mod(-s_);\n    if (!Ns_D_is_sq) s = s_; // 7\n    if (!Ns_D_is_sq) c = r; // 8\n    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n    const s2 = s * s;\n    const W0 = mod((s + s) * D); // 10\n    const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n    const W2 = mod(_1n - s2); // 12\n    const W3 = mod(_1n + s2); // 13\n    return new ed25519.Point(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\nfunction ristretto255_map(bytes) {\n    (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_3__.abytes)(bytes, 64);\n    const r1 = bytes255ToNumberLE(bytes.subarray(0, 32));\n    const R1 = calcElligatorRistrettoMap(r1);\n    const r2 = bytes255ToNumberLE(bytes.subarray(32, 64));\n    const R2 = calcElligatorRistrettoMap(r2);\n    return new _RistrettoPoint(R1.add(R2));\n}\n/**\n * Wrapper over Edwards Point for ristretto255.\n *\n * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,\n * but it should work in its own namespace: do not combine those two.\n * See [RFC9496](https://www.rfc-editor.org/rfc/rfc9496).\n */ class _RistrettoPoint extends _abstract_edwards_js__WEBPACK_IMPORTED_MODULE_2__.PrimeEdwardsPoint {\n    constructor(ep){\n        super(ep);\n    }\n    static fromAffine(ap) {\n        return new _RistrettoPoint(ed25519.Point.fromAffine(ap));\n    }\n    assertSame(other) {\n        if (!(other instanceof _RistrettoPoint)) throw new Error(\"RistrettoPoint expected\");\n    }\n    init(ep) {\n        return new _RistrettoPoint(ep);\n    }\n    /** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */ static hashToCurve(hex) {\n        return ristretto255_map((0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.ensureBytes)(\"ristrettoHash\", hex, 64));\n    }\n    static fromBytes(bytes) {\n        (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_3__.abytes)(bytes, 32);\n        const { a, d } = ed25519_CURVE;\n        const P = ed25519_CURVE_p;\n        const mod = (n)=>Fp.create(n);\n        const s = bytes255ToNumberLE(bytes);\n        // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n        // 3. Check that s is non-negative, or else abort\n        if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.equalBytes)(Fp.toBytes(s), bytes) || (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s, P)) throw new Error(\"invalid ristretto255 encoding 1\");\n        const s2 = mod(s * s);\n        const u1 = mod(_1n + a * s2); // 4 (a is -1)\n        const u2 = mod(_1n - a * s2); // 5\n        const u1_2 = mod(u1 * u1);\n        const u2_2 = mod(u2 * u2);\n        const v = mod(a * d * u1_2 - u2_2); // 6\n        const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n        const Dx = mod(I * u2); // 8\n        const Dy = mod(I * Dx * v); // 9\n        let x = mod((s + s) * Dx); // 10\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(x, P)) x = mod(-x); // 10\n        const y = mod(u1 * Dy); // 11\n        const t = mod(x * y); // 12\n        if (!isValid || (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(t, P) || y === _0n) throw new Error(\"invalid ristretto255 encoding 2\");\n        return new _RistrettoPoint(new ed25519.Point(x, y, _1n, t));\n    }\n    /**\n     * Converts ristretto-encoded string to ristretto point.\n     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).\n     * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n     */ static fromHex(hex) {\n        return _RistrettoPoint.fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.ensureBytes)(\"ristrettoHex\", hex, 32));\n    }\n    static msm(points, scalars) {\n        return (0,_abstract_curve_js__WEBPACK_IMPORTED_MODULE_7__.pippenger)(_RistrettoPoint, ed25519.Point.Fn, points, scalars);\n    }\n    /**\n     * Encodes ristretto point to Uint8Array.\n     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).\n     */ toBytes() {\n        let { X, Y, Z, T } = this.ep;\n        const P = ed25519_CURVE_p;\n        const mod = (n)=>Fp.create(n);\n        const u1 = mod(mod(Z + Y) * mod(Z - Y)); // 1\n        const u2 = mod(X * Y); // 2\n        // Square root always exists\n        const u2sq = mod(u2 * u2);\n        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n        const D1 = mod(invsqrt * u1); // 4\n        const D2 = mod(invsqrt * u2); // 5\n        const zInv = mod(D1 * D2 * T); // 6\n        let D; // 7\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(T * zInv, P)) {\n            let _x = mod(Y * SQRT_M1);\n            let _y = mod(X * SQRT_M1);\n            X = _x;\n            Y = _y;\n            D = mod(D1 * INVSQRT_A_MINUS_D);\n        } else {\n            D = D2; // 8\n        }\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(X * zInv, P)) Y = mod(-Y); // 9\n        let s = mod((Z - Y) * D); // 10 (check footer's note, no sqrt(-a))\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s, P)) s = mod(-s);\n        return Fp.toBytes(s); // 11\n    }\n    /**\n     * Compares two Ristretto points.\n     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).\n     */ equals(other) {\n        this.assertSame(other);\n        const { X: X1, Y: Y1 } = this.ep;\n        const { X: X2, Y: Y2 } = other.ep;\n        const mod = (n)=>Fp.create(n);\n        // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n        const one = mod(X1 * Y2) === mod(Y1 * X2);\n        const two = mod(Y1 * Y2) === mod(X1 * X2);\n        return one || two;\n    }\n    is0() {\n        return this.equals(_RistrettoPoint.ZERO);\n    }\n}\n// Do NOT change syntax: the following gymnastics is done,\n// because typescript strips comments, which makes bundlers disable tree-shaking.\n// prettier-ignore\n_RistrettoPoint.BASE = /* @__PURE__ */ (()=>new _RistrettoPoint(ed25519.Point.BASE))();\n// prettier-ignore\n_RistrettoPoint.ZERO = /* @__PURE__ */ (()=>new _RistrettoPoint(ed25519.Point.ZERO))();\n// prettier-ignore\n_RistrettoPoint.Fp = /* @__PURE__ */ (()=>Fp)();\n// prettier-ignore\n_RistrettoPoint.Fn = /* @__PURE__ */ (()=>Fn)();\nconst ristretto255 = {\n    Point: _RistrettoPoint\n};\n/** Hashing to ristretto255 points / field. RFC 9380 methods. */ const ristretto255_hasher = {\n    hashToCurve (msg, options) {\n        const DST = options?.DST || \"ristretto255_XMD:SHA-512_R255MAP_RO_\";\n        const xmd = (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.expand_message_xmd)(msg, DST, 64, _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_1__.sha512);\n        return ristretto255_map(xmd);\n    },\n    hashToScalar (msg, options = {\n        DST: _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__._DST_scalar\n    }) {\n        const xmd = (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.expand_message_xmd)(msg, options.DST, 64, _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_1__.sha512);\n        return Fn.create((0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.bytesToNumberLE)(xmd));\n    }\n};\n// export const ristretto255_oprf: OPRF = createORPF({\n//   name: 'ristretto255-SHA512',\n//   Point: RistrettoPoint,\n//   hash: sha512,\n//   hashToGroup: ristretto255_hasher.hashToCurve,\n//   hashToScalar: ristretto255_hasher.hashToScalar,\n// });\n/**\n * Weird / bogus points, useful for debugging.\n * All 8 ed25519 points of 8-torsion subgroup can be generated from the point\n * T = `26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05`.\n * ⟨T⟩ = { O, T, 2T, 3T, 4T, 5T, 6T, 7T }\n */ const ED25519_TORSION_SUBGROUP = [\n    \"0100000000000000000000000000000000000000000000000000000000000000\",\n    \"c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a\",\n    \"0000000000000000000000000000000000000000000000000000000000000080\",\n    \"26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05\",\n    \"ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f\",\n    \"26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85\",\n    \"0000000000000000000000000000000000000000000000000000000000000000\",\n    \"c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa\"\n];\n/** @deprecated use `ed25519.utils.toMontgomery` */ function edwardsToMontgomeryPub(edwardsPub) {\n    return ed25519.utils.toMontgomery((0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.ensureBytes)(\"pub\", edwardsPub));\n}\n/** @deprecated use `ed25519.utils.toMontgomery` */ const edwardsToMontgomery = edwardsToMontgomeryPub;\n/** @deprecated use `ed25519.utils.toMontgomerySecret` */ function edwardsToMontgomeryPriv(edwardsPriv) {\n    return ed25519.utils.toMontgomerySecret((0,_utils_js__WEBPACK_IMPORTED_MODULE_6__.ensureBytes)(\"pub\", edwardsPriv));\n}\n/** @deprecated use `ristretto255.Point` */ const RistrettoPoint = _RistrettoPoint;\n/** @deprecated use `import { ed25519_hasher } from '@noble/curves/ed25519.js';` */ const hashToCurve = /* @__PURE__ */ (()=>ed25519_hasher.hashToCurve)();\n/** @deprecated use `import { ed25519_hasher } from '@noble/curves/ed25519.js';` */ const encodeToCurve = /* @__PURE__ */ (()=>ed25519_hasher.encodeToCurve)();\n/** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */ const hashToRistretto255 = /* @__PURE__ */ (()=>ristretto255_hasher.hashToCurve)();\n/** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */ const hash_to_ristretto255 = /* @__PURE__ */ (()=>ristretto255_hasher.hashToCurve)(); //# sourceMappingURL=ed25519.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjkuNy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vZWQyNTUxOS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7Ozs7O0NBTUMsR0FDRCxvRUFBb0UsR0FDckI7QUFDMkI7QUFDMUI7QUFDMkI7QUFDa0I7QUFDTTtBQUM3QztBQUNnQjtBQUN0RSxrQkFBa0I7QUFDbEIsTUFBTW9CLE1BQU0sYUFBYSxHQUFHQyxPQUFPLElBQUlDLE1BQU1ELE9BQU8sSUFBSUUsTUFBTUYsT0FBTyxJQUFJRyxNQUFNSCxPQUFPO0FBQ3RGLGtCQUFrQjtBQUNsQixNQUFNSSxNQUFNSixPQUFPLElBQUlLLE1BQU1MLE9BQU87QUFDcEMsbUJBQW1CO0FBQ25CLE1BQU1NLGtCQUFrQk4sT0FBTztBQUMvQix5REFBeUQ7QUFDekQsNEJBQTRCO0FBQzVCLDREQUE0RDtBQUM1RCxNQUFNTyxnQkFBZ0MsYUFBSCxHQUFJLEtBQU87UUFDMUNDLEdBQUdGO1FBQ0hHLEdBQUdULE9BQU87UUFDVlUsR0FBR0w7UUFDSE0sR0FBR1gsT0FBTztRQUNWWSxHQUFHWixPQUFPO1FBQ1ZhLElBQUliLE9BQU87UUFDWGMsSUFBSWQsT0FBTztJQUNmLEVBQUM7QUFDRCxTQUFTZSxvQkFBb0JDLENBQUM7SUFDMUIsa0JBQWtCO0lBQ2xCLE1BQU1DLE9BQU9qQixPQUFPLEtBQUtrQixPQUFPbEIsT0FBTyxLQUFLbUIsT0FBT25CLE9BQU8sS0FBS29CLE9BQU9wQixPQUFPO0lBQzdFLE1BQU1xQixJQUFJZjtJQUNWLE1BQU1nQixLQUFLLElBQUtOLElBQUtLO0lBQ3JCLE1BQU1FLEtBQUssS0FBTVAsSUFBS0ssR0FBRyxVQUFVO0lBQ25DLE1BQU1HLEtBQUssMkRBQU1ELElBQUlyQixLQUFLbUIsS0FBS0UsS0FBTUYsR0FBRyxhQUFhO0lBQ3JELE1BQU1JLEtBQUssMkRBQU1ELElBQUl2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c0JKLHVCQUF1QjtBQUMxRCx1REFBdUQsR0FDaEQsU0FBU0ssd0JBQXdCQyxXQUFXO0lBQy9DLE9BQU9sSyxRQUFROEosS0FBSyxDQUFDSyxrQkFBa0IsQ0FBQzlOLHNEQUFXQSxDQUFDLE9BQU82TjtBQUMvRDtBQUNBLHlDQUF5QyxHQUNsQyxNQUFNRSxpQkFBaUIxRCxnQkFBZ0I7QUFDOUMsaUZBQWlGLEdBQzFFLE1BQU1RLGNBQThCLGFBQUgsR0FBSSxLQUFNL0MsZUFBZStDLFdBQVcsSUFBSTtBQUNoRixpRkFBaUYsR0FDMUUsTUFBTW1ELGdCQUFnQyxhQUFILEdBQUksS0FBTWxHLGVBQWVrRyxhQUFhLElBQUk7QUFDcEYsc0ZBQXNGLEdBQy9FLE1BQU1DLHFCQUFxQyxhQUFILEdBQUksS0FBTWhCLG9CQUFvQnBDLFdBQVcsSUFBSTtBQUM1RixzRkFBc0YsR0FDL0UsTUFBTXFELHVCQUF1QyxhQUFILEdBQUksS0FBTWpCLG9CQUFvQnBDLFdBQVcsSUFBSSxDQUM5RixtQ0FBbUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3Rhc2NhbS1wcm90b2NvbC8uL25vZGVfbW9kdWxlcy8ucG5wbS9Abm9ibGUrY3VydmVzQDEuOS43L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9lZDI1NTE5LmpzPzkyMDciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBlZDI1NTE5IFR3aXN0ZWQgRWR3YXJkcyBjdXJ2ZSB3aXRoIGZvbGxvd2luZyBhZGRvbnM6XG4gKiAtIFgyNTUxOSBFQ0RIXG4gKiAtIFJpc3RyZXR0byBjb2ZhY3RvciBlbGltaW5hdGlvblxuICogLSBFbGxpZ2F0b3IgaGFzaC10by1ncm91cCAvIHBvaW50IGluZGlzdGluZ3Vpc2hhYmlsaXR5XG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IHNoYTUxMiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMi5qcyc7XG5pbXBvcnQgeyBhYnl0ZXMsIGNvbmNhdEJ5dGVzLCB1dGY4VG9CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMuanMnO1xuaW1wb3J0IHsgcGlwcGVuZ2VyIH0gZnJvbSBcIi4vYWJzdHJhY3QvY3VydmUuanNcIjtcbmltcG9ydCB7IFByaW1lRWR3YXJkc1BvaW50LCB0d2lzdGVkRWR3YXJkcywgfSBmcm9tIFwiLi9hYnN0cmFjdC9lZHdhcmRzLmpzXCI7XG5pbXBvcnQgeyBfRFNUX3NjYWxhciwgY3JlYXRlSGFzaGVyLCBleHBhbmRfbWVzc2FnZV94bWQsIH0gZnJvbSBcIi4vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qc1wiO1xuaW1wb3J0IHsgRmllbGQsIEZwSW52ZXJ0QmF0Y2gsIEZwU3FydEV2ZW4sIGlzTmVnYXRpdmVMRSwgbW9kLCBwb3cyLCB9IGZyb20gXCIuL2Fic3RyYWN0L21vZHVsYXIuanNcIjtcbmltcG9ydCB7IG1vbnRnb21lcnkgfSBmcm9tIFwiLi9hYnN0cmFjdC9tb250Z29tZXJ5LmpzXCI7XG5pbXBvcnQgeyBieXRlc1RvTnVtYmVyTEUsIGVuc3VyZUJ5dGVzLCBlcXVhbEJ5dGVzIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF8zbiA9IEJpZ0ludCgzKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzVuID0gQmlnSW50KDUpLCBfOG4gPSBCaWdJbnQoOCk7XG4vLyBQID0gMm4qKjI1NW4tMTluXG5jb25zdCBlZDI1NTE5X0NVUlZFX3AgPSBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZCcpO1xuLy8gTiA9IDJuKioyNTJuICsgMjc3NDIzMTc3NzczNzIzNTM1MzU4NTE5Mzc3OTA4ODM2NDg0OTNuXG4vLyBhID0gRnAuY3JlYXRlKEJpZ0ludCgtMSkpXG4vLyBkID0gLTEyMTY2NS8xMjE2NjYgYS5rLmEuIEZwLm5lZygxMjE2NjUgKiBGcC5pbnYoMTIxNjY2KSlcbmNvbnN0IGVkMjU1MTlfQ1VSVkUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICh7XG4gICAgcDogZWQyNTUxOV9DVVJWRV9wLFxuICAgIG46IEJpZ0ludCgnMHgxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDE0ZGVmOWRlYTJmNzljZDY1ODEyNjMxYTVjZjVkM2VkJyksXG4gICAgaDogXzhuLFxuICAgIGE6IEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVjJyksXG4gICAgZDogQmlnSW50KCcweDUyMDM2Y2VlMmI2ZmZlNzM4Y2M3NDA3OTc3NzllODk4MDA3MDBhNGQ0MTQxZDhhYjc1ZWI0ZGNhMTM1OTc4YTMnKSxcbiAgICBHeDogQmlnSW50KCcweDIxNjkzNmQzY2Q2ZTUzZmVjMGE0ZTIzMWZkZDZkYzVjNjkyY2M3NjA5NTI1YTdiMmM5NTYyZDYwOGYyNWQ1MWEnKSxcbiAgICBHeTogQmlnSW50KCcweDY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NTgnKSxcbn0pKSgpO1xuZnVuY3Rpb24gZWQyNTUxOV9wb3dfMl8yNTJfMyh4KSB7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgXzEwbiA9IEJpZ0ludCgxMCksIF8yMG4gPSBCaWdJbnQoMjApLCBfNDBuID0gQmlnSW50KDQwKSwgXzgwbiA9IEJpZ0ludCg4MCk7XG4gICAgY29uc3QgUCA9IGVkMjU1MTlfQ1VSVkVfcDtcbiAgICBjb25zdCB4MiA9ICh4ICogeCkgJSBQO1xuICAgIGNvbnN0IGIyID0gKHgyICogeCkgJSBQOyAvLyB4XjMsIDExXG4gICAgY29uc3QgYjQgPSAocG93MihiMiwgXzJuLCBQKSAqIGIyKSAlIFA7IC8vIHheMTUsIDExMTFcbiAgICBjb25zdCBiNSA9IChwb3cyKGI0LCBfMW4sIFApICogeCkgJSBQOyAvLyB4XjMxXG4gICAgY29uc3QgYjEwID0gKHBvdzIoYjUsIF81biwgUCkgKiBiNSkgJSBQO1xuICAgIGNvbnN0IGIyMCA9IChwb3cyKGIxMCwgXzEwbiwgUCkgKiBiMTApICUgUDtcbiAgICBjb25zdCBiNDAgPSAocG93MihiMjAsIF8yMG4sIFApICogYjIwKSAlIFA7XG4gICAgY29uc3QgYjgwID0gKHBvdzIoYjQwLCBfNDBuLCBQKSAqIGI0MCkgJSBQO1xuICAgIGNvbnN0IGIxNjAgPSAocG93MihiODAsIF84MG4sIFApICogYjgwKSAlIFA7XG4gICAgY29uc3QgYjI0MCA9IChwb3cyKGIxNjAsIF84MG4sIFApICogYjgwKSAlIFA7XG4gICAgY29uc3QgYjI1MCA9IChwb3cyKGIyNDAsIF8xMG4sIFApICogYjEwKSAlIFA7XG4gICAgY29uc3QgcG93X3BfNV84ID0gKHBvdzIoYjI1MCwgXzJuLCBQKSAqIHgpICUgUDtcbiAgICAvLyBeIFRvIHBvdyB0byAocCszKS84LCBtdWx0aXBseSBpdCBieSB4LlxuICAgIHJldHVybiB7IHBvd19wXzVfOCwgYjIgfTtcbn1cbmZ1bmN0aW9uIGFkanVzdFNjYWxhckJ5dGVzKGJ5dGVzKSB7XG4gICAgLy8gU2VjdGlvbiA1OiBGb3IgWDI1NTE5LCBpbiBvcmRlciB0byBkZWNvZGUgMzIgcmFuZG9tIGJ5dGVzIGFzIGFuIGludGVnZXIgc2NhbGFyLFxuICAgIC8vIHNldCB0aGUgdGhyZWUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0cyBvZiB0aGUgZmlyc3QgYnl0ZVxuICAgIGJ5dGVzWzBdICY9IDI0ODsgLy8gMGIxMTExXzEwMDBcbiAgICAvLyBhbmQgdGhlIG1vc3Qgc2lnbmlmaWNhbnQgYml0IG9mIHRoZSBsYXN0IHRvIHplcm8sXG4gICAgYnl0ZXNbMzFdICY9IDEyNzsgLy8gMGIwMTExXzExMTFcbiAgICAvLyBzZXQgdGhlIHNlY29uZCBtb3N0IHNpZ25pZmljYW50IGJpdCBvZiB0aGUgbGFzdCBieXRlIHRvIDFcbiAgICBieXRlc1szMV0gfD0gNjQ7IC8vIDBiMDEwMF8wMDAwXG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuLy8g4oiaKC0xKSBha2Eg4oiaKGEpIGFrYSAyXigocC0xKS80KVxuLy8gRnAuc3FydChGcC5uZWcoMSkpXG5jb25zdCBFRDI1NTE5X1NRUlRfTTEgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KCcxOTY4MTE2MTM3NjcwNzUwNTk1NjgwNzA3OTMwNDk4ODU0MjAxNTQ0NjA2NjUxNTkyMzg5MDE2Mjc0NDAyMTA3MzEyMzgyOTc4NDc1MicpO1xuLy8gc3FydCh1L3YpXG5mdW5jdGlvbiB1dlJhdGlvKHUsIHYpIHtcbiAgICBjb25zdCBQID0gZWQyNTUxOV9DVVJWRV9wO1xuICAgIGNvbnN0IHYzID0gbW9kKHYgKiB2ICogdiwgUCk7IC8vIHbCs1xuICAgIGNvbnN0IHY3ID0gbW9kKHYzICogdjMgKiB2LCBQKTsgLy8gduKBt1xuICAgIC8vIChwKzMpLzggYW5kIChwLTUpLzhcbiAgICBjb25zdCBwb3cgPSBlZDI1NTE5X3Bvd18yXzI1Ml8zKHUgKiB2NykucG93X3BfNV84O1xuICAgIGxldCB4ID0gbW9kKHUgKiB2MyAqIHBvdywgUCk7IC8vICh1dsKzKSh1duKBtyleKHAtNSkvOFxuICAgIGNvbnN0IHZ4MiA9IG1vZCh2ICogeCAqIHgsIFApOyAvLyB2eMKyXG4gICAgY29uc3Qgcm9vdDEgPSB4OyAvLyBGaXJzdCByb290IGNhbmRpZGF0ZVxuICAgIGNvbnN0IHJvb3QyID0gbW9kKHggKiBFRDI1NTE5X1NRUlRfTTEsIFApOyAvLyBTZWNvbmQgcm9vdCBjYW5kaWRhdGVcbiAgICBjb25zdCB1c2VSb290MSA9IHZ4MiA9PT0gdTsgLy8gSWYgdnjCsiA9IHUgKG1vZCBwKSwgeCBpcyBhIHNxdWFyZSByb290XG4gICAgY29uc3QgdXNlUm9vdDIgPSB2eDIgPT09IG1vZCgtdSwgUCk7IC8vIElmIHZ4wrIgPSAtdSwgc2V0IHggPC0tIHggKiAyXigocC0xKS80KVxuICAgIGNvbnN0IG5vUm9vdCA9IHZ4MiA9PT0gbW9kKC11ICogRUQyNTUxOV9TUVJUX00xLCBQKTsgLy8gVGhlcmUgaXMgbm8gdmFsaWQgcm9vdCwgdnjCsiA9IC114oiaKC0xKVxuICAgIGlmICh1c2VSb290MSlcbiAgICAgICAgeCA9IHJvb3QxO1xuICAgIGlmICh1c2VSb290MiB8fCBub1Jvb3QpXG4gICAgICAgIHggPSByb290MjsgLy8gV2UgcmV0dXJuIHJvb3QyIGFueXdheSwgZm9yIGNvbnN0LXRpbWVcbiAgICBpZiAoaXNOZWdhdGl2ZUxFKHgsIFApKVxuICAgICAgICB4ID0gbW9kKC14LCBQKTtcbiAgICByZXR1cm4geyBpc1ZhbGlkOiB1c2VSb290MSB8fCB1c2VSb290MiwgdmFsdWU6IHggfTtcbn1cbmNvbnN0IEZwID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBGaWVsZChlZDI1NTE5X0NVUlZFLnAsIHsgaXNMRTogdHJ1ZSB9KSkoKTtcbmNvbnN0IEZuID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBGaWVsZChlZDI1NTE5X0NVUlZFLm4sIHsgaXNMRTogdHJ1ZSB9KSkoKTtcbmNvbnN0IGVkMjU1MTlEZWZhdWx0cyA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gKHtcbiAgICAuLi5lZDI1NTE5X0NVUlZFLFxuICAgIEZwLFxuICAgIGhhc2g6IHNoYTUxMixcbiAgICBhZGp1c3RTY2FsYXJCeXRlcyxcbiAgICAvLyBkb20yXG4gICAgLy8gUmF0aW8gb2YgdSB0byB2LiBBbGxvd3MgdXMgdG8gY29tYmluZSBpbnZlcnNpb24gYW5kIHNxdWFyZSByb290LiBVc2VzIGFsZ28gZnJvbSBSRkM4MDMyIDUuMS4zLlxuICAgIC8vIENvbnN0YW50LXRpbWUsIHUv4oiadlxuICAgIHV2UmF0aW8sXG59KSkoKTtcbi8qKlxuICogZWQyNTUxOSBjdXJ2ZSB3aXRoIEVkRFNBIHNpZ25hdHVyZXMuXG4gKiBAZXhhbXBsZVxuICogaW1wb3J0IHsgZWQyNTUxOSB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvZWQyNTUxOSc7XG4gKiBjb25zdCB7IHNlY3JldEtleSwgcHVibGljS2V5IH0gPSBlZDI1NTE5LmtleWdlbigpO1xuICogY29uc3QgbXNnID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKCdoZWxsbycpO1xuICogY29uc3Qgc2lnID0gZWQyNTUxOS5zaWduKG1zZywgcHJpdik7XG4gKiBlZDI1NTE5LnZlcmlmeShzaWcsIG1zZywgcHViKTsgLy8gRGVmYXVsdCBtb2RlOiBmb2xsb3dzIFpJUDIxNVxuICogZWQyNTUxOS52ZXJpZnkoc2lnLCBtc2csIHB1YiwgeyB6aXAyMTU6IGZhbHNlIH0pOyAvLyBSRkM4MDMyIC8gRklQUyAxODYtNVxuICovXG5leHBvcnQgY29uc3QgZWQyNTUxOSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gdHdpc3RlZEVkd2FyZHMoZWQyNTUxOURlZmF1bHRzKSkoKTtcbmZ1bmN0aW9uIGVkMjU1MTlfZG9tYWluKGRhdGEsIGN0eCwgcGhmbGFnKSB7XG4gICAgaWYgKGN0eC5sZW5ndGggPiAyNTUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udGV4dCBpcyB0b28gYmlnJyk7XG4gICAgcmV0dXJuIGNvbmNhdEJ5dGVzKHV0ZjhUb0J5dGVzKCdTaWdFZDI1NTE5IG5vIEVkMjU1MTkgY29sbGlzaW9ucycpLCBuZXcgVWludDhBcnJheShbcGhmbGFnID8gMSA6IDAsIGN0eC5sZW5ndGhdKSwgY3R4LCBkYXRhKTtcbn1cbi8qKiBDb250ZXh0IG9mIGVkMjU1MTkuIFVzZXMgY29udGV4dCBmb3IgZG9tYWluIHNlcGFyYXRpb24uICovXG5leHBvcnQgY29uc3QgZWQyNTUxOWN0eCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gdHdpc3RlZEVkd2FyZHMoe1xuICAgIC4uLmVkMjU1MTlEZWZhdWx0cyxcbiAgICBkb21haW46IGVkMjU1MTlfZG9tYWluLFxufSkpKCk7XG4vKiogUHJlaGFzaGVkIHZlcnNpb24gb2YgZWQyNTUxOS4gQWNjZXB0cyBhbHJlYWR5LWhhc2hlZCBtZXNzYWdlcyBpbiBzaWduKCkgYW5kIHZlcmlmeSgpLiAqL1xuZXhwb3J0IGNvbnN0IGVkMjU1MTlwaCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gdHdpc3RlZEVkd2FyZHMoT2JqZWN0LmFzc2lnbih7fSwgZWQyNTUxOURlZmF1bHRzLCB7XG4gICAgZG9tYWluOiBlZDI1NTE5X2RvbWFpbixcbiAgICBwcmVoYXNoOiBzaGE1MTIsXG59KSkpKCk7XG4vKipcbiAqIEVDREggdXNpbmcgY3VydmUyNTUxOSBha2EgeDI1NTE5LlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IHgyNTUxOSB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvZWQyNTUxOSc7XG4gKiBjb25zdCBwcml2ID0gJ2E1NDZlMzZiZjA1MjdjOWQzYjE2MTU0YjgyNDY1ZWRkNjIxNDRjMGFjMWZjNWExODUwNmEyMjQ0YmE0NDlhYzQnO1xuICogY29uc3QgcHViID0gJ2U2ZGI2ODY3NTgzMDMwZGIzNTk0YzFhNDI0YjE1ZjdjNzI2NjI0ZWMyNmIzMzUzYjEwYTkwM2E2ZDBhYjFjNGMnO1xuICogeDI1NTE5LmdldFNoYXJlZFNlY3JldChwcml2LCBwdWIpID09PSB4MjU1MTkuc2NhbGFyTXVsdChwcml2LCBwdWIpOyAvLyBhbGlhc2VzXG4gKiB4MjU1MTkuZ2V0UHVibGljS2V5KHByaXYpID09PSB4MjU1MTkuc2NhbGFyTXVsdEJhc2UocHJpdik7XG4gKiB4MjU1MTkuZ2V0UHVibGljS2V5KHgyNTUxOS51dGlscy5yYW5kb21TZWNyZXRLZXkoKSk7XG4gKi9cbmV4cG9ydCBjb25zdCB4MjU1MTkgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHtcbiAgICBjb25zdCBQID0gRnAuT1JERVI7XG4gICAgcmV0dXJuIG1vbnRnb21lcnkoe1xuICAgICAgICBQLFxuICAgICAgICB0eXBlOiAneDI1NTE5JyxcbiAgICAgICAgcG93UG1pbnVzMjogKHgpID0+IHtcbiAgICAgICAgICAgIC8vIHheKHAtMikgYWthIHheKDJeMjU1LTIxKVxuICAgICAgICAgICAgY29uc3QgeyBwb3dfcF81XzgsIGIyIH0gPSBlZDI1NTE5X3Bvd18yXzI1Ml8zKHgpO1xuICAgICAgICAgICAgcmV0dXJuIG1vZChwb3cyKHBvd19wXzVfOCwgXzNuLCBQKSAqIGIyLCBQKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRqdXN0U2NhbGFyQnl0ZXMsXG4gICAgfSk7XG59KSgpO1xuLy8gSGFzaCBUbyBDdXJ2ZSBFbGxpZ2F0b3IyIE1hcCAoTk9URTogZGlmZmVyZW50IGZyb20gcmlzdHJldHRvMjU1IGVsbGlnYXRvcilcbi8vIE5PVEU6IHZlcnkgaW1wb3J0YW50IHBhcnQgaXMgdXNhZ2Ugb2YgRnBTcXJ0RXZlbiBmb3IgRUxMMl9DMV9FRFdBUkRTLCBzaW5jZVxuLy8gU2FnZU1hdGggcmV0dXJucyBkaWZmZXJlbnQgcm9vdCBmaXJzdCBhbmQgZXZlcnl0aGluZyBmYWxscyBhcGFydFxuY29uc3QgRUxMMl9DMSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gKGVkMjU1MTlfQ1VSVkVfcCArIF8zbikgLyBfOG4pKCk7IC8vIDEuIGMxID0gKHEgKyAzKSAvIDggICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbmNvbnN0IEVMTDJfQzIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IEZwLnBvdyhfMm4sIEVMTDJfQzEpKSgpOyAvLyAyLiBjMiA9IDJeYzFcbmNvbnN0IEVMTDJfQzMgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IEZwLnNxcnQoRnAubmVnKEZwLk9ORSkpKSgpOyAvLyAzLiBjMyA9IHNxcnQoLTEpXG4vLyBwcmV0dGllci1pZ25vcmVcbmZ1bmN0aW9uIG1hcF90b19jdXJ2ZV9lbGxpZ2F0b3IyX2N1cnZlMjU1MTkodSkge1xuICAgIGNvbnN0IEVMTDJfQzQgPSAoZWQyNTUxOV9DVVJWRV9wIC0gXzVuKSAvIF84bjsgLy8gNC4gYzQgPSAocSAtIDUpIC8gOCAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IEVMTDJfSiA9IEJpZ0ludCg0ODY2NjIpO1xuICAgIGxldCB0djEgPSBGcC5zcXIodSk7IC8vICAxLiAgdHYxID0gdV4yXG4gICAgdHYxID0gRnAubXVsKHR2MSwgXzJuKTsgLy8gIDIuICB0djEgPSAyICogdHYxXG4gICAgbGV0IHhkID0gRnAuYWRkKHR2MSwgRnAuT05FKTsgLy8gIDMuICAgeGQgPSB0djEgKyAxICAgICAgICAgIyBOb256ZXJvOiAtMSBpcyBzcXVhcmUgKG1vZCBwKSwgdHYxIGlzIG5vdFxuICAgIGxldCB4MW4gPSBGcC5uZWcoRUxMMl9KKTsgLy8gIDQuICB4MW4gPSAtSiAgICAgICAgICAgICAgIyB4MSA9IHgxbiAvIHhkID0gLUogLyAoMSArIDIgKiB1XjIpXG4gICAgbGV0IHR2MiA9IEZwLnNxcih4ZCk7IC8vICA1LiAgdHYyID0geGReMlxuICAgIGxldCBneGQgPSBGcC5tdWwodHYyLCB4ZCk7IC8vICA2LiAgZ3hkID0gdHYyICogeGQgICAgICAgICMgZ3hkID0geGReM1xuICAgIGxldCBneDEgPSBGcC5tdWwodHYxLCBFTEwyX0opOyAvLyAgNy4gIGd4MSA9IEogKiB0djEgICAgICAgICAjIHgxbiArIEogKiB4ZFxuICAgIGd4MSA9IEZwLm11bChneDEsIHgxbik7IC8vICA4LiAgZ3gxID0gZ3gxICogeDFuICAgICAgICMgeDFuXjIgKyBKICogeDFuICogeGRcbiAgICBneDEgPSBGcC5hZGQoZ3gxLCB0djIpOyAvLyAgOS4gIGd4MSA9IGd4MSArIHR2MiAgICAgICAjIHgxbl4yICsgSiAqIHgxbiAqIHhkICsgeGReMlxuICAgIGd4MSA9IEZwLm11bChneDEsIHgxbik7IC8vICAxMC4gZ3gxID0gZ3gxICogeDFuICAgICAgICMgeDFuXjMgKyBKICogeDFuXjIgKiB4ZCArIHgxbiAqIHhkXjJcbiAgICBsZXQgdHYzID0gRnAuc3FyKGd4ZCk7IC8vICAxMS4gdHYzID0gZ3hkXjJcbiAgICB0djIgPSBGcC5zcXIodHYzKTsgLy8gIDEyLiB0djIgPSB0djNeMiAgICAgICAgICAgIyBneGReNFxuICAgIHR2MyA9IEZwLm11bCh0djMsIGd4ZCk7IC8vICAxMy4gdHYzID0gdHYzICogZ3hkICAgICAgICMgZ3hkXjNcbiAgICB0djMgPSBGcC5tdWwodHYzLCBneDEpOyAvLyAgMTQuIHR2MyA9IHR2MyAqIGd4MSAgICAgICAjIGd4MSAqIGd4ZF4zXG4gICAgdHYyID0gRnAubXVsKHR2MiwgdHYzKTsgLy8gIDE1LiB0djIgPSB0djIgKiB0djMgICAgICAgIyBneDEgKiBneGReN1xuICAgIGxldCB5MTEgPSBGcC5wb3codHYyLCBFTEwyX0M0KTsgLy8gIDE2LiB5MTEgPSB0djJeYzQgICAgICAgICMgKGd4MSAqIGd4ZF43KV4oKHAgLSA1KSAvIDgpXG4gICAgeTExID0gRnAubXVsKHkxMSwgdHYzKTsgLy8gIDE3LiB5MTEgPSB5MTEgKiB0djMgICAgICAgIyBneDEqZ3hkXjMqKGd4MSpneGReNyleKChwLTUpLzgpXG4gICAgbGV0IHkxMiA9IEZwLm11bCh5MTEsIEVMTDJfQzMpOyAvLyAgMTguIHkxMiA9IHkxMSAqIGMzXG4gICAgdHYyID0gRnAuc3FyKHkxMSk7IC8vICAxOS4gdHYyID0geTExXjJcbiAgICB0djIgPSBGcC5tdWwodHYyLCBneGQpOyAvLyAgMjAuIHR2MiA9IHR2MiAqIGd4ZFxuICAgIGxldCBlMSA9IEZwLmVxbCh0djIsIGd4MSk7IC8vICAyMS4gIGUxID0gdHYyID09IGd4MVxuICAgIGxldCB5MSA9IEZwLmNtb3YoeTEyLCB5MTEsIGUxKTsgLy8gIDIyLiAgeTEgPSBDTU9WKHkxMiwgeTExLCBlMSkgICMgSWYgZyh4MSkgaXMgc3F1YXJlLCB0aGlzIGlzIGl0cyBzcXJ0XG4gICAgbGV0IHgybiA9IEZwLm11bCh4MW4sIHR2MSk7IC8vICAyMy4geDJuID0geDFuICogdHYxICAgICAgICMgeDIgPSB4Mm4gLyB4ZCA9IDIgKiB1XjIgKiB4MW4gLyB4ZFxuICAgIGxldCB5MjEgPSBGcC5tdWwoeTExLCB1KTsgLy8gIDI0LiB5MjEgPSB5MTEgKiB1XG4gICAgeTIxID0gRnAubXVsKHkyMSwgRUxMMl9DMik7IC8vICAyNS4geTIxID0geTIxICogYzJcbiAgICBsZXQgeTIyID0gRnAubXVsKHkyMSwgRUxMMl9DMyk7IC8vICAyNi4geTIyID0geTIxICogYzNcbiAgICBsZXQgZ3gyID0gRnAubXVsKGd4MSwgdHYxKTsgLy8gIDI3LiBneDIgPSBneDEgKiB0djEgICAgICAgIyBnKHgyKSA9IGd4MiAvIGd4ZCA9IDIgKiB1XjIgKiBnKHgxKVxuICAgIHR2MiA9IEZwLnNxcih5MjEpOyAvLyAgMjguIHR2MiA9IHkyMV4yXG4gICAgdHYyID0gRnAubXVsKHR2MiwgZ3hkKTsgLy8gIDI5LiB0djIgPSB0djIgKiBneGRcbiAgICBsZXQgZTIgPSBGcC5lcWwodHYyLCBneDIpOyAvLyAgMzAuICBlMiA9IHR2MiA9PSBneDJcbiAgICBsZXQgeTIgPSBGcC5jbW92KHkyMiwgeTIxLCBlMik7IC8vICAzMS4gIHkyID0gQ01PVih5MjIsIHkyMSwgZTIpICAjIElmIGcoeDIpIGlzIHNxdWFyZSwgdGhpcyBpcyBpdHMgc3FydFxuICAgIHR2MiA9IEZwLnNxcih5MSk7IC8vICAzMi4gdHYyID0geTFeMlxuICAgIHR2MiA9IEZwLm11bCh0djIsIGd4ZCk7IC8vICAzMy4gdHYyID0gdHYyICogZ3hkXG4gICAgbGV0IGUzID0gRnAuZXFsKHR2MiwgZ3gxKTsgLy8gIDM0LiAgZTMgPSB0djIgPT0gZ3gxXG4gICAgbGV0IHhuID0gRnAuY21vdih4Mm4sIHgxbiwgZTMpOyAvLyAgMzUuICB4biA9IENNT1YoeDJuLCB4MW4sIGUzKSAgIyBJZiBlMywgeCA9IHgxLCBlbHNlIHggPSB4MlxuICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGUzKTsgLy8gIDM2LiAgIHkgPSBDTU9WKHkyLCB5MSwgZTMpICAgICMgSWYgZTMsIHkgPSB5MSwgZWxzZSB5ID0geTJcbiAgICBsZXQgZTQgPSBGcC5pc09kZCh5KTsgLy8gIDM3LiAgZTQgPSBzZ24wKHkpID09IDEgICAgICAgICMgRml4IHNpZ24gb2YgeVxuICAgIHkgPSBGcC5jbW92KHksIEZwLm5lZyh5KSwgZTMgIT09IGU0KTsgLy8gIDM4LiAgIHkgPSBDTU9WKHksIC15LCBlMyBYT1IgZTQpXG4gICAgcmV0dXJuIHsgeE1uOiB4biwgeE1kOiB4ZCwgeU1uOiB5LCB5TWQ6IF8xbiB9OyAvLyAgMzkuIHJldHVybiAoeG4sIHhkLCB5LCAxKVxufVxuY29uc3QgRUxMMl9DMV9FRFdBUkRTID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBGcFNxcnRFdmVuKEZwLCBGcC5uZWcoQmlnSW50KDQ4NjY2NCkpKSkoKTsgLy8gc2duMChjMSkgTVVTVCBlcXVhbCAwXG5mdW5jdGlvbiBtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9lZHdhcmRzMjU1MTkodSkge1xuICAgIGNvbnN0IHsgeE1uLCB4TWQsIHlNbiwgeU1kIH0gPSBtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9jdXJ2ZTI1NTE5KHUpOyAvLyAgMS4gICh4TW4sIHhNZCwgeU1uLCB5TWQpID1cbiAgICAvLyBtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9jdXJ2ZTI1NTE5KHUpXG4gICAgbGV0IHhuID0gRnAubXVsKHhNbiwgeU1kKTsgLy8gIDIuICB4biA9IHhNbiAqIHlNZFxuICAgIHhuID0gRnAubXVsKHhuLCBFTEwyX0MxX0VEV0FSRFMpOyAvLyAgMy4gIHhuID0geG4gKiBjMVxuICAgIGxldCB4ZCA9IEZwLm11bCh4TWQsIHlNbik7IC8vICA0LiAgeGQgPSB4TWQgKiB5TW4gICAgIyB4biAvIHhkID0gYzEgKiB4TSAvIHlNXG4gICAgbGV0IHluID0gRnAuc3ViKHhNbiwgeE1kKTsgLy8gIDUuICB5biA9IHhNbiAtIHhNZFxuICAgIGxldCB5ZCA9IEZwLmFkZCh4TW4sIHhNZCk7IC8vICA2LiAgeWQgPSB4TW4gKyB4TWQgICAgIyAobiAvIGQgLSAxKSAvIChuIC8gZCArIDEpID0gKG4gLSBkKSAvIChuICsgZClcbiAgICBsZXQgdHYxID0gRnAubXVsKHhkLCB5ZCk7IC8vICA3LiB0djEgPSB4ZCAqIHlkXG4gICAgbGV0IGUgPSBGcC5lcWwodHYxLCBGcC5aRVJPKTsgLy8gIDguICAgZSA9IHR2MSA9PSAwXG4gICAgeG4gPSBGcC5jbW92KHhuLCBGcC5aRVJPLCBlKTsgLy8gIDkuICB4biA9IENNT1YoeG4sIDAsIGUpXG4gICAgeGQgPSBGcC5jbW92KHhkLCBGcC5PTkUsIGUpOyAvLyAgMTAuIHhkID0gQ01PVih4ZCwgMSwgZSlcbiAgICB5biA9IEZwLmNtb3YoeW4sIEZwLk9ORSwgZSk7IC8vICAxMS4geW4gPSBDTU9WKHluLCAxLCBlKVxuICAgIHlkID0gRnAuY21vdih5ZCwgRnAuT05FLCBlKTsgLy8gIDEyLiB5ZCA9IENNT1YoeWQsIDEsIGUpXG4gICAgY29uc3QgW3hkX2ludiwgeWRfaW52XSA9IEZwSW52ZXJ0QmF0Y2goRnAsIFt4ZCwgeWRdLCB0cnVlKTsgLy8gYmF0Y2ggZGl2aXNpb25cbiAgICByZXR1cm4geyB4OiBGcC5tdWwoeG4sIHhkX2ludiksIHk6IEZwLm11bCh5biwgeWRfaW52KSB9OyAvLyAgMTMuIHJldHVybiAoeG4sIHhkLCB5biwgeWQpXG59XG4vKiogSGFzaGluZyB0byBlZDI1NTE5IHBvaW50cyAvIGZpZWxkLiBSRkMgOTM4MCBtZXRob2RzLiAqL1xuZXhwb3J0IGNvbnN0IGVkMjU1MTlfaGFzaGVyID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBjcmVhdGVIYXNoZXIoZWQyNTUxOS5Qb2ludCwgKHNjYWxhcnMpID0+IG1hcF90b19jdXJ2ZV9lbGxpZ2F0b3IyX2Vkd2FyZHMyNTUxOShzY2FsYXJzWzBdKSwge1xuICAgIERTVDogJ2Vkd2FyZHMyNTUxOV9YTUQ6U0hBLTUxMl9FTEwyX1JPXycsXG4gICAgZW5jb2RlRFNUOiAnZWR3YXJkczI1NTE5X1hNRDpTSEEtNTEyX0VMTDJfTlVfJyxcbiAgICBwOiBlZDI1NTE5X0NVUlZFX3AsXG4gICAgbTogMSxcbiAgICBrOiAxMjgsXG4gICAgZXhwYW5kOiAneG1kJyxcbiAgICBoYXNoOiBzaGE1MTIsXG59KSkoKTtcbi8vIOKImigtMSkgYWthIOKImihhKSBha2EgMl4oKHAtMSkvNClcbmNvbnN0IFNRUlRfTTEgPSBFRDI1NTE5X1NRUlRfTTE7XG4vLyDiiJooYWQgLSAxKVxuY29uc3QgU1FSVF9BRF9NSU5VU19PTkUgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KCcyNTA2MzA2ODk1MzM4NDYyMzQ3NDExMTQxNDE1ODcwMjE1MjcwMTI0NDUzMTUwMjQ5MjY1NjQ2MDA3OTIxMDQ4MjYxMDQzMDc1MDIzNScpO1xuLy8gMSAvIOKImihhLWQpXG5jb25zdCBJTlZTUVJUX0FfTUlOVVNfRCA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoJzU0NDY5MzA3MDA4OTA5MzE2OTIwOTk1ODEzODY4NzQ1MTQxNjA1MzkzNTk3MjkyOTI3NDU2OTIxMjA1MzEyODk2MzExNzIxMDE3NTc4Jyk7XG4vLyAxLWTCslxuY29uc3QgT05FX01JTlVTX0RfU1EgPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KCcxMTU5ODQzMDIxNjY4Nzc5ODc5MTkzNzc1NTIxODU1NTg2NjQ3OTM3MzU3NzU5NzE1NDE3NjU0NDM5ODc5NzIwODc2MTExODA2ODM4Jyk7XG4vLyAoZC0xKcKyXG5jb25zdCBEX01JTlVTX09ORV9TUSA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoJzQwNDQwODM0MzQ2MzA4NTM2ODU4MTAxMDQyNDY5MzIzMTkwODI2MjQ4Mzk5MTQ2MjM4NzA4MzUyMjQwMTMzMjIwODY1MTM3MjY1OTUyJyk7XG4vLyBDYWxjdWxhdGVzIDEv4oiaKG51bWJlcilcbmNvbnN0IGludmVydFNxcnQgPSAobnVtYmVyKSA9PiB1dlJhdGlvKF8xbiwgbnVtYmVyKTtcbmNvbnN0IE1BWF8yNTVCID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmJyk7XG5jb25zdCBieXRlczI1NVRvTnVtYmVyTEUgPSAoYnl0ZXMpID0+IGVkMjU1MTkuUG9pbnQuRnAuY3JlYXRlKGJ5dGVzVG9OdW1iZXJMRShieXRlcykgJiBNQVhfMjU1Qik7XG4vKipcbiAqIENvbXB1dGVzIEVsbGlnYXRvciBtYXAgZm9yIFJpc3RyZXR0bzI1NS5cbiAqIERlc2NyaWJlZCBpbiBbUkZDOTM4MF0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjYXBwZW5kaXgtQikgYW5kIG9uXG4gKiB0aGUgW3dlYnNpdGVdKGh0dHBzOi8vcmlzdHJldHRvLmdyb3VwL2Zvcm11bGFzL2VsbGlnYXRvci5odG1sKS5cbiAqL1xuZnVuY3Rpb24gY2FsY0VsbGlnYXRvclJpc3RyZXR0b01hcChyMCkge1xuICAgIGNvbnN0IHsgZCB9ID0gZWQyNTUxOV9DVVJWRTtcbiAgICBjb25zdCBQID0gZWQyNTUxOV9DVVJWRV9wO1xuICAgIGNvbnN0IG1vZCA9IChuKSA9PiBGcC5jcmVhdGUobik7XG4gICAgY29uc3QgciA9IG1vZChTUVJUX00xICogcjAgKiByMCk7IC8vIDFcbiAgICBjb25zdCBOcyA9IG1vZCgociArIF8xbikgKiBPTkVfTUlOVVNfRF9TUSk7IC8vIDJcbiAgICBsZXQgYyA9IEJpZ0ludCgtMSk7IC8vIDNcbiAgICBjb25zdCBEID0gbW9kKChjIC0gZCAqIHIpICogbW9kKHIgKyBkKSk7IC8vIDRcbiAgICBsZXQgeyBpc1ZhbGlkOiBOc19EX2lzX3NxLCB2YWx1ZTogcyB9ID0gdXZSYXRpbyhOcywgRCk7IC8vIDVcbiAgICBsZXQgc18gPSBtb2QocyAqIHIwKTsgLy8gNlxuICAgIGlmICghaXNOZWdhdGl2ZUxFKHNfLCBQKSlcbiAgICAgICAgc18gPSBtb2QoLXNfKTtcbiAgICBpZiAoIU5zX0RfaXNfc3EpXG4gICAgICAgIHMgPSBzXzsgLy8gN1xuICAgIGlmICghTnNfRF9pc19zcSlcbiAgICAgICAgYyA9IHI7IC8vIDhcbiAgICBjb25zdCBOdCA9IG1vZChjICogKHIgLSBfMW4pICogRF9NSU5VU19PTkVfU1EgLSBEKTsgLy8gOVxuICAgIGNvbnN0IHMyID0gcyAqIHM7XG4gICAgY29uc3QgVzAgPSBtb2QoKHMgKyBzKSAqIEQpOyAvLyAxMFxuICAgIGNvbnN0IFcxID0gbW9kKE50ICogU1FSVF9BRF9NSU5VU19PTkUpOyAvLyAxMVxuICAgIGNvbnN0IFcyID0gbW9kKF8xbiAtIHMyKTsgLy8gMTJcbiAgICBjb25zdCBXMyA9IG1vZChfMW4gKyBzMik7IC8vIDEzXG4gICAgcmV0dXJuIG5ldyBlZDI1NTE5LlBvaW50KG1vZChXMCAqIFczKSwgbW9kKFcyICogVzEpLCBtb2QoVzEgKiBXMyksIG1vZChXMCAqIFcyKSk7XG59XG5mdW5jdGlvbiByaXN0cmV0dG8yNTVfbWFwKGJ5dGVzKSB7XG4gICAgYWJ5dGVzKGJ5dGVzLCA2NCk7XG4gICAgY29uc3QgcjEgPSBieXRlczI1NVRvTnVtYmVyTEUoYnl0ZXMuc3ViYXJyYXkoMCwgMzIpKTtcbiAgICBjb25zdCBSMSA9IGNhbGNFbGxpZ2F0b3JSaXN0cmV0dG9NYXAocjEpO1xuICAgIGNvbnN0IHIyID0gYnl0ZXMyNTVUb051bWJlckxFKGJ5dGVzLnN1YmFycmF5KDMyLCA2NCkpO1xuICAgIGNvbnN0IFIyID0gY2FsY0VsbGlnYXRvclJpc3RyZXR0b01hcChyMik7XG4gICAgcmV0dXJuIG5ldyBfUmlzdHJldHRvUG9pbnQoUjEuYWRkKFIyKSk7XG59XG4vKipcbiAqIFdyYXBwZXIgb3ZlciBFZHdhcmRzIFBvaW50IGZvciByaXN0cmV0dG8yNTUuXG4gKlxuICogRWFjaCBlZDI1NTE5L0V4dGVuZGVkUG9pbnQgaGFzIDggZGlmZmVyZW50IGVxdWl2YWxlbnQgcG9pbnRzLiBUaGlzIGNhbiBiZVxuICogYSBzb3VyY2Ugb2YgYnVncyBmb3IgcHJvdG9jb2xzIGxpa2UgcmluZyBzaWduYXR1cmVzLiBSaXN0cmV0dG8gd2FzIGNyZWF0ZWQgdG8gc29sdmUgdGhpcy5cbiAqIFJpc3RyZXR0byBwb2ludCBvcGVyYXRlcyBpbiBYOlk6WjpUIGV4dGVuZGVkIGNvb3JkaW5hdGVzIGxpa2UgRXh0ZW5kZWRQb2ludCxcbiAqIGJ1dCBpdCBzaG91bGQgd29yayBpbiBpdHMgb3duIG5hbWVzcGFjZTogZG8gbm90IGNvbWJpbmUgdGhvc2UgdHdvLlxuICogU2VlIFtSRkM5NDk2XShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTQ5NikuXG4gKi9cbmNsYXNzIF9SaXN0cmV0dG9Qb2ludCBleHRlbmRzIFByaW1lRWR3YXJkc1BvaW50IHtcbiAgICBjb25zdHJ1Y3RvcihlcCkge1xuICAgICAgICBzdXBlcihlcCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQWZmaW5lKGFwKSB7XG4gICAgICAgIHJldHVybiBuZXcgX1Jpc3RyZXR0b1BvaW50KGVkMjU1MTkuUG9pbnQuZnJvbUFmZmluZShhcCkpO1xuICAgIH1cbiAgICBhc3NlcnRTYW1lKG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgX1Jpc3RyZXR0b1BvaW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmlzdHJldHRvUG9pbnQgZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgaW5pdChlcCkge1xuICAgICAgICByZXR1cm4gbmV3IF9SaXN0cmV0dG9Qb2ludChlcCk7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgYGltcG9ydCB7IHJpc3RyZXR0bzI1NV9oYXNoZXIgfSBmcm9tICdAbm9ibGUvY3VydmVzL2VkMjU1MTkuanMnO2AgKi9cbiAgICBzdGF0aWMgaGFzaFRvQ3VydmUoaGV4KSB7XG4gICAgICAgIHJldHVybiByaXN0cmV0dG8yNTVfbWFwKGVuc3VyZUJ5dGVzKCdyaXN0cmV0dG9IYXNoJywgaGV4LCA2NCkpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUJ5dGVzKGJ5dGVzKSB7XG4gICAgICAgIGFieXRlcyhieXRlcywgMzIpO1xuICAgICAgICBjb25zdCB7IGEsIGQgfSA9IGVkMjU1MTlfQ1VSVkU7XG4gICAgICAgIGNvbnN0IFAgPSBlZDI1NTE5X0NVUlZFX3A7XG4gICAgICAgIGNvbnN0IG1vZCA9IChuKSA9PiBGcC5jcmVhdGUobik7XG4gICAgICAgIGNvbnN0IHMgPSBieXRlczI1NVRvTnVtYmVyTEUoYnl0ZXMpO1xuICAgICAgICAvLyAxLiBDaGVjayB0aGF0IHNfYnl0ZXMgaXMgdGhlIGNhbm9uaWNhbCBlbmNvZGluZyBvZiBhIGZpZWxkIGVsZW1lbnQsIG9yIGVsc2UgYWJvcnQuXG4gICAgICAgIC8vIDMuIENoZWNrIHRoYXQgcyBpcyBub24tbmVnYXRpdmUsIG9yIGVsc2UgYWJvcnRcbiAgICAgICAgaWYgKCFlcXVhbEJ5dGVzKEZwLnRvQnl0ZXMocyksIGJ5dGVzKSB8fCBpc05lZ2F0aXZlTEUocywgUCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcmlzdHJldHRvMjU1IGVuY29kaW5nIDEnKTtcbiAgICAgICAgY29uc3QgczIgPSBtb2QocyAqIHMpO1xuICAgICAgICBjb25zdCB1MSA9IG1vZChfMW4gKyBhICogczIpOyAvLyA0IChhIGlzIC0xKVxuICAgICAgICBjb25zdCB1MiA9IG1vZChfMW4gLSBhICogczIpOyAvLyA1XG4gICAgICAgIGNvbnN0IHUxXzIgPSBtb2QodTEgKiB1MSk7XG4gICAgICAgIGNvbnN0IHUyXzIgPSBtb2QodTIgKiB1Mik7XG4gICAgICAgIGNvbnN0IHYgPSBtb2QoYSAqIGQgKiB1MV8yIC0gdTJfMik7IC8vIDZcbiAgICAgICAgY29uc3QgeyBpc1ZhbGlkLCB2YWx1ZTogSSB9ID0gaW52ZXJ0U3FydChtb2QodiAqIHUyXzIpKTsgLy8gN1xuICAgICAgICBjb25zdCBEeCA9IG1vZChJICogdTIpOyAvLyA4XG4gICAgICAgIGNvbnN0IER5ID0gbW9kKEkgKiBEeCAqIHYpOyAvLyA5XG4gICAgICAgIGxldCB4ID0gbW9kKChzICsgcykgKiBEeCk7IC8vIDEwXG4gICAgICAgIGlmIChpc05lZ2F0aXZlTEUoeCwgUCkpXG4gICAgICAgICAgICB4ID0gbW9kKC14KTsgLy8gMTBcbiAgICAgICAgY29uc3QgeSA9IG1vZCh1MSAqIER5KTsgLy8gMTFcbiAgICAgICAgY29uc3QgdCA9IG1vZCh4ICogeSk7IC8vIDEyXG4gICAgICAgIGlmICghaXNWYWxpZCB8fCBpc05lZ2F0aXZlTEUodCwgUCkgfHwgeSA9PT0gXzBuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHJpc3RyZXR0bzI1NSBlbmNvZGluZyAyJyk7XG4gICAgICAgIHJldHVybiBuZXcgX1Jpc3RyZXR0b1BvaW50KG5ldyBlZDI1NTE5LlBvaW50KHgsIHksIF8xbiwgdCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyByaXN0cmV0dG8tZW5jb2RlZCBzdHJpbmcgdG8gcmlzdHJldHRvIHBvaW50LlxuICAgICAqIERlc2NyaWJlZCBpbiBbUkZDOTQ5Nl0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzk0OTYjbmFtZS1kZWNvZGUpLlxuICAgICAqIEBwYXJhbSBoZXggUmlzdHJldHRvLWVuY29kZWQgMzIgYnl0ZXMuIE5vdCBldmVyeSAzMi1ieXRlIHN0cmluZyBpcyB2YWxpZCByaXN0cmV0dG8gZW5jb2RpbmdcbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgcmV0dXJuIF9SaXN0cmV0dG9Qb2ludC5mcm9tQnl0ZXMoZW5zdXJlQnl0ZXMoJ3Jpc3RyZXR0b0hleCcsIGhleCwgMzIpKTtcbiAgICB9XG4gICAgc3RhdGljIG1zbShwb2ludHMsIHNjYWxhcnMpIHtcbiAgICAgICAgcmV0dXJuIHBpcHBlbmdlcihfUmlzdHJldHRvUG9pbnQsIGVkMjU1MTkuUG9pbnQuRm4sIHBvaW50cywgc2NhbGFycyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgcmlzdHJldHRvIHBvaW50IHRvIFVpbnQ4QXJyYXkuXG4gICAgICogRGVzY3JpYmVkIGluIFtSRkM5NDk2XShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTQ5NiNuYW1lLWVuY29kZSkuXG4gICAgICovXG4gICAgdG9CeXRlcygpIHtcbiAgICAgICAgbGV0IHsgWCwgWSwgWiwgVCB9ID0gdGhpcy5lcDtcbiAgICAgICAgY29uc3QgUCA9IGVkMjU1MTlfQ1VSVkVfcDtcbiAgICAgICAgY29uc3QgbW9kID0gKG4pID0+IEZwLmNyZWF0ZShuKTtcbiAgICAgICAgY29uc3QgdTEgPSBtb2QobW9kKFogKyBZKSAqIG1vZChaIC0gWSkpOyAvLyAxXG4gICAgICAgIGNvbnN0IHUyID0gbW9kKFggKiBZKTsgLy8gMlxuICAgICAgICAvLyBTcXVhcmUgcm9vdCBhbHdheXMgZXhpc3RzXG4gICAgICAgIGNvbnN0IHUyc3EgPSBtb2QodTIgKiB1Mik7XG4gICAgICAgIGNvbnN0IHsgdmFsdWU6IGludnNxcnQgfSA9IGludmVydFNxcnQobW9kKHUxICogdTJzcSkpOyAvLyAzXG4gICAgICAgIGNvbnN0IEQxID0gbW9kKGludnNxcnQgKiB1MSk7IC8vIDRcbiAgICAgICAgY29uc3QgRDIgPSBtb2QoaW52c3FydCAqIHUyKTsgLy8gNVxuICAgICAgICBjb25zdCB6SW52ID0gbW9kKEQxICogRDIgKiBUKTsgLy8gNlxuICAgICAgICBsZXQgRDsgLy8gN1xuICAgICAgICBpZiAoaXNOZWdhdGl2ZUxFKFQgKiB6SW52LCBQKSkge1xuICAgICAgICAgICAgbGV0IF94ID0gbW9kKFkgKiBTUVJUX00xKTtcbiAgICAgICAgICAgIGxldCBfeSA9IG1vZChYICogU1FSVF9NMSk7XG4gICAgICAgICAgICBYID0gX3g7XG4gICAgICAgICAgICBZID0gX3k7XG4gICAgICAgICAgICBEID0gbW9kKEQxICogSU5WU1FSVF9BX01JTlVTX0QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgRCA9IEQyOyAvLyA4XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmVnYXRpdmVMRShYICogekludiwgUCkpXG4gICAgICAgICAgICBZID0gbW9kKC1ZKTsgLy8gOVxuICAgICAgICBsZXQgcyA9IG1vZCgoWiAtIFkpICogRCk7IC8vIDEwIChjaGVjayBmb290ZXIncyBub3RlLCBubyBzcXJ0KC1hKSlcbiAgICAgICAgaWYgKGlzTmVnYXRpdmVMRShzLCBQKSlcbiAgICAgICAgICAgIHMgPSBtb2QoLXMpO1xuICAgICAgICByZXR1cm4gRnAudG9CeXRlcyhzKTsgLy8gMTFcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcGFyZXMgdHdvIFJpc3RyZXR0byBwb2ludHMuXG4gICAgICogRGVzY3JpYmVkIGluIFtSRkM5NDk2XShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTQ5NiNuYW1lLWVxdWFscykuXG4gICAgICovXG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0U2FtZShvdGhlcik7XG4gICAgICAgIGNvbnN0IHsgWDogWDEsIFk6IFkxIH0gPSB0aGlzLmVwO1xuICAgICAgICBjb25zdCB7IFg6IFgyLCBZOiBZMiB9ID0gb3RoZXIuZXA7XG4gICAgICAgIGNvbnN0IG1vZCA9IChuKSA9PiBGcC5jcmVhdGUobik7XG4gICAgICAgIC8vICh4MSAqIHkyID09IHkxICogeDIpIHwgKHkxICogeTIgPT0geDEgKiB4MilcbiAgICAgICAgY29uc3Qgb25lID0gbW9kKFgxICogWTIpID09PSBtb2QoWTEgKiBYMik7XG4gICAgICAgIGNvbnN0IHR3byA9IG1vZChZMSAqIFkyKSA9PT0gbW9kKFgxICogWDIpO1xuICAgICAgICByZXR1cm4gb25lIHx8IHR3bztcbiAgICB9XG4gICAgaXMwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lcXVhbHMoX1Jpc3RyZXR0b1BvaW50LlpFUk8pO1xuICAgIH1cbn1cbi8vIERvIE5PVCBjaGFuZ2Ugc3ludGF4OiB0aGUgZm9sbG93aW5nIGd5bW5hc3RpY3MgaXMgZG9uZSxcbi8vIGJlY2F1c2UgdHlwZXNjcmlwdCBzdHJpcHMgY29tbWVudHMsIHdoaWNoIG1ha2VzIGJ1bmRsZXJzIGRpc2FibGUgdHJlZS1zaGFraW5nLlxuLy8gcHJldHRpZXItaWdub3JlXG5fUmlzdHJldHRvUG9pbnQuQkFTRSA9IFxuLyogQF9fUFVSRV9fICovICgoKSA9PiBuZXcgX1Jpc3RyZXR0b1BvaW50KGVkMjU1MTkuUG9pbnQuQkFTRSkpKCk7XG4vLyBwcmV0dGllci1pZ25vcmVcbl9SaXN0cmV0dG9Qb2ludC5aRVJPID0gXG4vKiBAX19QVVJFX18gKi8gKCgpID0+IG5ldyBfUmlzdHJldHRvUG9pbnQoZWQyNTUxOS5Qb2ludC5aRVJPKSkoKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuX1Jpc3RyZXR0b1BvaW50LkZwID0gXG4vKiBAX19QVVJFX18gKi8gKCgpID0+IEZwKSgpO1xuLy8gcHJldHRpZXItaWdub3JlXG5fUmlzdHJldHRvUG9pbnQuRm4gPSBcbi8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gRm4pKCk7XG5leHBvcnQgY29uc3QgcmlzdHJldHRvMjU1ID0geyBQb2ludDogX1Jpc3RyZXR0b1BvaW50IH07XG4vKiogSGFzaGluZyB0byByaXN0cmV0dG8yNTUgcG9pbnRzIC8gZmllbGQuIFJGQyA5MzgwIG1ldGhvZHMuICovXG5leHBvcnQgY29uc3QgcmlzdHJldHRvMjU1X2hhc2hlciA9IHtcbiAgICBoYXNoVG9DdXJ2ZShtc2csIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgRFNUID0gb3B0aW9ucz8uRFNUIHx8ICdyaXN0cmV0dG8yNTVfWE1EOlNIQS01MTJfUjI1NU1BUF9ST18nO1xuICAgICAgICBjb25zdCB4bWQgPSBleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIDY0LCBzaGE1MTIpO1xuICAgICAgICByZXR1cm4gcmlzdHJldHRvMjU1X21hcCh4bWQpO1xuICAgIH0sXG4gICAgaGFzaFRvU2NhbGFyKG1zZywgb3B0aW9ucyA9IHsgRFNUOiBfRFNUX3NjYWxhciB9KSB7XG4gICAgICAgIGNvbnN0IHhtZCA9IGV4cGFuZF9tZXNzYWdlX3htZChtc2csIG9wdGlvbnMuRFNULCA2NCwgc2hhNTEyKTtcbiAgICAgICAgcmV0dXJuIEZuLmNyZWF0ZShieXRlc1RvTnVtYmVyTEUoeG1kKSk7XG4gICAgfSxcbn07XG4vLyBleHBvcnQgY29uc3QgcmlzdHJldHRvMjU1X29wcmY6IE9QUkYgPSBjcmVhdGVPUlBGKHtcbi8vICAgbmFtZTogJ3Jpc3RyZXR0bzI1NS1TSEE1MTInLFxuLy8gICBQb2ludDogUmlzdHJldHRvUG9pbnQsXG4vLyAgIGhhc2g6IHNoYTUxMixcbi8vICAgaGFzaFRvR3JvdXA6IHJpc3RyZXR0bzI1NV9oYXNoZXIuaGFzaFRvQ3VydmUsXG4vLyAgIGhhc2hUb1NjYWxhcjogcmlzdHJldHRvMjU1X2hhc2hlci5oYXNoVG9TY2FsYXIsXG4vLyB9KTtcbi8qKlxuICogV2VpcmQgLyBib2d1cyBwb2ludHMsIHVzZWZ1bCBmb3IgZGVidWdnaW5nLlxuICogQWxsIDggZWQyNTUxOSBwb2ludHMgb2YgOC10b3JzaW9uIHN1Ymdyb3VwIGNhbiBiZSBnZW5lcmF0ZWQgZnJvbSB0aGUgcG9pbnRcbiAqIFQgPSBgMjZlODk1OGZjMmIyMjdiMDQ1YzNmNDg5ZjJlZjk4ZjBkNWRmYWMwNWQzYzYzMzM5YjEzODAyODg2ZDUzZmMwNWAuXG4gKiDin6hU4p+pID0geyBPLCBULCAyVCwgM1QsIDRULCA1VCwgNlQsIDdUIH1cbiAqL1xuZXhwb3J0IGNvbnN0IEVEMjU1MTlfVE9SU0lPTl9TVUJHUk9VUCA9IFtcbiAgICAnMDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJ2M3MTc2YTcwM2Q0ZGQ4NGZiYTNjMGI3NjBkMTA2NzBmMmEyMDUzZmEyYzM5Y2NjNjRlYzdmZDc3OTJhYzAzN2EnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDgwJyxcbiAgICAnMjZlODk1OGZjMmIyMjdiMDQ1YzNmNDg5ZjJlZjk4ZjBkNWRmYWMwNWQzYzYzMzM5YjEzODAyODg2ZDUzZmMwNScsXG4gICAgJ2VjZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmN2YnLFxuICAgICcyNmU4OTU4ZmMyYjIyN2IwNDVjM2Y0ODlmMmVmOThmMGQ1ZGZhYzA1ZDNjNjMzMzliMTM4MDI4ODZkNTNmYzg1JyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJ2M3MTc2YTcwM2Q0ZGQ4NGZiYTNjMGI3NjBkMTA2NzBmMmEyMDUzZmEyYzM5Y2NjNjRlYzdmZDc3OTJhYzAzZmEnLFxuXTtcbi8qKiBAZGVwcmVjYXRlZCB1c2UgYGVkMjU1MTkudXRpbHMudG9Nb250Z29tZXJ5YCAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVkd2FyZHNUb01vbnRnb21lcnlQdWIoZWR3YXJkc1B1Yikge1xuICAgIHJldHVybiBlZDI1NTE5LnV0aWxzLnRvTW9udGdvbWVyeShlbnN1cmVCeXRlcygncHViJywgZWR3YXJkc1B1YikpO1xufVxuLyoqIEBkZXByZWNhdGVkIHVzZSBgZWQyNTUxOS51dGlscy50b01vbnRnb21lcnlgICovXG5leHBvcnQgY29uc3QgZWR3YXJkc1RvTW9udGdvbWVyeSA9IGVkd2FyZHNUb01vbnRnb21lcnlQdWI7XG4vKiogQGRlcHJlY2F0ZWQgdXNlIGBlZDI1NTE5LnV0aWxzLnRvTW9udGdvbWVyeVNlY3JldGAgKi9cbmV4cG9ydCBmdW5jdGlvbiBlZHdhcmRzVG9Nb250Z29tZXJ5UHJpdihlZHdhcmRzUHJpdikge1xuICAgIHJldHVybiBlZDI1NTE5LnV0aWxzLnRvTW9udGdvbWVyeVNlY3JldChlbnN1cmVCeXRlcygncHViJywgZWR3YXJkc1ByaXYpKTtcbn1cbi8qKiBAZGVwcmVjYXRlZCB1c2UgYHJpc3RyZXR0bzI1NS5Qb2ludGAgKi9cbmV4cG9ydCBjb25zdCBSaXN0cmV0dG9Qb2ludCA9IF9SaXN0cmV0dG9Qb2ludDtcbi8qKiBAZGVwcmVjYXRlZCB1c2UgYGltcG9ydCB7IGVkMjU1MTlfaGFzaGVyIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9lZDI1NTE5LmpzJztgICovXG5leHBvcnQgY29uc3QgaGFzaFRvQ3VydmUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGVkMjU1MTlfaGFzaGVyLmhhc2hUb0N1cnZlKSgpO1xuLyoqIEBkZXByZWNhdGVkIHVzZSBgaW1wb3J0IHsgZWQyNTUxOV9oYXNoZXIgfSBmcm9tICdAbm9ibGUvY3VydmVzL2VkMjU1MTkuanMnO2AgKi9cbmV4cG9ydCBjb25zdCBlbmNvZGVUb0N1cnZlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBlZDI1NTE5X2hhc2hlci5lbmNvZGVUb0N1cnZlKSgpO1xuLyoqIEBkZXByZWNhdGVkIHVzZSBgaW1wb3J0IHsgcmlzdHJldHRvMjU1X2hhc2hlciB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvZWQyNTUxOS5qcyc7YCAqL1xuZXhwb3J0IGNvbnN0IGhhc2hUb1Jpc3RyZXR0bzI1NSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gcmlzdHJldHRvMjU1X2hhc2hlci5oYXNoVG9DdXJ2ZSkoKTtcbi8qKiBAZGVwcmVjYXRlZCB1c2UgYGltcG9ydCB7IHJpc3RyZXR0bzI1NV9oYXNoZXIgfSBmcm9tICdAbm9ibGUvY3VydmVzL2VkMjU1MTkuanMnO2AgKi9cbmV4cG9ydCBjb25zdCBoYXNoX3RvX3Jpc3RyZXR0bzI1NSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gcmlzdHJldHRvMjU1X2hhc2hlci5oYXNoVG9DdXJ2ZSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVkMjU1MTkuanMubWFwIl0sIm5hbWVzIjpbInNoYTUxMiIsImFieXRlcyIsImNvbmNhdEJ5dGVzIiwidXRmOFRvQnl0ZXMiLCJwaXBwZW5nZXIiLCJQcmltZUVkd2FyZHNQb2ludCIsInR3aXN0ZWRFZHdhcmRzIiwiX0RTVF9zY2FsYXIiLCJjcmVhdGVIYXNoZXIiLCJleHBhbmRfbWVzc2FnZV94bWQiLCJGaWVsZCIsIkZwSW52ZXJ0QmF0Y2giLCJGcFNxcnRFdmVuIiwiaXNOZWdhdGl2ZUxFIiwibW9kIiwicG93MiIsIm1vbnRnb21lcnkiLCJieXRlc1RvTnVtYmVyTEUiLCJlbnN1cmVCeXRlcyIsImVxdWFsQnl0ZXMiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJfMm4iLCJfM24iLCJfNW4iLCJfOG4iLCJlZDI1NTE5X0NVUlZFX3AiLCJlZDI1NTE5X0NVUlZFIiwicCIsIm4iLCJoIiwiYSIsImQiLCJHeCIsIkd5IiwiZWQyNTUxOV9wb3dfMl8yNTJfMyIsIngiLCJfMTBuIiwiXzIwbiIsIl80MG4iLCJfODBuIiwiUCIsIngyIiwiYjIiLCJiNCIsImI1IiwiYjEwIiwiYjIwIiwiYjQwIiwiYjgwIiwiYjE2MCIsImIyNDAiLCJiMjUwIiwicG93X3BfNV84IiwiYWRqdXN0U2NhbGFyQnl0ZXMiLCJieXRlcyIsIkVEMjU1MTlfU1FSVF9NMSIsInV2UmF0aW8iLCJ1IiwidiIsInYzIiwidjciLCJwb3ciLCJ2eDIiLCJyb290MSIsInJvb3QyIiwidXNlUm9vdDEiLCJ1c2VSb290MiIsIm5vUm9vdCIsImlzVmFsaWQiLCJ2YWx1ZSIsIkZwIiwiaXNMRSIsIkZuIiwiZWQyNTUxOURlZmF1bHRzIiwiaGFzaCIsImVkMjU1MTkiLCJlZDI1NTE5X2RvbWFpbiIsImRhdGEiLCJjdHgiLCJwaGZsYWciLCJsZW5ndGgiLCJFcnJvciIsIlVpbnQ4QXJyYXkiLCJlZDI1NTE5Y3R4IiwiZG9tYWluIiwiZWQyNTUxOXBoIiwiT2JqZWN0IiwiYXNzaWduIiwicHJlaGFzaCIsIngyNTUxOSIsIk9SREVSIiwidHlwZSIsInBvd1BtaW51czIiLCJFTEwyX0MxIiwiRUxMMl9DMiIsIkVMTDJfQzMiLCJzcXJ0IiwibmVnIiwiT05FIiwibWFwX3RvX2N1cnZlX2VsbGlnYXRvcjJfY3VydmUyNTUxOSIsIkVMTDJfQzQiLCJFTEwyX0oiLCJ0djEiLCJzcXIiLCJtdWwiLCJ4ZCIsImFkZCIsIngxbiIsInR2MiIsImd4ZCIsImd4MSIsInR2MyIsInkxMSIsInkxMiIsImUxIiwiZXFsIiwieTEiLCJjbW92IiwieDJuIiwieTIxIiwieTIyIiwiZ3gyIiwiZTIiLCJ5MiIsImUzIiwieG4iLCJ5IiwiZTQiLCJpc09kZCIsInhNbiIsInhNZCIsInlNbiIsInlNZCIsIkVMTDJfQzFfRURXQVJEUyIsIm1hcF90b19jdXJ2ZV9lbGxpZ2F0b3IyX2Vkd2FyZHMyNTUxOSIsInluIiwic3ViIiwieWQiLCJlIiwiWkVSTyIsInhkX2ludiIsInlkX2ludiIsImVkMjU1MTlfaGFzaGVyIiwiUG9pbnQiLCJzY2FsYXJzIiwiRFNUIiwiZW5jb2RlRFNUIiwibSIsImsiLCJleHBhbmQiLCJTUVJUX00xIiwiU1FSVF9BRF9NSU5VU19PTkUiLCJJTlZTUVJUX0FfTUlOVVNfRCIsIk9ORV9NSU5VU19EX1NRIiwiRF9NSU5VU19PTkVfU1EiLCJpbnZlcnRTcXJ0IiwibnVtYmVyIiwiTUFYXzI1NUIiLCJieXRlczI1NVRvTnVtYmVyTEUiLCJjcmVhdGUiLCJjYWxjRWxsaWdhdG9yUmlzdHJldHRvTWFwIiwicjAiLCJyIiwiTnMiLCJjIiwiRCIsIk5zX0RfaXNfc3EiLCJzIiwic18iLCJOdCIsInMyIiwiVzAiLCJXMSIsIlcyIiwiVzMiLCJyaXN0cmV0dG8yNTVfbWFwIiwicjEiLCJzdWJhcnJheSIsIlIxIiwicjIiLCJSMiIsIl9SaXN0cmV0dG9Qb2ludCIsImNvbnN0cnVjdG9yIiwiZXAiLCJmcm9tQWZmaW5lIiwiYXAiLCJhc3NlcnRTYW1lIiwib3RoZXIiLCJpbml0IiwiaGFzaFRvQ3VydmUiLCJoZXgiLCJmcm9tQnl0ZXMiLCJ0b0J5dGVzIiwidTEiLCJ1MiIsInUxXzIiLCJ1Ml8yIiwiSSIsIkR4IiwiRHkiLCJ0IiwiZnJvbUhleCIsIm1zbSIsInBvaW50cyIsIlgiLCJZIiwiWiIsIlQiLCJ1MnNxIiwiaW52c3FydCIsIkQxIiwiRDIiLCJ6SW52IiwiX3giLCJfeSIsImVxdWFscyIsIlgxIiwiWTEiLCJYMiIsIlkyIiwib25lIiwidHdvIiwiaXMwIiwiQkFTRSIsInJpc3RyZXR0bzI1NSIsInJpc3RyZXR0bzI1NV9oYXNoZXIiLCJtc2ciLCJvcHRpb25zIiwieG1kIiwiaGFzaFRvU2NhbGFyIiwiRUQyNTUxOV9UT1JTSU9OX1NVQkdST1VQIiwiZWR3YXJkc1RvTW9udGdvbWVyeVB1YiIsImVkd2FyZHNQdWIiLCJ1dGlscyIsInRvTW9udGdvbWVyeSIsImVkd2FyZHNUb01vbnRnb21lcnkiLCJlZHdhcmRzVG9Nb250Z29tZXJ5UHJpdiIsImVkd2FyZHNQcml2IiwidG9Nb250Z29tZXJ5U2VjcmV0IiwiUmlzdHJldHRvUG9pbnQiLCJlbmNvZGVUb0N1cnZlIiwiaGFzaFRvUmlzdHJldHRvMjU1IiwiaGFzaF90b19yaXN0cmV0dG8yNTUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/ed25519.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/nist.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/nist.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   p256: () => (/* binding */ p256),\n/* harmony export */   p256_hasher: () => (/* binding */ p256_hasher),\n/* harmony export */   p384: () => (/* binding */ p384),\n/* harmony export */   p384_hasher: () => (/* binding */ p384_hasher),\n/* harmony export */   p521: () => (/* binding */ p521),\n/* harmony export */   p521_hasher: () => (/* binding */ p521_hasher),\n/* harmony export */   secp256r1: () => (/* binding */ secp256r1),\n/* harmony export */   secp384r1: () => (/* binding */ secp384r1),\n/* harmony export */   secp521r1: () => (/* binding */ secp521r1)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/hashes/sha2.js */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/sha2.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_shortw_utils.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/_shortw_utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/**\n * Internal module for NIST P256, P384, P521 curves.\n * Do not use for now.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n\n\n// p = 2n**224n * (2n**32n-1n) + 2n**192n + 2n**96n - 1n\n// a = Fp256.create(BigInt('-3'));\nconst p256_CURVE = {\n    p: BigInt(\"0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff\"),\n    n: BigInt(\"0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551\"),\n    h: BigInt(1),\n    a: BigInt(\"0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc\"),\n    b: BigInt(\"0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\"),\n    Gx: BigInt(\"0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\"),\n    Gy: BigInt(\"0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5\")\n};\n// p = 2n**384n - 2n**128n - 2n**96n + 2n**32n - 1n\nconst p384_CURVE = {\n    p: BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff\"),\n    n: BigInt(\"0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973\"),\n    h: BigInt(1),\n    a: BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc\"),\n    b: BigInt(\"0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef\"),\n    Gx: BigInt(\"0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7\"),\n    Gy: BigInt(\"0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f\")\n};\n// p = 2n**521n - 1n\nconst p521_CURVE = {\n    p: BigInt(\"0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"),\n    n: BigInt(\"0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409\"),\n    h: BigInt(1),\n    a: BigInt(\"0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\"),\n    b: BigInt(\"0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00\"),\n    Gx: BigInt(\"0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66\"),\n    Gy: BigInt(\"0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650\")\n};\nconst Fp256 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(p256_CURVE.p);\nconst Fp384 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(p384_CURVE.p);\nconst Fp521 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(p521_CURVE.p);\nfunction createSWU(Point, opts) {\n    const map = (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_1__.mapToCurveSimpleSWU)(Point.Fp, opts);\n    return (scalars)=>map(scalars[0]);\n}\n/** NIST P256 (aka secp256r1, prime256v1) curve, ECDSA and ECDH methods. */ const p256 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_2__.createCurve)({\n    ...p256_CURVE,\n    Fp: Fp256,\n    lowS: false\n}, _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_3__.sha256);\n/** Hashing / encoding to p256 points / field. RFC 9380 methods. */ const p256_hasher = /* @__PURE__ */ (()=>{\n    return (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_4__.createHasher)(p256.Point, createSWU(p256.Point, {\n        A: p256_CURVE.a,\n        B: p256_CURVE.b,\n        Z: p256.Point.Fp.create(BigInt(\"-10\"))\n    }), {\n        DST: \"P256_XMD:SHA-256_SSWU_RO_\",\n        encodeDST: \"P256_XMD:SHA-256_SSWU_NU_\",\n        p: p256_CURVE.p,\n        m: 1,\n        k: 128,\n        expand: \"xmd\",\n        hash: _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_3__.sha256\n    });\n})();\n// export const p256_oprf: OPRF = createORPF({\n//   name: 'P256-SHA256',\n//   Point: p256.Point,\n//   hash: sha256,\n//   hashToGroup: p256_hasher.hashToCurve,\n//   hashToScalar: p256_hasher.hashToScalar,\n// });\n/** NIST P384 (aka secp384r1) curve, ECDSA and ECDH methods. */ const p384 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_2__.createCurve)({\n    ...p384_CURVE,\n    Fp: Fp384,\n    lowS: false\n}, _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_3__.sha384);\n/** Hashing / encoding to p384 points / field. RFC 9380 methods. */ const p384_hasher = /* @__PURE__ */ (()=>{\n    return (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_4__.createHasher)(p384.Point, createSWU(p384.Point, {\n        A: p384_CURVE.a,\n        B: p384_CURVE.b,\n        Z: p384.Point.Fp.create(BigInt(\"-12\"))\n    }), {\n        DST: \"P384_XMD:SHA-384_SSWU_RO_\",\n        encodeDST: \"P384_XMD:SHA-384_SSWU_NU_\",\n        p: p384_CURVE.p,\n        m: 1,\n        k: 192,\n        expand: \"xmd\",\n        hash: _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_3__.sha384\n    });\n})();\n// export const p384_oprf: OPRF = createORPF({\n//   name: 'P384-SHA384',\n//   Point: p384.Point,\n//   hash: sha384,\n//   hashToGroup: p384_hasher.hashToCurve,\n//   hashToScalar: p384_hasher.hashToScalar,\n// });\n// const Fn521 = Field(p521_CURVE.n, { allowedScalarLengths: [65, 66] });\n/** NIST P521 (aka secp521r1) curve, ECDSA and ECDH methods. */ const p521 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_2__.createCurve)({\n    ...p521_CURVE,\n    Fp: Fp521,\n    lowS: false,\n    allowedPrivateKeyLengths: [\n        130,\n        131,\n        132\n    ]\n}, _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_3__.sha512);\n/** @deprecated use `p256` for consistency with `p256_hasher` */ const secp256r1 = p256;\n/** @deprecated use `p384` for consistency with `p384_hasher` */ const secp384r1 = p384;\n/** @deprecated use `p521` for consistency with `p521_hasher` */ const secp521r1 = p521;\n/** Hashing / encoding to p521 points / field. RFC 9380 methods. */ const p521_hasher = /* @__PURE__ */ (()=>{\n    return (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_4__.createHasher)(p521.Point, createSWU(p521.Point, {\n        A: p521_CURVE.a,\n        B: p521_CURVE.b,\n        Z: p521.Point.Fp.create(BigInt(\"-4\"))\n    }), {\n        DST: \"P521_XMD:SHA-512_SSWU_RO_\",\n        encodeDST: \"P521_XMD:SHA-512_SSWU_NU_\",\n        p: p521_CURVE.p,\n        m: 1,\n        k: 256,\n        expand: \"xmd\",\n        hash: _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_3__.sha512\n    });\n})(); // export const p521_oprf: OPRF = createORPF({\n //   name: 'P521-SHA512',\n //   Point: p521.Point,\n //   hash: sha512,\n //   hashToGroup: p521_hasher.hashToCurve,\n //   hashToScalar: p521_hasher.hashToScalar, // produces L=98 just like in RFC\n // });\n //# sourceMappingURL=nist.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjkuNy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vbmlzdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7O0NBSUMsR0FDRCxvRUFBb0UsR0FDTDtBQUNkO0FBQ1U7QUFDYjtBQUNtQjtBQUNqRSx3REFBd0Q7QUFDeEQsa0NBQWtDO0FBQ2xDLE1BQU1PLGFBQWE7SUFDZkMsR0FBR0MsT0FBTztJQUNWQyxHQUFHRCxPQUFPO0lBQ1ZFLEdBQUdGLE9BQU87SUFDVkcsR0FBR0gsT0FBTztJQUNWSSxHQUFHSixPQUFPO0lBQ1ZLLElBQUlMLE9BQU87SUFDWE0sSUFBSU4sT0FBTztBQUNmO0FBQ0EsbURBQW1EO0FBQ25ELE1BQU1PLGFBQWE7SUFDZlIsR0FBR0MsT0FBTztJQUNWQyxHQUFHRCxPQUFPO0lBQ1ZFLEdBQUdGLE9BQU87SUFDVkcsR0FBR0gsT0FBTztJQUNWSSxHQUFHSixPQUFPO0lBQ1ZLLElBQUlMLE9BQU87SUFDWE0sSUFBSU4sT0FBTztBQUNmO0FBQ0Esb0JBQW9CO0FBQ3BCLE1BQU1RLGFBQWE7SUFDZlQsR0FBR0MsT0FBTztJQUNWQyxHQUFHRCxPQUFPO0lBQ1ZFLEdBQUdGLE9BQU87SUFDVkcsR0FBR0gsT0FBTztJQUNWSSxHQUFHSixPQUFPO0lBQ1ZLLElBQUlMLE9BQU87SUFDWE0sSUFBSU4sT0FBTztBQUNmO0FBQ0EsTUFBTVMsUUFBUWIsMkRBQUtBLENBQUNFLFdBQVdDLENBQUM7QUFDaEMsTUFBTVcsUUFBUWQsMkRBQUtBLENBQUNXLFdBQVdSLENBQUM7QUFDaEMsTUFBTVksUUFBUWYsMkRBQUtBLENBQUNZLFdBQVdULENBQUM7QUFDaEMsU0FBU2EsVUFBVUMsS0FBSyxFQUFFQyxJQUFJO0lBQzFCLE1BQU1DLE1BQU1sQiw2RUFBbUJBLENBQUNnQixNQUFNRyxFQUFFLEVBQUVGO0lBQzFDLE9BQU8sQ0FBQ0csVUFBWUYsSUFBSUUs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Q04sZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbm90YXNjYW0tcHJvdG9jb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjkuNy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vbmlzdC5qcz9kNmFjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSW50ZXJuYWwgbW9kdWxlIGZvciBOSVNUIFAyNTYsIFAzODQsIFA1MjEgY3VydmVzLlxuICogRG8gbm90IHVzZSBmb3Igbm93LlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBzaGEyNTYsIHNoYTM4NCwgc2hhNTEyIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGEyLmpzJztcbmltcG9ydCB7IGNyZWF0ZUN1cnZlIH0gZnJvbSBcIi4vX3Nob3J0d191dGlscy5qc1wiO1xuaW1wb3J0IHsgY3JlYXRlSGFzaGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qc1wiO1xuaW1wb3J0IHsgRmllbGQgfSBmcm9tIFwiLi9hYnN0cmFjdC9tb2R1bGFyLmpzXCI7XG5pbXBvcnQgeyBtYXBUb0N1cnZlU2ltcGxlU1dVLCB9IGZyb20gXCIuL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzXCI7XG4vLyBwID0gMm4qKjIyNG4gKiAoMm4qKjMybi0xbikgKyAybioqMTkybiArIDJuKio5Nm4gLSAxblxuLy8gYSA9IEZwMjU2LmNyZWF0ZShCaWdJbnQoJy0zJykpO1xuY29uc3QgcDI1Nl9DVVJWRSA9IHtcbiAgICBwOiBCaWdJbnQoJzB4ZmZmZmZmZmYwMDAwMDAwMTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZicpLFxuICAgIG46IEJpZ0ludCgnMHhmZmZmZmZmZjAwMDAwMDAwZmZmZmZmZmZmZmZmZmZmZmJjZTZmYWFkYTcxNzllODRmM2I5Y2FjMmZjNjMyNTUxJyksXG4gICAgaDogQmlnSW50KDEpLFxuICAgIGE6IEJpZ0ludCgnMHhmZmZmZmZmZjAwMDAwMDAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZjJyksXG4gICAgYjogQmlnSW50KCcweDVhYzYzNWQ4YWEzYTkzZTdiM2ViYmQ1NTc2OTg4NmJjNjUxZDA2YjBjYzUzYjBmNjNiY2UzYzNlMjdkMjYwNGInKSxcbiAgICBHeDogQmlnSW50KCcweDZiMTdkMWYyZTEyYzQyNDdmOGJjZTZlNTYzYTQ0MGYyNzcwMzdkODEyZGViMzNhMGY0YTEzOTQ1ZDg5OGMyOTYnKSxcbiAgICBHeTogQmlnSW50KCcweDRmZTM0MmUyZmUxYTdmOWI4ZWU3ZWI0YTdjMGY5ZTE2MmJjZTMzNTc2YjMxNWVjZWNiYjY0MDY4MzdiZjUxZjUnKSxcbn07XG4vLyBwID0gMm4qKjM4NG4gLSAybioqMTI4biAtIDJuKio5Nm4gKyAybioqMzJuIC0gMW5cbmNvbnN0IHAzODRfQ1VSVkUgPSB7XG4gICAgcDogQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZmZmZjAwMDAwMDAwMDAwMDAwMDBmZmZmZmZmZicpLFxuICAgIG46IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZjNzYzNGQ4MWY0MzcyZGRmNTgxYTBkYjI0OGIwYTc3YWVjZWMxOTZhY2NjNTI5NzMnKSxcbiAgICBoOiBCaWdJbnQoMSksXG4gICAgYTogQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmVmZmZmZmZmZjAwMDAwMDAwMDAwMDAwMDBmZmZmZmZmYycpLFxuICAgIGI6IEJpZ0ludCgnMHhiMzMxMmZhN2UyM2VlN2U0OTg4ZTA1NmJlM2Y4MmQxOTE4MWQ5YzZlZmU4MTQxMTIwMzE0MDg4ZjUwMTM4NzVhYzY1NjM5OGQ4YTJlZDE5ZDJhODVjOGVkZDNlYzJhZWYnKSxcbiAgICBHeDogQmlnSW50KCcweGFhODdjYTIyYmU4YjA1Mzc4ZWIxYzcxZWYzMjBhZDc0NmUxZDNiNjI4YmE3OWI5ODU5Zjc0MWUwODI1NDJhMzg1NTAyZjI1ZGJmNTUyOTZjM2E1NDVlMzg3Mjc2MGFiNycpLFxuICAgIEd5OiBCaWdJbnQoJzB4MzYxN2RlNGE5NjI2MmM2ZjVkOWU5OGJmOTI5MmRjMjlmOGY0MWRiZDI4OWExNDdjZTlkYTMxMTNiNWYwYjhjMDBhNjBiMWNlMWQ3ZTgxOWQ3YTQzMWQ3YzkwZWEwZTVmJyksXG59O1xuLy8gcCA9IDJuKio1MjFuIC0gMW5cbmNvbnN0IHA1MjFfQ1VSVkUgPSB7XG4gICAgcDogQmlnSW50KCcweDFmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmJyksXG4gICAgbjogQmlnSW50KCcweDAxZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZhNTE4Njg3ODNiZjJmOTY2YjdmY2MwMTQ4ZjcwOWE1ZDAzYmI1YzliODg5OWM0N2FlYmI2ZmI3MWU5MTM4NjQwOScpLFxuICAgIGg6IEJpZ0ludCgxKSxcbiAgICBhOiBCaWdJbnQoJzB4MWZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmMnKSxcbiAgICBiOiBCaWdJbnQoJzB4MDA1MTk1M2ViOTYxOGUxYzlhMWY5MjlhMjFhMGI2ODU0MGVlYTJkYTcyNWI5OWIzMTVmM2I4YjQ4OTkxOGVmMTA5ZTE1NjE5Mzk1MWVjN2U5MzdiMTY1MmMwYmQzYmIxYmYwNzM1NzNkZjg4M2QyYzM0ZjFlZjQ1MWZkNDZiNTAzZjAwJyksXG4gICAgR3g6IEJpZ0ludCgnMHgwMGM2ODU4ZTA2YjcwNDA0ZTljZDllM2VjYjY2MjM5NWI0NDI5YzY0ODEzOTA1M2ZiNTIxZjgyOGFmNjA2YjRkM2RiYWExNGI1ZTc3ZWZlNzU5MjhmZTFkYzEyN2EyZmZhOGRlMzM0OGIzYzE4NTZhNDI5YmY5N2U3ZTMxYzJlNWJkNjYnKSxcbiAgICBHeTogQmlnSW50KCcweDAxMTgzOTI5NmE3ODlhM2JjMDA0NWM4YTVmYjQyYzdkMWJkOTk4ZjU0NDQ5NTc5YjQ0NjgxN2FmYmQxNzI3M2U2NjJjOTdlZTcyOTk1ZWY0MjY0MGM1NTBiOTAxM2ZhZDA3NjEzNTNjNzA4NmEyNzJjMjQwODhiZTk0NzY5ZmQxNjY1MCcpLFxufTtcbmNvbnN0IEZwMjU2ID0gRmllbGQocDI1Nl9DVVJWRS5wKTtcbmNvbnN0IEZwMzg0ID0gRmllbGQocDM4NF9DVVJWRS5wKTtcbmNvbnN0IEZwNTIxID0gRmllbGQocDUyMV9DVVJWRS5wKTtcbmZ1bmN0aW9uIGNyZWF0ZVNXVShQb2ludCwgb3B0cykge1xuICAgIGNvbnN0IG1hcCA9IG1hcFRvQ3VydmVTaW1wbGVTV1UoUG9pbnQuRnAsIG9wdHMpO1xuICAgIHJldHVybiAoc2NhbGFycykgPT4gbWFwKHNjYWxhcnNbMF0pO1xufVxuLyoqIE5JU1QgUDI1NiAoYWthIHNlY3AyNTZyMSwgcHJpbWUyNTZ2MSkgY3VydmUsIEVDRFNBIGFuZCBFQ0RIIG1ldGhvZHMuICovXG5leHBvcnQgY29uc3QgcDI1NiA9IGNyZWF0ZUN1cnZlKHsgLi4ucDI1Nl9DVVJWRSwgRnA6IEZwMjU2LCBsb3dTOiBmYWxzZSB9LCBzaGEyNTYpO1xuLyoqIEhhc2hpbmcgLyBlbmNvZGluZyB0byBwMjU2IHBvaW50cyAvIGZpZWxkLiBSRkMgOTM4MCBtZXRob2RzLiAqL1xuZXhwb3J0IGNvbnN0IHAyNTZfaGFzaGVyID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gICAgcmV0dXJuIGNyZWF0ZUhhc2hlcihwMjU2LlBvaW50LCBjcmVhdGVTV1UocDI1Ni5Qb2ludCwge1xuICAgICAgICBBOiBwMjU2X0NVUlZFLmEsXG4gICAgICAgIEI6IHAyNTZfQ1VSVkUuYixcbiAgICAgICAgWjogcDI1Ni5Qb2ludC5GcC5jcmVhdGUoQmlnSW50KCctMTAnKSksXG4gICAgfSksIHtcbiAgICAgICAgRFNUOiAnUDI1Nl9YTUQ6U0hBLTI1Nl9TU1dVX1JPXycsXG4gICAgICAgIGVuY29kZURTVDogJ1AyNTZfWE1EOlNIQS0yNTZfU1NXVV9OVV8nLFxuICAgICAgICBwOiBwMjU2X0NVUlZFLnAsXG4gICAgICAgIG06IDEsXG4gICAgICAgIGs6IDEyOCxcbiAgICAgICAgZXhwYW5kOiAneG1kJyxcbiAgICAgICAgaGFzaDogc2hhMjU2LFxuICAgIH0pO1xufSkoKTtcbi8vIGV4cG9ydCBjb25zdCBwMjU2X29wcmY6IE9QUkYgPSBjcmVhdGVPUlBGKHtcbi8vICAgbmFtZTogJ1AyNTYtU0hBMjU2Jyxcbi8vICAgUG9pbnQ6IHAyNTYuUG9pbnQsXG4vLyAgIGhhc2g6IHNoYTI1Nixcbi8vICAgaGFzaFRvR3JvdXA6IHAyNTZfaGFzaGVyLmhhc2hUb0N1cnZlLFxuLy8gICBoYXNoVG9TY2FsYXI6IHAyNTZfaGFzaGVyLmhhc2hUb1NjYWxhcixcbi8vIH0pO1xuLyoqIE5JU1QgUDM4NCAoYWthIHNlY3AzODRyMSkgY3VydmUsIEVDRFNBIGFuZCBFQ0RIIG1ldGhvZHMuICovXG5leHBvcnQgY29uc3QgcDM4NCA9IGNyZWF0ZUN1cnZlKHsgLi4ucDM4NF9DVVJWRSwgRnA6IEZwMzg0LCBsb3dTOiBmYWxzZSB9LCBzaGEzODQpO1xuLyoqIEhhc2hpbmcgLyBlbmNvZGluZyB0byBwMzg0IHBvaW50cyAvIGZpZWxkLiBSRkMgOTM4MCBtZXRob2RzLiAqL1xuZXhwb3J0IGNvbnN0IHAzODRfaGFzaGVyID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gICAgcmV0dXJuIGNyZWF0ZUhhc2hlcihwMzg0LlBvaW50LCBjcmVhdGVTV1UocDM4NC5Qb2ludCwge1xuICAgICAgICBBOiBwMzg0X0NVUlZFLmEsXG4gICAgICAgIEI6IHAzODRfQ1VSVkUuYixcbiAgICAgICAgWjogcDM4NC5Qb2ludC5GcC5jcmVhdGUoQmlnSW50KCctMTInKSksXG4gICAgfSksIHtcbiAgICAgICAgRFNUOiAnUDM4NF9YTUQ6U0hBLTM4NF9TU1dVX1JPXycsXG4gICAgICAgIGVuY29kZURTVDogJ1AzODRfWE1EOlNIQS0zODRfU1NXVV9OVV8nLFxuICAgICAgICBwOiBwMzg0X0NVUlZFLnAsXG4gICAgICAgIG06IDEsXG4gICAgICAgIGs6IDE5MixcbiAgICAgICAgZXhwYW5kOiAneG1kJyxcbiAgICAgICAgaGFzaDogc2hhMzg0LFxuICAgIH0pO1xufSkoKTtcbi8vIGV4cG9ydCBjb25zdCBwMzg0X29wcmY6IE9QUkYgPSBjcmVhdGVPUlBGKHtcbi8vICAgbmFtZTogJ1AzODQtU0hBMzg0Jyxcbi8vICAgUG9pbnQ6IHAzODQuUG9pbnQsXG4vLyAgIGhhc2g6IHNoYTM4NCxcbi8vICAgaGFzaFRvR3JvdXA6IHAzODRfaGFzaGVyLmhhc2hUb0N1cnZlLFxuLy8gICBoYXNoVG9TY2FsYXI6IHAzODRfaGFzaGVyLmhhc2hUb1NjYWxhcixcbi8vIH0pO1xuLy8gY29uc3QgRm41MjEgPSBGaWVsZChwNTIxX0NVUlZFLm4sIHsgYWxsb3dlZFNjYWxhckxlbmd0aHM6IFs2NSwgNjZdIH0pO1xuLyoqIE5JU1QgUDUyMSAoYWthIHNlY3A1MjFyMSkgY3VydmUsIEVDRFNBIGFuZCBFQ0RIIG1ldGhvZHMuICovXG5leHBvcnQgY29uc3QgcDUyMSA9IGNyZWF0ZUN1cnZlKHsgLi4ucDUyMV9DVVJWRSwgRnA6IEZwNTIxLCBsb3dTOiBmYWxzZSwgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiBbMTMwLCAxMzEsIDEzMl0gfSwgc2hhNTEyKTtcbi8qKiBAZGVwcmVjYXRlZCB1c2UgYHAyNTZgIGZvciBjb25zaXN0ZW5jeSB3aXRoIGBwMjU2X2hhc2hlcmAgKi9cbmV4cG9ydCBjb25zdCBzZWNwMjU2cjEgPSBwMjU2O1xuLyoqIEBkZXByZWNhdGVkIHVzZSBgcDM4NGAgZm9yIGNvbnNpc3RlbmN5IHdpdGggYHAzODRfaGFzaGVyYCAqL1xuZXhwb3J0IGNvbnN0IHNlY3AzODRyMSA9IHAzODQ7XG4vKiogQGRlcHJlY2F0ZWQgdXNlIGBwNTIxYCBmb3IgY29uc2lzdGVuY3kgd2l0aCBgcDUyMV9oYXNoZXJgICovXG5leHBvcnQgY29uc3Qgc2VjcDUyMXIxID0gcDUyMTtcbi8qKiBIYXNoaW5nIC8gZW5jb2RpbmcgdG8gcDUyMSBwb2ludHMgLyBmaWVsZC4gUkZDIDkzODAgbWV0aG9kcy4gKi9cbmV4cG9ydCBjb25zdCBwNTIxX2hhc2hlciA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuICAgIHJldHVybiBjcmVhdGVIYXNoZXIocDUyMS5Qb2ludCwgY3JlYXRlU1dVKHA1MjEuUG9pbnQsIHtcbiAgICAgICAgQTogcDUyMV9DVVJWRS5hLFxuICAgICAgICBCOiBwNTIxX0NVUlZFLmIsXG4gICAgICAgIFo6IHA1MjEuUG9pbnQuRnAuY3JlYXRlKEJpZ0ludCgnLTQnKSksXG4gICAgfSksIHtcbiAgICAgICAgRFNUOiAnUDUyMV9YTUQ6U0hBLTUxMl9TU1dVX1JPXycsXG4gICAgICAgIGVuY29kZURTVDogJ1A1MjFfWE1EOlNIQS01MTJfU1NXVV9OVV8nLFxuICAgICAgICBwOiBwNTIxX0NVUlZFLnAsXG4gICAgICAgIG06IDEsXG4gICAgICAgIGs6IDI1NixcbiAgICAgICAgZXhwYW5kOiAneG1kJyxcbiAgICAgICAgaGFzaDogc2hhNTEyLFxuICAgIH0pO1xufSkoKTtcbi8vIGV4cG9ydCBjb25zdCBwNTIxX29wcmY6IE9QUkYgPSBjcmVhdGVPUlBGKHtcbi8vICAgbmFtZTogJ1A1MjEtU0hBNTEyJyxcbi8vICAgUG9pbnQ6IHA1MjEuUG9pbnQsXG4vLyAgIGhhc2g6IHNoYTUxMixcbi8vICAgaGFzaFRvR3JvdXA6IHA1MjFfaGFzaGVyLmhhc2hUb0N1cnZlLFxuLy8gICBoYXNoVG9TY2FsYXI6IHA1MjFfaGFzaGVyLmhhc2hUb1NjYWxhciwgLy8gcHJvZHVjZXMgTD05OCBqdXN0IGxpa2UgaW4gUkZDXG4vLyB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5pc3QuanMubWFwIl0sIm5hbWVzIjpbInNoYTI1NiIsInNoYTM4NCIsInNoYTUxMiIsImNyZWF0ZUN1cnZlIiwiY3JlYXRlSGFzaGVyIiwiRmllbGQiLCJtYXBUb0N1cnZlU2ltcGxlU1dVIiwicDI1Nl9DVVJWRSIsInAiLCJCaWdJbnQiLCJuIiwiaCIsImEiLCJiIiwiR3giLCJHeSIsInAzODRfQ1VSVkUiLCJwNTIxX0NVUlZFIiwiRnAyNTYiLCJGcDM4NCIsIkZwNTIxIiwiY3JlYXRlU1dVIiwiUG9pbnQiLCJvcHRzIiwibWFwIiwiRnAiLCJzY2FsYXJzIiwicDI1NiIsImxvd1MiLCJwMjU2X2hhc2hlciIsIkEiLCJCIiwiWiIsImNyZWF0ZSIsIkRTVCIsImVuY29kZURTVCIsIm0iLCJrIiwiZXhwYW5kIiwiaGFzaCIsInAzODQiLCJwMzg0X2hhc2hlciIsInA1MjEiLCJhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHMiLCJzZWNwMjU2cjEiLCJzZWNwMzg0cjEiLCJzZWNwNTIxcjEiLCJwNTIxX2hhc2hlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/nist.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/p256.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/p256.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   p256: () => (/* binding */ p256),\n/* harmony export */   secp256r1: () => (/* binding */ secp256r1)\n/* harmony export */ });\n/* harmony import */ var _nist_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nist.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/nist.js\");\n/**\n * NIST secp256r1 aka p256.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n/** @deprecated use `import { p256 } from '@noble/curves/nist.js';` */ const p256 = _nist_js__WEBPACK_IMPORTED_MODULE_0__.p256;\n/** @deprecated use `import { p256 } from '@noble/curves/nist.js';` */ const secp256r1 = _nist_js__WEBPACK_IMPORTED_MODULE_0__.p256;\n/** @deprecated use `import { p256_hasher } from '@noble/curves/nist.js';` */ const hashToCurve = /* @__PURE__ */ (()=>_nist_js__WEBPACK_IMPORTED_MODULE_0__.p256_hasher.hashToCurve)();\n/** @deprecated use `import { p256_hasher } from '@noble/curves/nist.js';` */ const encodeToCurve = /* @__PURE__ */ (()=>_nist_js__WEBPACK_IMPORTED_MODULE_0__.p256_hasher.encodeToCurve)(); //# sourceMappingURL=p256.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjkuNy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vcDI1Ni5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBOzs7Q0FHQyxHQUNELG9FQUFvRSxHQUN2QjtBQUNVO0FBQ3ZELG9FQUFvRSxHQUM3RCxNQUFNQyxPQUFPQywwQ0FBS0EsQ0FBQztBQUMxQixvRUFBb0UsR0FDN0QsTUFBTUMsWUFBWUQsMENBQUtBLENBQUM7QUFDL0IsMkVBQTJFLEdBQ3BFLE1BQU1FLGNBQThCLGFBQUgsR0FBSSxLQUFNSixpREFBV0EsQ0FBQ0ksV0FBVyxJQUFJO0FBQzdFLDJFQUEyRSxHQUNwRSxNQUFNQyxnQkFBZ0MsYUFBSCxHQUFJLEtBQU1MLGlEQUFXQSxDQUFDSyxhQUFhLElBQUksQ0FDakYsZ0NBQWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbm90YXNjYW0tcHJvdG9jb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjkuNy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vcDI1Ni5qcz9hYzUzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogTklTVCBzZWNwMjU2cjEgYWthIHAyNTYuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7fSBmcm9tIFwiLi9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzXCI7XG5pbXBvcnQgeyBwMjU2X2hhc2hlciwgcDI1NiBhcyBwMjU2biB9IGZyb20gXCIuL25pc3QuanNcIjtcbi8qKiBAZGVwcmVjYXRlZCB1c2UgYGltcG9ydCB7IHAyNTYgfSBmcm9tICdAbm9ibGUvY3VydmVzL25pc3QuanMnO2AgKi9cbmV4cG9ydCBjb25zdCBwMjU2ID0gcDI1Nm47XG4vKiogQGRlcHJlY2F0ZWQgdXNlIGBpbXBvcnQgeyBwMjU2IH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9uaXN0LmpzJztgICovXG5leHBvcnQgY29uc3Qgc2VjcDI1NnIxID0gcDI1Nm47XG4vKiogQGRlcHJlY2F0ZWQgdXNlIGBpbXBvcnQgeyBwMjU2X2hhc2hlciB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvbmlzdC5qcyc7YCAqL1xuZXhwb3J0IGNvbnN0IGhhc2hUb0N1cnZlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBwMjU2X2hhc2hlci5oYXNoVG9DdXJ2ZSkoKTtcbi8qKiBAZGVwcmVjYXRlZCB1c2UgYGltcG9ydCB7IHAyNTZfaGFzaGVyIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9uaXN0LmpzJztgICovXG5leHBvcnQgY29uc3QgZW5jb2RlVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gcDI1Nl9oYXNoZXIuZW5jb2RlVG9DdXJ2ZSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXAyNTYuanMubWFwIl0sIm5hbWVzIjpbInAyNTZfaGFzaGVyIiwicDI1NiIsInAyNTZuIiwic2VjcDI1NnIxIiwiaGFzaFRvQ3VydmUiLCJlbmNvZGVUb0N1cnZlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/p256.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/secp256k1.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/secp256k1.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   schnorr: () => (/* binding */ schnorr),\n/* harmony export */   secp256k1: () => (/* binding */ secp256k1),\n/* harmony export */   secp256k1_hasher: () => (/* binding */ secp256k1_hasher)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha2.js */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_shortw_utils.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/_shortw_utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils.js */ \"(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/utils.js\");\n/**\n * SECG secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).\n *\n * Belongs to Koblitz curves: it has efficiently-computable GLV endomorphism ψ,\n * check out {@link EndomorphismOpts}. Seems to be rigid (not backdoored).\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\n\n\n\n\n\n// Seems like generator was produced from some seed:\n// `Point.BASE.multiply(Point.Fn.inv(2n, N)).toAffine().x`\n// // gives short x 0x3b78ce563f89a0ed9414f5aa28ad0d96d6795f9c63n\nconst secp256k1_CURVE = {\n    p: BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\"),\n    n: BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\"),\n    h: BigInt(1),\n    a: BigInt(0),\n    b: BigInt(7),\n    Gx: BigInt(\"0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\"),\n    Gy: BigInt(\"0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\")\n};\nconst secp256k1_ENDO = {\n    beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),\n    basises: [\n        [\n            BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\"),\n            -BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\")\n        ],\n        [\n            BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\"),\n            BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\")\n        ]\n    ]\n};\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\n/**\n * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */ function sqrtMod(y) {\n    const P = secp256k1_CURVE.p;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = y * y * y % P; // x^3, 11\n    const b3 = b2 * b2 * y % P; // x^7\n    const b6 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b3, _3n, P) * b3 % P;\n    const b9 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b6, _3n, P) * b3 % P;\n    const b11 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b9, _2n, P) * b2 % P;\n    const b22 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b11, _11n, P) * b11 % P;\n    const b44 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b22, _22n, P) * b22 % P;\n    const b88 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b44, _44n, P) * b44 % P;\n    const b176 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b88, _88n, P) * b88 % P;\n    const b220 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b176, _44n, P) * b44 % P;\n    const b223 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b220, _3n, P) * b3 % P;\n    const t1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b223, _23n, P) * b22 % P;\n    const t2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t1, _6n, P) * b2 % P;\n    const root = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t2, _2n, P);\n    if (!Fpk1.eql(Fpk1.sqr(root), y)) throw new Error(\"Cannot find square root\");\n    return root;\n}\nconst Fpk1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(secp256k1_CURVE.p, {\n    sqrt: sqrtMod\n});\n/**\n * secp256k1 curve, ECDSA and ECDH methods.\n *\n * Field: `2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n`\n *\n * @example\n * ```js\n * import { secp256k1 } from '@noble/curves/secp256k1';\n * const { secretKey, publicKey } = secp256k1.keygen();\n * const msg = new TextEncoder().encode('hello');\n * const sig = secp256k1.sign(msg, secretKey);\n * const isValid = secp256k1.verify(sig, msg, publicKey) === true;\n * ```\n */ const secp256k1 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    ...secp256k1_CURVE,\n    Fp: Fpk1,\n    lowS: true,\n    endo: secp256k1_ENDO\n}, _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_2__.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */ const TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0,_noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_2__.sha256)((0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.utf8ToBytes)(tag));\n        tagP = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0,_noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_2__.sha256)((0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point)=>point.toBytes(true).slice(1);\nconst Pointk1 = /* @__PURE__ */ (()=>secp256k1.Point)();\nconst hasEven = (y)=>y % _2n === _0n;\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    const { Fn, BASE } = Pointk1;\n    const d_ = (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_4__._normFnElement)(Fn, priv);\n    const p = BASE.multiply(d_); // P = d'⋅G; 0 < d' < n check is done inside\n    const scalar = hasEven(p.y) ? d_ : Fn.neg(d_);\n    return {\n        scalar,\n        bytes: pointToBytes(p)\n    };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */ function lift_x(x) {\n    const Fp = Fpk1;\n    if (!Fp.isValidNot0(x)) throw new Error(\"invalid x: Fail if x ≥ p\");\n    const xx = Fp.create(x * x);\n    const c = Fp.create(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.\n    let y = Fp.sqrt(c); // Let y = c^(p+1)/4 mod p. Same as sqrt().\n    // Return the unique point P such that x(P) = x and\n    // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    if (!hasEven(y)) y = Fp.neg(y);\n    const p = Pointk1.fromAffine({\n        x,\n        y\n    });\n    p.assertValidity();\n    return p;\n}\nconst num = _utils_js__WEBPACK_IMPORTED_MODULE_5__.bytesToNumberBE;\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */ function challenge(...args) {\n    return Pointk1.Fn.create(num(taggedHash(\"BIP0340/challenge\", ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */ function schnorrGetPublicKey(secretKey) {\n    return schnorrGetExtPubKey(secretKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */ function schnorrSign(message, secretKey, auxRand = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.randomBytes)(32)) {\n    const { Fn } = Pointk1;\n    const m = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.ensureBytes)(\"message\", message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(secretKey); // checks for isWithinCurveOrder\n    const a = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.ensureBytes)(\"auxRand\", auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = Fn.toBytes(d ^ num(taggedHash(\"BIP0340/aux\", a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash(\"BIP0340/nonce\", t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    // Let k' = int(rand) mod n. Fail if k' = 0. Let R = k'⋅G\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(rand);\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(Fn.toBytes(Fn.create(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px)) throw new Error(\"sign: Invalid signature produced\");\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */ function schnorrVerify(signature, message, publicKey) {\n    const { Fn, BASE } = Pointk1;\n    const sig = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.ensureBytes)(\"signature\", signature, 64);\n    const m = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.ensureBytes)(\"message\", message);\n    const pub = (0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.ensureBytes)(\"publicKey\", publicKey, 32);\n    try {\n        const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.\n        if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.inRange)(r, _1n, secp256k1_CURVE.p)) return false;\n        const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.\n        if (!(0,_utils_js__WEBPACK_IMPORTED_MODULE_5__.inRange)(s, _1n, secp256k1_CURVE.n)) return false;\n        // int(challenge(bytes(r)||bytes(P)||m))%n\n        const e = challenge(Fn.toBytes(r), pointToBytes(P), m);\n        // R = s⋅G - e⋅P, where -eP == (n-e)P\n        const R = BASE.multiplyUnsafe(s).add(P.multiplyUnsafe(Fn.neg(e)));\n        const { x, y } = R.toAffine();\n        // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.\n        if (R.is0() || !hasEven(y) || x !== r) return false;\n        return true;\n    } catch (error) {\n        return false;\n    }\n}\n/**\n * Schnorr signatures over secp256k1.\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n * @example\n * ```js\n * import { schnorr } from '@noble/curves/secp256k1';\n * const { secretKey, publicKey } = schnorr.keygen();\n * // const publicKey = schnorr.getPublicKey(secretKey);\n * const msg = new TextEncoder().encode('hello');\n * const sig = schnorr.sign(msg, secretKey);\n * const isValid = schnorr.verify(sig, msg, publicKey);\n * ```\n */ const schnorr = /* @__PURE__ */ (()=>{\n    const size = 32;\n    const seedLength = 48;\n    const randomSecretKey = (seed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_3__.randomBytes)(seedLength))=>{\n        return (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mapHashToField)(seed, secp256k1_CURVE.n);\n    };\n    // TODO: remove\n    secp256k1.utils.randomSecretKey;\n    function keygen(seed) {\n        const secretKey = randomSecretKey(seed);\n        return {\n            secretKey,\n            publicKey: schnorrGetPublicKey(secretKey)\n        };\n    }\n    return {\n        keygen,\n        getPublicKey: schnorrGetPublicKey,\n        sign: schnorrSign,\n        verify: schnorrVerify,\n        Point: Pointk1,\n        utils: {\n            randomSecretKey: randomSecretKey,\n            randomPrivateKey: randomSecretKey,\n            taggedHash,\n            // TODO: remove\n            lift_x,\n            pointToBytes,\n            numberToBytesBE: _utils_js__WEBPACK_IMPORTED_MODULE_5__.numberToBytesBE,\n            bytesToNumberBE: _utils_js__WEBPACK_IMPORTED_MODULE_5__.bytesToNumberBE,\n            mod: _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod\n        },\n        lengths: {\n            secretKey: size,\n            publicKey: size,\n            publicKeyHasPrefix: false,\n            signature: size * 2,\n            seed: seedLength\n        }\n    };\n})();\nconst isoMap = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_6__.isogenyMap)(Fpk1, [\n        // xNum\n        [\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7\",\n            \"0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581\",\n            \"0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262\",\n            \"0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c\"\n        ],\n        // xDen\n        [\n            \"0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b\",\n            \"0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ],\n        // yNum\n        [\n            \"0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c\",\n            \"0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3\",\n            \"0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931\",\n            \"0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84\"\n        ],\n        // yDen\n        [\n            \"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b\",\n            \"0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573\",\n            \"0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f\",\n            \"0x0000000000000000000000000000000000000000000000000000000000000001\"\n        ]\n    ].map((i)=>i.map((j)=>BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (()=>(0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_4__.mapToCurveSimpleSWU)(Fpk1, {\n        A: BigInt(\"0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533\"),\n        B: BigInt(\"1771\"),\n        Z: Fpk1.create(BigInt(\"-11\"))\n    }))();\n/** Hashing / encoding to secp256k1 points / field. RFC 9380 methods. */ const secp256k1_hasher = /* @__PURE__ */ (()=>(0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_6__.createHasher)(secp256k1.Point, (scalars)=>{\n        const { x, y } = mapSWU(Fpk1.create(scalars[0]));\n        return isoMap(x, y);\n    }, {\n        DST: \"secp256k1_XMD:SHA-256_SSWU_RO_\",\n        encodeDST: \"secp256k1_XMD:SHA-256_SSWU_NU_\",\n        p: Fpk1.ORDER,\n        m: 1,\n        k: 128,\n        expand: \"xmd\",\n        hash: _noble_hashes_sha2_js__WEBPACK_IMPORTED_MODULE_2__.sha256\n    }))();\n/** @deprecated use `import { secp256k1_hasher } from '@noble/curves/secp256k1.js';` */ const hashToCurve = /* @__PURE__ */ (()=>secp256k1_hasher.hashToCurve)();\n/** @deprecated use `import { secp256k1_hasher } from '@noble/curves/secp256k1.js';` */ const encodeToCurve = /* @__PURE__ */ (()=>secp256k1_hasher.encodeToCurve)(); //# sourceMappingURL=secp256k1.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjkuNy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vc2VjcDI1NmsxLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Q0FNQyxHQUNELG9FQUFvRSxHQUNyQjtBQUNNO0FBQ0o7QUFDdUI7QUFDQztBQUNRO0FBQzhCO0FBQy9HLG9EQUFvRDtBQUNwRCwwREFBMEQ7QUFDMUQsaUVBQWlFO0FBQ2pFLE1BQU1pQixrQkFBa0I7SUFDcEJDLEdBQUdDLE9BQU87SUFDVkMsR0FBR0QsT0FBTztJQUNWRSxHQUFHRixPQUFPO0lBQ1ZHLEdBQUdILE9BQU87SUFDVkksR0FBR0osT0FBTztJQUNWSyxJQUFJTCxPQUFPO0lBQ1hNLElBQUlOLE9BQU87QUFDZjtBQUNBLE1BQU1PLGlCQUFpQjtJQUNuQkMsTUFBTVIsT0FBTztJQUNiUyxTQUFTO1FBQ0w7WUFBQ1QsT0FBTztZQUF1QyxDQUFDQSxPQUFPO1NBQXNDO1FBQzdGO1lBQUNBLE9BQU87WUFBd0NBLE9BQU87U0FBc0M7S0FDaEc7QUFDTDtBQUNBLE1BQU1VLE1BQU0sYUFBYSxHQUFHVixPQUFPO0FBQ25DLE1BQU1XLE1BQU0sYUFBYSxHQUFHWCxPQUFPO0FBQ25DLE1BQU1ZLE1BQU0sYUFBYSxHQUFHWixPQUFPO0FBQ25DOzs7Q0FHQyxHQUNELFNBQVNhLFFBQVFDLENBQUM7SUFDZCxNQUFNQyxJQUFJakIsZ0JBQWdCQyxDQUFDO0lBQzNCLGtCQUFrQjtJQUNsQixNQUFNaUIsTUFBTWhCLE9BQU8sSUFBSWlCLE1BQU1qQixPQUFPLElBQUlrQixPQUFPbEIsT0FBTyxLQUFLbUIsT0FBT25CLE9BQU87SUFDekUsa0JBQWtCO0lBQ2xCLE1BQU1vQixPQUFPcEIsT0FBTyxLQUFLcUIsT0FBT3JCLE9BQU8sS0FBS3NCLE9BQU90QixPQUFPO0lBQzFELE1BQU11QixLQUFLLElBQUtULElBQUlBLElBQUtDLEdBQUcsVUFB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QUc7UUFDSDRDLFFBQVE7UUFDUkMsTUFBTTNKLHlEQUFNQTtJQUNoQixFQUFDLElBQUs7QUFDTixxRkFBcUYsR0FDOUUsTUFBTTRKLGNBQThCLGFBQUgsR0FBSSxLQUFNUCxpQkFBaUJPLFdBQVcsSUFBSTtBQUNsRixxRkFBcUYsR0FDOUUsTUFBTUMsZ0JBQWdDLGFBQUgsR0FBSSxLQUFNUixpQkFBaUJRLGFBQWEsSUFBSSxDQUN0RixxQ0FBcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9ub3Rhc2NhbS1wcm90b2NvbC8uL25vZGVfbW9kdWxlcy8ucG5wbS9Abm9ibGUrY3VydmVzQDEuOS43L25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanM/MjRkZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFNFQ0cgc2VjcDI1NmsxLiBTZWUgW3BkZl0oaHR0cHM6Ly93d3cuc2VjZy5vcmcvc2VjMi12Mi5wZGYpLlxuICpcbiAqIEJlbG9uZ3MgdG8gS29ibGl0eiBjdXJ2ZXM6IGl0IGhhcyBlZmZpY2llbnRseS1jb21wdXRhYmxlIEdMViBlbmRvbW9ycGhpc20gz4gsXG4gKiBjaGVjayBvdXQge0BsaW5rIEVuZG9tb3JwaGlzbU9wdHN9LiBTZWVtcyB0byBiZSByaWdpZCAobm90IGJhY2tkb29yZWQpLlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTIuanMnO1xuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzLmpzJztcbmltcG9ydCB7IGNyZWF0ZUN1cnZlIH0gZnJvbSBcIi4vX3Nob3J0d191dGlscy5qc1wiO1xuaW1wb3J0IHsgY3JlYXRlSGFzaGVyLCBpc29nZW55TWFwLCB9IGZyb20gXCIuL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanNcIjtcbmltcG9ydCB7IEZpZWxkLCBtYXBIYXNoVG9GaWVsZCwgbW9kLCBwb3cyIH0gZnJvbSBcIi4vYWJzdHJhY3QvbW9kdWxhci5qc1wiO1xuaW1wb3J0IHsgX25vcm1GbkVsZW1lbnQsIG1hcFRvQ3VydmVTaW1wbGVTV1UsIH0gZnJvbSBcIi4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanNcIjtcbmltcG9ydCB7IGJ5dGVzVG9OdW1iZXJCRSwgY29uY2F0Qnl0ZXMsIGVuc3VyZUJ5dGVzLCBpblJhbmdlLCBudW1iZXJUb0J5dGVzQkUsIHV0ZjhUb0J5dGVzLCB9IGZyb20gXCIuL3V0aWxzLmpzXCI7XG4vLyBTZWVtcyBsaWtlIGdlbmVyYXRvciB3YXMgcHJvZHVjZWQgZnJvbSBzb21lIHNlZWQ6XG4vLyBgUG9pbnQuQkFTRS5tdWx0aXBseShQb2ludC5Gbi5pbnYoMm4sIE4pKS50b0FmZmluZSgpLnhgXG4vLyAvLyBnaXZlcyBzaG9ydCB4IDB4M2I3OGNlNTYzZjg5YTBlZDk0MTRmNWFhMjhhZDBkOTZkNjc5NWY5YzYzblxuY29uc3Qgc2VjcDI1NmsxX0NVUlZFID0ge1xuICAgIHA6IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmYzJmJyksXG4gICAgbjogQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDEnKSxcbiAgICBoOiBCaWdJbnQoMSksXG4gICAgYTogQmlnSW50KDApLFxuICAgIGI6IEJpZ0ludCg3KSxcbiAgICBHeDogQmlnSW50KCcweDc5YmU2NjdlZjlkY2JiYWM1NWEwNjI5NWNlODcwYjA3MDI5YmZjZGIyZGNlMjhkOTU5ZjI4MTViMTZmODE3OTgnKSxcbiAgICBHeTogQmlnSW50KCcweDQ4M2FkYTc3MjZhM2M0NjU1ZGE0ZmJmYzBlMTEwOGE4ZmQxN2I0NDhhNjg1NTQxOTljNDdkMDhmZmIxMGQ0YjgnKSxcbn07XG5jb25zdCBzZWNwMjU2azFfRU5ETyA9IHtcbiAgICBiZXRhOiBCaWdJbnQoJzB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScpLFxuICAgIGJhc2lzZXM6IFtcbiAgICAgICAgW0JpZ0ludCgnMHgzMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNScpLCAtQmlnSW50KCcweGU0NDM3ZWQ2MDEwZTg4Mjg2ZjU0N2ZhOTBhYmZlNGMzJyldLFxuICAgICAgICBbQmlnSW50KCcweDExNGNhNTBmN2E4ZTJmM2Y2NTdjMTEwOGQ5ZDQ0Y2ZkOCcpLCBCaWdJbnQoJzB4MzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnKV0sXG4gICAgXSxcbn07XG5jb25zdCBfMG4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDApO1xuY29uc3QgXzFuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMik7XG4vKipcbiAqIOKImm4gPSBuXigocCsxKS80KSBmb3IgZmllbGRzIHAgPSAzIG1vZCA0LiBXZSB1bndyYXAgdGhlIGxvb3AgYW5kIG11bHRpcGx5IGJpdC1ieS1iaXQuXG4gKiAoUCsxbi80bikudG9TdHJpbmcoMikgd291bGQgcHJvZHVjZSBiaXRzIFsyMjN4IDEsIDAsIDIyeCAxLCA0eCAwLCAxMSwgMDBdXG4gKi9cbmZ1bmN0aW9uIHNxcnRNb2QoeSkge1xuICAgIGNvbnN0IFAgPSBzZWNwMjU2azFfQ1VSVkUucDtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBfM24gPSBCaWdJbnQoMyksIF82biA9IEJpZ0ludCg2KSwgXzExbiA9IEJpZ0ludCgxMSksIF8yMm4gPSBCaWdJbnQoMjIpO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF8yM24gPSBCaWdJbnQoMjMpLCBfNDRuID0gQmlnSW50KDQ0KSwgXzg4biA9IEJpZ0ludCg4OCk7XG4gICAgY29uc3QgYjIgPSAoeSAqIHkgKiB5KSAlIFA7IC8vIHheMywgMTFcbiAgICBjb25zdCBiMyA9IChiMiAqIGIyICogeSkgJSBQOyAvLyB4XjdcbiAgICBjb25zdCBiNiA9IChwb3cyKGIzLCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCBiOSA9IChwb3cyKGI2LCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCBiMTEgPSAocG93MihiOSwgXzJuLCBQKSAqIGIyKSAlIFA7XG4gICAgY29uc3QgYjIyID0gKHBvdzIoYjExLCBfMTFuLCBQKSAqIGIxMSkgJSBQO1xuICAgIGNvbnN0IGI0NCA9IChwb3cyKGIyMiwgXzIybiwgUCkgKiBiMjIpICUgUDtcbiAgICBjb25zdCBiODggPSAocG93MihiNDQsIF80NG4sIFApICogYjQ0KSAlIFA7XG4gICAgY29uc3QgYjE3NiA9IChwb3cyKGI4OCwgXzg4biwgUCkgKiBiODgpICUgUDtcbiAgICBjb25zdCBiMjIwID0gKHBvdzIoYjE3NiwgXzQ0biwgUCkgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMjIzID0gKHBvdzIoYjIyMCwgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgdDEgPSAocG93MihiMjIzLCBfMjNuLCBQKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IHQyID0gKHBvdzIodDEsIF82biwgUCkgKiBiMikgJSBQO1xuICAgIGNvbnN0IHJvb3QgPSBwb3cyKHQyLCBfMm4sIFApO1xuICAgIGlmICghRnBrMS5lcWwoRnBrMS5zcXIocm9vdCksIHkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgcmV0dXJuIHJvb3Q7XG59XG5jb25zdCBGcGsxID0gRmllbGQoc2VjcDI1NmsxX0NVUlZFLnAsIHsgc3FydDogc3FydE1vZCB9KTtcbi8qKlxuICogc2VjcDI1NmsxIGN1cnZlLCBFQ0RTQSBhbmQgRUNESCBtZXRob2RzLlxuICpcbiAqIEZpZWxkOiBgMm4qKjI1Nm4gLSAybioqMzJuIC0gMm4qKjluIC0gMm4qKjhuIC0gMm4qKjduIC0gMm4qKjZuIC0gMm4qKjRuIC0gMW5gXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBpbXBvcnQgeyBzZWNwMjU2azEgfSBmcm9tICdAbm9ibGUvY3VydmVzL3NlY3AyNTZrMSc7XG4gKiBjb25zdCB7IHNlY3JldEtleSwgcHVibGljS2V5IH0gPSBzZWNwMjU2azEua2V5Z2VuKCk7XG4gKiBjb25zdCBtc2cgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoJ2hlbGxvJyk7XG4gKiBjb25zdCBzaWcgPSBzZWNwMjU2azEuc2lnbihtc2csIHNlY3JldEtleSk7XG4gKiBjb25zdCBpc1ZhbGlkID0gc2VjcDI1NmsxLnZlcmlmeShzaWcsIG1zZywgcHVibGljS2V5KSA9PT0gdHJ1ZTtcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3Qgc2VjcDI1NmsxID0gY3JlYXRlQ3VydmUoeyAuLi5zZWNwMjU2azFfQ1VSVkUsIEZwOiBGcGsxLCBsb3dTOiB0cnVlLCBlbmRvOiBzZWNwMjU2azFfRU5ETyB9LCBzaGEyNTYpO1xuLy8gU2Nobm9yciBzaWduYXR1cmVzIGFyZSBzdXBlcmlvciB0byBFQ0RTQSBmcm9tIGFib3ZlLiBCZWxvdyBpcyBTY2hub3JyLXNwZWNpZmljIEJJUDAzNDAgY29kZS5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAzNDAubWVkaWF3aWtpXG4vKiogQW4gb2JqZWN0IG1hcHBpbmcgdGFncyB0byB0aGVpciB0YWdnZWQgaGFzaCBwcmVmaXggb2YgW1NIQTI1Nih0YWcpIHwgU0hBMjU2KHRhZyldICovXG5jb25zdCBUQUdHRURfSEFTSF9QUkVGSVhFUyA9IHt9O1xuZnVuY3Rpb24gdGFnZ2VkSGFzaCh0YWcsIC4uLm1lc3NhZ2VzKSB7XG4gICAgbGV0IHRhZ1AgPSBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddO1xuICAgIGlmICh0YWdQID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdGFnSCA9IHNoYTI1Nih1dGY4VG9CeXRlcyh0YWcpKTtcbiAgICAgICAgdGFnUCA9IGNvbmNhdEJ5dGVzKHRhZ0gsIHRhZ0gpO1xuICAgICAgICBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddID0gdGFnUDtcbiAgICB9XG4gICAgcmV0dXJuIHNoYTI1Nihjb25jYXRCeXRlcyh0YWdQLCAuLi5tZXNzYWdlcykpO1xufVxuLy8gRUNEU0EgY29tcGFjdCBwb2ludHMgYXJlIDMzLWJ5dGUuIFNjaG5vcnIgaXMgMzI6IHdlIHN0cmlwIGZpcnN0IGJ5dGUgMHgwMiBvciAweDAzXG5jb25zdCBwb2ludFRvQnl0ZXMgPSAocG9pbnQpID0+IHBvaW50LnRvQnl0ZXModHJ1ZSkuc2xpY2UoMSk7XG5jb25zdCBQb2ludGsxID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBzZWNwMjU2azEuUG9pbnQpKCk7XG5jb25zdCBoYXNFdmVuID0gKHkpID0+IHkgJSBfMm4gPT09IF8wbjtcbi8vIENhbGN1bGF0ZSBwb2ludCwgc2NhbGFyIGFuZCBieXRlc1xuZnVuY3Rpb24gc2Nobm9yckdldEV4dFB1YktleShwcml2KSB7XG4gICAgY29uc3QgeyBGbiwgQkFTRSB9ID0gUG9pbnRrMTtcbiAgICBjb25zdCBkXyA9IF9ub3JtRm5FbGVtZW50KEZuLCBwcml2KTtcbiAgICBjb25zdCBwID0gQkFTRS5tdWx0aXBseShkXyk7IC8vIFAgPSBkJ+KLhUc7IDAgPCBkJyA8IG4gY2hlY2sgaXMgZG9uZSBpbnNpZGVcbiAgICBjb25zdCBzY2FsYXIgPSBoYXNFdmVuKHAueSkgPyBkXyA6IEZuLm5lZyhkXyk7XG4gICAgcmV0dXJuIHsgc2NhbGFyLCBieXRlczogcG9pbnRUb0J5dGVzKHApIH07XG59XG4vKipcbiAqIGxpZnRfeCBmcm9tIEJJUDM0MC4gQ29udmVydCAzMi1ieXRlIHggY29vcmRpbmF0ZSB0byBlbGxpcHRpYyBjdXJ2ZSBwb2ludC5cbiAqIEByZXR1cm5zIHZhbGlkIHBvaW50IGNoZWNrZWQgZm9yIGJlaW5nIG9uLWN1cnZlXG4gKi9cbmZ1bmN0aW9uIGxpZnRfeCh4KSB7XG4gICAgY29uc3QgRnAgPSBGcGsxO1xuICAgIGlmICghRnAuaXNWYWxpZE5vdDAoeCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB4OiBGYWlsIGlmIHgg4omlIHAnKTtcbiAgICBjb25zdCB4eCA9IEZwLmNyZWF0ZSh4ICogeCk7XG4gICAgY29uc3QgYyA9IEZwLmNyZWF0ZSh4eCAqIHggKyBCaWdJbnQoNykpOyAvLyBMZXQgYyA9IHjCsyArIDcgbW9kIHAuXG4gICAgbGV0IHkgPSBGcC5zcXJ0KGMpOyAvLyBMZXQgeSA9IGNeKHArMSkvNCBtb2QgcC4gU2FtZSBhcyBzcXJ0KCkuXG4gICAgLy8gUmV0dXJuIHRoZSB1bmlxdWUgcG9pbnQgUCBzdWNoIHRoYXQgeChQKSA9IHggYW5kXG4gICAgLy8geShQKSA9IHkgaWYgeSBtb2QgMiA9IDAgb3IgeShQKSA9IHAteSBvdGhlcndpc2UuXG4gICAgaWYgKCFoYXNFdmVuKHkpKVxuICAgICAgICB5ID0gRnAubmVnKHkpO1xuICAgIGNvbnN0IHAgPSBQb2ludGsxLmZyb21BZmZpbmUoeyB4LCB5IH0pO1xuICAgIHAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICByZXR1cm4gcDtcbn1cbmNvbnN0IG51bSA9IGJ5dGVzVG9OdW1iZXJCRTtcbi8qKlxuICogQ3JlYXRlIHRhZ2dlZCBoYXNoLCBjb252ZXJ0IGl0IHRvIGJpZ2ludCwgcmVkdWNlIG1vZHVsby1uLlxuICovXG5mdW5jdGlvbiBjaGFsbGVuZ2UoLi4uYXJncykge1xuICAgIHJldHVybiBQb2ludGsxLkZuLmNyZWF0ZShudW0odGFnZ2VkSGFzaCgnQklQMDM0MC9jaGFsbGVuZ2UnLCAuLi5hcmdzKSkpO1xufVxuLyoqXG4gKiBTY2hub3JyIHB1YmxpYyBrZXkgaXMganVzdCBgeGAgY29vcmRpbmF0ZSBvZiBQb2ludCBhcyBwZXIgQklQMzQwLlxuICovXG5mdW5jdGlvbiBzY2hub3JyR2V0UHVibGljS2V5KHNlY3JldEtleSkge1xuICAgIHJldHVybiBzY2hub3JyR2V0RXh0UHViS2V5KHNlY3JldEtleSkuYnl0ZXM7IC8vIGQnPWludChzaykuIEZhaWwgaWYgZCc9MCBvciBkJ+KJpW4uIFJldCBieXRlcyhkJ+KLhUcpXG59XG4vKipcbiAqIENyZWF0ZXMgU2Nobm9yciBzaWduYXR1cmUgYXMgcGVyIEJJUDM0MC4gVmVyaWZpZXMgaXRzZWxmIGJlZm9yZSByZXR1cm5pbmcgYW55dGhpbmcuXG4gKiBhdXhSYW5kIGlzIG9wdGlvbmFsIGFuZCBpcyBub3QgdGhlIHNvbGUgc291cmNlIG9mIGsgZ2VuZXJhdGlvbjogYmFkIENTUFJORyB3b24ndCBiZSBkYW5nZXJvdXMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJTaWduKG1lc3NhZ2UsIHNlY3JldEtleSwgYXV4UmFuZCA9IHJhbmRvbUJ5dGVzKDMyKSkge1xuICAgIGNvbnN0IHsgRm4gfSA9IFBvaW50azE7XG4gICAgY29uc3QgbSA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbWVzc2FnZSk7XG4gICAgY29uc3QgeyBieXRlczogcHgsIHNjYWxhcjogZCB9ID0gc2Nobm9yckdldEV4dFB1YktleShzZWNyZXRLZXkpOyAvLyBjaGVja3MgZm9yIGlzV2l0aGluQ3VydmVPcmRlclxuICAgIGNvbnN0IGEgPSBlbnN1cmVCeXRlcygnYXV4UmFuZCcsIGF1eFJhbmQsIDMyKTsgLy8gQXV4aWxpYXJ5IHJhbmRvbSBkYXRhIGE6IGEgMzItYnl0ZSBhcnJheVxuICAgIGNvbnN0IHQgPSBGbi50b0J5dGVzKGQgXiBudW0odGFnZ2VkSGFzaCgnQklQMDM0MC9hdXgnLCBhKSkpOyAvLyBMZXQgdCBiZSB0aGUgYnl0ZS13aXNlIHhvciBvZiBieXRlcyhkKSBhbmQgaGFzaC9hdXgoYSlcbiAgICBjb25zdCByYW5kID0gdGFnZ2VkSGFzaCgnQklQMDM0MC9ub25jZScsIHQsIHB4LCBtKTsgLy8gTGV0IHJhbmQgPSBoYXNoL25vbmNlKHQgfHwgYnl0ZXMoUCkgfHwgbSlcbiAgICAvLyBMZXQgaycgPSBpbnQocmFuZCkgbW9kIG4uIEZhaWwgaWYgaycgPSAwLiBMZXQgUiA9IGsn4ouFR1xuICAgIGNvbnN0IHsgYnl0ZXM6IHJ4LCBzY2FsYXI6IGsgfSA9IHNjaG5vcnJHZXRFeHRQdWJLZXkocmFuZCk7XG4gICAgY29uc3QgZSA9IGNoYWxsZW5nZShyeCwgcHgsIG0pOyAvLyBMZXQgZSA9IGludChoYXNoL2NoYWxsZW5nZShieXRlcyhSKSB8fCBieXRlcyhQKSB8fCBtKSkgbW9kIG4uXG4gICAgY29uc3Qgc2lnID0gbmV3IFVpbnQ4QXJyYXkoNjQpOyAvLyBMZXQgc2lnID0gYnl0ZXMoUikgfHwgYnl0ZXMoKGsgKyBlZCkgbW9kIG4pLlxuICAgIHNpZy5zZXQocngsIDApO1xuICAgIHNpZy5zZXQoRm4udG9CeXRlcyhGbi5jcmVhdGUoayArIGUgKiBkKSksIDMyKTtcbiAgICAvLyBJZiBWZXJpZnkoYnl0ZXMoUCksIG0sIHNpZykgKHNlZSBiZWxvdykgcmV0dXJucyBmYWlsdXJlLCBhYm9ydFxuICAgIGlmICghc2Nobm9yclZlcmlmeShzaWcsIG0sIHB4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduOiBJbnZhbGlkIHNpZ25hdHVyZSBwcm9kdWNlZCcpO1xuICAgIHJldHVybiBzaWc7XG59XG4vKipcbiAqIFZlcmlmaWVzIFNjaG5vcnIgc2lnbmF0dXJlLlxuICogV2lsbCBzd2FsbG93IGVycm9ycyAmIHJldHVybiBmYWxzZSBleGNlcHQgZm9yIGluaXRpYWwgdHlwZSB2YWxpZGF0aW9uIG9mIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yclZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSkge1xuICAgIGNvbnN0IHsgRm4sIEJBU0UgfSA9IFBvaW50azE7XG4gICAgY29uc3Qgc2lnID0gZW5zdXJlQnl0ZXMoJ3NpZ25hdHVyZScsIHNpZ25hdHVyZSwgNjQpO1xuICAgIGNvbnN0IG0gPSBlbnN1cmVCeXRlcygnbWVzc2FnZScsIG1lc3NhZ2UpO1xuICAgIGNvbnN0IHB1YiA9IGVuc3VyZUJ5dGVzKCdwdWJsaWNLZXknLCBwdWJsaWNLZXksIDMyKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBQID0gbGlmdF94KG51bShwdWIpKTsgLy8gUCA9IGxpZnRfeChpbnQocGspKTsgZmFpbCBpZiB0aGF0IGZhaWxzXG4gICAgICAgIGNvbnN0IHIgPSBudW0oc2lnLnN1YmFycmF5KDAsIDMyKSk7IC8vIExldCByID0gaW50KHNpZ1swOjMyXSk7IGZhaWwgaWYgciDiiaUgcC5cbiAgICAgICAgaWYgKCFpblJhbmdlKHIsIF8xbiwgc2VjcDI1NmsxX0NVUlZFLnApKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBzID0gbnVtKHNpZy5zdWJhcnJheSgzMiwgNjQpKTsgLy8gTGV0IHMgPSBpbnQoc2lnWzMyOjY0XSk7IGZhaWwgaWYgcyDiiaUgbi5cbiAgICAgICAgaWYgKCFpblJhbmdlKHMsIF8xbiwgc2VjcDI1NmsxX0NVUlZFLm4pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBpbnQoY2hhbGxlbmdlKGJ5dGVzKHIpfHxieXRlcyhQKXx8bSkpJW5cbiAgICAgICAgY29uc3QgZSA9IGNoYWxsZW5nZShGbi50b0J5dGVzKHIpLCBwb2ludFRvQnl0ZXMoUCksIG0pO1xuICAgICAgICAvLyBSID0gc+KLhUcgLSBl4ouFUCwgd2hlcmUgLWVQID09IChuLWUpUFxuICAgICAgICBjb25zdCBSID0gQkFTRS5tdWx0aXBseVVuc2FmZShzKS5hZGQoUC5tdWx0aXBseVVuc2FmZShGbi5uZWcoZSkpKTtcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBSLnRvQWZmaW5lKCk7XG4gICAgICAgIC8vIEZhaWwgaWYgaXNfaW5maW5pdGUoUikgLyBub3QgaGFzX2V2ZW5feShSKSAvIHgoUikg4omgIHIuXG4gICAgICAgIGlmIChSLmlzMCgpIHx8ICFoYXNFdmVuKHkpIHx8IHggIT09IHIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogU2Nobm9yciBzaWduYXR1cmVzIG92ZXIgc2VjcDI1NmsxLlxuICogaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2lcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogaW1wb3J0IHsgc2Nobm9yciB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxJztcbiAqIGNvbnN0IHsgc2VjcmV0S2V5LCBwdWJsaWNLZXkgfSA9IHNjaG5vcnIua2V5Z2VuKCk7XG4gKiAvLyBjb25zdCBwdWJsaWNLZXkgPSBzY2hub3JyLmdldFB1YmxpY0tleShzZWNyZXRLZXkpO1xuICogY29uc3QgbXNnID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKCdoZWxsbycpO1xuICogY29uc3Qgc2lnID0gc2Nobm9yci5zaWduKG1zZywgc2VjcmV0S2V5KTtcbiAqIGNvbnN0IGlzVmFsaWQgPSBzY2hub3JyLnZlcmlmeShzaWcsIG1zZywgcHVibGljS2V5KTtcbiAqIGBgYFxuICovXG5leHBvcnQgY29uc3Qgc2Nobm9yciA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuICAgIGNvbnN0IHNpemUgPSAzMjtcbiAgICBjb25zdCBzZWVkTGVuZ3RoID0gNDg7XG4gICAgY29uc3QgcmFuZG9tU2VjcmV0S2V5ID0gKHNlZWQgPSByYW5kb21CeXRlcyhzZWVkTGVuZ3RoKSkgPT4ge1xuICAgICAgICByZXR1cm4gbWFwSGFzaFRvRmllbGQoc2VlZCwgc2VjcDI1NmsxX0NVUlZFLm4pO1xuICAgIH07XG4gICAgLy8gVE9ETzogcmVtb3ZlXG4gICAgc2VjcDI1NmsxLnV0aWxzLnJhbmRvbVNlY3JldEtleTtcbiAgICBmdW5jdGlvbiBrZXlnZW4oc2VlZCkge1xuICAgICAgICBjb25zdCBzZWNyZXRLZXkgPSByYW5kb21TZWNyZXRLZXkoc2VlZCk7XG4gICAgICAgIHJldHVybiB7IHNlY3JldEtleSwgcHVibGljS2V5OiBzY2hub3JyR2V0UHVibGljS2V5KHNlY3JldEtleSkgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2V5Z2VuLFxuICAgICAgICBnZXRQdWJsaWNLZXk6IHNjaG5vcnJHZXRQdWJsaWNLZXksXG4gICAgICAgIHNpZ246IHNjaG5vcnJTaWduLFxuICAgICAgICB2ZXJpZnk6IHNjaG5vcnJWZXJpZnksXG4gICAgICAgIFBvaW50OiBQb2ludGsxLFxuICAgICAgICB1dGlsczoge1xuICAgICAgICAgICAgcmFuZG9tU2VjcmV0S2V5OiByYW5kb21TZWNyZXRLZXksXG4gICAgICAgICAgICByYW5kb21Qcml2YXRlS2V5OiByYW5kb21TZWNyZXRLZXksXG4gICAgICAgICAgICB0YWdnZWRIYXNoLFxuICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlXG4gICAgICAgICAgICBsaWZ0X3gsXG4gICAgICAgICAgICBwb2ludFRvQnl0ZXMsXG4gICAgICAgICAgICBudW1iZXJUb0J5dGVzQkUsXG4gICAgICAgICAgICBieXRlc1RvTnVtYmVyQkUsXG4gICAgICAgICAgICBtb2QsXG4gICAgICAgIH0sXG4gICAgICAgIGxlbmd0aHM6IHtcbiAgICAgICAgICAgIHNlY3JldEtleTogc2l6ZSxcbiAgICAgICAgICAgIHB1YmxpY0tleTogc2l6ZSxcbiAgICAgICAgICAgIHB1YmxpY0tleUhhc1ByZWZpeDogZmFsc2UsXG4gICAgICAgICAgICBzaWduYXR1cmU6IHNpemUgKiAyLFxuICAgICAgICAgICAgc2VlZDogc2VlZExlbmd0aCxcbiAgICAgICAgfSxcbiAgICB9O1xufSkoKTtcbmNvbnN0IGlzb01hcCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaXNvZ2VueU1hcChGcGsxLCBbXG4gICAgLy8geE51bVxuICAgIFtcbiAgICAgICAgJzB4OGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGUzOGRhYWFhYThjNycsXG4gICAgICAgICcweDdkM2Q0YzgwYmMzMjFkNWI5ZjMxNWNlYTdmZDQ0YzVkNTk1ZDJmYzBiZjYzYjkyZGZmZjEwNDRmMTdjNjU4MScsXG4gICAgICAgICcweDUzNGMzMjhkMjNmMjM0ZTZlMmE0MTNkZWNhMjVjYWVjZTQ1MDYxNDQwMzdjNDAzMTRlY2JkMGI1M2Q5ZGQyNjInLFxuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhODhjJyxcbiAgICBdLFxuICAgIC8vIHhEZW5cbiAgICBbXG4gICAgICAgICcweGQzNTc3MTE5M2Q5NDkxOGE5Y2EzNGNjYmI3YjY0MGRkODZjZDQwOTU0MmY4NDg3ZDlmZTZiNzQ1NzgxZWI0OWInLFxuICAgICAgICAnMHhlZGFkYzZmNjQzODNkYzFkZjdjNGIyZDUxYjU0MjI1NDA2ZDM2YjY0MWY1ZTQxYmJjNTJhNTY2MTJhOGM2ZDE0JyxcbiAgICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsIC8vIExBU1QgMVxuICAgIF0sXG4gICAgLy8geU51bVxuICAgIFtcbiAgICAgICAgJzB4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGI4ZTM4ZTIzYycsXG4gICAgICAgICcweGM3NWUwYzMyZDVjYjdjMGZhOWQwYTU0YjEyYTBhNmQ1NjQ3YWIwNDZkNjg2ZGE2ZmRmZmM5MGZjMjAxZDcxYTMnLFxuICAgICAgICAnMHgyOWE2MTk0NjkxZjkxYTczNzE1MjA5ZWY2NTEyZTU3NjcyMjgzMGEyMDFiZTIwMThhNzY1ZTg1YTllY2VlOTMxJyxcbiAgICAgICAgJzB4MmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmY2ODRiZGExMmYzOGUzOGQ4NCcsXG4gICAgXSxcbiAgICAvLyB5RGVuXG4gICAgW1xuICAgICAgICAnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmOTNiJyxcbiAgICAgICAgJzB4N2EwNjUzNGJiOGJkYjQ5ZmQ1ZTllNjYzMjcyMmMyOTg5NDY3YzFiZmM4ZThkOTc4ZGZiNDI1ZDI2ODVjMjU3MycsXG4gICAgICAgICcweDY0ODRhYTcxNjU0NWNhMmNmM2E3MGMzZmE4ZmUzMzdlMGEzZDIxMTYyZjBkNjI5OWE3YmY4MTkyYmZkMmE3NmYnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbl0ubWFwKChpKSA9PiBpLm1hcCgoaikgPT4gQmlnSW50KGopKSkpKSgpO1xuY29uc3QgbWFwU1dVID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwazEsIHtcbiAgICBBOiBCaWdJbnQoJzB4M2Y4NzMxYWJkZDY2MWFkY2EwOGE1NTU4ZjBmNWQyNzJlOTUzZDM2M2NiNmYwZTVkNDA1NDQ3YzAxYTQ0NDUzMycpLFxuICAgIEI6IEJpZ0ludCgnMTc3MScpLFxuICAgIFo6IEZwazEuY3JlYXRlKEJpZ0ludCgnLTExJykpLFxufSkpKCk7XG4vKiogSGFzaGluZyAvIGVuY29kaW5nIHRvIHNlY3AyNTZrMSBwb2ludHMgLyBmaWVsZC4gUkZDIDkzODAgbWV0aG9kcy4gKi9cbmV4cG9ydCBjb25zdCBzZWNwMjU2azFfaGFzaGVyID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBjcmVhdGVIYXNoZXIoc2VjcDI1NmsxLlBvaW50LCAoc2NhbGFycykgPT4ge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gbWFwU1dVKEZwazEuY3JlYXRlKHNjYWxhcnNbMF0pKTtcbiAgICByZXR1cm4gaXNvTWFwKHgsIHkpO1xufSwge1xuICAgIERTVDogJ3NlY3AyNTZrMV9YTUQ6U0hBLTI1Nl9TU1dVX1JPXycsXG4gICAgZW5jb2RlRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfTlVfJyxcbiAgICBwOiBGcGsxLk9SREVSLFxuICAgIG06IDEsXG4gICAgazogMTI4LFxuICAgIGV4cGFuZDogJ3htZCcsXG4gICAgaGFzaDogc2hhMjU2LFxufSkpKCk7XG4vKiogQGRlcHJlY2F0ZWQgdXNlIGBpbXBvcnQgeyBzZWNwMjU2azFfaGFzaGVyIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9zZWNwMjU2azEuanMnO2AgKi9cbmV4cG9ydCBjb25zdCBoYXNoVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gc2VjcDI1NmsxX2hhc2hlci5oYXNoVG9DdXJ2ZSkoKTtcbi8qKiBAZGVwcmVjYXRlZCB1c2UgYGltcG9ydCB7IHNlY3AyNTZrMV9oYXNoZXIgfSBmcm9tICdAbm9ibGUvY3VydmVzL3NlY3AyNTZrMS5qcyc7YCAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZVRvQ3VydmUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHNlY3AyNTZrMV9oYXNoZXIuZW5jb2RlVG9DdXJ2ZSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlY3AyNTZrMS5qcy5tYXAiXSwibmFtZXMiOlsic2hhMjU2IiwicmFuZG9tQnl0ZXMiLCJjcmVhdGVDdXJ2ZSIsImNyZWF0ZUhhc2hlciIsImlzb2dlbnlNYXAiLCJGaWVsZCIsIm1hcEhhc2hUb0ZpZWxkIiwibW9kIiwicG93MiIsIl9ub3JtRm5FbGVtZW50IiwibWFwVG9DdXJ2ZVNpbXBsZVNXVSIsImJ5dGVzVG9OdW1iZXJCRSIsImNvbmNhdEJ5dGVzIiwiZW5zdXJlQnl0ZXMiLCJpblJhbmdlIiwibnVtYmVyVG9CeXRlc0JFIiwidXRmOFRvQnl0ZXMiLCJzZWNwMjU2azFfQ1VSVkUiLCJwIiwiQmlnSW50IiwibiIsImgiLCJhIiwiYiIsIkd4IiwiR3kiLCJzZWNwMjU2azFfRU5ETyIsImJldGEiLCJiYXNpc2VzIiwiXzBuIiwiXzFuIiwiXzJuIiwic3FydE1vZCIsInkiLCJQIiwiXzNuIiwiXzZuIiwiXzExbiIsIl8yMm4iLCJfMjNuIiwiXzQ0biIsIl84OG4iLCJiMiIsImIzIiwiYjYiLCJiOSIsImIxMSIsImIyMiIsImI0NCIsImI4OCIsImIxNzYiLCJiMjIwIiwiYjIyMyIsInQxIiwidDIiLCJyb290IiwiRnBrMSIsImVxbCIsInNxciIsIkVycm9yIiwic3FydCIsInNlY3AyNTZrMSIsIkZwIiwibG93UyIsImVuZG8iLCJUQUdHRURfSEFTSF9QUkVGSVhFUyIsInRhZ2dlZEhhc2giLCJ0YWciLCJtZXNzYWdlcyIsInRhZ1AiLCJ1bmRlZmluZWQiLCJ0YWdIIiwicG9pbnRUb0J5dGVzIiwicG9pbnQiLCJ0b0J5dGVzIiwic2xpY2UiLCJQb2ludGsxIiwiUG9pbnQiLCJoYXNFdmVuIiwic2Nobm9yckdldEV4dFB1YktleSIsInByaXYiLCJGbiIsIkJBU0UiLCJkXyIsIm11bHRpcGx5Iiwic2NhbGFyIiwibmVnIiwiYnl0ZXMiLCJsaWZ0X3giLCJ4IiwiaXNWYWxpZE5vdDAiLCJ4eCIsImNyZWF0ZSIsImMiLCJmcm9tQWZmaW5lIiwiYXNzZXJ0VmFsaWRpdHkiLCJudW0iLCJjaGFsbGVuZ2UiLCJhcmdzIiwic2Nobm9yckdldFB1YmxpY0tleSIsInNlY3JldEtleSIsInNjaG5vcnJTaWduIiwibWVzc2FnZSIsImF1eFJhbmQiLCJtIiwicHgiLCJkIiwidCIsInJhbmQiLCJyeCIsImsiLCJlIiwic2lnIiwiVWludDhBcnJheSIsInNldCIsInNjaG5vcnJWZXJpZnkiLCJzaWduYXR1cmUiLCJwdWJsaWNLZXkiLCJwdWIiLCJyIiwic3ViYXJyYXkiLCJzIiwiUiIsIm11bHRpcGx5VW5zYWZlIiwiYWRkIiwidG9BZmZpbmUiLCJpczAiLCJlcnJvciIsInNjaG5vcnIiLCJzaXplIiwic2VlZExlbmd0aCIsInJhbmRvbVNlY3JldEtleSIsInNlZWQiLCJ1dGlscyIsImtleWdlbiIsImdldFB1YmxpY0tleSIsInNpZ24iLCJ2ZXJpZnkiLCJyYW5kb21Qcml2YXRlS2V5IiwibGVuZ3RocyIsInB1YmxpY0tleUhhc1ByZWZpeCIsImlzb01hcCIsIm1hcCIsImkiLCJqIiwibWFwU1dVIiwiQSIsIkIiLCJaIiwic2VjcDI1NmsxX2hhc2hlciIsInNjYWxhcnMiLCJEU1QiLCJlbmNvZGVEU1QiLCJPUkRFUiIsImV4cGFuZCIsImhhc2giLCJoYXNoVG9DdXJ2ZSIsImVuY29kZVRvQ3VydmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/secp256k1.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/utils.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/utils.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _abool2: () => (/* binding */ _abool2),\n/* harmony export */   _abytes2: () => (/* binding */ _abytes2),\n/* harmony export */   _validateObject: () => (/* binding */ _validateObject),\n/* harmony export */   aInRange: () => (/* binding */ aInRange),\n/* harmony export */   abool: () => (/* binding */ abool),\n/* harmony export */   abytes: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes),\n/* harmony export */   anumber: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.anumber),\n/* harmony export */   asciiToBytes: () => (/* binding */ asciiToBytes),\n/* harmony export */   bitGet: () => (/* binding */ bitGet),\n/* harmony export */   bitLen: () => (/* binding */ bitLen),\n/* harmony export */   bitMask: () => (/* binding */ bitMask),\n/* harmony export */   bitSet: () => (/* binding */ bitSet),\n/* harmony export */   bytesToHex: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex),\n/* harmony export */   bytesToNumberBE: () => (/* binding */ bytesToNumberBE),\n/* harmony export */   bytesToNumberLE: () => (/* binding */ bytesToNumberLE),\n/* harmony export */   bytesToUtf8: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToUtf8),\n/* harmony export */   concatBytes: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes),\n/* harmony export */   copyBytes: () => (/* binding */ copyBytes),\n/* harmony export */   createHmacDrbg: () => (/* binding */ createHmacDrbg),\n/* harmony export */   ensureBytes: () => (/* binding */ ensureBytes),\n/* harmony export */   equalBytes: () => (/* binding */ equalBytes),\n/* harmony export */   hexToBytes: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes),\n/* harmony export */   hexToNumber: () => (/* binding */ hexToNumber),\n/* harmony export */   inRange: () => (/* binding */ inRange),\n/* harmony export */   isBytes: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes),\n/* harmony export */   isHash: () => (/* binding */ isHash),\n/* harmony export */   memoized: () => (/* binding */ memoized),\n/* harmony export */   notImplemented: () => (/* binding */ notImplemented),\n/* harmony export */   numberToBytesBE: () => (/* binding */ numberToBytesBE),\n/* harmony export */   numberToBytesLE: () => (/* binding */ numberToBytesLE),\n/* harmony export */   numberToHexUnpadded: () => (/* binding */ numberToHexUnpadded),\n/* harmony export */   numberToVarBytesBE: () => (/* binding */ numberToVarBytesBE),\n/* harmony export */   randomBytes: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.randomBytes),\n/* harmony export */   utf8ToBytes: () => (/* reexport safe */ _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes),\n/* harmony export */   validateObject: () => (/* binding */ validateObject)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/utils.js */ \"(ssr)/./node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/utils.js\");\n/**\n * Hex, bytes and number utilities.\n * @module\n */ /*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */ \n\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nfunction abool(title, value) {\n    if (typeof value !== \"boolean\") throw new Error(title + \" boolean expected, got \" + value);\n}\n// tmp name until v2\nfunction _abool2(value, title = \"\") {\n    if (typeof value !== \"boolean\") {\n        const prefix = title && `\"${title}\"`;\n        throw new Error(prefix + \"expected boolean, got type=\" + typeof value);\n    }\n    return value;\n}\n// tmp name until v2\n/** Asserts something is Uint8Array. */ function _abytes2(value, length, title = \"\") {\n    const bytes = (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes)(value);\n    const len = value?.length;\n    const needsLen = length !== undefined;\n    if (!bytes || needsLen && len !== length) {\n        const prefix = title && `\"${title}\" `;\n        const ofLen = needsLen ? ` of length ${length}` : \"\";\n        const got = bytes ? `length=${len}` : `type=${typeof value}`;\n        throw new Error(prefix + \"expected Uint8Array\" + ofLen + \", got \" + got);\n    }\n    return value;\n}\n// Used in weierstrass, der\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? \"0\" + hex : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== \"string\") throw new Error(\"hex string expected, got \" + typeof hex);\n    return hex === \"\" ? _0n : BigInt(\"0x\" + hex); // Big Endian\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber((0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(bytes);\n    return hexToNumber((0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex)(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(n.toString(16).padStart(len * 2, \"0\"));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'secret key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */ function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === \"string\") {\n        try {\n            res = (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes)(hex);\n        } catch (e) {\n            throw new Error(title + \" must be hex string or Uint8Array, cause: \" + e);\n        }\n    } else if ((0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes)(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    } else {\n        throw new Error(title + \" must be hex string or Uint8Array\");\n    }\n    const len = res.length;\n    if (typeof expectedLength === \"number\" && len !== expectedLength) throw new Error(title + \" of length \" + expectedLength + \" expected, got \" + len);\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length) return false;\n    let diff = 0;\n    for(let i = 0; i < a.length; i++)diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * Copies Uint8Array. We can't use u8a.slice(), because u8a can be Buffer,\n * and Buffer#slice creates mutable copy. Never use Buffers!\n */ function copyBytes(bytes) {\n    return Uint8Array.from(bytes);\n}\n/**\n * Decodes 7-bit ASCII string to Uint8Array, throws on non-ascii symbols\n * Should be safe to use for things expected to be ASCII.\n * Returns exact same result as utf8ToBytes for ASCII or throws.\n */ function asciiToBytes(ascii) {\n    return Uint8Array.from(ascii, (c, i)=>{\n        const charCode = c.charCodeAt(0);\n        if (c.length !== 1 || charCode > 127) {\n            throw new Error(`string contains non-ASCII character \"${ascii[i]}\" with code ${charCode} at position ${i}`);\n        }\n        return charCode;\n    });\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */ // export const utf8ToBytes: typeof utf8ToBytes_ = utf8ToBytes_;\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */ // export const bytesToUtf8: typeof bytesToUtf8_ = bytesToUtf8_;\n// Is positive bigint\nconst isPosBig = (n)=>typeof n === \"bigint\" && _0n <= n;\nfunction inRange(n, min, max) {\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */ function aInRange(title, n, min, max) {\n    // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n    // consider P=256n, min=0n, max=P\n    // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n    // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n    // - our way is the cleanest:               `inRange('x', x, 0n, P)\n    if (!inRange(n, min, max)) throw new Error(\"expected valid \" + title + \": \" + min + \" <= n < \" + max + \", got \" + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */ function bitLen(n) {\n    let len;\n    for(len = 0; n > _0n; n >>= _1n, len += 1);\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */ function bitGet(n, pos) {\n    return n >> BigInt(pos) & _1n;\n}\n/**\n * Sets single bit at position.\n */ function bitSet(n, pos, value) {\n    return n | (value ? _1n : _0n) << BigInt(pos);\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */ const bitMask = (n)=>(_1n << BigInt(n)) - _1n;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */ function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== \"number\" || hashLen < 2) throw new Error(\"hashLen must be a number\");\n    if (typeof qByteLen !== \"number\" || qByteLen < 2) throw new Error(\"qByteLen must be a number\");\n    if (typeof hmacFn !== \"function\") throw new Error(\"hmacFn must be a function\");\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    const u8n = (len)=>new Uint8Array(len); // creates Uint8Array\n    const u8of = (byte)=>Uint8Array.of(byte); // another shortcut\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = ()=>{\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b)=>hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n(0))=>{\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8of(0x00), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0) return;\n        k = h(u8of(0x01), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = ()=>{\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000) throw new Error(\"drbg: tried 1000 values\");\n        let len = 0;\n        const out = [];\n        while(len < qByteLen){\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...out);\n    };\n    const genUntil = (seed, pred)=>{\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while(!(res = pred(gen())))reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val)=>typeof val === \"bigint\",\n    function: (val)=>typeof val === \"function\",\n    boolean: (val)=>typeof val === \"boolean\",\n    string: (val)=>typeof val === \"string\",\n    stringOrUint8Array: (val)=>typeof val === \"string\" || (0,_noble_hashes_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes)(val),\n    isSafeInteger: (val)=>Number.isSafeInteger(val),\n    array: (val)=>Array.isArray(val),\n    field: (val, object)=>object.Fp.isValid(val),\n    hash: (val)=>typeof val === \"function\" && Number.isSafeInteger(val.outputLen)\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional)=>{\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== \"function\") throw new Error(\"invalid validator function\");\n        const val = object[fieldName];\n        if (isOptional && val === undefined) return;\n        if (!checkVal(val, object)) {\n            throw new Error(\"param \" + String(fieldName) + \" is invalid. Expected \" + type + \", got \" + val);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\nfunction isHash(val) {\n    return typeof val === \"function\" && Number.isSafeInteger(val.outputLen);\n}\nfunction _validateObject(object, fields, optFields = {}) {\n    if (!object || typeof object !== \"object\") throw new Error(\"expected valid options object\");\n    function checkField(fieldName, expectedType, isOpt) {\n        const val = object[fieldName];\n        if (isOpt && val === undefined) return;\n        const current = typeof val;\n        if (current !== expectedType || val === null) throw new Error(`param \"${fieldName}\" is invalid: expected ${expectedType}, got ${current}`);\n    }\n    Object.entries(fields).forEach(([k, v])=>checkField(k, v, false));\n    Object.entries(optFields).forEach(([k, v])=>checkField(k, v, true));\n}\n/**\n * throws not implemented error\n */ const notImplemented = ()=>{\n    throw new Error(\"not implemented\");\n};\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */ function memoized(fn) {\n    const map = new WeakMap();\n    return (arg, ...args)=>{\n        const val = map.get(arg);\n        if (val !== undefined) return val;\n        const computed = fn(arg, ...args);\n        map.set(arg, computed);\n        return computed;\n    };\n} //# sourceMappingURL=utils.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQG5vYmxlK2N1cnZlc0AxLjkuNy9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7OztDQUdDLEdBQ0Qsb0VBQW9FLEdBQ2dHO0FBQ3JCO0FBQy9JLE1BQU1jLE1BQU0sYUFBYSxHQUFHQyxPQUFPO0FBQ25DLE1BQU1DLE1BQU0sYUFBYSxHQUFHRCxPQUFPO0FBQzVCLFNBQVNFLE1BQU1DLEtBQUssRUFBRUMsS0FBSztJQUM5QixJQUFJLE9BQU9BLFVBQVUsV0FDakIsTUFBTSxJQUFJQyxNQUFNRixRQUFRLDRCQUE0QkM7QUFDNUQ7QUFDQSxvQkFBb0I7QUFDYixTQUFTRSxRQUFRRixLQUFLLEVBQUVELFFBQVEsRUFBRTtJQUNyQyxJQUFJLE9BQU9DLFVBQVUsV0FBVztRQUM1QixNQUFNRyxTQUFTSixTQUFTLENBQUMsQ0FBQyxFQUFFQSxNQUFNLENBQUMsQ0FBQztRQUNwQyxNQUFNLElBQUlFLE1BQU1FLFNBQVMsZ0NBQWdDLE9BQU9IO0lBQ3BFO0lBQ0EsT0FBT0E7QUFDWDtBQUNBLG9CQUFvQjtBQUNwQixxQ0FBcUMsR0FDOUIsU0FBU0ksU0FBU0osS0FBSyxFQUFFSyxNQUFNLEVBQUVOLFFBQVEsRUFBRTtJQUM5QyxNQUFNTyxRQUFRaEIsK0RBQVFBLENBQUNVO0lBQ3ZCLE1BQU1PLE1BQU1QLE9BQU9LO0lBQ25CLE1BQU1HLFdBQVdILFdBQVdJO0lBQzVCLElBQUksQ0FBQ0gsU0FBVUUsWUFBWUQsUUFBUUYsUUFBUztRQUN4QyxNQUFNRixTQUFTSixTQUFTLENBQUMsQ0FBQyxFQUFFQSxNQUFNLEVBQUUsQ0FBQztRQUNyQyxNQUFNVyxRQUFRRixXQUFXLENBQUMsV0FBVyxFQUFFSCxPQUFPLENBQUMsR0FBRztRQUNsRCxNQUFNTSxNQUFNTCxRQUFRLENBQUMsT0FBTyxFQUFFQyxJQUFJ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QUs7UUFDOUMsTUFBTWhDLE1BQU1XLE1BQU0sQ0FBQ1MsVUFBVTtRQUM3QixJQUFJWSxTQUFTaEMsUUFBUW5FLFdBQ2pCO1FBQ0osTUFBTW9HLFVBQVUsT0FBT2pDO1FBQ3ZCLElBQUlpQyxZQUFZRixnQkFBZ0IvQixRQUFRLE1BQ3BDLE1BQU0sSUFBSTNFLE1BQU0sQ0FBQyxPQUFPLEVBQUUrRixVQUFVLHVCQUF1QixFQUFFVyxhQUFhLE1BQU0sRUFBRUUsUUFBUSxDQUFDO0lBQ25HO0lBQ0FSLE9BQU9DLE9BQU8sQ0FBQ0csUUFBUUssT0FBTyxDQUFDLENBQUMsQ0FBQ2pELEdBQUdELEVBQUUsR0FBS21DLFdBQVdsQyxHQUFHRCxHQUFHO0lBQzVEeUMsT0FBT0MsT0FBTyxDQUFDSSxXQUFXSSxPQUFPLENBQUMsQ0FBQyxDQUFDakQsR0FBR0QsRUFBRSxHQUFLbUMsV0FBV2xDLEdBQUdELEdBQUc7QUFDbkU7QUFDQTs7Q0FFQyxHQUNNLE1BQU1tRCxpQkFBaUI7SUFDMUIsTUFBTSxJQUFJOUcsTUFBTTtBQUNwQixFQUFFO0FBQ0Y7OztDQUdDLEdBQ00sU0FBUytHLFNBQVNDLEVBQUU7SUFDdkIsTUFBTUMsTUFBTSxJQUFJQztJQUNoQixPQUFPLENBQUNDLEtBQUssR0FBR0M7UUFDWixNQUFNekMsTUFBTXNDLElBQUlJLEdBQUcsQ0FBQ0Y7UUFDcEIsSUFBSXhDLFFBQVFuRSxXQUNSLE9BQU9tRTtRQUNYLE1BQU0yQyxXQUFXTixHQUFHRyxRQUFRQztRQUM1QkgsSUFBSU0sR0FBRyxDQUFDSixLQUFLRztRQUNiLE9BQU9BO0lBQ1g7QUFDSixFQUNBLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL25vdGFzY2FtLXByb3RvY29sLy4vbm9kZV9tb2R1bGVzLy5wbnBtL0Bub2JsZStjdXJ2ZXNAMS45Ljcvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL3V0aWxzLmpzPzA4ZjciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBIZXgsIGJ5dGVzIGFuZCBudW1iZXIgdXRpbGl0aWVzLlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBhYnl0ZXMgYXMgYWJ5dGVzXywgYnl0ZXNUb0hleCBhcyBieXRlc1RvSGV4XywgY29uY2F0Qnl0ZXMgYXMgY29uY2F0Qnl0ZXNfLCBoZXhUb0J5dGVzIGFzIGhleFRvQnl0ZXNfLCBpc0J5dGVzIGFzIGlzQnl0ZXNfLCB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMuanMnO1xuZXhwb3J0IHsgYWJ5dGVzLCBhbnVtYmVyLCBieXRlc1RvSGV4LCBieXRlc1RvVXRmOCwgY29uY2F0Qnl0ZXMsIGhleFRvQnl0ZXMsIGlzQnl0ZXMsIHJhbmRvbUJ5dGVzLCB1dGY4VG9CeXRlcywgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzLmpzJztcbmNvbnN0IF8wbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDEpO1xuZXhwb3J0IGZ1bmN0aW9uIGFib29sKHRpdGxlLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRpdGxlICsgJyBib29sZWFuIGV4cGVjdGVkLCBnb3QgJyArIHZhbHVlKTtcbn1cbi8vIHRtcCBuYW1lIHVudGlsIHYyXG5leHBvcnQgZnVuY3Rpb24gX2Fib29sMih2YWx1ZSwgdGl0bGUgPSAnJykge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJykge1xuICAgICAgICBjb25zdCBwcmVmaXggPSB0aXRsZSAmJiBgXCIke3RpdGxlfVwiYDtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHByZWZpeCArICdleHBlY3RlZCBib29sZWFuLCBnb3QgdHlwZT0nICsgdHlwZW9mIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLy8gdG1wIG5hbWUgdW50aWwgdjJcbi8qKiBBc3NlcnRzIHNvbWV0aGluZyBpcyBVaW50OEFycmF5LiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9hYnl0ZXMyKHZhbHVlLCBsZW5ndGgsIHRpdGxlID0gJycpIHtcbiAgICBjb25zdCBieXRlcyA9IGlzQnl0ZXNfKHZhbHVlKTtcbiAgICBjb25zdCBsZW4gPSB2YWx1ZT8ubGVuZ3RoO1xuICAgIGNvbnN0IG5lZWRzTGVuID0gbGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgaWYgKCFieXRlcyB8fCAobmVlZHNMZW4gJiYgbGVuICE9PSBsZW5ndGgpKSB7XG4gICAgICAgIGNvbnN0IHByZWZpeCA9IHRpdGxlICYmIGBcIiR7dGl0bGV9XCIgYDtcbiAgICAgICAgY29uc3Qgb2ZMZW4gPSBuZWVkc0xlbiA/IGAgb2YgbGVuZ3RoICR7bGVuZ3RofWAgOiAnJztcbiAgICAgICAgY29uc3QgZ290ID0gYnl0ZXMgPyBgbGVuZ3RoPSR7bGVufWAgOiBgdHlwZT0ke3R5cGVvZiB2YWx1ZX1gO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocHJlZml4ICsgJ2V4cGVjdGVkIFVpbnQ4QXJyYXknICsgb2ZMZW4gKyAnLCBnb3QgJyArIGdvdCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8vIFVzZWQgaW4gd2VpZXJzdHJhc3MsIGRlclxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvSGV4VW5wYWRkZWQobnVtKSB7XG4gICAgY29uc3QgaGV4ID0gbnVtLnRvU3RyaW5nKDE2KTtcbiAgICByZXR1cm4gaGV4Lmxlbmd0aCAmIDEgPyAnMCcgKyBoZXggOiBoZXg7XG59XG5leHBvcnQgZnVuY3Rpb24gaGV4VG9OdW1iZXIoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgcmV0dXJuIGhleCA9PT0gJycgPyBfMG4gOiBCaWdJbnQoJzB4JyArIGhleCk7IC8vIEJpZyBFbmRpYW5cbn1cbi8vIEJFOiBCaWcgRW5kaWFuLCBMRTogTGl0dGxlIEVuZGlhblxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJCRShieXRlcykge1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4XyhieXRlcykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJMRShieXRlcykge1xuICAgIGFieXRlc18oYnl0ZXMpO1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4XyhVaW50OEFycmF5LmZyb20oYnl0ZXMpLnJldmVyc2UoKSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlc18obi50b1N0cmluZygxNikucGFkU3RhcnQobGVuICogMiwgJzAnKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlc0xFKG4sIGxlbikge1xuICAgIHJldHVybiBudW1iZXJUb0J5dGVzQkUobiwgbGVuKS5yZXZlcnNlKCk7XG59XG4vLyBVbnBhZGRlZCwgcmFyZWx5IHVzZWRcbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb1ZhckJ5dGVzQkUobikge1xuICAgIHJldHVybiBoZXhUb0J5dGVzXyhudW1iZXJUb0hleFVucGFkZGVkKG4pKTtcbn1cbi8qKlxuICogVGFrZXMgaGV4IHN0cmluZyBvciBVaW50OEFycmF5LCBjb252ZXJ0cyB0byBVaW50OEFycmF5LlxuICogVmFsaWRhdGVzIG91dHB1dCBsZW5ndGguXG4gKiBXaWxsIHRocm93IGVycm9yIGZvciBvdGhlciB0eXBlcy5cbiAqIEBwYXJhbSB0aXRsZSBkZXNjcmlwdGl2ZSB0aXRsZSBmb3IgYW4gZXJyb3IgZS5nLiAnc2VjcmV0IGtleSdcbiAqIEBwYXJhbSBoZXggaGV4IHN0cmluZyBvciBVaW50OEFycmF5XG4gKiBAcGFyYW0gZXhwZWN0ZWRMZW5ndGggb3B0aW9uYWwsIHdpbGwgY29tcGFyZSB0byByZXN1bHQgYXJyYXkncyBsZW5ndGhcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVCeXRlcyh0aXRsZSwgaGV4LCBleHBlY3RlZExlbmd0aCkge1xuICAgIGxldCByZXM7XG4gICAgaWYgKHR5cGVvZiBoZXggPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMgPSBoZXhUb0J5dGVzXyhoZXgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IodGl0bGUgKyAnIG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5LCBjYXVzZTogJyArIGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQnl0ZXNfKGhleCkpIHtcbiAgICAgICAgLy8gVWludDhBcnJheS5mcm9tKCkgaW5zdGVhZCBvZiBoYXNoLnNsaWNlKCkgYmVjYXVzZSBub2RlLmpzIEJ1ZmZlclxuICAgICAgICAvLyBpcyBpbnN0YW5jZSBvZiBVaW50OEFycmF5LCBhbmQgaXRzIHNsaWNlKCkgY3JlYXRlcyAqKm11dGFibGUqKiBjb3B5XG4gICAgICAgIHJlcyA9IFVpbnQ4QXJyYXkuZnJvbShoZXgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHRpdGxlICsgJyBtdXN0IGJlIGhleCBzdHJpbmcgb3IgVWludDhBcnJheScpO1xuICAgIH1cbiAgICBjb25zdCBsZW4gPSByZXMubGVuZ3RoO1xuICAgIGlmICh0eXBlb2YgZXhwZWN0ZWRMZW5ndGggPT09ICdudW1iZXInICYmIGxlbiAhPT0gZXhwZWN0ZWRMZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcih0aXRsZSArICcgb2YgbGVuZ3RoICcgKyBleHBlY3RlZExlbmd0aCArICcgZXhwZWN0ZWQsIGdvdCAnICsgbGVuKTtcbiAgICByZXR1cm4gcmVzO1xufVxuLy8gQ29tcGFyZXMgMiB1OGEtcyBpbiBraW5kYSBjb25zdGFudCB0aW1lXG5leHBvcnQgZnVuY3Rpb24gZXF1YWxCeXRlcyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBkaWZmID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgIGRpZmYgfD0gYVtpXSBeIGJbaV07XG4gICAgcmV0dXJuIGRpZmYgPT09IDA7XG59XG4vKipcbiAqIENvcGllcyBVaW50OEFycmF5LiBXZSBjYW4ndCB1c2UgdThhLnNsaWNlKCksIGJlY2F1c2UgdThhIGNhbiBiZSBCdWZmZXIsXG4gKiBhbmQgQnVmZmVyI3NsaWNlIGNyZWF0ZXMgbXV0YWJsZSBjb3B5LiBOZXZlciB1c2UgQnVmZmVycyFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvcHlCeXRlcyhieXRlcykge1xuICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oYnl0ZXMpO1xufVxuLyoqXG4gKiBEZWNvZGVzIDctYml0IEFTQ0lJIHN0cmluZyB0byBVaW50OEFycmF5LCB0aHJvd3Mgb24gbm9uLWFzY2lpIHN5bWJvbHNcbiAqIFNob3VsZCBiZSBzYWZlIHRvIHVzZSBmb3IgdGhpbmdzIGV4cGVjdGVkIHRvIGJlIEFTQ0lJLlxuICogUmV0dXJucyBleGFjdCBzYW1lIHJlc3VsdCBhcyB1dGY4VG9CeXRlcyBmb3IgQVNDSUkgb3IgdGhyb3dzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNjaWlUb0J5dGVzKGFzY2lpKSB7XG4gICAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShhc2NpaSwgKGMsIGkpID0+IHtcbiAgICAgICAgY29uc3QgY2hhckNvZGUgPSBjLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIGlmIChjLmxlbmd0aCAhPT0gMSB8fCBjaGFyQ29kZSA+IDEyNykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzdHJpbmcgY29udGFpbnMgbm9uLUFTQ0lJIGNoYXJhY3RlciBcIiR7YXNjaWlbaV19XCIgd2l0aCBjb2RlICR7Y2hhckNvZGV9IGF0IHBvc2l0aW9uICR7aX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhckNvZGU7XG4gICAgfSk7XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbi8vIGV4cG9ydCBjb25zdCB1dGY4VG9CeXRlczogdHlwZW9mIHV0ZjhUb0J5dGVzXyA9IHV0ZjhUb0J5dGVzXztcbi8qKlxuICogQ29udmVydHMgYnl0ZXMgdG8gc3RyaW5nIHVzaW5nIFVURjggZW5jb2RpbmcuXG4gKiBAZXhhbXBsZSBieXRlc1RvVXRmOChVaW50OEFycmF5LmZyb20oWzk3LCA5OCwgOTldKSkgLy8gJ2FiYydcbiAqL1xuLy8gZXhwb3J0IGNvbnN0IGJ5dGVzVG9VdGY4OiB0eXBlb2YgYnl0ZXNUb1V0ZjhfID0gYnl0ZXNUb1V0ZjhfO1xuLy8gSXMgcG9zaXRpdmUgYmlnaW50XG5jb25zdCBpc1Bvc0JpZyA9IChuKSA9PiB0eXBlb2YgbiA9PT0gJ2JpZ2ludCcgJiYgXzBuIDw9IG47XG5leHBvcnQgZnVuY3Rpb24gaW5SYW5nZShuLCBtaW4sIG1heCkge1xuICAgIHJldHVybiBpc1Bvc0JpZyhuKSAmJiBpc1Bvc0JpZyhtaW4pICYmIGlzUG9zQmlnKG1heCkgJiYgbWluIDw9IG4gJiYgbiA8IG1heDtcbn1cbi8qKlxuICogQXNzZXJ0cyBtaW4gPD0gbiA8IG1heC4gTk9URTogSXQncyA8IG1heCBhbmQgbm90IDw9IG1heC5cbiAqIEBleGFtcGxlXG4gKiBhSW5SYW5nZSgneCcsIHgsIDFuLCAyNTZuKTsgLy8gd291bGQgYXNzdW1lIHggaXMgaW4gKDFuLi4yNTVuKVxuICovXG5leHBvcnQgZnVuY3Rpb24gYUluUmFuZ2UodGl0bGUsIG4sIG1pbiwgbWF4KSB7XG4gICAgLy8gV2h5IG1pbiA8PSBuIDwgbWF4IGFuZCBub3QgYSAobWluIDwgbiA8IG1heCkgT1IgYiAobWluIDw9IG4gPD0gbWF4KT9cbiAgICAvLyBjb25zaWRlciBQPTI1Nm4sIG1pbj0wbiwgbWF4PVBcbiAgICAvLyAtIGEgZm9yIG1pbj0wIHdvdWxkIHJlcXVpcmUgLTE6ICAgICAgICAgIGBpblJhbmdlKCd4JywgeCwgLTFuLCBQKWBcbiAgICAvLyAtIGIgd291bGQgY29tbW9ubHkgcmVxdWlyZSBzdWJ0cmFjdGlvbjogIGBpblJhbmdlKCd4JywgeCwgMG4sIFAgLSAxbilgXG4gICAgLy8gLSBvdXIgd2F5IGlzIHRoZSBjbGVhbmVzdDogICAgICAgICAgICAgICBgaW5SYW5nZSgneCcsIHgsIDBuLCBQKVxuICAgIGlmICghaW5SYW5nZShuLCBtaW4sIG1heCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwZWN0ZWQgdmFsaWQgJyArIHRpdGxlICsgJzogJyArIG1pbiArICcgPD0gbiA8ICcgKyBtYXggKyAnLCBnb3QgJyArIG4pO1xufVxuLy8gQml0IG9wZXJhdGlvbnNcbi8qKlxuICogQ2FsY3VsYXRlcyBhbW91bnQgb2YgYml0cyBpbiBhIGJpZ2ludC5cbiAqIFNhbWUgYXMgYG4udG9TdHJpbmcoMikubGVuZ3RoYFxuICogVE9ETzogbWVyZ2Ugd2l0aCBuTGVuZ3RoIGluIG1vZHVsYXJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdExlbihuKSB7XG4gICAgbGV0IGxlbjtcbiAgICBmb3IgKGxlbiA9IDA7IG4gPiBfMG47IG4gPj49IF8xbiwgbGVuICs9IDEpXG4gICAgICAgIDtcbiAgICByZXR1cm4gbGVuO1xufVxuLyoqXG4gKiBHZXRzIHNpbmdsZSBiaXQgYXQgcG9zaXRpb24uXG4gKiBOT1RFOiBmaXJzdCBiaXQgcG9zaXRpb24gaXMgMCAoc2FtZSBhcyBhcnJheXMpXG4gKiBTYW1lIGFzIGAhIStBcnJheS5mcm9tKG4udG9TdHJpbmcoMikpLnJldmVyc2UoKVtwb3NdYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0R2V0KG4sIHBvcykge1xuICAgIHJldHVybiAobiA+PiBCaWdJbnQocG9zKSkgJiBfMW47XG59XG4vKipcbiAqIFNldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJpdFNldChuLCBwb3MsIHZhbHVlKSB7XG4gICAgcmV0dXJuIG4gfCAoKHZhbHVlID8gXzFuIDogXzBuKSA8PCBCaWdJbnQocG9zKSk7XG59XG4vKipcbiAqIENhbGN1bGF0ZSBtYXNrIGZvciBOIGJpdHMuIE5vdCB1c2luZyAqKiBvcGVyYXRvciB3aXRoIGJpZ2ludHMgYmVjYXVzZSBvZiBvbGQgZW5naW5lcy5cbiAqIFNhbWUgYXMgQmlnSW50KGAwYiR7QXJyYXkoaSkuZmlsbCgnMScpLmpvaW4oJycpfWApXG4gKi9cbmV4cG9ydCBjb25zdCBiaXRNYXNrID0gKG4pID0+IChfMW4gPDwgQmlnSW50KG4pKSAtIF8xbjtcbi8qKlxuICogTWluaW1hbCBITUFDLURSQkcgZnJvbSBOSVNUIDgwMC05MCBmb3IgUkZDNjk3OSBzaWdzLlxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB3aWxsIGNhbGwgRFJCRyB1bnRpbCAybmQgYXJnIHJldHVybnMgc29tZXRoaW5nIG1lYW5pbmdmdWxcbiAqIEBleGFtcGxlXG4gKiAgIGNvbnN0IGRyYmcgPSBjcmVhdGVIbWFjRFJCRzxLZXk+KDMyLCAzMiwgaG1hYyk7XG4gKiAgIGRyYmcoc2VlZCwgYnl0ZXNUb0tleSk7IC8vIGJ5dGVzVG9LZXkgbXVzdCByZXR1cm4gS2V5IG9yIHVuZGVmaW5lZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSG1hY0RyYmcoaGFzaExlbiwgcUJ5dGVMZW4sIGhtYWNGbikge1xuICAgIGlmICh0eXBlb2YgaGFzaExlbiAhPT0gJ251bWJlcicgfHwgaGFzaExlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGFzaExlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgaWYgKHR5cGVvZiBxQnl0ZUxlbiAhPT0gJ251bWJlcicgfHwgcUJ5dGVMZW4gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3FCeXRlTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIGhtYWNGbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdobWFjRm4gbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgLy8gU3RlcCBCLCBTdGVwIEM6IHNldCBoYXNoTGVuIHRvIDgqY2VpbChobGVuLzgpXG4gICAgY29uc3QgdThuID0gKGxlbikgPT4gbmV3IFVpbnQ4QXJyYXkobGVuKTsgLy8gY3JlYXRlcyBVaW50OEFycmF5XG4gICAgY29uc3QgdThvZiA9IChieXRlKSA9PiBVaW50OEFycmF5Lm9mKGJ5dGUpOyAvLyBhbm90aGVyIHNob3J0Y3V0XG4gICAgbGV0IHYgPSB1OG4oaGFzaExlbik7IC8vIE1pbmltYWwgbm9uLWZ1bGwtc3BlYyBITUFDLURSQkcgZnJvbSBOSVNUIDgwMC05MCBmb3IgUkZDNjk3OSBzaWdzLlxuICAgIGxldCBrID0gdThuKGhhc2hMZW4pOyAvLyBTdGVwcyBCIGFuZCBDIG9mIFJGQzY5NzkgMy4yOiBzZXQgaGFzaExlbiwgaW4gb3VyIGNhc2UgYWx3YXlzIHNhbWVcbiAgICBsZXQgaSA9IDA7IC8vIEl0ZXJhdGlvbnMgY291bnRlciwgd2lsbCB0aHJvdyB3aGVuIG92ZXIgMTAwMFxuICAgIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuICAgICAgICB2LmZpbGwoMSk7XG4gICAgICAgIGsuZmlsbCgwKTtcbiAgICAgICAgaSA9IDA7XG4gICAgfTtcbiAgICBjb25zdCBoID0gKC4uLmIpID0+IGhtYWNGbihrLCB2LCAuLi5iKTsgLy8gaG1hYyhrKSh2LCAuLi52YWx1ZXMpXG4gICAgY29uc3QgcmVzZWVkID0gKHNlZWQgPSB1OG4oMCkpID0+IHtcbiAgICAgICAgLy8gSE1BQy1EUkJHIHJlc2VlZCgpIGZ1bmN0aW9uLiBTdGVwcyBELUdcbiAgICAgICAgayA9IGgodThvZigweDAwKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAwIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICAgICAgaWYgKHNlZWQubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBrID0gaCh1OG9mKDB4MDEpLCBzZWVkKTsgLy8gayA9IGhtYWMoayB8fCB2IHx8IDB4MDEgfHwgc2VlZClcbiAgICAgICAgdiA9IGgoKTsgLy8gdiA9IGhtYWMoayB8fCB2KVxuICAgIH07XG4gICAgY29uc3QgZ2VuID0gKCkgPT4ge1xuICAgICAgICAvLyBITUFDLURSQkcgZ2VuZXJhdGUoKSBmdW5jdGlvblxuICAgICAgICBpZiAoaSsrID49IDEwMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RyYmc6IHRyaWVkIDEwMDAgdmFsdWVzJyk7XG4gICAgICAgIGxldCBsZW4gPSAwO1xuICAgICAgICBjb25zdCBvdXQgPSBbXTtcbiAgICAgICAgd2hpbGUgKGxlbiA8IHFCeXRlTGVuKSB7XG4gICAgICAgICAgICB2ID0gaCgpO1xuICAgICAgICAgICAgY29uc3Qgc2wgPSB2LnNsaWNlKCk7XG4gICAgICAgICAgICBvdXQucHVzaChzbCk7XG4gICAgICAgICAgICBsZW4gKz0gdi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmNhdEJ5dGVzXyguLi5vdXQpO1xuICAgIH07XG4gICAgY29uc3QgZ2VuVW50aWwgPSAoc2VlZCwgcHJlZCkgPT4ge1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXNlZWQoc2VlZCk7IC8vIFN0ZXBzIEQtR1xuICAgICAgICBsZXQgcmVzID0gdW5kZWZpbmVkOyAvLyBTdGVwIEg6IGdyaW5kIHVudGlsIGsgaXMgaW4gWzEuLm4tMV1cbiAgICAgICAgd2hpbGUgKCEocmVzID0gcHJlZChnZW4oKSkpKVxuICAgICAgICAgICAgcmVzZWVkKCk7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICByZXR1cm4gZ2VuVW50aWw7XG59XG4vLyBWYWxpZGF0aW5nIGN1cnZlcyBhbmQgZmllbGRzXG5jb25zdCB2YWxpZGF0b3JGbnMgPSB7XG4gICAgYmlnaW50OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYmlnaW50JyxcbiAgICBmdW5jdGlvbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyxcbiAgICBib29sZWFuOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYm9vbGVhbicsXG4gICAgc3RyaW5nOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyxcbiAgICBzdHJpbmdPclVpbnQ4QXJyYXk6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IGlzQnl0ZXNfKHZhbCksXG4gICAgaXNTYWZlSW50ZWdlcjogKHZhbCkgPT4gTnVtYmVyLmlzU2FmZUludGVnZXIodmFsKSxcbiAgICBhcnJheTogKHZhbCkgPT4gQXJyYXkuaXNBcnJheSh2YWwpLFxuICAgIGZpZWxkOiAodmFsLCBvYmplY3QpID0+IG9iamVjdC5GcC5pc1ZhbGlkKHZhbCksXG4gICAgaGFzaDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyAmJiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwub3V0cHV0TGVuKSxcbn07XG4vLyB0eXBlIFJlY29yZDxLIGV4dGVuZHMgc3RyaW5nIHwgbnVtYmVyIHwgc3ltYm9sLCBUPiA9IHsgW1AgaW4gS106IFQ7IH1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZU9iamVjdChvYmplY3QsIHZhbGlkYXRvcnMsIG9wdFZhbGlkYXRvcnMgPSB7fSkge1xuICAgIGNvbnN0IGNoZWNrRmllbGQgPSAoZmllbGROYW1lLCB0eXBlLCBpc09wdGlvbmFsKSA9PiB7XG4gICAgICAgIGNvbnN0IGNoZWNrVmFsID0gdmFsaWRhdG9yRm5zW3R5cGVdO1xuICAgICAgICBpZiAodHlwZW9mIGNoZWNrVmFsICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHZhbGlkYXRvciBmdW5jdGlvbicpO1xuICAgICAgICBjb25zdCB2YWwgPSBvYmplY3RbZmllbGROYW1lXTtcbiAgICAgICAgaWYgKGlzT3B0aW9uYWwgJiYgdmFsID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghY2hlY2tWYWwodmFsLCBvYmplY3QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhcmFtICcgKyBTdHJpbmcoZmllbGROYW1lKSArICcgaXMgaW52YWxpZC4gRXhwZWN0ZWQgJyArIHR5cGUgKyAnLCBnb3QgJyArIHZhbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXModmFsaWRhdG9ycykpXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCBmYWxzZSk7XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyhvcHRWYWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIHRydWUpO1xuICAgIHJldHVybiBvYmplY3Q7XG59XG4vLyB2YWxpZGF0ZSB0eXBlIHRlc3RzXG4vLyBjb25zdCBvOiB7IGE6IG51bWJlcjsgYjogbnVtYmVyOyBjOiBudW1iZXIgfSA9IHsgYTogMSwgYjogNSwgYzogNiB9O1xuLy8gY29uc3QgejAgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICdiaWdpbnQnIH0pOyAvLyBPayFcbi8vIC8vIFNob3VsZCBmYWlsIHR5cGUtY2hlY2tcbi8vIGNvbnN0IHoxID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAndG1wJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MiA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHozID0gdmFsaWRhdGVPYmplY3QobywgeyB0ZXN0OiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuLy8gY29uc3QgejQgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG5leHBvcnQgZnVuY3Rpb24gaXNIYXNoKHZhbCkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nICYmIE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbC5vdXRwdXRMZW4pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIF92YWxpZGF0ZU9iamVjdChvYmplY3QsIGZpZWxkcywgb3B0RmllbGRzID0ge30pIHtcbiAgICBpZiAoIW9iamVjdCB8fCB0eXBlb2Ygb2JqZWN0ICE9PSAnb2JqZWN0JylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCB2YWxpZCBvcHRpb25zIG9iamVjdCcpO1xuICAgIGZ1bmN0aW9uIGNoZWNrRmllbGQoZmllbGROYW1lLCBleHBlY3RlZFR5cGUsIGlzT3B0KSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IG9iamVjdFtmaWVsZE5hbWVdO1xuICAgICAgICBpZiAoaXNPcHQgJiYgdmFsID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0eXBlb2YgdmFsO1xuICAgICAgICBpZiAoY3VycmVudCAhPT0gZXhwZWN0ZWRUeXBlIHx8IHZhbCA9PT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcGFyYW0gXCIke2ZpZWxkTmFtZX1cIiBpcyBpbnZhbGlkOiBleHBlY3RlZCAke2V4cGVjdGVkVHlwZX0sIGdvdCAke2N1cnJlbnR9YCk7XG4gICAgfVxuICAgIE9iamVjdC5lbnRyaWVzKGZpZWxkcykuZm9yRWFjaCgoW2ssIHZdKSA9PiBjaGVja0ZpZWxkKGssIHYsIGZhbHNlKSk7XG4gICAgT2JqZWN0LmVudHJpZXMob3B0RmllbGRzKS5mb3JFYWNoKChbaywgdl0pID0+IGNoZWNrRmllbGQoaywgdiwgdHJ1ZSkpO1xufVxuLyoqXG4gKiB0aHJvd3Mgbm90IGltcGxlbWVudGVkIGVycm9yXG4gKi9cbmV4cG9ydCBjb25zdCBub3RJbXBsZW1lbnRlZCA9ICgpID0+IHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xufTtcbi8qKlxuICogTWVtb2l6ZXMgKGNhY2hlcykgY29tcHV0YXRpb24gcmVzdWx0LlxuICogVXNlcyBXZWFrTWFwOiB0aGUgdmFsdWUgaXMgZ29pbmcgYXV0by1jbGVhbmVkIGJ5IEdDIGFmdGVyIGxhc3QgcmVmZXJlbmNlIGlzIHJlbW92ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZW1vaXplZChmbikge1xuICAgIGNvbnN0IG1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgcmV0dXJuIChhcmcsIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgdmFsID0gbWFwLmdldChhcmcpO1xuICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICBjb25zdCBjb21wdXRlZCA9IGZuKGFyZywgLi4uYXJncyk7XG4gICAgICAgIG1hcC5zZXQoYXJnLCBjb21wdXRlZCk7XG4gICAgICAgIHJldHVybiBjb21wdXRlZDtcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbImFieXRlcyIsImFieXRlc18iLCJieXRlc1RvSGV4IiwiYnl0ZXNUb0hleF8iLCJjb25jYXRCeXRlcyIsImNvbmNhdEJ5dGVzXyIsImhleFRvQnl0ZXMiLCJoZXhUb0J5dGVzXyIsImlzQnl0ZXMiLCJpc0J5dGVzXyIsImFudW1iZXIiLCJieXRlc1RvVXRmOCIsInJhbmRvbUJ5dGVzIiwidXRmOFRvQnl0ZXMiLCJfMG4iLCJCaWdJbnQiLCJfMW4iLCJhYm9vbCIsInRpdGxlIiwidmFsdWUiLCJFcnJvciIsIl9hYm9vbDIiLCJwcmVmaXgiLCJfYWJ5dGVzMiIsImxlbmd0aCIsImJ5dGVzIiwibGVuIiwibmVlZHNMZW4iLCJ1bmRlZmluZWQiLCJvZkxlbiIsImdvdCIsIm51bWJlclRvSGV4VW5wYWRkZWQiLCJudW0iLCJoZXgiLCJ0b1N0cmluZyIsImhleFRvTnVtYmVyIiwiYnl0ZXNUb051bWJlckJFIiwiYnl0ZXNUb051bWJlckxFIiwiVWludDhBcnJheSIsImZyb20iLCJyZXZlcnNlIiwibnVtYmVyVG9CeXRlc0JFIiwibiIsInBhZFN0YXJ0IiwibnVtYmVyVG9CeXRlc0xFIiwibnVtYmVyVG9WYXJCeXRlc0JFIiwiZW5zdXJlQnl0ZXMiLCJleHBlY3RlZExlbmd0aCIsInJlcyIsImUiLCJlcXVhbEJ5dGVzIiwiYSIsImIiLCJkaWZmIiwiaSIsImNvcHlCeXRlcyIsImFzY2lpVG9CeXRlcyIsImFzY2lpIiwiYyIsImNoYXJDb2RlIiwiY2hhckNvZGVBdCIsImlzUG9zQmlnIiwiaW5SYW5nZSIsIm1pbiIsIm1heCIsImFJblJhbmdlIiwiYml0TGVuIiwiYml0R2V0IiwicG9zIiwiYml0U2V0IiwiYml0TWFzayIsImNyZWF0ZUhtYWNEcmJnIiwiaGFzaExlbiIsInFCeXRlTGVuIiwiaG1hY0ZuIiwidThuIiwidThvZiIsImJ5dGUiLCJvZiIsInYiLCJrIiwicmVzZXQiLCJmaWxsIiwiaCIsInJlc2VlZCIsInNlZWQiLCJnZW4iLCJvdXQiLCJzbCIsInNsaWNlIiwicHVzaCIsImdlblVudGlsIiwicHJlZCIsInZhbGlkYXRvckZucyIsImJpZ2ludCIsInZhbCIsImZ1bmN0aW9uIiwiYm9vbGVhbiIsInN0cmluZyIsInN0cmluZ09yVWludDhBcnJheSIsImlzU2FmZUludGVnZXIiLCJOdW1iZXIiLCJhcnJheSIsIkFycmF5IiwiaXNBcnJheSIsImZpZWxkIiwib2JqZWN0IiwiRnAiLCJpc1ZhbGlkIiwiaGFzaCIsIm91dHB1dExlbiIsInZhbGlkYXRlT2JqZWN0IiwidmFsaWRhdG9ycyIsIm9wdFZhbGlkYXRvcnMiLCJjaGVja0ZpZWxkIiwiZmllbGROYW1lIiwidHlwZSIsImlzT3B0aW9uYWwiLCJjaGVja1ZhbCIsIlN0cmluZyIsIk9iamVjdCIsImVudHJpZXMiLCJpc0hhc2giLCJfdmFsaWRhdGVPYmplY3QiLCJmaWVsZHMiLCJvcHRGaWVsZHMiLCJleHBlY3RlZFR5cGUiLCJpc09wdCIsImN1cnJlbnQiLCJmb3JFYWNoIiwibm90SW1wbGVtZW50ZWQiLCJtZW1vaXplZCIsImZuIiwibWFwIiwiV2Vha01hcCIsImFyZyIsImFyZ3MiLCJnZXQiLCJjb21wdXRlZCIsInNldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/utils.js\n");

/***/ })

};
;