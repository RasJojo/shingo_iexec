"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/valibot@0.36.0";
exports.ids = ["vendor-chunks/valibot@0.36.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/valibot@0.36.0/node_modules/valibot/dist/index.js":
/*!******************************************************************************!*\
  !*** ./node_modules/.pnpm/valibot@0.36.0/node_modules/valibot/dist/index.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BIC_REGEX: () => (/* binding */ BIC_REGEX),\n/* harmony export */   CUID2_REGEX: () => (/* binding */ CUID2_REGEX),\n/* harmony export */   DECIMAL_REGEX: () => (/* binding */ DECIMAL_REGEX),\n/* harmony export */   EMAIL_REGEX: () => (/* binding */ EMAIL_REGEX),\n/* harmony export */   EMOJI_REGEX: () => (/* binding */ EMOJI_REGEX),\n/* harmony export */   HEXADECIMAL_REGEX: () => (/* binding */ HEXADECIMAL_REGEX),\n/* harmony export */   HEX_COLOR_REGEX: () => (/* binding */ HEX_COLOR_REGEX),\n/* harmony export */   IMEI_REGEX: () => (/* binding */ IMEI_REGEX),\n/* harmony export */   IPV4_REGEX: () => (/* binding */ IPV4_REGEX),\n/* harmony export */   IPV6_REGEX: () => (/* binding */ IPV6_REGEX),\n/* harmony export */   IP_REGEX: () => (/* binding */ IP_REGEX),\n/* harmony export */   ISO_DATE_REGEX: () => (/* binding */ ISO_DATE_REGEX),\n/* harmony export */   ISO_DATE_TIME_REGEX: () => (/* binding */ ISO_DATE_TIME_REGEX),\n/* harmony export */   ISO_TIMESTAMP_REGEX: () => (/* binding */ ISO_TIMESTAMP_REGEX),\n/* harmony export */   ISO_TIME_REGEX: () => (/* binding */ ISO_TIME_REGEX),\n/* harmony export */   ISO_TIME_SECOND_REGEX: () => (/* binding */ ISO_TIME_SECOND_REGEX),\n/* harmony export */   ISO_WEEK_REGEX: () => (/* binding */ ISO_WEEK_REGEX),\n/* harmony export */   MAC48_REGEX: () => (/* binding */ MAC48_REGEX),\n/* harmony export */   MAC64_REGEX: () => (/* binding */ MAC64_REGEX),\n/* harmony export */   MAC_REGEX: () => (/* binding */ MAC_REGEX),\n/* harmony export */   OCTAL_REGEX: () => (/* binding */ OCTAL_REGEX),\n/* harmony export */   ULID_REGEX: () => (/* binding */ ULID_REGEX),\n/* harmony export */   UUID_REGEX: () => (/* binding */ UUID_REGEX),\n/* harmony export */   ValiError: () => (/* binding */ ValiError),\n/* harmony export */   _addIssue: () => (/* binding */ _addIssue),\n/* harmony export */   _isLuhnAlgo: () => (/* binding */ _isLuhnAlgo),\n/* harmony export */   _isValidObjectKey: () => (/* binding */ _isValidObjectKey),\n/* harmony export */   _stringify: () => (/* binding */ _stringify),\n/* harmony export */   any: () => (/* binding */ any),\n/* harmony export */   array: () => (/* binding */ array),\n/* harmony export */   arrayAsync: () => (/* binding */ arrayAsync),\n/* harmony export */   awaitAsync: () => (/* binding */ awaitAsync),\n/* harmony export */   bic: () => (/* binding */ bic),\n/* harmony export */   bigint: () => (/* binding */ bigint),\n/* harmony export */   blob: () => (/* binding */ blob),\n/* harmony export */   boolean: () => (/* binding */ boolean),\n/* harmony export */   brand: () => (/* binding */ brand),\n/* harmony export */   bytes: () => (/* binding */ bytes),\n/* harmony export */   check: () => (/* binding */ check),\n/* harmony export */   checkAsync: () => (/* binding */ checkAsync),\n/* harmony export */   checkItems: () => (/* binding */ checkItems),\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   creditCard: () => (/* binding */ creditCard),\n/* harmony export */   cuid2: () => (/* binding */ cuid2),\n/* harmony export */   custom: () => (/* binding */ custom),\n/* harmony export */   customAsync: () => (/* binding */ customAsync),\n/* harmony export */   date: () => (/* binding */ date),\n/* harmony export */   decimal: () => (/* binding */ decimal),\n/* harmony export */   deleteGlobalConfig: () => (/* binding */ deleteGlobalConfig),\n/* harmony export */   deleteGlobalMessage: () => (/* binding */ deleteGlobalMessage),\n/* harmony export */   deleteSchemaMessage: () => (/* binding */ deleteSchemaMessage),\n/* harmony export */   deleteSpecificMessage: () => (/* binding */ deleteSpecificMessage),\n/* harmony export */   email: () => (/* binding */ email),\n/* harmony export */   emoji: () => (/* binding */ emoji),\n/* harmony export */   empty: () => (/* binding */ empty),\n/* harmony export */   endsWith: () => (/* binding */ endsWith),\n/* harmony export */   entriesFromList: () => (/* binding */ entriesFromList),\n/* harmony export */   \"enum\": () => (/* binding */ enum_),\n/* harmony export */   enum_: () => (/* binding */ enum_),\n/* harmony export */   everyItem: () => (/* binding */ everyItem),\n/* harmony export */   excludes: () => (/* binding */ excludes),\n/* harmony export */   fallback: () => (/* binding */ fallback),\n/* harmony export */   fallbackAsync: () => (/* binding */ fallbackAsync),\n/* harmony export */   file: () => (/* binding */ file),\n/* harmony export */   filterItems: () => (/* binding */ filterItems),\n/* harmony export */   findItem: () => (/* binding */ findItem),\n/* harmony export */   finite: () => (/* binding */ finite),\n/* harmony export */   flatten: () => (/* binding */ flatten),\n/* harmony export */   forward: () => (/* binding */ forward),\n/* harmony export */   forwardAsync: () => (/* binding */ forwardAsync),\n/* harmony export */   \"function\": () => (/* binding */ function_),\n/* harmony export */   function_: () => (/* binding */ function_),\n/* harmony export */   getDefault: () => (/* binding */ getDefault),\n/* harmony export */   getDefaults: () => (/* binding */ getDefaults),\n/* harmony export */   getDefaultsAsync: () => (/* binding */ getDefaultsAsync),\n/* harmony export */   getDotPath: () => (/* binding */ getDotPath),\n/* harmony export */   getFallback: () => (/* binding */ getFallback),\n/* harmony export */   getFallbacks: () => (/* binding */ getFallbacks),\n/* harmony export */   getFallbacksAsync: () => (/* binding */ getFallbacksAsync),\n/* harmony export */   getGlobalConfig: () => (/* binding */ getGlobalConfig),\n/* harmony export */   getGlobalMessage: () => (/* binding */ getGlobalMessage),\n/* harmony export */   getSchemaMessage: () => (/* binding */ getSchemaMessage),\n/* harmony export */   getSpecificMessage: () => (/* binding */ getSpecificMessage),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   hexColor: () => (/* binding */ hexColor),\n/* harmony export */   hexadecimal: () => (/* binding */ hexadecimal),\n/* harmony export */   imei: () => (/* binding */ imei),\n/* harmony export */   includes: () => (/* binding */ includes),\n/* harmony export */   instance: () => (/* binding */ instance),\n/* harmony export */   integer: () => (/* binding */ integer),\n/* harmony export */   intersect: () => (/* binding */ intersect),\n/* harmony export */   intersectAsync: () => (/* binding */ intersectAsync),\n/* harmony export */   ip: () => (/* binding */ ip),\n/* harmony export */   ipv4: () => (/* binding */ ipv4),\n/* harmony export */   ipv6: () => (/* binding */ ipv6),\n/* harmony export */   is: () => (/* binding */ is),\n/* harmony export */   isOfKind: () => (/* binding */ isOfKind),\n/* harmony export */   isOfType: () => (/* binding */ isOfType),\n/* harmony export */   isValiError: () => (/* binding */ isValiError),\n/* harmony export */   isoDate: () => (/* binding */ isoDate),\n/* harmony export */   isoDateTime: () => (/* binding */ isoDateTime),\n/* harmony export */   isoTime: () => (/* binding */ isoTime),\n/* harmony export */   isoTimeSecond: () => (/* binding */ isoTimeSecond),\n/* harmony export */   isoTimestamp: () => (/* binding */ isoTimestamp),\n/* harmony export */   isoWeek: () => (/* binding */ isoWeek),\n/* harmony export */   keyof: () => (/* binding */ keyof),\n/* harmony export */   lazy: () => (/* binding */ lazy),\n/* harmony export */   lazyAsync: () => (/* binding */ lazyAsync),\n/* harmony export */   length: () => (/* binding */ length),\n/* harmony export */   literal: () => (/* binding */ literal),\n/* harmony export */   looseObject: () => (/* binding */ looseObject),\n/* harmony export */   looseObjectAsync: () => (/* binding */ looseObjectAsync),\n/* harmony export */   looseTuple: () => (/* binding */ looseTuple),\n/* harmony export */   looseTupleAsync: () => (/* binding */ looseTupleAsync),\n/* harmony export */   mac: () => (/* binding */ mac),\n/* harmony export */   mac48: () => (/* binding */ mac48),\n/* harmony export */   mac64: () => (/* binding */ mac64),\n/* harmony export */   map: () => (/* binding */ map),\n/* harmony export */   mapAsync: () => (/* binding */ mapAsync),\n/* harmony export */   mapItems: () => (/* binding */ mapItems),\n/* harmony export */   maxBytes: () => (/* binding */ maxBytes),\n/* harmony export */   maxLength: () => (/* binding */ maxLength),\n/* harmony export */   maxSize: () => (/* binding */ maxSize),\n/* harmony export */   maxValue: () => (/* binding */ maxValue),\n/* harmony export */   mimeType: () => (/* binding */ mimeType),\n/* harmony export */   minBytes: () => (/* binding */ minBytes),\n/* harmony export */   minLength: () => (/* binding */ minLength),\n/* harmony export */   minSize: () => (/* binding */ minSize),\n/* harmony export */   minValue: () => (/* binding */ minValue),\n/* harmony export */   multipleOf: () => (/* binding */ multipleOf),\n/* harmony export */   nan: () => (/* binding */ nan),\n/* harmony export */   never: () => (/* binding */ never),\n/* harmony export */   nonEmpty: () => (/* binding */ nonEmpty),\n/* harmony export */   nonNullable: () => (/* binding */ nonNullable),\n/* harmony export */   nonNullableAsync: () => (/* binding */ nonNullableAsync),\n/* harmony export */   nonNullish: () => (/* binding */ nonNullish),\n/* harmony export */   nonNullishAsync: () => (/* binding */ nonNullishAsync),\n/* harmony export */   nonOptional: () => (/* binding */ nonOptional),\n/* harmony export */   nonOptionalAsync: () => (/* binding */ nonOptionalAsync),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   notBytes: () => (/* binding */ notBytes),\n/* harmony export */   notLength: () => (/* binding */ notLength),\n/* harmony export */   notSize: () => (/* binding */ notSize),\n/* harmony export */   notValue: () => (/* binding */ notValue),\n/* harmony export */   \"null\": () => (/* binding */ null_),\n/* harmony export */   null_: () => (/* binding */ null_),\n/* harmony export */   nullable: () => (/* binding */ nullable),\n/* harmony export */   nullableAsync: () => (/* binding */ nullableAsync),\n/* harmony export */   nullish: () => (/* binding */ nullish),\n/* harmony export */   nullishAsync: () => (/* binding */ nullishAsync),\n/* harmony export */   number: () => (/* binding */ number),\n/* harmony export */   object: () => (/* binding */ object),\n/* harmony export */   objectAsync: () => (/* binding */ objectAsync),\n/* harmony export */   objectWithRest: () => (/* binding */ objectWithRest),\n/* harmony export */   objectWithRestAsync: () => (/* binding */ objectWithRestAsync),\n/* harmony export */   octal: () => (/* binding */ octal),\n/* harmony export */   omit: () => (/* binding */ omit),\n/* harmony export */   optional: () => (/* binding */ optional),\n/* harmony export */   optionalAsync: () => (/* binding */ optionalAsync),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   parseAsync: () => (/* binding */ parseAsync),\n/* harmony export */   parser: () => (/* binding */ parser),\n/* harmony export */   parserAsync: () => (/* binding */ parserAsync),\n/* harmony export */   partial: () => (/* binding */ partial),\n/* harmony export */   partialAsync: () => (/* binding */ partialAsync),\n/* harmony export */   partialCheck: () => (/* binding */ partialCheck),\n/* harmony export */   partialCheckAsync: () => (/* binding */ partialCheckAsync),\n/* harmony export */   pick: () => (/* binding */ pick),\n/* harmony export */   picklist: () => (/* binding */ picklist),\n/* harmony export */   pipe: () => (/* binding */ pipe),\n/* harmony export */   pipeAsync: () => (/* binding */ pipeAsync),\n/* harmony export */   promise: () => (/* binding */ promise),\n/* harmony export */   rawCheck: () => (/* binding */ rawCheck),\n/* harmony export */   rawCheckAsync: () => (/* binding */ rawCheckAsync),\n/* harmony export */   rawTransform: () => (/* binding */ rawTransform),\n/* harmony export */   rawTransformAsync: () => (/* binding */ rawTransformAsync),\n/* harmony export */   readonly: () => (/* binding */ readonly),\n/* harmony export */   record: () => (/* binding */ record),\n/* harmony export */   recordAsync: () => (/* binding */ recordAsync),\n/* harmony export */   reduceItems: () => (/* binding */ reduceItems),\n/* harmony export */   regex: () => (/* binding */ regex),\n/* harmony export */   required: () => (/* binding */ required),\n/* harmony export */   requiredAsync: () => (/* binding */ requiredAsync),\n/* harmony export */   safeInteger: () => (/* binding */ safeInteger),\n/* harmony export */   safeParse: () => (/* binding */ safeParse),\n/* harmony export */   safeParseAsync: () => (/* binding */ safeParseAsync),\n/* harmony export */   safeParser: () => (/* binding */ safeParser),\n/* harmony export */   safeParserAsync: () => (/* binding */ safeParserAsync),\n/* harmony export */   set: () => (/* binding */ set),\n/* harmony export */   setAsync: () => (/* binding */ setAsync),\n/* harmony export */   setGlobalConfig: () => (/* binding */ setGlobalConfig),\n/* harmony export */   setGlobalMessage: () => (/* binding */ setGlobalMessage),\n/* harmony export */   setSchemaMessage: () => (/* binding */ setSchemaMessage),\n/* harmony export */   setSpecificMessage: () => (/* binding */ setSpecificMessage),\n/* harmony export */   size: () => (/* binding */ size),\n/* harmony export */   someItem: () => (/* binding */ someItem),\n/* harmony export */   sortItems: () => (/* binding */ sortItems),\n/* harmony export */   startsWith: () => (/* binding */ startsWith),\n/* harmony export */   strictObject: () => (/* binding */ strictObject),\n/* harmony export */   strictObjectAsync: () => (/* binding */ strictObjectAsync),\n/* harmony export */   strictTuple: () => (/* binding */ strictTuple),\n/* harmony export */   strictTupleAsync: () => (/* binding */ strictTupleAsync),\n/* harmony export */   string: () => (/* binding */ string),\n/* harmony export */   symbol: () => (/* binding */ symbol),\n/* harmony export */   toLowerCase: () => (/* binding */ toLowerCase),\n/* harmony export */   toMaxValue: () => (/* binding */ toMaxValue),\n/* harmony export */   toMinValue: () => (/* binding */ toMinValue),\n/* harmony export */   toUpperCase: () => (/* binding */ toUpperCase),\n/* harmony export */   transform: () => (/* binding */ transform),\n/* harmony export */   transformAsync: () => (/* binding */ transformAsync),\n/* harmony export */   trim: () => (/* binding */ trim),\n/* harmony export */   trimEnd: () => (/* binding */ trimEnd),\n/* harmony export */   trimStart: () => (/* binding */ trimStart),\n/* harmony export */   tuple: () => (/* binding */ tuple),\n/* harmony export */   tupleAsync: () => (/* binding */ tupleAsync),\n/* harmony export */   tupleWithRest: () => (/* binding */ tupleWithRest),\n/* harmony export */   tupleWithRestAsync: () => (/* binding */ tupleWithRestAsync),\n/* harmony export */   ulid: () => (/* binding */ ulid),\n/* harmony export */   undefined: () => (/* binding */ undefined_),\n/* harmony export */   undefined_: () => (/* binding */ undefined_),\n/* harmony export */   union: () => (/* binding */ union),\n/* harmony export */   unionAsync: () => (/* binding */ unionAsync),\n/* harmony export */   unknown: () => (/* binding */ unknown),\n/* harmony export */   unwrap: () => (/* binding */ unwrap),\n/* harmony export */   url: () => (/* binding */ url),\n/* harmony export */   uuid: () => (/* binding */ uuid),\n/* harmony export */   value: () => (/* binding */ value),\n/* harmony export */   variant: () => (/* binding */ variant),\n/* harmony export */   variantAsync: () => (/* binding */ variantAsync),\n/* harmony export */   \"void\": () => (/* binding */ void_),\n/* harmony export */   void_: () => (/* binding */ void_)\n/* harmony export */ });\n// src/actions/await/awaitAsync.ts\nfunction awaitAsync() {\n    return {\n        kind: \"transformation\",\n        type: \"await\",\n        reference: awaitAsync,\n        async: true,\n        async _run (dataset) {\n            dataset.value = await dataset.value;\n            return dataset;\n        }\n    };\n}\n// src/regex.ts\nvar BIC_REGEX = /^[A-Z]{6}(?!00)[A-Z\\d]{2}(?:[A-Z\\d]{3})?$/u;\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\nvar DECIMAL_REGEX = /^\\d+$/u;\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\nvar EMOJI_REGEX = /^[\\p{Extended_Pictographic}\\p{Emoji_Component}]+$/u;\nvar HEXADECIMAL_REGEX = /^(?:0h|0x)?[\\da-f]+$/iu;\nvar HEX_COLOR_REGEX = /^#(?:[\\da-f]{3,4}|[\\da-f]{6}|[\\da-f]{8})$/iu;\nvar IMEI_REGEX = /^\\d{15}$|^\\d{2}-\\d{6}-\\d{6}-\\d$/u;\nvar IPV4_REGEX = // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\n/^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u;\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar IP_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$|^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?(?:Z|[+-](?:0\\d|1\\d|2[0-3])(?::?[0-5]\\d)?)$/u;\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\nvar MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\nvar MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar MAC_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$|^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar OCTAL_REGEX = /^(?:0o)?[0-7]+$/iu;\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-z]{26}$/iu;\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n// src/storages/globalConfig/globalConfig.ts\nvar store;\nfunction setGlobalConfig(config2) {\n    store = {\n        ...store,\n        ...config2\n    };\n}\nfunction getGlobalConfig(config2) {\n    return {\n        lang: config2?.lang ?? store?.lang,\n        message: config2?.message,\n        abortEarly: config2?.abortEarly ?? store?.abortEarly,\n        abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly\n    };\n}\nfunction deleteGlobalConfig() {\n    store = void 0;\n}\n// src/storages/globalMessage/globalMessage.ts\nvar store2;\nfunction setGlobalMessage(message, lang) {\n    if (!store2) store2 = /* @__PURE__ */ new Map();\n    store2.set(lang, message);\n}\nfunction getGlobalMessage(lang) {\n    return store2?.get(lang);\n}\nfunction deleteGlobalMessage(lang) {\n    store2?.delete(lang);\n}\n// src/storages/schemaMessage/schemaMessage.ts\nvar store3;\nfunction setSchemaMessage(message, lang) {\n    if (!store3) store3 = /* @__PURE__ */ new Map();\n    store3.set(lang, message);\n}\nfunction getSchemaMessage(lang) {\n    return store3?.get(lang);\n}\nfunction deleteSchemaMessage(lang) {\n    store3?.delete(lang);\n}\n// src/storages/specificMessage/specificMessage.ts\nvar store4;\nfunction setSpecificMessage(reference, message, lang) {\n    if (!store4) store4 = /* @__PURE__ */ new Map();\n    if (!store4.get(reference)) store4.set(reference, /* @__PURE__ */ new Map());\n    store4.get(reference).set(lang, message);\n}\nfunction getSpecificMessage(reference, lang) {\n    return store4?.get(reference)?.get(lang);\n}\nfunction deleteSpecificMessage(reference, lang) {\n    store4?.get(reference)?.delete(lang);\n}\n// src/utils/_stringify/_stringify.ts\nfunction _stringify(input) {\n    const type = typeof input;\n    if (type === \"string\") {\n        return `\"${input}\"`;\n    }\n    if (type === \"number\" || type === \"bigint\" || type === \"boolean\") {\n        return `${input}`;\n    }\n    if (type === \"object\" || type === \"function\") {\n        return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? \"null\";\n    }\n    return type;\n}\n// src/utils/_addIssue/_addIssue.ts\nfunction _addIssue(context, label, dataset, config2, other) {\n    const input = other && \"input\" in other ? other.input : dataset.value;\n    const expected = other?.expected ?? context.expects ?? null;\n    const received = other?.received ?? _stringify(input);\n    const issue = {\n        kind: context.kind,\n        type: context.type,\n        input,\n        expected,\n        received,\n        message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : \"R\"}eceived ${received}`,\n        // @ts-expect-error\n        requirement: context.requirement,\n        path: other?.path,\n        issues: other?.issues,\n        lang: config2.lang,\n        abortEarly: config2.abortEarly,\n        abortPipeEarly: config2.abortPipeEarly\n    };\n    const isSchema = context.kind === \"schema\";\n    const message = other?.message ?? // @ts-expect-error\n    context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);\n    if (message) {\n        issue.message = typeof message === \"function\" ? message(issue) : message;\n    }\n    if (isSchema) {\n        dataset.typed = false;\n    }\n    if (dataset.issues) {\n        dataset.issues.push(issue);\n    } else {\n        dataset.issues = [\n            issue\n        ];\n    }\n}\n// src/utils/_isLuhnAlgo/_isLuhnAlgo.ts\nvar NON_DIGIT_REGEX = /\\D/gu;\nfunction _isLuhnAlgo(input) {\n    const number2 = input.replace(NON_DIGIT_REGEX, \"\");\n    let length2 = number2.length;\n    let bit = 1;\n    let sum = 0;\n    while(length2){\n        const value2 = +number2[--length2];\n        bit ^= 1;\n        sum += bit ? [\n            0,\n            2,\n            4,\n            6,\n            8,\n            1,\n            3,\n            5,\n            7,\n            9\n        ][value2] : value2;\n    }\n    return sum % 10 === 0;\n}\n// src/utils/_isValidObjectKey/_isValidObjectKey.ts\nfunction _isValidObjectKey(object2, key) {\n    return Object.hasOwn(object2, key) && key !== \"__proto__\" && key !== \"prototype\" && key !== \"constructor\";\n}\n// src/utils/entriesFromList/entriesFromList.ts\nfunction entriesFromList(list, schema) {\n    const entries = {};\n    for (const key of list){\n        entries[key] = schema;\n    }\n    return entries;\n}\n// src/utils/getDotPath/getDotPath.ts\nfunction getDotPath(issue) {\n    if (issue.path) {\n        let key = \"\";\n        for (const item of issue.path){\n            if (typeof item.key === \"string\" || typeof item.key === \"number\") {\n                if (key) {\n                    key += `.${item.key}`;\n                } else {\n                    key += item.key;\n                }\n            } else {\n                return null;\n            }\n        }\n        return key;\n    }\n    return null;\n}\n// src/utils/isOfKind/isOfKind.ts\nfunction isOfKind(kind, object2) {\n    return object2.kind === kind;\n}\n// src/utils/isOfType/isOfType.ts\nfunction isOfType(type, object2) {\n    return object2.type === type;\n}\n// src/utils/isValiError/isValiError.ts\nfunction isValiError(error) {\n    return error instanceof ValiError;\n}\n// src/utils/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n    /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */ constructor(issues){\n        super(issues[0].message);\n        this.name = \"ValiError\";\n        this.issues = issues;\n    }\n};\n// src/actions/bic/bic.ts\nfunction bic(message) {\n    return {\n        kind: \"validation\",\n        type: \"bic\",\n        reference: bic,\n        async: false,\n        expects: null,\n        requirement: BIC_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"BIC\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/brand/brand.ts\nfunction brand(name) {\n    return {\n        kind: \"transformation\",\n        type: \"brand\",\n        reference: brand,\n        async: false,\n        name,\n        _run (dataset) {\n            return dataset;\n        }\n    };\n}\n// src/actions/bytes/bytes.ts\nfunction bytes(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"bytes\",\n        reference: bytes,\n        async: false,\n        expects: `${requirement}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed) {\n                const length2 = new TextEncoder().encode(dataset.value).length;\n                if (length2 !== this.requirement) {\n                    _addIssue(this, \"bytes\", dataset, config2, {\n                        received: `${length2}`\n                    });\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/check/check.ts\nfunction check(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"check\",\n        reference: check,\n        async: false,\n        expects: null,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement(dataset.value)) {\n                _addIssue(this, \"input\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/check/checkAsync.ts\nfunction checkAsync(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"check\",\n        reference: checkAsync,\n        async: true,\n        expects: null,\n        requirement,\n        message,\n        async _run (dataset, config2) {\n            if (dataset.typed && !await this.requirement(dataset.value)) {\n                _addIssue(this, \"input\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/checkItems/checkItems.ts\nfunction checkItems(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"check_items\",\n        reference: checkItems,\n        async: false,\n        expects: null,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed) {\n                for(let index = 0; index < dataset.value.length; index++){\n                    const item = dataset.value[index];\n                    if (!this.requirement(item, index, dataset.value)) {\n                        _addIssue(this, \"item\", dataset, config2, {\n                            input: item,\n                            path: [\n                                {\n                                    type: \"array\",\n                                    origin: \"value\",\n                                    input: dataset.value,\n                                    key: index,\n                                    value: item\n                                }\n                            ]\n                        });\n                    }\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/creditCard/creditCard.ts\nvar CREDIT_CARD_REGEX = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\nvar SANITIZE_REGEX = /[- ]/gu;\nvar PROVIDER_REGEX_LIST = [\n    // American Express\n    /^3[47]\\d{13}$/u,\n    // Diners Club\n    /^3(?:0[0-5]|[68]\\d)\\d{11,13}$/u,\n    // Discover\n    /^6(?:011|5\\d{2})\\d{12,15}$/u,\n    // JCB\n    /^(?:2131|1800|35\\d{3})\\d{11}$/u,\n    // Mastercard\n    /^5[1-5]\\d{2}|(?:222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n    // UnionPay\n    /^(?:6[27]\\d{14,17}|81\\d{14,17})$/u,\n    // Visa\n    /^4\\d{12}(?:\\d{3,6})?$/u\n];\nfunction creditCard(message) {\n    return {\n        kind: \"validation\",\n        type: \"credit_card\",\n        reference: creditCard,\n        async: false,\n        expects: null,\n        requirement (input) {\n            let sanitized;\n            return CREDIT_CARD_REGEX.test(input) && // Remove any hyphens and blanks\n            (sanitized = input.replace(SANITIZE_REGEX, \"\")) && // Check if it matches a provider\n            PROVIDER_REGEX_LIST.some((regex2)=>regex2.test(sanitized)) && // Check if passes luhn algorithm\n            _isLuhnAlgo(sanitized);\n        },\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement(dataset.value)) {\n                _addIssue(this, \"credit card\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/cuid2/cuid2.ts\nfunction cuid2(message) {\n    return {\n        kind: \"validation\",\n        type: \"cuid2\",\n        reference: cuid2,\n        async: false,\n        expects: null,\n        requirement: CUID2_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"Cuid2\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/decimal/decimal.ts\nfunction decimal(message) {\n    return {\n        kind: \"validation\",\n        type: \"decimal\",\n        reference: decimal,\n        async: false,\n        expects: null,\n        requirement: DECIMAL_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"decimal\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/email/email.ts\nfunction email(message) {\n    return {\n        kind: \"validation\",\n        type: \"email\",\n        reference: email,\n        expects: null,\n        async: false,\n        requirement: EMAIL_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"email\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/emoji/emoji.ts\nfunction emoji(message) {\n    return {\n        kind: \"validation\",\n        type: \"emoji\",\n        reference: emoji,\n        async: false,\n        expects: null,\n        requirement: EMOJI_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"emoji\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/empty/empty.ts\nfunction empty(message) {\n    return {\n        kind: \"validation\",\n        type: \"empty\",\n        reference: empty,\n        async: false,\n        expects: \"0\",\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && dataset.value.length > 0) {\n                _addIssue(this, \"length\", dataset, config2, {\n                    received: `${dataset.value.length}`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/endsWith/endsWith.ts\nfunction endsWith(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"ends_with\",\n        reference: endsWith,\n        async: false,\n        expects: `\"${requirement}\"`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !dataset.value.endsWith(this.requirement)) {\n                _addIssue(this, \"end\", dataset, config2, {\n                    received: `\"${dataset.value.slice(-this.requirement.length)}\"`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/everyItem/everyItem.ts\nfunction everyItem(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"every_item\",\n        reference: everyItem,\n        async: false,\n        expects: null,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !dataset.value.every(this.requirement)) {\n                _addIssue(this, \"item\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/excludes/excludes.ts\nfunction excludes(requirement, message) {\n    const received = _stringify(requirement);\n    return {\n        kind: \"validation\",\n        type: \"excludes\",\n        reference: excludes,\n        async: false,\n        expects: `!${received}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && dataset.value.includes(this.requirement)) {\n                _addIssue(this, \"content\", dataset, config2, {\n                    received\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/filterItems/filterItems.ts\nfunction filterItems(operation) {\n    return {\n        kind: \"transformation\",\n        type: \"filter_items\",\n        reference: filterItems,\n        async: false,\n        operation,\n        _run (dataset) {\n            dataset.value = dataset.value.filter(this.operation);\n            return dataset;\n        }\n    };\n}\n// src/actions/findItem/findItem.ts\nfunction findItem(operation) {\n    return {\n        kind: \"transformation\",\n        type: \"find_item\",\n        reference: findItem,\n        async: false,\n        operation,\n        _run (dataset) {\n            dataset.value = dataset.value.find(this.operation);\n            return dataset;\n        }\n    };\n}\n// src/actions/finite/finite.ts\nfunction finite(message) {\n    return {\n        kind: \"validation\",\n        type: \"finite\",\n        reference: finite,\n        async: false,\n        expects: null,\n        requirement: Number.isFinite,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement(dataset.value)) {\n                _addIssue(this, \"finite\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/hash/hash.ts\nvar HASH_LENGTHS = {\n    md4: 32,\n    md5: 32,\n    sha1: 40,\n    sha256: 64,\n    sha384: 96,\n    sha512: 128,\n    ripemd128: 32,\n    ripemd160: 40,\n    tiger128: 32,\n    tiger160: 40,\n    tiger192: 48,\n    crc32: 8,\n    crc32b: 8,\n    adler32: 8\n};\nfunction hash(types, message) {\n    return {\n        kind: \"validation\",\n        type: \"hash\",\n        reference: hash,\n        expects: null,\n        async: false,\n        requirement: RegExp(types.map((type)=>`^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"), \"iu\"),\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"hash\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/hexadecimal/hexadecimal.ts\nfunction hexadecimal(message) {\n    return {\n        kind: \"validation\",\n        type: \"hexadecimal\",\n        reference: hexadecimal,\n        async: false,\n        expects: null,\n        requirement: HEXADECIMAL_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"hexadecimal\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/hexColor/hexColor.ts\nfunction hexColor(message) {\n    return {\n        kind: \"validation\",\n        type: \"hex_color\",\n        reference: hexColor,\n        async: false,\n        expects: null,\n        requirement: HEX_COLOR_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"hex color\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/imei/imei.ts\nfunction imei(message) {\n    return {\n        kind: \"validation\",\n        type: \"imei\",\n        reference: imei,\n        async: false,\n        expects: null,\n        requirement (input) {\n            return IMEI_REGEX.test(input) && _isLuhnAlgo(input);\n        },\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement(dataset.value)) {\n                _addIssue(this, \"IMEI\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/includes/includes.ts\nfunction includes(requirement, message) {\n    const expects = _stringify(requirement);\n    return {\n        kind: \"validation\",\n        type: \"includes\",\n        reference: includes,\n        async: false,\n        expects,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !dataset.value.includes(this.requirement)) {\n                _addIssue(this, \"content\", dataset, config2, {\n                    received: `!${expects}`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/integer/integer.ts\nfunction integer(message) {\n    return {\n        kind: \"validation\",\n        type: \"integer\",\n        reference: integer,\n        async: false,\n        expects: null,\n        requirement: Number.isInteger,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement(dataset.value)) {\n                _addIssue(this, \"integer\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/ip/ip.ts\nfunction ip(message) {\n    return {\n        kind: \"validation\",\n        type: \"ip\",\n        reference: ip,\n        async: false,\n        expects: null,\n        requirement: IP_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"IP\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/ipv4/ipv4.ts\nfunction ipv4(message) {\n    return {\n        kind: \"validation\",\n        type: \"ipv4\",\n        reference: ipv4,\n        async: false,\n        expects: null,\n        requirement: IPV4_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"IPv4\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/ipv6/ipv6.ts\nfunction ipv6(message) {\n    return {\n        kind: \"validation\",\n        type: \"ipv6\",\n        reference: ipv6,\n        async: false,\n        expects: null,\n        requirement: IPV6_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"IPv6\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/isoDate/isoDate.ts\nfunction isoDate(message) {\n    return {\n        kind: \"validation\",\n        type: \"iso_date\",\n        reference: isoDate,\n        async: false,\n        expects: null,\n        requirement: ISO_DATE_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"date\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/isoDateTime/isoDateTime.ts\nfunction isoDateTime(message) {\n    return {\n        kind: \"validation\",\n        type: \"iso_date_time\",\n        reference: isoDateTime,\n        async: false,\n        expects: null,\n        requirement: ISO_DATE_TIME_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"date-time\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/isoTime/isoTime.ts\nfunction isoTime(message) {\n    return {\n        kind: \"validation\",\n        type: \"iso_time\",\n        reference: isoTime,\n        async: false,\n        expects: null,\n        requirement: ISO_TIME_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"time\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/isoTimeSecond/isoTimeSecond.ts\nfunction isoTimeSecond(message) {\n    return {\n        kind: \"validation\",\n        type: \"iso_time_second\",\n        reference: isoTimeSecond,\n        async: false,\n        expects: null,\n        requirement: ISO_TIME_SECOND_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"time-second\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/isoTimestamp/isoTimestamp.ts\nfunction isoTimestamp(message) {\n    return {\n        kind: \"validation\",\n        type: \"iso_timestamp\",\n        reference: isoTimestamp,\n        async: false,\n        expects: null,\n        requirement: ISO_TIMESTAMP_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"timestamp\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/isoWeek/isoWeek.ts\nfunction isoWeek(message) {\n    return {\n        kind: \"validation\",\n        type: \"iso_week\",\n        reference: isoWeek,\n        async: false,\n        expects: null,\n        requirement: ISO_WEEK_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"week\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/length/length.ts\nfunction length(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"length\",\n        reference: length,\n        async: false,\n        expects: `${requirement}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && dataset.value.length !== this.requirement) {\n                _addIssue(this, \"length\", dataset, config2, {\n                    received: `${dataset.value.length}`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/mac/mac.ts\nfunction mac(message) {\n    return {\n        kind: \"validation\",\n        type: \"mac\",\n        reference: mac,\n        async: false,\n        expects: null,\n        requirement: MAC_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"MAC\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/mac48/mac48.ts\nfunction mac48(message) {\n    return {\n        kind: \"validation\",\n        type: \"mac48\",\n        reference: mac48,\n        async: false,\n        expects: null,\n        requirement: MAC48_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"48-bit MAC\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/mac64/mac64.ts\nfunction mac64(message) {\n    return {\n        kind: \"validation\",\n        type: \"mac64\",\n        reference: mac64,\n        async: false,\n        expects: null,\n        requirement: MAC64_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"64-bit MAC\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/mapItems/mapItems.ts\nfunction mapItems(operation) {\n    return {\n        kind: \"transformation\",\n        type: \"map_items\",\n        reference: mapItems,\n        async: false,\n        operation,\n        _run (dataset) {\n            dataset.value = dataset.value.map(this.operation);\n            return dataset;\n        }\n    };\n}\n// src/actions/maxBytes/maxBytes.ts\nfunction maxBytes(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"max_bytes\",\n        reference: maxBytes,\n        async: false,\n        expects: `<=${requirement}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed) {\n                const length2 = new TextEncoder().encode(dataset.value).length;\n                if (length2 > this.requirement) {\n                    _addIssue(this, \"bytes\", dataset, config2, {\n                        received: `${length2}`\n                    });\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/maxLength/maxLength.ts\nfunction maxLength(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"max_length\",\n        reference: maxLength,\n        async: false,\n        expects: `<=${requirement}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && dataset.value.length > this.requirement) {\n                _addIssue(this, \"length\", dataset, config2, {\n                    received: `${dataset.value.length}`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/maxSize/maxSize.ts\nfunction maxSize(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"max_size\",\n        reference: maxSize,\n        async: false,\n        expects: `<=${requirement}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && dataset.value.size > this.requirement) {\n                _addIssue(this, \"size\", dataset, config2, {\n                    received: `${dataset.value.size}`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/maxValue/maxValue.ts\nfunction maxValue(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"max_value\",\n        reference: maxValue,\n        async: false,\n        expects: `<=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && dataset.value > this.requirement) {\n                _addIssue(this, \"value\", dataset, config2, {\n                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/mimeType/mimeType.ts\nfunction mimeType(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"mime_type\",\n        reference: mimeType,\n        async: false,\n        expects: requirement.map((option)=>`\"${option}\"`).join(\" | \") || \"never\",\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.includes(dataset.value.type)) {\n                _addIssue(this, \"MIME type\", dataset, config2, {\n                    received: `\"${dataset.value.type}\"`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/minBytes/minBytes.ts\nfunction minBytes(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"min_bytes\",\n        reference: minBytes,\n        async: false,\n        expects: `>=${requirement}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed) {\n                const length2 = new TextEncoder().encode(dataset.value).length;\n                if (length2 < this.requirement) {\n                    _addIssue(this, \"bytes\", dataset, config2, {\n                        received: `${length2}`\n                    });\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/minLength/minLength.ts\nfunction minLength(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"min_length\",\n        reference: minLength,\n        async: false,\n        expects: `>=${requirement}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && dataset.value.length < this.requirement) {\n                _addIssue(this, \"length\", dataset, config2, {\n                    received: `${dataset.value.length}`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/minSize/minSize.ts\nfunction minSize(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"min_size\",\n        reference: minSize,\n        async: false,\n        expects: `>=${requirement}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && dataset.value.size < this.requirement) {\n                _addIssue(this, \"size\", dataset, config2, {\n                    received: `${dataset.value.size}`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/minValue/minValue.ts\nfunction minValue(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"min_value\",\n        reference: minValue,\n        async: false,\n        expects: `>=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && dataset.value < this.requirement) {\n                _addIssue(this, \"value\", dataset, config2, {\n                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/multipleOf/multipleOf.ts\nfunction multipleOf(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"multiple_of\",\n        reference: multipleOf,\n        async: false,\n        expects: `%${requirement}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && dataset.value % this.requirement !== 0) {\n                _addIssue(this, \"multiple\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/nonEmpty/nonEmpty.ts\nfunction nonEmpty(message) {\n    return {\n        kind: \"validation\",\n        type: \"non_empty\",\n        reference: nonEmpty,\n        async: false,\n        expects: \"!0\",\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && dataset.value.length === 0) {\n                _addIssue(this, \"length\", dataset, config2, {\n                    received: \"0\"\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/normalize/normalize.ts\nfunction normalize(form) {\n    return {\n        kind: \"transformation\",\n        type: \"normalize\",\n        reference: normalize,\n        async: false,\n        form,\n        _run (dataset) {\n            dataset.value = dataset.value.normalize(this.form);\n            return dataset;\n        }\n    };\n}\n// src/actions/notBytes/notBytes.ts\nfunction notBytes(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"not_bytes\",\n        reference: notBytes,\n        async: false,\n        expects: `!${requirement}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed) {\n                const length2 = new TextEncoder().encode(dataset.value).length;\n                if (length2 === this.requirement) {\n                    _addIssue(this, \"bytes\", dataset, config2, {\n                        received: `${length2}`\n                    });\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/notLength/notLength.ts\nfunction notLength(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"not_length\",\n        reference: notLength,\n        async: false,\n        expects: `!${requirement}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && dataset.value.length === this.requirement) {\n                _addIssue(this, \"length\", dataset, config2, {\n                    received: `${dataset.value.length}`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/notSize/notSize.ts\nfunction notSize(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"not_size\",\n        reference: notSize,\n        async: false,\n        expects: `!${requirement}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && dataset.value.size === this.requirement) {\n                _addIssue(this, \"size\", dataset, config2, {\n                    received: `${dataset.value.size}`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/notValue/notValue.ts\nfunction notValue(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"not_value\",\n        reference: notValue,\n        async: false,\n        expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${_stringify(requirement)}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) {\n                _addIssue(this, \"value\", dataset, config2, {\n                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/octal/octal.ts\nfunction octal(message) {\n    return {\n        kind: \"validation\",\n        type: \"octal\",\n        reference: octal,\n        async: false,\n        expects: null,\n        requirement: OCTAL_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"octal\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts\nfunction _isPartiallyTyped(dataset, pathList) {\n    if (dataset.issues) {\n        for (const path of pathList){\n            for (const issue of dataset.issues){\n                let typed = false;\n                const bound = Math.min(path.length, issue.path?.length ?? 0);\n                for(let index = 0; index < bound; index++){\n                    if (path[index] !== issue.path[index].key) {\n                        typed = true;\n                        break;\n                    }\n                }\n                if (!typed) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n// src/actions/partialCheck/partialCheck.ts\nfunction partialCheck(pathList, requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"partial_check\",\n        reference: partialCheck,\n        async: false,\n        expects: null,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\n            !this.requirement(dataset.value)) {\n                _addIssue(this, \"input\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/partialCheck/partialCheckAsync.ts\nfunction partialCheckAsync(pathList, requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"partial_check\",\n        reference: partialCheckAsync,\n        async: true,\n        expects: null,\n        requirement,\n        message,\n        async _run (dataset, config2) {\n            if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\n            !await this.requirement(dataset.value)) {\n                _addIssue(this, \"input\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/rawCheck/rawCheck.ts\nfunction rawCheck(action) {\n    return {\n        kind: \"validation\",\n        type: \"raw_check\",\n        reference: rawCheck,\n        async: false,\n        expects: null,\n        _run (dataset, config2) {\n            action({\n                dataset,\n                config: config2,\n                addIssue: (info)=>_addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n            });\n            return dataset;\n        }\n    };\n}\n// src/actions/rawCheck/rawCheckAsync.ts\nfunction rawCheckAsync(action) {\n    return {\n        kind: \"validation\",\n        type: \"raw_check\",\n        reference: rawCheckAsync,\n        async: true,\n        expects: null,\n        async _run (dataset, config2) {\n            await action({\n                dataset,\n                config: config2,\n                addIssue: (info)=>_addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n            });\n            return dataset;\n        }\n    };\n}\n// src/actions/rawTransform/rawTransform.ts\nfunction rawTransform(action) {\n    return {\n        kind: \"transformation\",\n        type: \"raw_transform\",\n        reference: rawTransform,\n        async: false,\n        _run (dataset, config2) {\n            const output = action({\n                dataset,\n                config: config2,\n                addIssue: (info)=>_addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n                NEVER: null\n            });\n            if (dataset.issues) {\n                dataset.typed = false;\n            } else {\n                dataset.value = output;\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/rawTransform/rawTransformAsync.ts\nfunction rawTransformAsync(action) {\n    return {\n        kind: \"transformation\",\n        type: \"raw_transform\",\n        reference: rawTransformAsync,\n        async: true,\n        async _run (dataset, config2) {\n            const output = await action({\n                dataset,\n                config: config2,\n                addIssue: (info)=>_addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n                NEVER: null\n            });\n            if (dataset.issues) {\n                dataset.typed = false;\n            } else {\n                dataset.value = output;\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/readonly/readonly.ts\nfunction readonly() {\n    return {\n        kind: \"transformation\",\n        type: \"readonly\",\n        reference: readonly,\n        async: false,\n        _run (dataset) {\n            return dataset;\n        }\n    };\n}\n// src/actions/reduceItems/reduceItems.ts\nfunction reduceItems(operation, initial) {\n    return {\n        kind: \"transformation\",\n        type: \"reduce_items\",\n        reference: reduceItems,\n        async: false,\n        operation,\n        initial,\n        _run (dataset) {\n            dataset.value = dataset.value.reduce(this.operation, this.initial);\n            return dataset;\n        }\n    };\n}\n// src/actions/regex/regex.ts\nfunction regex(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"regex\",\n        reference: regex,\n        async: false,\n        expects: `${requirement}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"format\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/safeInteger/safeInteger.ts\nfunction safeInteger(message) {\n    return {\n        kind: \"validation\",\n        type: \"safe_integer\",\n        reference: safeInteger,\n        async: false,\n        expects: null,\n        requirement: Number.isSafeInteger,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement(dataset.value)) {\n                _addIssue(this, \"safe integer\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/size/size.ts\nfunction size(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"size\",\n        reference: size,\n        async: false,\n        expects: `${requirement}`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && dataset.value.size !== this.requirement) {\n                _addIssue(this, \"size\", dataset, config2, {\n                    received: `${dataset.value.size}`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/someItem/someItem.ts\nfunction someItem(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"some_item\",\n        reference: someItem,\n        async: false,\n        expects: null,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !dataset.value.some(this.requirement)) {\n                _addIssue(this, \"item\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/sortItems/sortItems.ts\nfunction sortItems(operation) {\n    return {\n        kind: \"transformation\",\n        type: \"sort_items\",\n        reference: sortItems,\n        async: false,\n        operation,\n        _run (dataset) {\n            dataset.value = dataset.value.sort(this.operation);\n            return dataset;\n        }\n    };\n}\n// src/actions/startsWith/startsWith.ts\nfunction startsWith(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"starts_with\",\n        reference: startsWith,\n        async: false,\n        expects: `\"${requirement}\"`,\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !dataset.value.startsWith(this.requirement)) {\n                _addIssue(this, \"start\", dataset, config2, {\n                    received: `\"${dataset.value.slice(0, this.requirement.length)}\"`\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/toLowerCase/toLowerCase.ts\nfunction toLowerCase() {\n    return {\n        kind: \"transformation\",\n        type: \"to_lower_case\",\n        reference: toLowerCase,\n        async: false,\n        _run (dataset) {\n            dataset.value = dataset.value.toLowerCase();\n            return dataset;\n        }\n    };\n}\n// src/actions/toMaxValue/toMaxValue.ts\nfunction toMaxValue(requirement) {\n    return {\n        kind: \"transformation\",\n        type: \"to_max_value\",\n        reference: toMaxValue,\n        async: false,\n        requirement,\n        _run (dataset) {\n            dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;\n            return dataset;\n        }\n    };\n}\n// src/actions/toMinValue/toMinValue.ts\nfunction toMinValue(requirement) {\n    return {\n        kind: \"transformation\",\n        type: \"to_min_value\",\n        reference: toMinValue,\n        async: false,\n        requirement,\n        _run (dataset) {\n            dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;\n            return dataset;\n        }\n    };\n}\n// src/actions/toUpperCase/toUpperCase.ts\nfunction toUpperCase() {\n    return {\n        kind: \"transformation\",\n        type: \"to_upper_case\",\n        reference: toUpperCase,\n        async: false,\n        _run (dataset) {\n            dataset.value = dataset.value.toUpperCase();\n            return dataset;\n        }\n    };\n}\n// src/actions/transform/transform.ts\nfunction transform(operation) {\n    return {\n        kind: \"transformation\",\n        type: \"transform\",\n        reference: transform,\n        async: false,\n        operation,\n        _run (dataset) {\n            dataset.value = this.operation(dataset.value);\n            return dataset;\n        }\n    };\n}\n// src/actions/transform/transformAsync.ts\nfunction transformAsync(operation) {\n    return {\n        kind: \"transformation\",\n        type: \"transform\",\n        reference: transformAsync,\n        async: true,\n        operation,\n        async _run (dataset) {\n            dataset.value = await this.operation(dataset.value);\n            return dataset;\n        }\n    };\n}\n// src/actions/trim/trim.ts\nfunction trim() {\n    return {\n        kind: \"transformation\",\n        type: \"trim\",\n        reference: trim,\n        async: false,\n        _run (dataset) {\n            dataset.value = dataset.value.trim();\n            return dataset;\n        }\n    };\n}\n// src/actions/trimEnd/trimEnd.ts\nfunction trimEnd() {\n    return {\n        kind: \"transformation\",\n        type: \"trim_end\",\n        reference: trimEnd,\n        async: false,\n        _run (dataset) {\n            dataset.value = dataset.value.trimEnd();\n            return dataset;\n        }\n    };\n}\n// src/actions/trimStart/trimStart.ts\nfunction trimStart() {\n    return {\n        kind: \"transformation\",\n        type: \"trim_start\",\n        reference: trimStart,\n        async: false,\n        _run (dataset) {\n            dataset.value = dataset.value.trimStart();\n            return dataset;\n        }\n    };\n}\n// src/actions/ulid/ulid.ts\nfunction ulid(message) {\n    return {\n        kind: \"validation\",\n        type: \"ulid\",\n        reference: ulid,\n        async: false,\n        expects: null,\n        requirement: ULID_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"ULID\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/url/url.ts\nfunction url(message) {\n    return {\n        kind: \"validation\",\n        type: \"url\",\n        reference: url,\n        async: false,\n        expects: null,\n        requirement (input) {\n            try {\n                new URL(input);\n                return true;\n            } catch  {\n                return false;\n            }\n        },\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement(dataset.value)) {\n                _addIssue(this, \"URL\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/uuid/uuid.ts\nfunction uuid(message) {\n    return {\n        kind: \"validation\",\n        type: \"uuid\",\n        reference: uuid,\n        async: false,\n        expects: null,\n        requirement: UUID_REGEX,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !this.requirement.test(dataset.value)) {\n                _addIssue(this, \"UUID\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/actions/value/value.ts\nfunction value(requirement, message) {\n    return {\n        kind: \"validation\",\n        type: \"value\",\n        reference: value,\n        async: false,\n        expects: requirement instanceof Date ? requirement.toJSON() : _stringify(requirement),\n        requirement,\n        message,\n        _run (dataset, config2) {\n            if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) {\n                _addIssue(this, \"value\", dataset, config2, {\n                    received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/methods/config/config.ts\nfunction config(schema, config2) {\n    return {\n        ...schema,\n        _run (dataset, config_) {\n            return schema._run(dataset, {\n                ...config_,\n                ...config2\n            });\n        }\n    };\n}\n// src/methods/getFallback/getFallback.ts\nfunction getFallback(schema, dataset, config2) {\n    return typeof schema.fallback === \"function\" ? // @ts-expect-error\n    schema.fallback(dataset, config2) : // @ts-expect-error\n    schema.fallback;\n}\n// src/methods/fallback/fallback.ts\nfunction fallback(schema, fallback2) {\n    return {\n        ...schema,\n        fallback: fallback2,\n        _run (dataset, config2) {\n            schema._run(dataset, config2);\n            return dataset.issues ? {\n                typed: true,\n                value: getFallback(this, dataset, config2)\n            } : dataset;\n        }\n    };\n}\n// src/methods/fallback/fallbackAsync.ts\nfunction fallbackAsync(schema, fallback2) {\n    return {\n        ...schema,\n        fallback: fallback2,\n        async: true,\n        async _run (dataset, config2) {\n            schema._run(dataset, config2);\n            return dataset.issues ? // @ts-expect-error\n            {\n                typed: true,\n                value: await getFallback(this, dataset, config2)\n            } : dataset;\n        }\n    };\n}\n// src/methods/flatten/flatten.ts\nfunction flatten(issues) {\n    const flatErrors = {};\n    for (const issue of issues){\n        if (issue.path) {\n            const dotPath = getDotPath(issue);\n            if (dotPath) {\n                if (!flatErrors.nested) {\n                    flatErrors.nested = {};\n                }\n                if (flatErrors.nested[dotPath]) {\n                    flatErrors.nested[dotPath].push(issue.message);\n                } else {\n                    flatErrors.nested[dotPath] = [\n                        issue.message\n                    ];\n                }\n            } else {\n                if (flatErrors.other) {\n                    flatErrors.other.push(issue.message);\n                } else {\n                    flatErrors.other = [\n                        issue.message\n                    ];\n                }\n            }\n        } else {\n            if (flatErrors.root) {\n                flatErrors.root.push(issue.message);\n            } else {\n                flatErrors.root = [\n                    issue.message\n                ];\n            }\n        }\n    }\n    return flatErrors;\n}\n// src/methods/forward/forward.ts\nfunction forward(action, pathKeys) {\n    return {\n        ...action,\n        _run (dataset, config2) {\n            const prevIssues = dataset.issues && [\n                ...dataset.issues\n            ];\n            action._run(dataset, config2);\n            if (dataset.issues) {\n                for (const issue of dataset.issues){\n                    if (!prevIssues?.includes(issue)) {\n                        let pathInput = dataset.value;\n                        for (const key of pathKeys){\n                            const pathValue = pathInput[key];\n                            const pathItem = {\n                                type: \"unknown\",\n                                origin: \"value\",\n                                input: pathInput,\n                                key,\n                                value: pathValue\n                            };\n                            if (issue.path) {\n                                issue.path.push(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            if (!pathValue) {\n                                break;\n                            }\n                            pathInput = pathValue;\n                        }\n                    }\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/methods/forward/forwardAsync.ts\nfunction forwardAsync(action, pathKeys) {\n    return {\n        ...action,\n        async: true,\n        async _run (dataset, config2) {\n            const prevIssues = dataset.issues && [\n                ...dataset.issues\n            ];\n            await action._run(dataset, config2);\n            if (dataset.issues) {\n                for (const issue of dataset.issues){\n                    if (!prevIssues?.includes(issue)) {\n                        let pathInput = dataset.value;\n                        for (const key of pathKeys){\n                            const pathValue = pathInput[key];\n                            const pathItem = {\n                                type: \"unknown\",\n                                origin: \"value\",\n                                input: pathInput,\n                                key,\n                                value: pathValue\n                            };\n                            if (issue.path) {\n                                issue.path.push(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            if (!pathValue) {\n                                break;\n                            }\n                            pathInput = pathValue;\n                        }\n                    }\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/methods/getDefault/getDefault.ts\nfunction getDefault(schema, dataset, config2) {\n    return typeof schema.default === \"function\" ? // @ts-expect-error\n    schema.default(dataset, config2) : // @ts-expect-error\n    schema.default;\n}\n// src/methods/getDefaults/getDefaults.ts\nfunction getDefaults(schema) {\n    if (\"entries\" in schema) {\n        const object2 = {};\n        for(const key in schema.entries){\n            object2[key] = getDefaults(schema.entries[key]);\n        }\n        return object2;\n    }\n    if (\"items\" in schema) {\n        return schema.items.map(getDefaults);\n    }\n    return getDefault(schema);\n}\n// src/methods/getDefaults/getDefaultsAsync.ts\nasync function getDefaultsAsync(schema) {\n    if (\"entries\" in schema) {\n        return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key, value2])=>[\n                key,\n                await getDefaultsAsync(value2)\n            ])));\n    }\n    if (\"items\" in schema) {\n        return Promise.all(schema.items.map(getDefaultsAsync));\n    }\n    return getDefault(schema);\n}\n// src/methods/getFallbacks/getFallbacks.ts\nfunction getFallbacks(schema) {\n    if (\"entries\" in schema) {\n        const object2 = {};\n        for(const key in schema.entries){\n            object2[key] = getFallbacks(schema.entries[key]);\n        }\n        return object2;\n    }\n    if (\"items\" in schema) {\n        return schema.items.map(getFallbacks);\n    }\n    return getFallback(schema);\n}\n// src/methods/getFallbacks/getFallbacksAsync.ts\nasync function getFallbacksAsync(schema) {\n    if (\"entries\" in schema) {\n        return Object.fromEntries(await Promise.all(Object.entries(schema.entries).map(async ([key, value2])=>[\n                key,\n                await getFallbacksAsync(value2)\n            ])));\n    }\n    if (\"items\" in schema) {\n        return Promise.all(schema.items.map(getFallbacksAsync));\n    }\n    return getFallback(schema);\n}\n// src/methods/is/is.ts\nfunction is(schema, input) {\n    return !schema._run({\n        typed: false,\n        value: input\n    }, {\n        abortEarly: true\n    }).issues;\n}\n// src/schemas/any/any.ts\nfunction any() {\n    return {\n        kind: \"schema\",\n        type: \"any\",\n        reference: any,\n        expects: \"any\",\n        async: false,\n        _run (dataset) {\n            dataset.typed = true;\n            return dataset;\n        }\n    };\n}\n// src/schemas/array/array.ts\nfunction array(item, message) {\n    return {\n        kind: \"schema\",\n        type: \"array\",\n        reference: array,\n        expects: \"Array\",\n        async: false,\n        item,\n        message,\n        _run (dataset, config2) {\n            const input = dataset.value;\n            if (Array.isArray(input)) {\n                dataset.typed = true;\n                dataset.value = [];\n                for(let key = 0; key < input.length; key++){\n                    const value2 = input[key];\n                    const itemDataset = this.item._run({\n                        typed: false,\n                        value: value2\n                    }, config2);\n                    if (itemDataset.issues) {\n                        const pathItem = {\n                            type: \"array\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of itemDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = itemDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!itemDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.push(itemDataset.value);\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/array/arrayAsync.ts\nfunction arrayAsync(item, message) {\n    return {\n        kind: \"schema\",\n        type: \"array\",\n        reference: arrayAsync,\n        expects: \"Array\",\n        async: true,\n        item,\n        message,\n        async _run (dataset, config2) {\n            const input = dataset.value;\n            if (Array.isArray(input)) {\n                dataset.typed = true;\n                dataset.value = [];\n                const itemDatasets = await Promise.all(input.map((value2)=>this.item._run({\n                        typed: false,\n                        value: value2\n                    }, config2)));\n                for(let key = 0; key < itemDatasets.length; key++){\n                    const itemDataset = itemDatasets[key];\n                    if (itemDataset.issues) {\n                        const pathItem = {\n                            type: \"array\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: input[key]\n                        };\n                        for (const issue of itemDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = itemDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!itemDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.push(itemDataset.value);\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/bigint/bigint.ts\nfunction bigint(message) {\n    return {\n        kind: \"schema\",\n        type: \"bigint\",\n        reference: bigint,\n        expects: \"bigint\",\n        async: false,\n        message,\n        _run (dataset, config2) {\n            if (typeof dataset.value === \"bigint\") {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/blob/blob.ts\nfunction blob(message) {\n    return {\n        kind: \"schema\",\n        type: \"blob\",\n        reference: blob,\n        expects: \"Blob\",\n        async: false,\n        message,\n        _run (dataset, config2) {\n            if (dataset.value instanceof Blob) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/boolean/boolean.ts\nfunction boolean(message) {\n    return {\n        kind: \"schema\",\n        type: \"boolean\",\n        reference: boolean,\n        expects: \"boolean\",\n        async: false,\n        message,\n        _run (dataset, config2) {\n            if (typeof dataset.value === \"boolean\") {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/custom/custom.ts\nfunction custom(check2, message) {\n    return {\n        kind: \"schema\",\n        type: \"custom\",\n        reference: custom,\n        expects: \"unknown\",\n        async: false,\n        check: check2,\n        message,\n        _run (dataset, config2) {\n            if (this.check(dataset.value)) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/custom/customAsync.ts\nfunction customAsync(check2, message) {\n    return {\n        kind: \"schema\",\n        type: \"custom\",\n        reference: customAsync,\n        expects: \"unknown\",\n        async: true,\n        check: check2,\n        message,\n        async _run (dataset, config2) {\n            if (await this.check(dataset.value)) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/date/date.ts\nfunction date(message) {\n    return {\n        kind: \"schema\",\n        type: \"date\",\n        reference: date,\n        expects: \"Date\",\n        async: false,\n        message,\n        _run (dataset, config2) {\n            if (dataset.value instanceof Date) {\n                if (!isNaN(dataset.value)) {\n                    dataset.typed = true;\n                } else {\n                    _addIssue(this, \"type\", dataset, config2, {\n                        received: '\"Invalid Date\"'\n                    });\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/enum/enum.ts\nfunction enum_(enum__, message) {\n    const options = Object.entries(enum__).filter(([key])=>isNaN(+key)).map(([, value2])=>value2);\n    return {\n        kind: \"schema\",\n        type: \"enum\",\n        reference: enum_,\n        expects: options.map(_stringify).join(\" | \") || \"never\",\n        async: false,\n        enum: enum__,\n        options,\n        message,\n        _run (dataset, config2) {\n            if (this.options.includes(dataset.value)) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/file/file.ts\nfunction file(message) {\n    return {\n        kind: \"schema\",\n        type: \"file\",\n        reference: file,\n        expects: \"File\",\n        async: false,\n        message,\n        _run (dataset, config2) {\n            if (dataset.value instanceof File) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/function/function.ts\nfunction function_(message) {\n    return {\n        kind: \"schema\",\n        type: \"function\",\n        reference: function_,\n        expects: \"Function\",\n        async: false,\n        message,\n        _run (dataset, config2) {\n            if (typeof dataset.value === \"function\") {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/instance/instance.ts\nfunction instance(class_, message) {\n    return {\n        kind: \"schema\",\n        type: \"instance\",\n        reference: instance,\n        expects: class_.name,\n        async: false,\n        class: class_,\n        message,\n        _run (dataset, config2) {\n            if (dataset.value instanceof this.class) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/intersect/utils/_merge/_merge.ts\nfunction _merge(value1, value2) {\n    if (typeof value1 === typeof value2) {\n        if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) {\n            return {\n                value: value1\n            };\n        }\n        if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {\n            for(const key in value2){\n                if (key in value1) {\n                    const dataset = _merge(value1[key], value2[key]);\n                    if (dataset.issue) {\n                        return dataset;\n                    }\n                    value1[key] = dataset.value;\n                } else {\n                    value1[key] = value2[key];\n                }\n            }\n            return {\n                value: value1\n            };\n        }\n        if (Array.isArray(value1) && Array.isArray(value2)) {\n            if (value1.length === value2.length) {\n                for(let index = 0; index < value1.length; index++){\n                    const dataset = _merge(value1[index], value2[index]);\n                    if (dataset.issue) {\n                        return dataset;\n                    }\n                    value1[index] = dataset.value;\n                }\n                return {\n                    value: value1\n                };\n            }\n        }\n    }\n    return {\n        issue: true\n    };\n}\n// src/schemas/intersect/intersect.ts\nfunction intersect(options, message) {\n    return {\n        kind: \"schema\",\n        type: \"intersect\",\n        reference: intersect,\n        expects: [\n            ...new Set(options.map((option)=>option.expects))\n        ].join(\" & \") || \"never\",\n        async: false,\n        options,\n        message,\n        _run (dataset, config2) {\n            if (this.options.length) {\n                const input = dataset.value;\n                let outputs;\n                dataset.typed = true;\n                for (const schema of this.options){\n                    const optionDataset = schema._run({\n                        typed: false,\n                        value: input\n                    }, config2);\n                    if (optionDataset.issues) {\n                        if (dataset.issues) {\n                            dataset.issues.push(...optionDataset.issues);\n                        } else {\n                            dataset.issues = optionDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!optionDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    if (dataset.typed) {\n                        if (outputs) {\n                            outputs.push(optionDataset.value);\n                        } else {\n                            outputs = [\n                                optionDataset.value\n                            ];\n                        }\n                    }\n                }\n                if (dataset.typed) {\n                    dataset.value = outputs[0];\n                    for(let index = 1; index < outputs.length; index++){\n                        const mergeDataset = _merge(dataset.value, outputs[index]);\n                        if (mergeDataset.issue) {\n                            _addIssue(this, \"type\", dataset, config2, {\n                                received: \"unknown\"\n                            });\n                            break;\n                        }\n                        dataset.value = mergeDataset.value;\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/intersect/intersectAsync.ts\nfunction intersectAsync(options, message) {\n    return {\n        kind: \"schema\",\n        type: \"intersect\",\n        reference: intersectAsync,\n        expects: [\n            ...new Set(options.map((option)=>option.expects))\n        ].join(\" & \") || \"never\",\n        async: true,\n        options,\n        message,\n        async _run (dataset, config2) {\n            if (this.options.length) {\n                const input = dataset.value;\n                let outputs;\n                dataset.typed = true;\n                const optionDatasets = await Promise.all(this.options.map((schema)=>schema._run({\n                        typed: false,\n                        value: input\n                    }, config2)));\n                for (const optionDataset of optionDatasets){\n                    if (optionDataset.issues) {\n                        if (dataset.issues) {\n                            dataset.issues.push(...optionDataset.issues);\n                        } else {\n                            dataset.issues = optionDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!optionDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    if (dataset.typed) {\n                        if (outputs) {\n                            outputs.push(optionDataset.value);\n                        } else {\n                            outputs = [\n                                optionDataset.value\n                            ];\n                        }\n                    }\n                }\n                if (dataset.typed) {\n                    dataset.value = outputs[0];\n                    for(let index = 1; index < outputs.length; index++){\n                        const mergeDataset = _merge(dataset.value, outputs[index]);\n                        if (mergeDataset.issue) {\n                            _addIssue(this, \"type\", dataset, config2, {\n                                received: \"unknown\"\n                            });\n                            break;\n                        }\n                        dataset.value = mergeDataset.value;\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/lazy/lazy.ts\nfunction lazy(getter) {\n    return {\n        kind: \"schema\",\n        type: \"lazy\",\n        reference: lazy,\n        expects: \"unknown\",\n        async: false,\n        getter,\n        _run (dataset, config2) {\n            return this.getter(dataset.value)._run(dataset, config2);\n        }\n    };\n}\n// src/schemas/lazy/lazyAsync.ts\nfunction lazyAsync(getter) {\n    return {\n        kind: \"schema\",\n        type: \"lazy\",\n        reference: lazyAsync,\n        expects: \"unknown\",\n        async: true,\n        getter,\n        async _run (dataset, config2) {\n            return (await this.getter(dataset.value))._run(dataset, config2);\n        }\n    };\n}\n// src/schemas/literal/literal.ts\nfunction literal(literal_, message) {\n    return {\n        kind: \"schema\",\n        type: \"literal\",\n        reference: literal,\n        expects: _stringify(literal_),\n        async: false,\n        literal: literal_,\n        message,\n        _run (dataset, config2) {\n            if (dataset.value === this.literal) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/looseObject/looseObject.ts\nfunction looseObject(entries, message) {\n    return {\n        kind: \"schema\",\n        type: \"loose_object\",\n        reference: looseObject,\n        expects: \"Object\",\n        async: false,\n        entries,\n        message,\n        _run (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                dataset.typed = true;\n                dataset.value = {};\n                for(const key in this.entries){\n                    const value2 = input[key];\n                    const valueDataset = this.entries[key]._run({\n                        typed: false,\n                        value: value2\n                    }, config2);\n                    if (valueDataset.issues) {\n                        const pathItem = {\n                            type: \"object\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of valueDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = valueDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!valueDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    if (valueDataset.value !== void 0 || key in input) {\n                        dataset.value[key] = valueDataset.value;\n                    }\n                }\n                if (!dataset.issues || !config2.abortEarly) {\n                    for(const key in input){\n                        if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n                            dataset.value[key] = input[key];\n                        }\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/looseObject/looseObjectAsync.ts\nfunction looseObjectAsync(entries, message) {\n    return {\n        kind: \"schema\",\n        type: \"loose_object\",\n        reference: looseObjectAsync,\n        expects: \"Object\",\n        async: true,\n        entries,\n        message,\n        async _run (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                dataset.typed = true;\n                dataset.value = {};\n                const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, schema])=>{\n                    const value2 = input[key];\n                    return [\n                        key,\n                        value2,\n                        await schema._run({\n                            typed: false,\n                            value: value2\n                        }, config2)\n                    ];\n                }));\n                for (const [key, value2, valueDataset] of valueDatasets){\n                    if (valueDataset.issues) {\n                        const pathItem = {\n                            type: \"object\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of valueDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = valueDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!valueDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    if (valueDataset.value !== void 0 || key in input) {\n                        dataset.value[key] = valueDataset.value;\n                    }\n                }\n                if (!dataset.issues || !config2.abortEarly) {\n                    for(const key in input){\n                        if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n                            dataset.value[key] = input[key];\n                        }\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/looseTuple/looseTuple.ts\nfunction looseTuple(items, message) {\n    return {\n        kind: \"schema\",\n        type: \"loose_tuple\",\n        reference: looseTuple,\n        expects: \"Array\",\n        async: false,\n        items,\n        message,\n        _run (dataset, config2) {\n            const input = dataset.value;\n            if (Array.isArray(input)) {\n                dataset.typed = true;\n                dataset.value = [];\n                for(let key = 0; key < this.items.length; key++){\n                    const value2 = input[key];\n                    const itemDataset = this.items[key]._run({\n                        typed: false,\n                        value: value2\n                    }, config2);\n                    if (itemDataset.issues) {\n                        const pathItem = {\n                            type: \"array\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of itemDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = itemDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!itemDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.push(itemDataset.value);\n                }\n                if (!dataset.issues || !config2.abortEarly) {\n                    for(let key = this.items.length; key < input.length; key++){\n                        dataset.value.push(input[key]);\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/looseTuple/looseTupleAsync.ts\nfunction looseTupleAsync(items, message) {\n    return {\n        kind: \"schema\",\n        type: \"loose_tuple\",\n        reference: looseTupleAsync,\n        expects: \"Array\",\n        async: true,\n        items,\n        message,\n        async _run (dataset, config2) {\n            const input = dataset.value;\n            if (Array.isArray(input)) {\n                dataset.typed = true;\n                dataset.value = [];\n                const itemDatasets = await Promise.all(this.items.map(async (item, key)=>{\n                    const value2 = input[key];\n                    return [\n                        key,\n                        value2,\n                        await item._run({\n                            typed: false,\n                            value: value2\n                        }, config2)\n                    ];\n                }));\n                for (const [key, value2, itemDataset] of itemDatasets){\n                    if (itemDataset.issues) {\n                        const pathItem = {\n                            type: \"array\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of itemDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = itemDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!itemDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.push(itemDataset.value);\n                }\n                if (!dataset.issues || !config2.abortEarly) {\n                    for(let key = this.items.length; key < input.length; key++){\n                        dataset.value.push(input[key]);\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/map/map.ts\nfunction map(key, value2, message) {\n    return {\n        kind: \"schema\",\n        type: \"map\",\n        reference: map,\n        expects: \"Map\",\n        async: false,\n        key,\n        value: value2,\n        message,\n        _run (dataset, config2) {\n            const input = dataset.value;\n            if (input instanceof Map) {\n                dataset.typed = true;\n                dataset.value = /* @__PURE__ */ new Map();\n                for (const [inputKey, inputValue] of input){\n                    const keyDataset = this.key._run({\n                        typed: false,\n                        value: inputKey\n                    }, config2);\n                    if (keyDataset.issues) {\n                        const pathItem = {\n                            type: \"map\",\n                            origin: \"key\",\n                            input,\n                            key: inputKey,\n                            value: inputValue\n                        };\n                        for (const issue of keyDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = keyDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    const valueDataset = this.value._run({\n                        typed: false,\n                        value: inputValue\n                    }, config2);\n                    if (valueDataset.issues) {\n                        const pathItem = {\n                            type: \"map\",\n                            origin: \"value\",\n                            input,\n                            key: inputKey,\n                            value: inputValue\n                        };\n                        for (const issue of valueDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = valueDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!keyDataset.typed || !valueDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.set(keyDataset.value, valueDataset.value);\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/map/mapAsync.ts\nfunction mapAsync(key, value2, message) {\n    return {\n        kind: \"schema\",\n        type: \"map\",\n        reference: mapAsync,\n        expects: \"Map\",\n        async: true,\n        key,\n        value: value2,\n        message,\n        async _run (dataset, config2) {\n            const input = dataset.value;\n            if (input instanceof Map) {\n                dataset.typed = true;\n                dataset.value = /* @__PURE__ */ new Map();\n                const datasets = await Promise.all([\n                    ...input\n                ].map(([inputKey, inputValue])=>Promise.all([\n                        inputKey,\n                        inputValue,\n                        this.key._run({\n                            typed: false,\n                            value: inputKey\n                        }, config2),\n                        this.value._run({\n                            typed: false,\n                            value: inputValue\n                        }, config2)\n                    ])));\n                for (const [inputKey, inputValue, keyDataset, valueDataset] of datasets){\n                    if (keyDataset.issues) {\n                        const pathItem = {\n                            type: \"map\",\n                            origin: \"key\",\n                            input,\n                            key: inputKey,\n                            value: inputValue\n                        };\n                        for (const issue of keyDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = keyDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (valueDataset.issues) {\n                        const pathItem = {\n                            type: \"map\",\n                            origin: \"value\",\n                            input,\n                            key: inputKey,\n                            value: inputValue\n                        };\n                        for (const issue of valueDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = valueDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!keyDataset.typed || !valueDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.set(keyDataset.value, valueDataset.value);\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/nan/nan.ts\nfunction nan(message) {\n    return {\n        kind: \"schema\",\n        type: \"nan\",\n        reference: nan,\n        expects: \"NaN\",\n        async: false,\n        message,\n        _run (dataset, config2) {\n            if (Number.isNaN(dataset.value)) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/never/never.ts\nfunction never(message) {\n    return {\n        kind: \"schema\",\n        type: \"never\",\n        reference: never,\n        expects: \"never\",\n        async: false,\n        message,\n        _run (dataset, config2) {\n            _addIssue(this, \"type\", dataset, config2);\n            return dataset;\n        }\n    };\n}\n// src/schemas/nonNullable/nonNullable.ts\nfunction nonNullable(wrapped, message) {\n    return {\n        kind: \"schema\",\n        type: \"non_nullable\",\n        reference: nonNullable,\n        expects: \"!null\",\n        async: false,\n        wrapped,\n        message,\n        _run (dataset, config2) {\n            if (dataset.value === null) {\n                _addIssue(this, \"type\", dataset, config2);\n                return dataset;\n            }\n            return this.wrapped._run(dataset, config2);\n        }\n    };\n}\n// src/schemas/nonNullable/nonNullableAsync.ts\nfunction nonNullableAsync(wrapped, message) {\n    return {\n        kind: \"schema\",\n        type: \"non_nullable\",\n        reference: nonNullableAsync,\n        expects: \"!null\",\n        async: true,\n        wrapped,\n        message,\n        async _run (dataset, config2) {\n            if (dataset.value === null) {\n                _addIssue(this, \"type\", dataset, config2);\n                return dataset;\n            }\n            return this.wrapped._run(dataset, config2);\n        }\n    };\n}\n// src/schemas/nonNullish/nonNullish.ts\nfunction nonNullish(wrapped, message) {\n    return {\n        kind: \"schema\",\n        type: \"non_nullish\",\n        reference: nonNullish,\n        expects: \"!null & !undefined\",\n        async: false,\n        wrapped,\n        message,\n        _run (dataset, config2) {\n            if (dataset.value === null || dataset.value === void 0) {\n                _addIssue(this, \"type\", dataset, config2);\n                return dataset;\n            }\n            return this.wrapped._run(dataset, config2);\n        }\n    };\n}\n// src/schemas/nonNullish/nonNullishAsync.ts\nfunction nonNullishAsync(wrapped, message) {\n    return {\n        kind: \"schema\",\n        type: \"non_nullish\",\n        reference: nonNullishAsync,\n        expects: \"!null & !undefined\",\n        async: true,\n        wrapped,\n        message,\n        async _run (dataset, config2) {\n            if (dataset.value === null || dataset.value === void 0) {\n                _addIssue(this, \"type\", dataset, config2);\n                return dataset;\n            }\n            return this.wrapped._run(dataset, config2);\n        }\n    };\n}\n// src/schemas/nonOptional/nonOptional.ts\nfunction nonOptional(wrapped, message) {\n    return {\n        kind: \"schema\",\n        type: \"non_optional\",\n        reference: nonOptional,\n        expects: \"!undefined\",\n        async: false,\n        wrapped,\n        message,\n        _run (dataset, config2) {\n            if (dataset.value === void 0) {\n                _addIssue(this, \"type\", dataset, config2);\n                return dataset;\n            }\n            return this.wrapped._run(dataset, config2);\n        }\n    };\n}\n// src/schemas/nonOptional/nonOptionalAsync.ts\nfunction nonOptionalAsync(wrapped, message) {\n    return {\n        kind: \"schema\",\n        type: \"non_optional\",\n        reference: nonOptionalAsync,\n        expects: \"!undefined\",\n        async: true,\n        wrapped,\n        message,\n        async _run (dataset, config2) {\n            if (dataset.value === void 0) {\n                _addIssue(this, \"type\", dataset, config2);\n                return dataset;\n            }\n            return this.wrapped._run(dataset, config2);\n        }\n    };\n}\n// src/schemas/null/null.ts\nfunction null_(message) {\n    return {\n        kind: \"schema\",\n        type: \"null\",\n        reference: null_,\n        expects: \"null\",\n        async: false,\n        message,\n        _run (dataset, config2) {\n            if (dataset.value === null) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/nullable/nullable.ts\nfunction nullable(wrapped, ...args) {\n    const schema = {\n        kind: \"schema\",\n        type: \"nullable\",\n        reference: nullable,\n        expects: `${wrapped.expects} | null`,\n        async: false,\n        wrapped,\n        _run (dataset, config2) {\n            if (dataset.value === null) {\n                if (\"default\" in this) {\n                    dataset.value = getDefault(this, dataset, config2);\n                }\n                if (dataset.value === null) {\n                    dataset.typed = true;\n                    return dataset;\n                }\n            }\n            return this.wrapped._run(dataset, config2);\n        }\n    };\n    if (0 in args) {\n        schema.default = args[0];\n    }\n    return schema;\n}\n// src/schemas/nullable/nullableAsync.ts\nfunction nullableAsync(wrapped, ...args) {\n    const schema = {\n        kind: \"schema\",\n        type: \"nullable\",\n        reference: nullableAsync,\n        expects: `${wrapped.expects} | null`,\n        async: true,\n        wrapped,\n        async _run (dataset, config2) {\n            if (dataset.value === null) {\n                if (\"default\" in this) {\n                    dataset.value = await getDefault(this, dataset, config2);\n                }\n                if (dataset.value === null) {\n                    dataset.typed = true;\n                    return dataset;\n                }\n            }\n            return this.wrapped._run(dataset, config2);\n        }\n    };\n    if (0 in args) {\n        schema.default = args[0];\n    }\n    return schema;\n}\n// src/schemas/nullish/nullish.ts\nfunction nullish(wrapped, ...args) {\n    const schema = {\n        kind: \"schema\",\n        type: \"nullish\",\n        reference: nullish,\n        expects: `${wrapped.expects} | null | undefined`,\n        async: false,\n        wrapped,\n        _run (dataset, config2) {\n            if (dataset.value === null || dataset.value === void 0) {\n                if (\"default\" in this) {\n                    dataset.value = getDefault(this, dataset, config2);\n                }\n                if (dataset.value === null || dataset.value === void 0) {\n                    dataset.typed = true;\n                    return dataset;\n                }\n            }\n            return this.wrapped._run(dataset, config2);\n        }\n    };\n    if (0 in args) {\n        schema.default = args[0];\n    }\n    return schema;\n}\n// src/schemas/nullish/nullishAsync.ts\nfunction nullishAsync(wrapped, ...args) {\n    const schema = {\n        kind: \"schema\",\n        type: \"nullish\",\n        reference: nullishAsync,\n        expects: `${wrapped.expects} | null | undefined`,\n        async: true,\n        wrapped,\n        async _run (dataset, config2) {\n            if (dataset.value === null || dataset.value === void 0) {\n                if (\"default\" in this) {\n                    dataset.value = await getDefault(this, dataset, config2);\n                }\n                if (dataset.value === null || dataset.value === void 0) {\n                    dataset.typed = true;\n                    return dataset;\n                }\n            }\n            return this.wrapped._run(dataset, config2);\n        }\n    };\n    if (0 in args) {\n        schema.default = args[0];\n    }\n    return schema;\n}\n// src/schemas/number/number.ts\nfunction number(message) {\n    return {\n        kind: \"schema\",\n        type: \"number\",\n        reference: number,\n        expects: \"number\",\n        async: false,\n        message,\n        _run (dataset, config2) {\n            if (typeof dataset.value === \"number\" && !isNaN(dataset.value)) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/object/object.ts\nfunction object(entries, message) {\n    return {\n        kind: \"schema\",\n        type: \"object\",\n        reference: object,\n        expects: \"Object\",\n        async: false,\n        entries,\n        message,\n        _run (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                dataset.typed = true;\n                dataset.value = {};\n                for(const key in this.entries){\n                    const value2 = input[key];\n                    const valueDataset = this.entries[key]._run({\n                        typed: false,\n                        value: value2\n                    }, config2);\n                    if (valueDataset.issues) {\n                        const pathItem = {\n                            type: \"object\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of valueDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = valueDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!valueDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    if (valueDataset.value !== void 0 || key in input) {\n                        dataset.value[key] = valueDataset.value;\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/object/objectAsync.ts\nfunction objectAsync(entries, message) {\n    return {\n        kind: \"schema\",\n        type: \"object\",\n        reference: objectAsync,\n        expects: \"Object\",\n        async: true,\n        entries,\n        message,\n        async _run (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                dataset.typed = true;\n                dataset.value = {};\n                const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, schema])=>{\n                    const value2 = input[key];\n                    return [\n                        key,\n                        value2,\n                        await schema._run({\n                            typed: false,\n                            value: value2\n                        }, config2)\n                    ];\n                }));\n                for (const [key, value2, valueDataset] of valueDatasets){\n                    if (valueDataset.issues) {\n                        const pathItem = {\n                            type: \"object\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of valueDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = valueDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!valueDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    if (valueDataset.value !== void 0 || key in input) {\n                        dataset.value[key] = valueDataset.value;\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/objectWithRest/objectWithRest.ts\nfunction objectWithRest(entries, rest, message) {\n    return {\n        kind: \"schema\",\n        type: \"object_with_rest\",\n        reference: objectWithRest,\n        expects: \"Object\",\n        async: false,\n        entries,\n        rest,\n        message,\n        _run (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                dataset.typed = true;\n                dataset.value = {};\n                for(const key in this.entries){\n                    const value2 = input[key];\n                    const valueDataset = this.entries[key]._run({\n                        typed: false,\n                        value: value2\n                    }, config2);\n                    if (valueDataset.issues) {\n                        const pathItem = {\n                            type: \"object\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of valueDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = valueDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!valueDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    if (valueDataset.value !== void 0 || key in input) {\n                        dataset.value[key] = valueDataset.value;\n                    }\n                }\n                if (!dataset.issues || !config2.abortEarly) {\n                    for(const key in input){\n                        if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n                            const value2 = input[key];\n                            const valueDataset = this.rest._run({\n                                typed: false,\n                                value: value2\n                            }, config2);\n                            if (valueDataset.issues) {\n                                const pathItem = {\n                                    type: \"object\",\n                                    origin: \"value\",\n                                    input,\n                                    key,\n                                    value: value2\n                                };\n                                for (const issue of valueDataset.issues){\n                                    if (issue.path) {\n                                        issue.path.unshift(pathItem);\n                                    } else {\n                                        issue.path = [\n                                            pathItem\n                                        ];\n                                    }\n                                    dataset.issues?.push(issue);\n                                }\n                                if (!dataset.issues) {\n                                    dataset.issues = valueDataset.issues;\n                                }\n                                if (config2.abortEarly) {\n                                    dataset.typed = false;\n                                    break;\n                                }\n                            }\n                            if (!valueDataset.typed) {\n                                dataset.typed = false;\n                            }\n                            dataset.value[key] = valueDataset.value;\n                        }\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/objectWithRest/objectWithRestAsync.ts\nfunction objectWithRestAsync(entries, rest, message) {\n    return {\n        kind: \"schema\",\n        type: \"object_with_rest\",\n        reference: objectWithRestAsync,\n        expects: \"Object\",\n        async: true,\n        entries,\n        rest,\n        message,\n        async _run (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                dataset.typed = true;\n                dataset.value = {};\n                const [normalDatasets, restDatasets] = await Promise.all([\n                    // Parse schema of each normal entry\n                    Promise.all(Object.entries(this.entries).map(async ([key, schema])=>{\n                        const value2 = input[key];\n                        return [\n                            key,\n                            value2,\n                            await schema._run({\n                                typed: false,\n                                value: value2\n                            }, config2)\n                        ];\n                    })),\n                    // Parse other entries with rest schema\n                    Promise.all(Object.entries(input).filter(([key])=>_isValidObjectKey(input, key) && !(key in this.entries)).map(async ([key, value2])=>[\n                            key,\n                            value2,\n                            await this.rest._run({\n                                typed: false,\n                                value: value2\n                            }, config2)\n                        ]))\n                ]);\n                for (const [key, value2, valueDataset] of normalDatasets){\n                    if (valueDataset.issues) {\n                        const pathItem = {\n                            type: \"object\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of valueDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = valueDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!valueDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    if (valueDataset.value !== void 0 || key in input) {\n                        dataset.value[key] = valueDataset.value;\n                    }\n                }\n                if (!dataset.issues || !config2.abortEarly) {\n                    for (const [key, value2, valueDataset] of restDatasets){\n                        if (valueDataset.issues) {\n                            const pathItem = {\n                                type: \"object\",\n                                origin: \"value\",\n                                input,\n                                key,\n                                value: value2\n                            };\n                            for (const issue of valueDataset.issues){\n                                if (issue.path) {\n                                    issue.path.unshift(pathItem);\n                                } else {\n                                    issue.path = [\n                                        pathItem\n                                    ];\n                                }\n                                dataset.issues?.push(issue);\n                            }\n                            if (!dataset.issues) {\n                                dataset.issues = valueDataset.issues;\n                            }\n                            if (config2.abortEarly) {\n                                dataset.typed = false;\n                                break;\n                            }\n                        }\n                        if (!valueDataset.typed) {\n                            dataset.typed = false;\n                        }\n                        dataset.value[key] = valueDataset.value;\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/optional/optional.ts\nfunction optional(wrapped, ...args) {\n    const schema = {\n        kind: \"schema\",\n        type: \"optional\",\n        reference: optional,\n        expects: `${wrapped.expects} | undefined`,\n        async: false,\n        wrapped,\n        _run (dataset, config2) {\n            if (dataset.value === void 0) {\n                if (\"default\" in this) {\n                    dataset.value = getDefault(this, dataset, config2);\n                }\n                if (dataset.value === void 0) {\n                    dataset.typed = true;\n                    return dataset;\n                }\n            }\n            return this.wrapped._run(dataset, config2);\n        }\n    };\n    if (0 in args) {\n        schema.default = args[0];\n    }\n    return schema;\n}\n// src/schemas/optional/optionalAsync.ts\nfunction optionalAsync(wrapped, ...args) {\n    const schema = {\n        kind: \"schema\",\n        type: \"optional\",\n        reference: optionalAsync,\n        expects: `${wrapped.expects} | undefined`,\n        async: true,\n        wrapped,\n        async _run (dataset, config2) {\n            if (dataset.value === void 0) {\n                if (\"default\" in this) {\n                    dataset.value = await getDefault(this, dataset, config2);\n                }\n                if (dataset.value === void 0) {\n                    dataset.typed = true;\n                    return dataset;\n                }\n            }\n            return this.wrapped._run(dataset, config2);\n        }\n    };\n    if (0 in args) {\n        schema.default = args[0];\n    }\n    return schema;\n}\n// src/schemas/picklist/picklist.ts\nfunction picklist(options, message) {\n    return {\n        kind: \"schema\",\n        type: \"picklist\",\n        reference: picklist,\n        expects: options.map(_stringify).join(\" | \") || \"never\",\n        async: false,\n        options,\n        message,\n        _run (dataset, config2) {\n            if (this.options.includes(dataset.value)) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/promise/promise.ts\nfunction promise(message) {\n    return {\n        kind: \"schema\",\n        type: \"promise\",\n        reference: promise,\n        expects: \"Promise\",\n        async: false,\n        message,\n        _run (dataset, config2) {\n            if (dataset.value instanceof Promise) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/record/record.ts\nfunction record(key, value2, message) {\n    return {\n        kind: \"schema\",\n        type: \"record\",\n        reference: record,\n        expects: \"Object\",\n        async: false,\n        key,\n        value: value2,\n        message,\n        _run (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                dataset.typed = true;\n                dataset.value = {};\n                for(const entryKey in input){\n                    if (_isValidObjectKey(input, entryKey)) {\n                        const entryValue = input[entryKey];\n                        const keyDataset = this.key._run({\n                            typed: false,\n                            value: entryKey\n                        }, config2);\n                        if (keyDataset.issues) {\n                            const pathItem = {\n                                type: \"object\",\n                                origin: \"key\",\n                                input,\n                                key: entryKey,\n                                value: entryValue\n                            };\n                            for (const issue of keyDataset.issues){\n                                issue.path = [\n                                    pathItem\n                                ];\n                                dataset.issues?.push(issue);\n                            }\n                            if (!dataset.issues) {\n                                dataset.issues = keyDataset.issues;\n                            }\n                            if (config2.abortEarly) {\n                                dataset.typed = false;\n                                break;\n                            }\n                        }\n                        const valueDataset = this.value._run({\n                            typed: false,\n                            value: entryValue\n                        }, config2);\n                        if (valueDataset.issues) {\n                            const pathItem = {\n                                type: \"object\",\n                                origin: \"value\",\n                                input,\n                                key: entryKey,\n                                value: entryValue\n                            };\n                            for (const issue of valueDataset.issues){\n                                if (issue.path) {\n                                    issue.path.unshift(pathItem);\n                                } else {\n                                    issue.path = [\n                                        pathItem\n                                    ];\n                                }\n                                dataset.issues?.push(issue);\n                            }\n                            if (!dataset.issues) {\n                                dataset.issues = valueDataset.issues;\n                            }\n                            if (config2.abortEarly) {\n                                dataset.typed = false;\n                                break;\n                            }\n                        }\n                        if (!keyDataset.typed || !valueDataset.typed) {\n                            dataset.typed = false;\n                        }\n                        if (keyDataset.typed) {\n                            dataset.value[keyDataset.value] = valueDataset.value;\n                        }\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/record/recordAsync.ts\nfunction recordAsync(key, value2, message) {\n    return {\n        kind: \"schema\",\n        type: \"record\",\n        reference: recordAsync,\n        expects: \"Object\",\n        async: true,\n        key,\n        value: value2,\n        message,\n        async _run (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                dataset.typed = true;\n                dataset.value = {};\n                const datasets = await Promise.all(Object.entries(input).filter(([key2])=>_isValidObjectKey(input, key2)).map(([entryKey, entryValue])=>Promise.all([\n                        entryKey,\n                        entryValue,\n                        this.key._run({\n                            typed: false,\n                            value: entryKey\n                        }, config2),\n                        this.value._run({\n                            typed: false,\n                            value: entryValue\n                        }, config2)\n                    ])));\n                for (const [entryKey, entryValue, keyDataset, valueDataset] of datasets){\n                    if (keyDataset.issues) {\n                        const pathItem = {\n                            type: \"object\",\n                            origin: \"key\",\n                            input,\n                            key: entryKey,\n                            value: entryValue\n                        };\n                        for (const issue of keyDataset.issues){\n                            issue.path = [\n                                pathItem\n                            ];\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = keyDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (valueDataset.issues) {\n                        const pathItem = {\n                            type: \"object\",\n                            origin: \"value\",\n                            input,\n                            key: entryKey,\n                            value: entryValue\n                        };\n                        for (const issue of valueDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = valueDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!keyDataset.typed || !valueDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    if (keyDataset.typed) {\n                        dataset.value[keyDataset.value] = valueDataset.value;\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/set/set.ts\nfunction set(value2, message) {\n    return {\n        kind: \"schema\",\n        type: \"set\",\n        reference: set,\n        expects: \"Set\",\n        async: false,\n        value: value2,\n        message,\n        _run (dataset, config2) {\n            const input = dataset.value;\n            if (input instanceof Set) {\n                dataset.typed = true;\n                dataset.value = /* @__PURE__ */ new Set();\n                for (const inputValue of input){\n                    const valueDataset = this.value._run({\n                        typed: false,\n                        value: inputValue\n                    }, config2);\n                    if (valueDataset.issues) {\n                        const pathItem = {\n                            type: \"set\",\n                            origin: \"value\",\n                            input,\n                            key: null,\n                            value: inputValue\n                        };\n                        for (const issue of valueDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = valueDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!valueDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.add(valueDataset.value);\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/set/setAsync.ts\nfunction setAsync(value2, message) {\n    return {\n        kind: \"schema\",\n        type: \"set\",\n        reference: setAsync,\n        expects: \"Set\",\n        async: true,\n        value: value2,\n        message,\n        async _run (dataset, config2) {\n            const input = dataset.value;\n            if (input instanceof Set) {\n                dataset.typed = true;\n                dataset.value = /* @__PURE__ */ new Set();\n                const valueDatasets = await Promise.all([\n                    ...input\n                ].map(async (inputValue)=>[\n                        inputValue,\n                        await this.value._run({\n                            typed: false,\n                            value: inputValue\n                        }, config2)\n                    ]));\n                for (const [inputValue, valueDataset] of valueDatasets){\n                    if (valueDataset.issues) {\n                        const pathItem = {\n                            type: \"set\",\n                            origin: \"value\",\n                            input,\n                            key: null,\n                            value: inputValue\n                        };\n                        for (const issue of valueDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = valueDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!valueDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.add(valueDataset.value);\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/strictObject/strictObject.ts\nfunction strictObject(entries, message) {\n    return {\n        kind: \"schema\",\n        type: \"strict_object\",\n        reference: strictObject,\n        expects: \"Object\",\n        async: false,\n        entries,\n        message,\n        _run (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                dataset.typed = true;\n                dataset.value = {};\n                for(const key in this.entries){\n                    const value2 = input[key];\n                    const valueDataset = this.entries[key]._run({\n                        typed: false,\n                        value: value2\n                    }, config2);\n                    if (valueDataset.issues) {\n                        const pathItem = {\n                            type: \"object\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of valueDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = valueDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!valueDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    if (valueDataset.value !== void 0 || key in input) {\n                        dataset.value[key] = valueDataset.value;\n                    }\n                }\n                if (!dataset.issues || !config2.abortEarly) {\n                    for(const key in input){\n                        if (!(key in this.entries)) {\n                            const value2 = input[key];\n                            _addIssue(this, \"type\", dataset, config2, {\n                                input: value2,\n                                expected: \"never\",\n                                path: [\n                                    {\n                                        type: \"object\",\n                                        origin: \"value\",\n                                        input,\n                                        key,\n                                        value: value2\n                                    }\n                                ]\n                            });\n                            break;\n                        }\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/strictObject/strictObjectAsync.ts\nfunction strictObjectAsync(entries, message) {\n    return {\n        kind: \"schema\",\n        type: \"strict_object\",\n        reference: strictObjectAsync,\n        expects: \"Object\",\n        async: true,\n        entries,\n        message,\n        async _run (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                dataset.typed = true;\n                dataset.value = {};\n                const valueDatasets = await Promise.all(Object.entries(this.entries).map(async ([key, schema])=>{\n                    const value2 = input[key];\n                    return [\n                        key,\n                        value2,\n                        await schema._run({\n                            typed: false,\n                            value: value2\n                        }, config2)\n                    ];\n                }));\n                for (const [key, value2, valueDataset] of valueDatasets){\n                    if (valueDataset.issues) {\n                        const pathItem = {\n                            type: \"object\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of valueDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = valueDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!valueDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    if (valueDataset.value !== void 0 || key in input) {\n                        dataset.value[key] = valueDataset.value;\n                    }\n                }\n                if (!dataset.issues || !config2.abortEarly) {\n                    for(const key in input){\n                        if (!(key in this.entries)) {\n                            const value2 = input[key];\n                            _addIssue(this, \"type\", dataset, config2, {\n                                input: value2,\n                                expected: \"never\",\n                                path: [\n                                    {\n                                        type: \"object\",\n                                        origin: \"value\",\n                                        input,\n                                        key,\n                                        value: value2\n                                    }\n                                ]\n                            });\n                            break;\n                        }\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/strictTuple/strictTuple.ts\nfunction strictTuple(items, message) {\n    return {\n        kind: \"schema\",\n        type: \"strict_tuple\",\n        reference: strictTuple,\n        expects: \"Array\",\n        async: false,\n        items,\n        message,\n        _run (dataset, config2) {\n            const input = dataset.value;\n            if (Array.isArray(input)) {\n                dataset.typed = true;\n                dataset.value = [];\n                for(let key = 0; key < this.items.length; key++){\n                    const value2 = input[key];\n                    const itemDataset = this.items[key]._run({\n                        typed: false,\n                        value: value2\n                    }, config2);\n                    if (itemDataset.issues) {\n                        const pathItem = {\n                            type: \"array\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of itemDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = itemDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!itemDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.push(itemDataset.value);\n                }\n                if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n                    const value2 = input[items.length];\n                    _addIssue(this, \"type\", dataset, config2, {\n                        input: value2,\n                        expected: \"never\",\n                        path: [\n                            {\n                                type: \"array\",\n                                origin: \"value\",\n                                input,\n                                key: this.items.length,\n                                value: value2\n                            }\n                        ]\n                    });\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/strictTuple/strictTupleAsync.ts\nfunction strictTupleAsync(items, message) {\n    return {\n        kind: \"schema\",\n        type: \"strict_tuple\",\n        reference: strictTupleAsync,\n        expects: \"Array\",\n        async: true,\n        items,\n        message,\n        async _run (dataset, config2) {\n            const input = dataset.value;\n            if (Array.isArray(input)) {\n                dataset.typed = true;\n                dataset.value = [];\n                const itemDatasets = await Promise.all(this.items.map(async (item, key)=>{\n                    const value2 = input[key];\n                    return [\n                        key,\n                        value2,\n                        await item._run({\n                            typed: false,\n                            value: value2\n                        }, config2)\n                    ];\n                }));\n                for (const [key, value2, itemDataset] of itemDatasets){\n                    if (itemDataset.issues) {\n                        const pathItem = {\n                            type: \"array\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of itemDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = itemDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!itemDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.push(itemDataset.value);\n                }\n                if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n                    const value2 = input[items.length];\n                    _addIssue(this, \"type\", dataset, config2, {\n                        input: value2,\n                        expected: \"never\",\n                        path: [\n                            {\n                                type: \"array\",\n                                origin: \"value\",\n                                input,\n                                key: this.items.length,\n                                value: value2\n                            }\n                        ]\n                    });\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/string/string.ts\nfunction string(message) {\n    return {\n        kind: \"schema\",\n        type: \"string\",\n        reference: string,\n        expects: \"string\",\n        async: false,\n        message,\n        _run (dataset, config2) {\n            if (typeof dataset.value === \"string\") {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/symbol/symbol.ts\nfunction symbol(message) {\n    return {\n        kind: \"schema\",\n        type: \"symbol\",\n        reference: symbol,\n        expects: \"symbol\",\n        async: false,\n        message,\n        _run (dataset, config2) {\n            if (typeof dataset.value === \"symbol\") {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/tuple/tuple.ts\nfunction tuple(items, message) {\n    return {\n        kind: \"schema\",\n        type: \"tuple\",\n        reference: tuple,\n        expects: \"Array\",\n        async: false,\n        items,\n        message,\n        _run (dataset, config2) {\n            const input = dataset.value;\n            if (Array.isArray(input)) {\n                dataset.typed = true;\n                dataset.value = [];\n                for(let key = 0; key < this.items.length; key++){\n                    const value2 = input[key];\n                    const itemDataset = this.items[key]._run({\n                        typed: false,\n                        value: value2\n                    }, config2);\n                    if (itemDataset.issues) {\n                        const pathItem = {\n                            type: \"array\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of itemDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = itemDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!itemDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.push(itemDataset.value);\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/tuple/tupleAsync.ts\nfunction tupleAsync(items, message) {\n    return {\n        kind: \"schema\",\n        type: \"tuple\",\n        reference: tupleAsync,\n        expects: \"Array\",\n        async: true,\n        items,\n        message,\n        async _run (dataset, config2) {\n            const input = dataset.value;\n            if (Array.isArray(input)) {\n                dataset.typed = true;\n                dataset.value = [];\n                const itemDatasets = await Promise.all(this.items.map(async (item, key)=>{\n                    const value2 = input[key];\n                    return [\n                        key,\n                        value2,\n                        await item._run({\n                            typed: false,\n                            value: value2\n                        }, config2)\n                    ];\n                }));\n                for (const [key, value2, itemDataset] of itemDatasets){\n                    if (itemDataset.issues) {\n                        const pathItem = {\n                            type: \"array\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of itemDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = itemDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!itemDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.push(itemDataset.value);\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/tupleWithRest/tupleWithRest.ts\nfunction tupleWithRest(items, rest, message) {\n    return {\n        kind: \"schema\",\n        type: \"tuple_with_rest\",\n        reference: tupleWithRest,\n        expects: \"Array\",\n        async: false,\n        items,\n        rest,\n        message,\n        _run (dataset, config2) {\n            const input = dataset.value;\n            if (Array.isArray(input)) {\n                dataset.typed = true;\n                dataset.value = [];\n                for(let key = 0; key < this.items.length; key++){\n                    const value2 = input[key];\n                    const itemDataset = this.items[key]._run({\n                        typed: false,\n                        value: value2\n                    }, config2);\n                    if (itemDataset.issues) {\n                        const pathItem = {\n                            type: \"array\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of itemDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = itemDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!itemDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.push(itemDataset.value);\n                }\n                if (!dataset.issues || !config2.abortEarly) {\n                    for(let key = this.items.length; key < input.length; key++){\n                        const value2 = input[key];\n                        const itemDataset = this.rest._run({\n                            typed: false,\n                            value: value2\n                        }, config2);\n                        if (itemDataset.issues) {\n                            const pathItem = {\n                                type: \"array\",\n                                origin: \"value\",\n                                input,\n                                key,\n                                value: value2\n                            };\n                            for (const issue of itemDataset.issues){\n                                if (issue.path) {\n                                    issue.path.unshift(pathItem);\n                                } else {\n                                    issue.path = [\n                                        pathItem\n                                    ];\n                                }\n                                dataset.issues?.push(issue);\n                            }\n                            if (!dataset.issues) {\n                                dataset.issues = itemDataset.issues;\n                            }\n                            if (config2.abortEarly) {\n                                dataset.typed = false;\n                                break;\n                            }\n                        }\n                        if (!itemDataset.typed) {\n                            dataset.typed = false;\n                        }\n                        dataset.value.push(itemDataset.value);\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/tupleWithRest/tupleWithRestAsync.ts\nfunction tupleWithRestAsync(items, rest, message) {\n    return {\n        kind: \"schema\",\n        type: \"tuple_with_rest\",\n        reference: tupleWithRestAsync,\n        expects: \"Array\",\n        async: true,\n        items,\n        rest,\n        message,\n        async _run (dataset, config2) {\n            const input = dataset.value;\n            if (Array.isArray(input)) {\n                dataset.typed = true;\n                dataset.value = [];\n                const [normalDatasets, restDatasets] = await Promise.all([\n                    // Parse schema of each normal item\n                    Promise.all(this.items.map(async (item, key)=>{\n                        const value2 = input[key];\n                        return [\n                            key,\n                            value2,\n                            await item._run({\n                                typed: false,\n                                value: value2\n                            }, config2)\n                        ];\n                    })),\n                    // Parse other items with rest schema\n                    Promise.all(input.slice(this.items.length).map(async (value2, key)=>{\n                        return [\n                            key + this.items.length,\n                            value2,\n                            await this.rest._run({\n                                typed: false,\n                                value: value2\n                            }, config2)\n                        ];\n                    }))\n                ]);\n                for (const [key, value2, itemDataset] of normalDatasets){\n                    if (itemDataset.issues) {\n                        const pathItem = {\n                            type: \"array\",\n                            origin: \"value\",\n                            input,\n                            key,\n                            value: value2\n                        };\n                        for (const issue of itemDataset.issues){\n                            if (issue.path) {\n                                issue.path.unshift(pathItem);\n                            } else {\n                                issue.path = [\n                                    pathItem\n                                ];\n                            }\n                            dataset.issues?.push(issue);\n                        }\n                        if (!dataset.issues) {\n                            dataset.issues = itemDataset.issues;\n                        }\n                        if (config2.abortEarly) {\n                            dataset.typed = false;\n                            break;\n                        }\n                    }\n                    if (!itemDataset.typed) {\n                        dataset.typed = false;\n                    }\n                    dataset.value.push(itemDataset.value);\n                }\n                if (!dataset.issues || !config2.abortEarly) {\n                    for (const [key, value2, itemDataset] of restDatasets){\n                        if (itemDataset.issues) {\n                            const pathItem = {\n                                type: \"array\",\n                                origin: \"value\",\n                                input,\n                                key,\n                                value: value2\n                            };\n                            for (const issue of itemDataset.issues){\n                                if (issue.path) {\n                                    issue.path.unshift(pathItem);\n                                } else {\n                                    issue.path = [\n                                        pathItem\n                                    ];\n                                }\n                                dataset.issues?.push(issue);\n                            }\n                            if (!dataset.issues) {\n                                dataset.issues = itemDataset.issues;\n                            }\n                            if (config2.abortEarly) {\n                                dataset.typed = false;\n                                break;\n                            }\n                        }\n                        if (!itemDataset.typed) {\n                            dataset.typed = false;\n                        }\n                        dataset.value.push(itemDataset.value);\n                    }\n                }\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/undefined/undefined.ts\nfunction undefined_(message) {\n    return {\n        kind: \"schema\",\n        type: \"undefined\",\n        reference: undefined_,\n        expects: \"undefined\",\n        async: false,\n        message,\n        _run (dataset, config2) {\n            if (dataset.value === void 0) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/union/utils/_subIssues/_subIssues.ts\nfunction _subIssues(datasets) {\n    let issues;\n    if (datasets) {\n        for (const dataset of datasets){\n            if (issues) {\n                issues.push(...dataset.issues);\n            } else {\n                issues = dataset.issues;\n            }\n        }\n    }\n    return issues;\n}\n// src/schemas/union/union.ts\nfunction union(options, message) {\n    return {\n        kind: \"schema\",\n        type: \"union\",\n        reference: union,\n        expects: [\n            ...new Set(options.map((option)=>option.expects))\n        ].join(\" | \") || \"never\",\n        async: false,\n        options,\n        message,\n        _run (dataset, config2) {\n            let validDataset;\n            let typedDatasets;\n            let untypedDatasets;\n            for (const schema of this.options){\n                const optionDataset = schema._run({\n                    typed: false,\n                    value: dataset.value\n                }, config2);\n                if (optionDataset.typed) {\n                    if (optionDataset.issues) {\n                        if (typedDatasets) {\n                            typedDatasets.push(optionDataset);\n                        } else {\n                            typedDatasets = [\n                                optionDataset\n                            ];\n                        }\n                    } else {\n                        validDataset = optionDataset;\n                        break;\n                    }\n                } else {\n                    if (untypedDatasets) {\n                        untypedDatasets.push(optionDataset);\n                    } else {\n                        untypedDatasets = [\n                            optionDataset\n                        ];\n                    }\n                }\n            }\n            if (validDataset) {\n                return validDataset;\n            }\n            if (typedDatasets) {\n                if (typedDatasets.length === 1) {\n                    return typedDatasets[0];\n                }\n                _addIssue(this, \"type\", dataset, config2, {\n                    issues: _subIssues(typedDatasets)\n                });\n                dataset.typed = true;\n            } else if (untypedDatasets?.length === 1) {\n                return untypedDatasets[0];\n            } else {\n                _addIssue(this, \"type\", dataset, config2, {\n                    issues: _subIssues(untypedDatasets)\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/union/unionAsync.ts\nfunction unionAsync(options, message) {\n    return {\n        kind: \"schema\",\n        type: \"union\",\n        reference: unionAsync,\n        expects: [\n            ...new Set(options.map((option)=>option.expects))\n        ].join(\" | \") || \"never\",\n        async: true,\n        options,\n        message,\n        async _run (dataset, config2) {\n            let validDataset;\n            let typedDatasets;\n            let untypedDatasets;\n            for (const schema of this.options){\n                const optionDataset = await schema._run({\n                    typed: false,\n                    value: dataset.value\n                }, config2);\n                if (optionDataset.typed) {\n                    if (optionDataset.issues) {\n                        if (typedDatasets) {\n                            typedDatasets.push(optionDataset);\n                        } else {\n                            typedDatasets = [\n                                optionDataset\n                            ];\n                        }\n                    } else {\n                        validDataset = optionDataset;\n                        break;\n                    }\n                } else {\n                    if (untypedDatasets) {\n                        untypedDatasets.push(optionDataset);\n                    } else {\n                        untypedDatasets = [\n                            optionDataset\n                        ];\n                    }\n                }\n            }\n            if (validDataset) {\n                return validDataset;\n            }\n            if (typedDatasets) {\n                if (typedDatasets.length === 1) {\n                    return typedDatasets[0];\n                }\n                _addIssue(this, \"type\", dataset, config2, {\n                    issues: _subIssues(typedDatasets)\n                });\n                dataset.typed = true;\n            } else if (untypedDatasets?.length === 1) {\n                return untypedDatasets[0];\n            } else {\n                _addIssue(this, \"type\", dataset, config2, {\n                    issues: _subIssues(untypedDatasets)\n                });\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/unknown/unknown.ts\nfunction unknown() {\n    return {\n        kind: \"schema\",\n        type: \"unknown\",\n        reference: unknown,\n        expects: \"unknown\",\n        async: false,\n        _run (dataset) {\n            dataset.typed = true;\n            return dataset;\n        }\n    };\n}\n// src/schemas/variant/utils/_discriminators/_discriminators.ts\nfunction _discriminators(key, options, set2 = /* @__PURE__ */ new Set()) {\n    for (const schema of options){\n        if (schema.type === \"variant\") {\n            _discriminators(key, schema.options, set2);\n        } else {\n            set2.add(schema.entries[key].expects);\n        }\n    }\n    return set2;\n}\n// src/schemas/variant/variant.ts\nfunction variant(key, options, message) {\n    let expectedDiscriminators;\n    return {\n        kind: \"schema\",\n        type: \"variant\",\n        reference: variant,\n        expects: \"Object\",\n        async: false,\n        key,\n        options,\n        message,\n        _run (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                const discriminator = input[this.key];\n                if (this.key in input) {\n                    let outputDataset;\n                    for (const schema of this.options){\n                        if (schema.type === \"variant\" || !schema.entries[this.key]._run({\n                            typed: false,\n                            value: discriminator\n                        }, config2).issues) {\n                            const optionDataset = schema._run({\n                                typed: false,\n                                value: input\n                            }, config2);\n                            if (!optionDataset.issues) {\n                                return optionDataset;\n                            }\n                            if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                                outputDataset = optionDataset;\n                            }\n                        }\n                    }\n                    if (outputDataset) {\n                        return outputDataset;\n                    }\n                }\n                if (!expectedDiscriminators) {\n                    expectedDiscriminators = [\n                        ..._discriminators(this.key, this.options)\n                    ].join(\" | \") || \"never\";\n                }\n                _addIssue(this, \"type\", dataset, config2, {\n                    input: discriminator,\n                    expected: expectedDiscriminators,\n                    path: [\n                        {\n                            type: \"object\",\n                            origin: \"value\",\n                            input,\n                            key: this.key,\n                            value: discriminator\n                        }\n                    ]\n                });\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/variant/variantAsync.ts\nfunction variantAsync(key, options, message) {\n    let expectedDiscriminators;\n    return {\n        kind: \"schema\",\n        type: \"variant\",\n        reference: variantAsync,\n        expects: \"Object\",\n        async: true,\n        key,\n        options,\n        message,\n        async _run (dataset, config2) {\n            const input = dataset.value;\n            if (input && typeof input === \"object\") {\n                const discriminator = input[this.key];\n                if (this.key in input) {\n                    let outputDataset;\n                    for (const schema of this.options){\n                        if (schema.type === \"variant\" || !(await schema.entries[this.key]._run({\n                            typed: false,\n                            value: discriminator\n                        }, config2)).issues) {\n                            const optionDataset = await schema._run({\n                                typed: false,\n                                value: input\n                            }, config2);\n                            if (!optionDataset.issues) {\n                                return optionDataset;\n                            }\n                            if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                                outputDataset = optionDataset;\n                            }\n                        }\n                    }\n                    if (outputDataset) {\n                        return outputDataset;\n                    }\n                }\n                if (!expectedDiscriminators) {\n                    expectedDiscriminators = [\n                        ..._discriminators(this.key, this.options)\n                    ].join(\" | \") || \"never\";\n                }\n                _addIssue(this, \"type\", dataset, config2, {\n                    input: discriminator,\n                    expected: expectedDiscriminators,\n                    path: [\n                        {\n                            type: \"object\",\n                            origin: \"value\",\n                            input,\n                            key: this.key,\n                            value: discriminator\n                        }\n                    ]\n                });\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/schemas/void/void.ts\nfunction void_(message) {\n    return {\n        kind: \"schema\",\n        type: \"void\",\n        reference: void_,\n        expects: \"void\",\n        async: false,\n        message,\n        _run (dataset, config2) {\n            if (dataset.value === void 0) {\n                dataset.typed = true;\n            } else {\n                _addIssue(this, \"type\", dataset, config2);\n            }\n            return dataset;\n        }\n    };\n}\n// src/methods/keyof/keyof.ts\nfunction keyof(schema, message) {\n    return picklist(Object.keys(schema.entries), message);\n}\n// src/methods/omit/omit.ts\nfunction omit(schema, keys) {\n    const entries = {\n        ...schema.entries\n    };\n    for (const key of keys){\n        delete entries[key];\n    }\n    return {\n        ...schema,\n        entries\n    };\n}\n// src/methods/parse/parse.ts\nfunction parse(schema, input, config2) {\n    const dataset = schema._run({\n        typed: false,\n        value: input\n    }, getGlobalConfig(config2));\n    if (dataset.issues) {\n        throw new ValiError(dataset.issues);\n    }\n    return dataset.value;\n}\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, config2) {\n    const dataset = await schema._run({\n        typed: false,\n        value: input\n    }, getGlobalConfig(config2));\n    if (dataset.issues) {\n        throw new ValiError(dataset.issues);\n    }\n    return dataset.value;\n}\n// src/methods/parser/parser.ts\nfunction parser(schema, config2) {\n    const func = (input)=>parse(schema, input, config2);\n    func.schema = schema;\n    func.config = config2;\n    return func;\n}\n// src/methods/parser/parserAsync.ts\nfunction parserAsync(schema, config2) {\n    const func = (input)=>parseAsync(schema, input, config2);\n    func.schema = schema;\n    func.config = config2;\n    return func;\n}\n// src/methods/partial/partial.ts\nfunction partial(schema, keys) {\n    const entries = {};\n    for(const key in schema.entries){\n        entries[key] = !keys || keys.includes(key) ? optional(schema.entries[key]) : schema.entries[key];\n    }\n    return {\n        ...schema,\n        entries\n    };\n}\n// src/methods/partial/partialAsync.ts\nfunction partialAsync(schema, keys) {\n    const entries = {};\n    for(const key in schema.entries){\n        entries[key] = !keys || keys.includes(key) ? optionalAsync(schema.entries[key]) : schema.entries[key];\n    }\n    return {\n        ...schema,\n        entries\n    };\n}\n// src/methods/pick/pick.ts\nfunction pick(schema, keys) {\n    const entries = {};\n    for (const key of keys){\n        entries[key] = schema.entries[key];\n    }\n    return {\n        ...schema,\n        entries\n    };\n}\n// src/methods/pipe/pipe.ts\nfunction pipe(...pipe2) {\n    return {\n        ...pipe2[0],\n        pipe: pipe2,\n        _run (dataset, config2) {\n            for(let index = 0; index < pipe2.length; index++){\n                if (dataset.issues && (pipe2[index].kind === \"schema\" || pipe2[index].kind === \"transformation\")) {\n                    dataset.typed = false;\n                    break;\n                }\n                if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n                    dataset = pipe2[index]._run(dataset, config2);\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/methods/pipe/pipeAsync.ts\nfunction pipeAsync(...pipe2) {\n    return {\n        ...pipe2[0],\n        pipe: pipe2,\n        async: true,\n        async _run (dataset, config2) {\n            for(let index = 0; index < pipe2.length; index++){\n                if (dataset.issues && (pipe2[index].kind === \"schema\" || pipe2[index].kind === \"transformation\")) {\n                    dataset.typed = false;\n                    break;\n                }\n                if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n                    dataset = await pipe2[index]._run(dataset, config2);\n                }\n            }\n            return dataset;\n        }\n    };\n}\n// src/methods/required/required.ts\nfunction required(schema, arg2, arg3) {\n    const keys = Array.isArray(arg2) ? arg2 : void 0;\n    const message = Array.isArray(arg2) ? arg3 : arg2;\n    const entries = {};\n    for(const key in schema.entries){\n        entries[key] = !keys || keys.includes(key) ? nonOptional(schema.entries[key], message) : schema.entries[key];\n    }\n    return {\n        ...schema,\n        entries\n    };\n}\n// src/methods/required/requiredAsync.ts\nfunction requiredAsync(schema, arg2, arg3) {\n    const keys = Array.isArray(arg2) ? arg2 : void 0;\n    const message = Array.isArray(arg2) ? arg3 : arg2;\n    const entries = {};\n    for(const key in schema.entries){\n        entries[key] = !keys || keys.includes(key) ? nonOptionalAsync(schema.entries[key], message) : schema.entries[key];\n    }\n    return {\n        ...schema,\n        entries\n    };\n}\n// src/methods/safeParse/safeParse.ts\nfunction safeParse(schema, input, config2) {\n    const dataset = schema._run({\n        typed: false,\n        value: input\n    }, getGlobalConfig(config2));\n    return {\n        typed: dataset.typed,\n        success: !dataset.issues,\n        output: dataset.value,\n        issues: dataset.issues\n    };\n}\n// src/methods/safeParse/safeParseAsync.ts\nasync function safeParseAsync(schema, input, config2) {\n    const dataset = await schema._run({\n        typed: false,\n        value: input\n    }, getGlobalConfig(config2));\n    return {\n        typed: dataset.typed,\n        success: !dataset.issues,\n        output: dataset.value,\n        issues: dataset.issues\n    };\n}\n// src/methods/safeParser/safeParser.ts\nfunction safeParser(schema, config2) {\n    const func = (input)=>safeParse(schema, input, config2);\n    func.schema = schema;\n    func.config = config2;\n    return func;\n}\n// src/methods/safeParser/safeParserAsync.ts\nfunction safeParserAsync(schema, config2) {\n    const func = (input)=>safeParseAsync(schema, input, config2);\n    func.schema = schema;\n    func.config = config2;\n    return func;\n}\n// src/methods/unwrap/unwrap.ts\nfunction unwrap(schema) {\n    return schema.wrapped;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vdmFsaWJvdEAwLjM2LjAvbm9kZV9tb2R1bGVzL3ZhbGlib3QvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxrQ0FBa0M7QUFDbEMsU0FBU0E7SUFDUCxPQUFPO1FBQ0xDLE1BQU07UUFDTkMsTUFBTTtRQUNOQyxXQUFXSDtRQUNYSSxPQUFPO1FBQ1AsTUFBTUMsTUFBS0MsT0FBTztZQUNoQkEsUUFBUUMsS0FBSyxHQUFHLE1BQU1ELFFBQVFDLEtBQUs7WUFDbkMsT0FBT0Q7UUFDVDtJQUNGO0FBQ0Y7QUFFQSxlQUFlO0FBQ2YsSUFBSUUsWUFBWTtBQUNoQixJQUFJQyxjQUFjO0FBQ2xCLElBQUlDLGdCQUFnQjtBQUNwQixJQUFJQyxjQUFjO0FBQ2xCLElBQUlDLGNBQWM7QUFDbEIsSUFBSUMsb0JBQW9CO0FBQ3hCLElBQUlDLGtCQUFrQjtBQUN0QixJQUFJQyxhQUFhO0FBQ2pCLElBQUlDLGFBQ0YsNEVBQTRFO0FBQzVFO0FBRUYsSUFBSUMsYUFBYTtBQUNqQixJQUFJQyxXQUFXO0FBQ2YsSUFBSUMsaUJBQWlCO0FBQ3JCLElBQUlDLHNCQUFzQjtBQUMxQixJQUFJQyxpQkFBaUI7QUFDckIsSUFBSUMsd0JBQXdCO0FBQzVCLElBQUlDLHNCQUFzQjtBQUMxQixJQUFJQyxpQkFBaUI7QUFDckIsSUFBSUMsY0FBYztBQUNsQixJQUFJQyxjQUFjO0FBQ2xCLElBQUlDLFlBQVk7QUFDaEIsSUFB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TUFBTXFGLE9BQU90RixJQUFJLENBQy9CO1FBQUVxRSxPQUFPO1FBQU9uRSxPQUFPa0Q7SUFBTSxHQUM3QnZCLGdCQUFnQkQ7SUFFbEIsT0FBTztRQUNMeUMsT0FBT3BFLFFBQVFvRSxLQUFLO1FBQ3BCb1UsU0FBUyxDQUFDeFksUUFBUWtFLE1BQU07UUFDeEI0SSxRQUFROU0sUUFBUUMsS0FBSztRQUNyQmlFLFFBQVFsRSxRQUFRa0UsTUFBTTtJQUN4QjtBQUNGO0FBRUEsdUNBQXVDO0FBQ3ZDLFNBQVN3VSxXQUFXclQsTUFBTSxFQUFFMUQsT0FBTztJQUNqQyxNQUFNZ1csT0FBTyxDQUFDeFUsUUFBVW9WLFVBQVVsVCxRQUFRbEMsT0FBT3hCO0lBQ2pEZ1csS0FBS3RTLE1BQU0sR0FBR0E7SUFDZHNTLEtBQUtsTCxNQUFNLEdBQUc5SztJQUNkLE9BQU9nVztBQUNUO0FBRUEsNENBQTRDO0FBQzVDLFNBQVNnQixnQkFBZ0J0VCxNQUFNLEVBQUUxRCxPQUFPO0lBQ3RDLE1BQU1nVyxPQUFPLENBQUN4VSxRQUFVc1YsZUFBZXBULFFBQVFsQyxPQUFPeEI7SUFDdERnVyxLQUFLdFMsTUFBTSxHQUFHQTtJQUNkc1MsS0FBS2xMLE1BQU0sR0FBRzlLO0lBQ2QsT0FBT2dXO0FBQ1Q7QUFFQSwrQkFBK0I7QUFDL0IsU0FBU2lCLE9BQU92VCxNQUFNO0lBQ3BCLE9BQU9BLE9BQU91TyxPQUFPO0FBQ3ZCO0FBeU9FIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbm90YXNjYW0tcHJvdG9jb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vdmFsaWJvdEAwLjM2LjAvbm9kZV9tb2R1bGVzL3ZhbGlib3QvZGlzdC9pbmRleC5qcz9mYjk3Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9hY3Rpb25zL2F3YWl0L2F3YWl0QXN5bmMudHNcbmZ1bmN0aW9uIGF3YWl0QXN5bmMoKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHR5cGU6IFwiYXdhaXRcIixcbiAgICByZWZlcmVuY2U6IGF3YWl0QXN5bmMsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgYXN5bmMgX3J1bihkYXRhc2V0KSB7XG4gICAgICBkYXRhc2V0LnZhbHVlID0gYXdhaXQgZGF0YXNldC52YWx1ZTtcbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3JlZ2V4LnRzXG52YXIgQklDX1JFR0VYID0gL15bQS1aXXs2fSg/ITAwKVtBLVpcXGRdezJ9KD86W0EtWlxcZF17M30pPyQvdTtcbnZhciBDVUlEMl9SRUdFWCA9IC9eW2Etel1bXFxkYS16XSokL3U7XG52YXIgREVDSU1BTF9SRUdFWCA9IC9eXFxkKyQvdTtcbnZhciBFTUFJTF9SRUdFWCA9IC9eW1xcdystXSsoPzpcXC5bXFx3Ky1dKykqQFtcXGRhLXpdKyg/OlsuLV1bXFxkYS16XSspKlxcLlthLXpdezIsfSQvaXU7XG52YXIgRU1PSklfUkVHRVggPSAvXltcXHB7RXh0ZW5kZWRfUGljdG9ncmFwaGljfVxccHtFbW9qaV9Db21wb25lbnR9XSskL3U7XG52YXIgSEVYQURFQ0lNQUxfUkVHRVggPSAvXig/OjBofDB4KT9bXFxkYS1mXSskL2l1O1xudmFyIEhFWF9DT0xPUl9SRUdFWCA9IC9eIyg/OltcXGRhLWZdezMsNH18W1xcZGEtZl17Nn18W1xcZGEtZl17OH0pJC9pdTtcbnZhciBJTUVJX1JFR0VYID0gL15cXGR7MTV9JHxeXFxkezJ9LVxcZHs2fS1cXGR7Nn0tXFxkJC91O1xudmFyIElQVjRfUkVHRVggPSAoXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWRvcy1kZXRlY3Rvci9uby11bnNhZmUtcmVnZXggLS0gZmFsc2UgcG9zaXRpdmVcbiAgL14oPzooPzpbMS05XXwxXFxkfDJbMC00XSk/XFxkfDI1WzAtNV0pKD86XFwuKD86KD86WzEtOV18MVxcZHwyWzAtNF0pP1xcZHwyNVswLTVdKSl7M30kL3Vcbik7XG52YXIgSVBWNl9SRUdFWCA9IC9eKD86KD86W1xcZGEtZl17MSw0fTopezd9W1xcZGEtZl17MSw0fXwoPzpbXFxkYS1mXXsxLDR9Oil7MSw3fTp8KD86W1xcZGEtZl17MSw0fTopezEsNn06W1xcZGEtZl17MSw0fXwoPzpbXFxkYS1mXXsxLDR9Oil7MSw1fSg/OjpbXFxkYS1mXXsxLDR9KXsxLDJ9fCg/OltcXGRhLWZdezEsNH06KXsxLDR9KD86OltcXGRhLWZdezEsNH0pezEsM318KD86W1xcZGEtZl17MSw0fTopezEsM30oPzo6W1xcZGEtZl17MSw0fSl7MSw0fXwoPzpbXFxkYS1mXXsxLDR9Oil7MSwyfSg/OjpbXFxkYS1mXXsxLDR9KXsxLDV9fFtcXGRhLWZdezEsNH06KD86OltcXGRhLWZdezEsNH0pezEsNn18Oig/Oig/OjpbXFxkYS1mXXsxLDR9KXsxLDd9fDopfGZlODA6KD86OltcXGRhLWZdezAsNH0pezAsNH0lW1xcZGEtel0rfDo6KD86Zns0fSg/OjowezEsNH0pPzopPyg/Oig/OjI1WzAtNV18KD86MlswLTRdfDE/XFxkKT9cXGQpXFwuKXszfSg/OjI1WzAtNV18KD86MlswLTRdfDE/XFxkKT9cXGQpfCg/OltcXGRhLWZdezEsNH06KXsxLDR9Oig/Oig/OjI1WzAtNV18KD86MlswLTRdfDE/XFxkKT9cXGQpXFwuKXszfSg/OjI1WzAtNV18KD86MlswLTRdfDE/XFxkKT9cXGQpKSQvaXU7XG52YXIgSVBfUkVHRVggPSAvXig/Oig/OlsxLTldfDFcXGR8MlswLTRdKT9cXGR8MjVbMC01XSkoPzpcXC4oPzooPzpbMS05XXwxXFxkfDJbMC00XSk/XFxkfDI1WzAtNV0pKXszfSR8Xig/Oig/OltcXGRhLWZdezEsNH06KXs3fVtcXGRhLWZdezEsNH18KD86W1xcZGEtZl17MSw0fTopezEsN306fCg/OltcXGRhLWZdezEsNH06KXsxLDZ9OltcXGRhLWZdezEsNH18KD86W1xcZGEtZl17MSw0fTopezEsNX0oPzo6W1xcZGEtZl17MSw0fSl7MSwyfXwoPzpbXFxkYS1mXXsxLDR9Oil7MSw0fSg/OjpbXFxkYS1mXXsxLDR9KXsxLDN9fCg/OltcXGRhLWZdezEsNH06KXsxLDN9KD86OltcXGRhLWZdezEsNH0pezEsNH18KD86W1xcZGEtZl17MSw0fTopezEsMn0oPzo6W1xcZGEtZl17MSw0fSl7MSw1fXxbXFxkYS1mXXsxLDR9Oig/OjpbXFxkYS1mXXsxLDR9KXsxLDZ9fDooPzooPzo6W1xcZGEtZl17MSw0fSl7MSw3fXw6KXxmZTgwOig/OjpbXFxkYS1mXXswLDR9KXswLDR9JVtcXGRhLXpdK3w6Oig/OmZ7NH0oPzo6MHsxLDR9KT86KT8oPzooPzoyNVswLTVdfCg/OjJbMC00XXwxP1xcZCk/XFxkKVxcLil7M30oPzoyNVswLTVdfCg/OjJbMC00XXwxP1xcZCk/XFxkKXwoPzpbXFxkYS1mXXsxLDR9Oil7MSw0fTooPzooPzoyNVswLTVdfCg/OjJbMC00XXwxP1xcZCk/XFxkKVxcLil7M30oPzoyNVswLTVdfCg/OjJbMC00XXwxP1xcZCk/XFxkKSkkL2l1O1xudmFyIElTT19EQVRFX1JFR0VYID0gL15cXGR7NH0tKD86MFsxLTldfDFbMC0yXSktKD86WzEyXVxcZHwwWzEtOV18M1swMV0pJC91O1xudmFyIElTT19EQVRFX1RJTUVfUkVHRVggPSAvXlxcZHs0fS0oPzowWzEtOV18MVswLTJdKS0oPzpbMTJdXFxkfDBbMS05XXwzWzAxXSlUKD86MFxcZHwxXFxkfDJbMC0zXSk6WzAtNV1cXGQkL3U7XG52YXIgSVNPX1RJTUVfUkVHRVggPSAvXig/OjBcXGR8MVxcZHwyWzAtM10pOlswLTVdXFxkJC91O1xudmFyIElTT19USU1FX1NFQ09ORF9SRUdFWCA9IC9eKD86MFxcZHwxXFxkfDJbMC0zXSkoPzo6WzAtNV1cXGQpezJ9JC91O1xudmFyIElTT19USU1FU1RBTVBfUkVHRVggPSAvXlxcZHs0fS0oPzowWzEtOV18MVswLTJdKS0oPzpbMTJdXFxkfDBbMS05XXwzWzAxXSlUKD86MFxcZHwxXFxkfDJbMC0zXSkoPzo6WzAtNV1cXGQpezJ9KD86XFwuXFxkezEsOX0pPyg/Olp8WystXSg/OjBcXGR8MVxcZHwyWzAtM10pKD86Oj9bMC01XVxcZCk/KSQvdTtcbnZhciBJU09fV0VFS19SRUdFWCA9IC9eXFxkezR9LVcoPzowWzEtOV18WzEtNF1cXGR8NVswLTNdKSQvdTtcbnZhciBNQUM0OF9SRUdFWCA9IC9eKD86W1xcZGEtZl17Mn06KXs1fVtcXGRhLWZdezJ9JHxeKD86W1xcZGEtZl17Mn0tKXs1fVtcXGRhLWZdezJ9JHxeKD86W1xcZGEtZl17NH1cXC4pezJ9W1xcZGEtZl17NH0kL2l1O1xudmFyIE1BQzY0X1JFR0VYID0gL14oPzpbXFxkYS1mXXsyfTopezd9W1xcZGEtZl17Mn0kfF4oPzpbXFxkYS1mXXsyfS0pezd9W1xcZGEtZl17Mn0kfF4oPzpbXFxkYS1mXXs0fVxcLil7M31bXFxkYS1mXXs0fSR8Xig/OltcXGRhLWZdezR9Oil7M31bXFxkYS1mXXs0fSQvaXU7XG52YXIgTUFDX1JFR0VYID0gL14oPzpbXFxkYS1mXXsyfTopezV9W1xcZGEtZl17Mn0kfF4oPzpbXFxkYS1mXXsyfS0pezV9W1xcZGEtZl17Mn0kfF4oPzpbXFxkYS1mXXs0fVxcLil7Mn1bXFxkYS1mXXs0fSR8Xig/OltcXGRhLWZdezJ9Oil7N31bXFxkYS1mXXsyfSR8Xig/OltcXGRhLWZdezJ9LSl7N31bXFxkYS1mXXsyfSR8Xig/OltcXGRhLWZdezR9XFwuKXszfVtcXGRhLWZdezR9JHxeKD86W1xcZGEtZl17NH06KXszfVtcXGRhLWZdezR9JC9pdTtcbnZhciBPQ1RBTF9SRUdFWCA9IC9eKD86MG8pP1swLTddKyQvaXU7XG52YXIgVUxJRF9SRUdFWCA9IC9eW1xcZGEtaGprbW5wLXR2LXpdezI2fSQvaXU7XG52YXIgVVVJRF9SRUdFWCA9IC9eW1xcZGEtZl17OH0oPzotW1xcZGEtZl17NH0pezN9LVtcXGRhLWZdezEyfSQvaXU7XG5cbi8vIHNyYy9zdG9yYWdlcy9nbG9iYWxDb25maWcvZ2xvYmFsQ29uZmlnLnRzXG52YXIgc3RvcmU7XG5mdW5jdGlvbiBzZXRHbG9iYWxDb25maWcoY29uZmlnMikge1xuICBzdG9yZSA9IHsgLi4uc3RvcmUsIC4uLmNvbmZpZzIgfTtcbn1cbmZ1bmN0aW9uIGdldEdsb2JhbENvbmZpZyhjb25maWcyKSB7XG4gIHJldHVybiB7XG4gICAgbGFuZzogY29uZmlnMj8ubGFuZyA/PyBzdG9yZT8ubGFuZyxcbiAgICBtZXNzYWdlOiBjb25maWcyPy5tZXNzYWdlLFxuICAgIGFib3J0RWFybHk6IGNvbmZpZzI/LmFib3J0RWFybHkgPz8gc3RvcmU/LmFib3J0RWFybHksXG4gICAgYWJvcnRQaXBlRWFybHk6IGNvbmZpZzI/LmFib3J0UGlwZUVhcmx5ID8/IHN0b3JlPy5hYm9ydFBpcGVFYXJseVxuICB9O1xufVxuZnVuY3Rpb24gZGVsZXRlR2xvYmFsQ29uZmlnKCkge1xuICBzdG9yZSA9IHZvaWQgMDtcbn1cblxuLy8gc3JjL3N0b3JhZ2VzL2dsb2JhbE1lc3NhZ2UvZ2xvYmFsTWVzc2FnZS50c1xudmFyIHN0b3JlMjtcbmZ1bmN0aW9uIHNldEdsb2JhbE1lc3NhZ2UobWVzc2FnZSwgbGFuZykge1xuICBpZiAoIXN0b3JlMikgc3RvcmUyID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgc3RvcmUyLnNldChsYW5nLCBtZXNzYWdlKTtcbn1cbmZ1bmN0aW9uIGdldEdsb2JhbE1lc3NhZ2UobGFuZykge1xuICByZXR1cm4gc3RvcmUyPy5nZXQobGFuZyk7XG59XG5mdW5jdGlvbiBkZWxldGVHbG9iYWxNZXNzYWdlKGxhbmcpIHtcbiAgc3RvcmUyPy5kZWxldGUobGFuZyk7XG59XG5cbi8vIHNyYy9zdG9yYWdlcy9zY2hlbWFNZXNzYWdlL3NjaGVtYU1lc3NhZ2UudHNcbnZhciBzdG9yZTM7XG5mdW5jdGlvbiBzZXRTY2hlbWFNZXNzYWdlKG1lc3NhZ2UsIGxhbmcpIHtcbiAgaWYgKCFzdG9yZTMpIHN0b3JlMyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIHN0b3JlMy5zZXQobGFuZywgbWVzc2FnZSk7XG59XG5mdW5jdGlvbiBnZXRTY2hlbWFNZXNzYWdlKGxhbmcpIHtcbiAgcmV0dXJuIHN0b3JlMz8uZ2V0KGxhbmcpO1xufVxuZnVuY3Rpb24gZGVsZXRlU2NoZW1hTWVzc2FnZShsYW5nKSB7XG4gIHN0b3JlMz8uZGVsZXRlKGxhbmcpO1xufVxuXG4vLyBzcmMvc3RvcmFnZXMvc3BlY2lmaWNNZXNzYWdlL3NwZWNpZmljTWVzc2FnZS50c1xudmFyIHN0b3JlNDtcbmZ1bmN0aW9uIHNldFNwZWNpZmljTWVzc2FnZShyZWZlcmVuY2UsIG1lc3NhZ2UsIGxhbmcpIHtcbiAgaWYgKCFzdG9yZTQpIHN0b3JlNCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGlmICghc3RvcmU0LmdldChyZWZlcmVuY2UpKSBzdG9yZTQuc2V0KHJlZmVyZW5jZSwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gIHN0b3JlNC5nZXQocmVmZXJlbmNlKS5zZXQobGFuZywgbWVzc2FnZSk7XG59XG5mdW5jdGlvbiBnZXRTcGVjaWZpY01lc3NhZ2UocmVmZXJlbmNlLCBsYW5nKSB7XG4gIHJldHVybiBzdG9yZTQ/LmdldChyZWZlcmVuY2UpPy5nZXQobGFuZyk7XG59XG5mdW5jdGlvbiBkZWxldGVTcGVjaWZpY01lc3NhZ2UocmVmZXJlbmNlLCBsYW5nKSB7XG4gIHN0b3JlND8uZ2V0KHJlZmVyZW5jZSk/LmRlbGV0ZShsYW5nKTtcbn1cblxuLy8gc3JjL3V0aWxzL19zdHJpbmdpZnkvX3N0cmluZ2lmeS50c1xuZnVuY3Rpb24gX3N0cmluZ2lmeShpbnB1dCkge1xuICBjb25zdCB0eXBlID0gdHlwZW9mIGlucHV0O1xuICBpZiAodHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBgXCIke2lucHV0fVwiYDtcbiAgfVxuICBpZiAodHlwZSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlID09PSBcImJpZ2ludFwiIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgcmV0dXJuIGAke2lucHV0fWA7XG4gIH1cbiAgaWYgKHR5cGUgPT09IFwib2JqZWN0XCIgfHwgdHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIChpbnB1dCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoaW5wdXQpPy5jb25zdHJ1Y3Rvcj8ubmFtZSkgPz8gXCJudWxsXCI7XG4gIH1cbiAgcmV0dXJuIHR5cGU7XG59XG5cbi8vIHNyYy91dGlscy9fYWRkSXNzdWUvX2FkZElzc3VlLnRzXG5mdW5jdGlvbiBfYWRkSXNzdWUoY29udGV4dCwgbGFiZWwsIGRhdGFzZXQsIGNvbmZpZzIsIG90aGVyKSB7XG4gIGNvbnN0IGlucHV0ID0gb3RoZXIgJiYgXCJpbnB1dFwiIGluIG90aGVyID8gb3RoZXIuaW5wdXQgOiBkYXRhc2V0LnZhbHVlO1xuICBjb25zdCBleHBlY3RlZCA9IG90aGVyPy5leHBlY3RlZCA/PyBjb250ZXh0LmV4cGVjdHMgPz8gbnVsbDtcbiAgY29uc3QgcmVjZWl2ZWQgPSBvdGhlcj8ucmVjZWl2ZWQgPz8gX3N0cmluZ2lmeShpbnB1dCk7XG4gIGNvbnN0IGlzc3VlID0ge1xuICAgIGtpbmQ6IGNvbnRleHQua2luZCxcbiAgICB0eXBlOiBjb250ZXh0LnR5cGUsXG4gICAgaW5wdXQsXG4gICAgZXhwZWN0ZWQsXG4gICAgcmVjZWl2ZWQsXG4gICAgbWVzc2FnZTogYEludmFsaWQgJHtsYWJlbH06ICR7ZXhwZWN0ZWQgPyBgRXhwZWN0ZWQgJHtleHBlY3RlZH0gYnV0IHJgIDogXCJSXCJ9ZWNlaXZlZCAke3JlY2VpdmVkfWAsXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIHJlcXVpcmVtZW50OiBjb250ZXh0LnJlcXVpcmVtZW50LFxuICAgIHBhdGg6IG90aGVyPy5wYXRoLFxuICAgIGlzc3Vlczogb3RoZXI/Lmlzc3VlcyxcbiAgICBsYW5nOiBjb25maWcyLmxhbmcsXG4gICAgYWJvcnRFYXJseTogY29uZmlnMi5hYm9ydEVhcmx5LFxuICAgIGFib3J0UGlwZUVhcmx5OiBjb25maWcyLmFib3J0UGlwZUVhcmx5XG4gIH07XG4gIGNvbnN0IGlzU2NoZW1hID0gY29udGV4dC5raW5kID09PSBcInNjaGVtYVwiO1xuICBjb25zdCBtZXNzYWdlID0gb3RoZXI/Lm1lc3NhZ2UgPz8gLy8gQHRzLWV4cGVjdC1lcnJvclxuICBjb250ZXh0Lm1lc3NhZ2UgPz8gZ2V0U3BlY2lmaWNNZXNzYWdlKGNvbnRleHQucmVmZXJlbmNlLCBpc3N1ZS5sYW5nKSA/PyAoaXNTY2hlbWEgPyBnZXRTY2hlbWFNZXNzYWdlKGlzc3VlLmxhbmcpIDogbnVsbCkgPz8gY29uZmlnMi5tZXNzYWdlID8/IGdldEdsb2JhbE1lc3NhZ2UoaXNzdWUubGFuZyk7XG4gIGlmIChtZXNzYWdlKSB7XG4gICAgaXNzdWUubWVzc2FnZSA9IHR5cGVvZiBtZXNzYWdlID09PSBcImZ1bmN0aW9uXCIgPyBtZXNzYWdlKGlzc3VlKSA6IG1lc3NhZ2U7XG4gIH1cbiAgaWYgKGlzU2NoZW1hKSB7XG4gICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICB9XG4gIGlmIChkYXRhc2V0Lmlzc3Vlcykge1xuICAgIGRhdGFzZXQuaXNzdWVzLnB1c2goaXNzdWUpO1xuICB9IGVsc2Uge1xuICAgIGRhdGFzZXQuaXNzdWVzID0gW2lzc3VlXTtcbiAgfVxufVxuXG4vLyBzcmMvdXRpbHMvX2lzTHVobkFsZ28vX2lzTHVobkFsZ28udHNcbnZhciBOT05fRElHSVRfUkVHRVggPSAvXFxEL2d1O1xuZnVuY3Rpb24gX2lzTHVobkFsZ28oaW5wdXQpIHtcbiAgY29uc3QgbnVtYmVyMiA9IGlucHV0LnJlcGxhY2UoTk9OX0RJR0lUX1JFR0VYLCBcIlwiKTtcbiAgbGV0IGxlbmd0aDIgPSBudW1iZXIyLmxlbmd0aDtcbiAgbGV0IGJpdCA9IDE7XG4gIGxldCBzdW0gPSAwO1xuICB3aGlsZSAobGVuZ3RoMikge1xuICAgIGNvbnN0IHZhbHVlMiA9ICtudW1iZXIyWy0tbGVuZ3RoMl07XG4gICAgYml0IF49IDE7XG4gICAgc3VtICs9IGJpdCA/IFswLCAyLCA0LCA2LCA4LCAxLCAzLCA1LCA3LCA5XVt2YWx1ZTJdIDogdmFsdWUyO1xuICB9XG4gIHJldHVybiBzdW0gJSAxMCA9PT0gMDtcbn1cblxuLy8gc3JjL3V0aWxzL19pc1ZhbGlkT2JqZWN0S2V5L19pc1ZhbGlkT2JqZWN0S2V5LnRzXG5mdW5jdGlvbiBfaXNWYWxpZE9iamVjdEtleShvYmplY3QyLCBrZXkpIHtcbiAgcmV0dXJuIE9iamVjdC5oYXNPd24ob2JqZWN0Miwga2V5KSAmJiBrZXkgIT09IFwiX19wcm90b19fXCIgJiYga2V5ICE9PSBcInByb3RvdHlwZVwiICYmIGtleSAhPT0gXCJjb25zdHJ1Y3RvclwiO1xufVxuXG4vLyBzcmMvdXRpbHMvZW50cmllc0Zyb21MaXN0L2VudHJpZXNGcm9tTGlzdC50c1xuZnVuY3Rpb24gZW50cmllc0Zyb21MaXN0KGxpc3QsIHNjaGVtYSkge1xuICBjb25zdCBlbnRyaWVzID0ge307XG4gIGZvciAoY29uc3Qga2V5IG9mIGxpc3QpIHtcbiAgICBlbnRyaWVzW2tleV0gPSBzY2hlbWE7XG4gIH1cbiAgcmV0dXJuIGVudHJpZXM7XG59XG5cbi8vIHNyYy91dGlscy9nZXREb3RQYXRoL2dldERvdFBhdGgudHNcbmZ1bmN0aW9uIGdldERvdFBhdGgoaXNzdWUpIHtcbiAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICBsZXQga2V5ID0gXCJcIjtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXNzdWUucGF0aCkge1xuICAgICAgaWYgKHR5cGVvZiBpdGVtLmtleSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgaXRlbS5rZXkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgIGtleSArPSBgLiR7aXRlbS5rZXl9YDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBrZXkgKz0gaXRlbS5rZXk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBzcmMvdXRpbHMvaXNPZktpbmQvaXNPZktpbmQudHNcbmZ1bmN0aW9uIGlzT2ZLaW5kKGtpbmQsIG9iamVjdDIpIHtcbiAgcmV0dXJuIG9iamVjdDIua2luZCA9PT0ga2luZDtcbn1cblxuLy8gc3JjL3V0aWxzL2lzT2ZUeXBlL2lzT2ZUeXBlLnRzXG5mdW5jdGlvbiBpc09mVHlwZSh0eXBlLCBvYmplY3QyKSB7XG4gIHJldHVybiBvYmplY3QyLnR5cGUgPT09IHR5cGU7XG59XG5cbi8vIHNyYy91dGlscy9pc1ZhbGlFcnJvci9pc1ZhbGlFcnJvci50c1xuZnVuY3Rpb24gaXNWYWxpRXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgVmFsaUVycm9yO1xufVxuXG4vLyBzcmMvdXRpbHMvVmFsaUVycm9yL1ZhbGlFcnJvci50c1xudmFyIFZhbGlFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICAvKipcbiAgICogVGhlIGVycm9yIGlzc3Vlcy5cbiAgICovXG4gIGlzc3VlcztcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBWYWxpYm90IGVycm9yIHdpdGggdXNlZnVsIGluZm9ybWF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gaXNzdWVzIFRoZSBlcnJvciBpc3N1ZXMuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihpc3N1ZXMpIHtcbiAgICBzdXBlcihpc3N1ZXNbMF0ubWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gXCJWYWxpRXJyb3JcIjtcbiAgICB0aGlzLmlzc3VlcyA9IGlzc3VlcztcbiAgfVxufTtcblxuLy8gc3JjL2FjdGlvbnMvYmljL2JpYy50c1xuZnVuY3Rpb24gYmljKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImJpY1wiLFxuICAgIHJlZmVyZW5jZTogYmljLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBCSUNfUkVHRVgsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiQklDXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9icmFuZC9icmFuZC50c1xuZnVuY3Rpb24gYnJhbmQobmFtZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcImJyYW5kXCIsXG4gICAgcmVmZXJlbmNlOiBicmFuZCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbmFtZSxcbiAgICBfcnVuKGRhdGFzZXQpIHtcbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvYnl0ZXMvYnl0ZXMudHNcbmZ1bmN0aW9uIGJ5dGVzKHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJieXRlc1wiLFxuICAgIHJlZmVyZW5jZTogYnl0ZXMsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IGAke3JlcXVpcmVtZW50fWAsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aDIgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoZGF0YXNldC52YWx1ZSkubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoMiAhPT0gdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImJ5dGVzXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICAgIHJlY2VpdmVkOiBgJHtsZW5ndGgyfWBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9jaGVjay9jaGVjay50c1xuZnVuY3Rpb24gY2hlY2socmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImNoZWNrXCIsXG4gICAgcmVmZXJlbmNlOiBjaGVjayxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiaW5wdXRcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2NoZWNrL2NoZWNrQXN5bmMudHNcbmZ1bmN0aW9uIGNoZWNrQXN5bmMocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImNoZWNrXCIsXG4gICAgcmVmZXJlbmNlOiBjaGVja0FzeW5jLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBhc3luYyBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICFhd2FpdCB0aGlzLnJlcXVpcmVtZW50KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImlucHV0XCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9jaGVja0l0ZW1zL2NoZWNrSXRlbXMudHNcbmZ1bmN0aW9uIGNoZWNrSXRlbXMocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImNoZWNrX2l0ZW1zXCIsXG4gICAgcmVmZXJlbmNlOiBjaGVja0l0ZW1zLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCkge1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgZGF0YXNldC52YWx1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBjb25zdCBpdGVtID0gZGF0YXNldC52YWx1ZVtpbmRleF07XG4gICAgICAgICAgaWYgKCF0aGlzLnJlcXVpcmVtZW50KGl0ZW0sIGluZGV4LCBkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiaXRlbVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgICAgIGlucHV0OiBpdGVtLFxuICAgICAgICAgICAgICBwYXRoOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dDogZGF0YXNldC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgIGtleTogaW5kZXgsXG4gICAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2NyZWRpdENhcmQvY3JlZGl0Q2FyZC50c1xudmFyIENSRURJVF9DQVJEX1JFR0VYID0gL14oPzpcXGR7MTQsMTl9fFxcZHs0fSg/OiBcXGR7Myw2fSl7Miw0fXxcXGR7NH0oPzotXFxkezMsNn0pezIsNH0pJC91O1xudmFyIFNBTklUSVpFX1JFR0VYID0gL1stIF0vZ3U7XG52YXIgUFJPVklERVJfUkVHRVhfTElTVCA9IFtcbiAgLy8gQW1lcmljYW4gRXhwcmVzc1xuICAvXjNbNDddXFxkezEzfSQvdSxcbiAgLy8gRGluZXJzIENsdWJcbiAgL14zKD86MFswLTVdfFs2OF1cXGQpXFxkezExLDEzfSQvdSxcbiAgLy8gRGlzY292ZXJcbiAgL142KD86MDExfDVcXGR7Mn0pXFxkezEyLDE1fSQvdSxcbiAgLy8gSkNCXG4gIC9eKD86MjEzMXwxODAwfDM1XFxkezN9KVxcZHsxMX0kL3UsXG4gIC8vIE1hc3RlcmNhcmRcbiAgL141WzEtNV1cXGR7Mn18KD86MjIyXFxkfDIyWzMtOV1cXGR8MlszLTZdXFxkezJ9fDI3WzAxXVxcZHwyNzIwKVxcZHsxMn0kL3UsXG4gIC8vIFVuaW9uUGF5XG4gIC9eKD86NlsyN11cXGR7MTQsMTd9fDgxXFxkezE0LDE3fSkkL3UsXG4gIC8vIFZpc2FcbiAgL140XFxkezEyfSg/OlxcZHszLDZ9KT8kL3Vcbl07XG5mdW5jdGlvbiBjcmVkaXRDYXJkKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImNyZWRpdF9jYXJkXCIsXG4gICAgcmVmZXJlbmNlOiBjcmVkaXRDYXJkLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50KGlucHV0KSB7XG4gICAgICBsZXQgc2FuaXRpemVkO1xuICAgICAgcmV0dXJuIENSRURJVF9DQVJEX1JFR0VYLnRlc3QoaW5wdXQpICYmIC8vIFJlbW92ZSBhbnkgaHlwaGVucyBhbmQgYmxhbmtzXG4gICAgICAoc2FuaXRpemVkID0gaW5wdXQucmVwbGFjZShTQU5JVElaRV9SRUdFWCwgXCJcIikpICYmIC8vIENoZWNrIGlmIGl0IG1hdGNoZXMgYSBwcm92aWRlclxuICAgICAgUFJPVklERVJfUkVHRVhfTElTVC5zb21lKChyZWdleDIpID0+IHJlZ2V4Mi50ZXN0KHNhbml0aXplZCkpICYmIC8vIENoZWNrIGlmIHBhc3NlcyBsdWhuIGFsZ29yaXRobVxuICAgICAgX2lzTHVobkFsZ28oc2FuaXRpemVkKTtcbiAgICB9LFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJjcmVkaXQgY2FyZFwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvY3VpZDIvY3VpZDIudHNcbmZ1bmN0aW9uIGN1aWQyKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImN1aWQyXCIsXG4gICAgcmVmZXJlbmNlOiBjdWlkMixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogQ1VJRDJfUkVHRVgsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiQ3VpZDJcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2RlY2ltYWwvZGVjaW1hbC50c1xuZnVuY3Rpb24gZGVjaW1hbChtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJkZWNpbWFsXCIsXG4gICAgcmVmZXJlbmNlOiBkZWNpbWFsLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBERUNJTUFMX1JFR0VYLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImRlY2ltYWxcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2VtYWlsL2VtYWlsLnRzXG5mdW5jdGlvbiBlbWFpbChtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJlbWFpbFwiLFxuICAgIHJlZmVyZW5jZTogZW1haWwsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgcmVxdWlyZW1lbnQ6IEVNQUlMX1JFR0VYLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImVtYWlsXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9lbW9qaS9lbW9qaS50c1xuZnVuY3Rpb24gZW1vamkobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwiZW1vamlcIixcbiAgICByZWZlcmVuY2U6IGVtb2ppLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBFTU9KSV9SRUdFWCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQudGVzdChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJlbW9qaVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvZW1wdHkvZW1wdHkudHNcbmZ1bmN0aW9uIGVtcHR5KG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImVtcHR5XCIsXG4gICAgcmVmZXJlbmNlOiBlbXB0eSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogXCIwXCIsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmIGRhdGFzZXQudmFsdWUubGVuZ3RoID4gMCkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJsZW5ndGhcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIHJlY2VpdmVkOiBgJHtkYXRhc2V0LnZhbHVlLmxlbmd0aH1gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9lbmRzV2l0aC9lbmRzV2l0aC50c1xuZnVuY3Rpb24gZW5kc1dpdGgocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImVuZHNfd2l0aFwiLFxuICAgIHJlZmVyZW5jZTogZW5kc1dpdGgsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IGBcIiR7cmVxdWlyZW1lbnR9XCJgLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhZGF0YXNldC52YWx1ZS5lbmRzV2l0aCh0aGlzLnJlcXVpcmVtZW50KSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJlbmRcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIHJlY2VpdmVkOiBgXCIke2RhdGFzZXQudmFsdWUuc2xpY2UoLXRoaXMucmVxdWlyZW1lbnQubGVuZ3RoKX1cImBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2V2ZXJ5SXRlbS9ldmVyeUl0ZW0udHNcbmZ1bmN0aW9uIGV2ZXJ5SXRlbShyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwiZXZlcnlfaXRlbVwiLFxuICAgIHJlZmVyZW5jZTogZXZlcnlJdGVtLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhZGF0YXNldC52YWx1ZS5ldmVyeSh0aGlzLnJlcXVpcmVtZW50KSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJpdGVtXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9leGNsdWRlcy9leGNsdWRlcy50c1xuZnVuY3Rpb24gZXhjbHVkZXMocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgY29uc3QgcmVjZWl2ZWQgPSBfc3RyaW5naWZ5KHJlcXVpcmVtZW50KTtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImV4Y2x1ZGVzXCIsXG4gICAgcmVmZXJlbmNlOiBleGNsdWRlcyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogYCEke3JlY2VpdmVkfWAsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmIGRhdGFzZXQudmFsdWUuaW5jbHVkZXModGhpcy5yZXF1aXJlbWVudCkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiY29udGVudFwiLCBkYXRhc2V0LCBjb25maWcyLCB7IHJlY2VpdmVkIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9maWx0ZXJJdGVtcy9maWx0ZXJJdGVtcy50c1xuZnVuY3Rpb24gZmlsdGVySXRlbXMob3BlcmF0aW9uKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHR5cGU6IFwiZmlsdGVyX2l0ZW1zXCIsXG4gICAgcmVmZXJlbmNlOiBmaWx0ZXJJdGVtcyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgb3BlcmF0aW9uLFxuICAgIF9ydW4oZGF0YXNldCkge1xuICAgICAgZGF0YXNldC52YWx1ZSA9IGRhdGFzZXQudmFsdWUuZmlsdGVyKHRoaXMub3BlcmF0aW9uKTtcbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvZmluZEl0ZW0vZmluZEl0ZW0udHNcbmZ1bmN0aW9uIGZpbmRJdGVtKG9wZXJhdGlvbikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcImZpbmRfaXRlbVwiLFxuICAgIHJlZmVyZW5jZTogZmluZEl0ZW0sXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG9wZXJhdGlvbixcbiAgICBfcnVuKGRhdGFzZXQpIHtcbiAgICAgIGRhdGFzZXQudmFsdWUgPSBkYXRhc2V0LnZhbHVlLmZpbmQodGhpcy5vcGVyYXRpb24pO1xuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9maW5pdGUvZmluaXRlLnRzXG5mdW5jdGlvbiBmaW5pdGUobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwiZmluaXRlXCIsXG4gICAgcmVmZXJlbmNlOiBmaW5pdGUsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQ6IE51bWJlci5pc0Zpbml0ZSxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiZmluaXRlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9oYXNoL2hhc2gudHNcbnZhciBIQVNIX0xFTkdUSFMgPSB7XG4gIG1kNDogMzIsXG4gIG1kNTogMzIsXG4gIHNoYTE6IDQwLFxuICBzaGEyNTY6IDY0LFxuICBzaGEzODQ6IDk2LFxuICBzaGE1MTI6IDEyOCxcbiAgcmlwZW1kMTI4OiAzMixcbiAgcmlwZW1kMTYwOiA0MCxcbiAgdGlnZXIxMjg6IDMyLFxuICB0aWdlcjE2MDogNDAsXG4gIHRpZ2VyMTkyOiA0OCxcbiAgY3JjMzI6IDgsXG4gIGNyYzMyYjogOCxcbiAgYWRsZXIzMjogOFxufTtcbmZ1bmN0aW9uIGhhc2godHlwZXMsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImhhc2hcIixcbiAgICByZWZlcmVuY2U6IGhhc2gsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgcmVxdWlyZW1lbnQ6IFJlZ0V4cChcbiAgICAgIHR5cGVzLm1hcCgodHlwZSkgPT4gYF5bYS1mMC05XXske0hBU0hfTEVOR1RIU1t0eXBlXX19JGApLmpvaW4oXCJ8XCIpLFxuICAgICAgXCJpdVwiXG4gICAgKSxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQudGVzdChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJoYXNoXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9oZXhhZGVjaW1hbC9oZXhhZGVjaW1hbC50c1xuZnVuY3Rpb24gaGV4YWRlY2ltYWwobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwiaGV4YWRlY2ltYWxcIixcbiAgICByZWZlcmVuY2U6IGhleGFkZWNpbWFsLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBIRVhBREVDSU1BTF9SRUdFWCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQudGVzdChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJoZXhhZGVjaW1hbFwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvaGV4Q29sb3IvaGV4Q29sb3IudHNcbmZ1bmN0aW9uIGhleENvbG9yKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImhleF9jb2xvclwiLFxuICAgIHJlZmVyZW5jZTogaGV4Q29sb3IsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQ6IEhFWF9DT0xPUl9SRUdFWCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQudGVzdChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJoZXggY29sb3JcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2ltZWkvaW1laS50c1xuZnVuY3Rpb24gaW1laShtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJpbWVpXCIsXG4gICAgcmVmZXJlbmNlOiBpbWVpLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50KGlucHV0KSB7XG4gICAgICByZXR1cm4gSU1FSV9SRUdFWC50ZXN0KGlucHV0KSAmJiBfaXNMdWhuQWxnbyhpbnB1dCk7XG4gICAgfSxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiSU1FSVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvaW5jbHVkZXMvaW5jbHVkZXMudHNcbmZ1bmN0aW9uIGluY2x1ZGVzKHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIGNvbnN0IGV4cGVjdHMgPSBfc3RyaW5naWZ5KHJlcXVpcmVtZW50KTtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImluY2x1ZGVzXCIsXG4gICAgcmVmZXJlbmNlOiBpbmNsdWRlcyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0cyxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIWRhdGFzZXQudmFsdWUuaW5jbHVkZXModGhpcy5yZXF1aXJlbWVudCkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiY29udGVudFwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgcmVjZWl2ZWQ6IGAhJHtleHBlY3RzfWBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2ludGVnZXIvaW50ZWdlci50c1xuZnVuY3Rpb24gaW50ZWdlcihtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJpbnRlZ2VyXCIsXG4gICAgcmVmZXJlbmNlOiBpbnRlZ2VyLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBOdW1iZXIuaXNJbnRlZ2VyLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJpbnRlZ2VyXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9pcC9pcC50c1xuZnVuY3Rpb24gaXAobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwiaXBcIixcbiAgICByZWZlcmVuY2U6IGlwLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBJUF9SRUdFWCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQudGVzdChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJJUFwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvaXB2NC9pcHY0LnRzXG5mdW5jdGlvbiBpcHY0KG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImlwdjRcIixcbiAgICByZWZlcmVuY2U6IGlwdjQsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQ6IElQVjRfUkVHRVgsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiSVB2NFwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvaXB2Ni9pcHY2LnRzXG5mdW5jdGlvbiBpcHY2KG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImlwdjZcIixcbiAgICByZWZlcmVuY2U6IGlwdjYsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQ6IElQVjZfUkVHRVgsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiSVB2NlwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvaXNvRGF0ZS9pc29EYXRlLnRzXG5mdW5jdGlvbiBpc29EYXRlKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImlzb19kYXRlXCIsXG4gICAgcmVmZXJlbmNlOiBpc29EYXRlLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBJU09fREFURV9SRUdFWCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQudGVzdChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJkYXRlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9pc29EYXRlVGltZS9pc29EYXRlVGltZS50c1xuZnVuY3Rpb24gaXNvRGF0ZVRpbWUobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwiaXNvX2RhdGVfdGltZVwiLFxuICAgIHJlZmVyZW5jZTogaXNvRGF0ZVRpbWUsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQ6IElTT19EQVRFX1RJTUVfUkVHRVgsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiZGF0ZS10aW1lXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9pc29UaW1lL2lzb1RpbWUudHNcbmZ1bmN0aW9uIGlzb1RpbWUobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwiaXNvX3RpbWVcIixcbiAgICByZWZlcmVuY2U6IGlzb1RpbWUsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQ6IElTT19USU1FX1JFR0VYLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInRpbWVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2lzb1RpbWVTZWNvbmQvaXNvVGltZVNlY29uZC50c1xuZnVuY3Rpb24gaXNvVGltZVNlY29uZChtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJpc29fdGltZV9zZWNvbmRcIixcbiAgICByZWZlcmVuY2U6IGlzb1RpbWVTZWNvbmQsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQ6IElTT19USU1FX1NFQ09ORF9SRUdFWCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQudGVzdChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0aW1lLXNlY29uZFwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvaXNvVGltZXN0YW1wL2lzb1RpbWVzdGFtcC50c1xuZnVuY3Rpb24gaXNvVGltZXN0YW1wKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcImlzb190aW1lc3RhbXBcIixcbiAgICByZWZlcmVuY2U6IGlzb1RpbWVzdGFtcCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogSVNPX1RJTUVTVEFNUF9SRUdFWCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQudGVzdChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0aW1lc3RhbXBcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL2lzb1dlZWsvaXNvV2Vlay50c1xuZnVuY3Rpb24gaXNvV2VlayhtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJpc29fd2Vla1wiLFxuICAgIHJlZmVyZW5jZTogaXNvV2VlayxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudDogSVNPX1dFRUtfUkVHRVgsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwid2Vla1wiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvbGVuZ3RoL2xlbmd0aC50c1xuZnVuY3Rpb24gbGVuZ3RoKHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJsZW5ndGhcIixcbiAgICByZWZlcmVuY2U6IGxlbmd0aCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogYCR7cmVxdWlyZW1lbnR9YCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgZGF0YXNldC52YWx1ZS5sZW5ndGggIT09IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwibGVuZ3RoXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICByZWNlaXZlZDogYCR7ZGF0YXNldC52YWx1ZS5sZW5ndGh9YFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvbWFjL21hYy50c1xuZnVuY3Rpb24gbWFjKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm1hY1wiLFxuICAgIHJlZmVyZW5jZTogbWFjLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBNQUNfUkVHRVgsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiTUFDXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9tYWM0OC9tYWM0OC50c1xuZnVuY3Rpb24gbWFjNDgobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwibWFjNDhcIixcbiAgICByZWZlcmVuY2U6IG1hYzQ4LFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBNQUM0OF9SRUdFWCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQudGVzdChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCI0OC1iaXQgTUFDXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9tYWM2NC9tYWM2NC50c1xuZnVuY3Rpb24gbWFjNjQobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwibWFjNjRcIixcbiAgICByZWZlcmVuY2U6IG1hYzY0LFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBNQUM2NF9SRUdFWCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQudGVzdChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCI2NC1iaXQgTUFDXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9tYXBJdGVtcy9tYXBJdGVtcy50c1xuZnVuY3Rpb24gbWFwSXRlbXMob3BlcmF0aW9uKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHR5cGU6IFwibWFwX2l0ZW1zXCIsXG4gICAgcmVmZXJlbmNlOiBtYXBJdGVtcyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgb3BlcmF0aW9uLFxuICAgIF9ydW4oZGF0YXNldCkge1xuICAgICAgZGF0YXNldC52YWx1ZSA9IGRhdGFzZXQudmFsdWUubWFwKHRoaXMub3BlcmF0aW9uKTtcbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvbWF4Qnl0ZXMvbWF4Qnl0ZXMudHNcbmZ1bmN0aW9uIG1heEJ5dGVzKHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJtYXhfYnl0ZXNcIixcbiAgICByZWZlcmVuY2U6IG1heEJ5dGVzLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgPD0ke3JlcXVpcmVtZW50fWAsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aDIgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoZGF0YXNldC52YWx1ZSkubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoMiA+IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJieXRlc1wiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgICByZWNlaXZlZDogYCR7bGVuZ3RoMn1gXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvbWF4TGVuZ3RoL21heExlbmd0aC50c1xuZnVuY3Rpb24gbWF4TGVuZ3RoKHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJtYXhfbGVuZ3RoXCIsXG4gICAgcmVmZXJlbmNlOiBtYXhMZW5ndGgsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IGA8PSR7cmVxdWlyZW1lbnR9YCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgZGF0YXNldC52YWx1ZS5sZW5ndGggPiB0aGlzLnJlcXVpcmVtZW50KSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcImxlbmd0aFwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgcmVjZWl2ZWQ6IGAke2RhdGFzZXQudmFsdWUubGVuZ3RofWBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL21heFNpemUvbWF4U2l6ZS50c1xuZnVuY3Rpb24gbWF4U2l6ZShyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwibWF4X3NpemVcIixcbiAgICByZWZlcmVuY2U6IG1heFNpemUsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IGA8PSR7cmVxdWlyZW1lbnR9YCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgZGF0YXNldC52YWx1ZS5zaXplID4gdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJzaXplXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICByZWNlaXZlZDogYCR7ZGF0YXNldC52YWx1ZS5zaXplfWBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL21heFZhbHVlL21heFZhbHVlLnRzXG5mdW5jdGlvbiBtYXhWYWx1ZShyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwibWF4X3ZhbHVlXCIsXG4gICAgcmVmZXJlbmNlOiBtYXhWYWx1ZSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogYDw9JHtyZXF1aXJlbWVudCBpbnN0YW5jZW9mIERhdGUgPyByZXF1aXJlbWVudC50b0pTT04oKSA6IF9zdHJpbmdpZnkocmVxdWlyZW1lbnQpfWAsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmIGRhdGFzZXQudmFsdWUgPiB0aGlzLnJlcXVpcmVtZW50KSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInZhbHVlXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICByZWNlaXZlZDogZGF0YXNldC52YWx1ZSBpbnN0YW5jZW9mIERhdGUgPyBkYXRhc2V0LnZhbHVlLnRvSlNPTigpIDogX3N0cmluZ2lmeShkYXRhc2V0LnZhbHVlKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvbWltZVR5cGUvbWltZVR5cGUudHNcbmZ1bmN0aW9uIG1pbWVUeXBlKHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJtaW1lX3R5cGVcIixcbiAgICByZWZlcmVuY2U6IG1pbWVUeXBlLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiByZXF1aXJlbWVudC5tYXAoKG9wdGlvbikgPT4gYFwiJHtvcHRpb259XCJgKS5qb2luKFwiIHwgXCIpIHx8IFwibmV2ZXJcIixcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQuaW5jbHVkZXMoZGF0YXNldC52YWx1ZS50eXBlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJNSU1FIHR5cGVcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIHJlY2VpdmVkOiBgXCIke2RhdGFzZXQudmFsdWUudHlwZX1cImBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL21pbkJ5dGVzL21pbkJ5dGVzLnRzXG5mdW5jdGlvbiBtaW5CeXRlcyhyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwibWluX2J5dGVzXCIsXG4gICAgcmVmZXJlbmNlOiBtaW5CeXRlcyxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogYD49JHtyZXF1aXJlbWVudH1gLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCkge1xuICAgICAgICBjb25zdCBsZW5ndGgyID0gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKGRhdGFzZXQudmFsdWUpLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aDIgPCB0aGlzLnJlcXVpcmVtZW50KSB7XG4gICAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiYnl0ZXNcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgICAgcmVjZWl2ZWQ6IGAke2xlbmd0aDJ9YFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL21pbkxlbmd0aC9taW5MZW5ndGgudHNcbmZ1bmN0aW9uIG1pbkxlbmd0aChyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwibWluX2xlbmd0aFwiLFxuICAgIHJlZmVyZW5jZTogbWluTGVuZ3RoLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgPj0ke3JlcXVpcmVtZW50fWAsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmIGRhdGFzZXQudmFsdWUubGVuZ3RoIDwgdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJsZW5ndGhcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIHJlY2VpdmVkOiBgJHtkYXRhc2V0LnZhbHVlLmxlbmd0aH1gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9taW5TaXplL21pblNpemUudHNcbmZ1bmN0aW9uIG1pblNpemUocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm1pbl9zaXplXCIsXG4gICAgcmVmZXJlbmNlOiBtaW5TaXplLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgPj0ke3JlcXVpcmVtZW50fWAsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmIGRhdGFzZXQudmFsdWUuc2l6ZSA8IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwic2l6ZVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgcmVjZWl2ZWQ6IGAke2RhdGFzZXQudmFsdWUuc2l6ZX1gXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9taW5WYWx1ZS9taW5WYWx1ZS50c1xuZnVuY3Rpb24gbWluVmFsdWUocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm1pbl92YWx1ZVwiLFxuICAgIHJlZmVyZW5jZTogbWluVmFsdWUsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IGA+PSR7cmVxdWlyZW1lbnQgaW5zdGFuY2VvZiBEYXRlID8gcmVxdWlyZW1lbnQudG9KU09OKCkgOiBfc3RyaW5naWZ5KHJlcXVpcmVtZW50KX1gLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiBkYXRhc2V0LnZhbHVlIDwgdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ2YWx1ZVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgcmVjZWl2ZWQ6IGRhdGFzZXQudmFsdWUgaW5zdGFuY2VvZiBEYXRlID8gZGF0YXNldC52YWx1ZS50b0pTT04oKSA6IF9zdHJpbmdpZnkoZGF0YXNldC52YWx1ZSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL211bHRpcGxlT2YvbXVsdGlwbGVPZi50c1xuZnVuY3Rpb24gbXVsdGlwbGVPZihyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwibXVsdGlwbGVfb2ZcIixcbiAgICByZWZlcmVuY2U6IG11bHRpcGxlT2YsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IGAlJHtyZXF1aXJlbWVudH1gLFxuICAgIHJlcXVpcmVtZW50LFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiBkYXRhc2V0LnZhbHVlICUgdGhpcy5yZXF1aXJlbWVudCAhPT0gMCkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJtdWx0aXBsZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvbm9uRW1wdHkvbm9uRW1wdHkudHNcbmZ1bmN0aW9uIG5vbkVtcHR5KG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcIm5vbl9lbXB0eVwiLFxuICAgIHJlZmVyZW5jZTogbm9uRW1wdHksXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IFwiITBcIixcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgZGF0YXNldC52YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwibGVuZ3RoXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICByZWNlaXZlZDogXCIwXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL25vcm1hbGl6ZS9ub3JtYWxpemUudHNcbmZ1bmN0aW9uIG5vcm1hbGl6ZShmb3JtKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHR5cGU6IFwibm9ybWFsaXplXCIsXG4gICAgcmVmZXJlbmNlOiBub3JtYWxpemUsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGZvcm0sXG4gICAgX3J1bihkYXRhc2V0KSB7XG4gICAgICBkYXRhc2V0LnZhbHVlID0gZGF0YXNldC52YWx1ZS5ub3JtYWxpemUodGhpcy5mb3JtKTtcbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvbm90Qnl0ZXMvbm90Qnl0ZXMudHNcbmZ1bmN0aW9uIG5vdEJ5dGVzKHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJub3RfYnl0ZXNcIixcbiAgICByZWZlcmVuY2U6IG5vdEJ5dGVzLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgISR7cmVxdWlyZW1lbnR9YCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoMiA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShkYXRhc2V0LnZhbHVlKS5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGgyID09PSB0aGlzLnJlcXVpcmVtZW50KSB7XG4gICAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiYnl0ZXNcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgICAgcmVjZWl2ZWQ6IGAke2xlbmd0aDJ9YFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL25vdExlbmd0aC9ub3RMZW5ndGgudHNcbmZ1bmN0aW9uIG5vdExlbmd0aChyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwibm90X2xlbmd0aFwiLFxuICAgIHJlZmVyZW5jZTogbm90TGVuZ3RoLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBgISR7cmVxdWlyZW1lbnR9YCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgZGF0YXNldC52YWx1ZS5sZW5ndGggPT09IHRoaXMucmVxdWlyZW1lbnQpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwibGVuZ3RoXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICByZWNlaXZlZDogYCR7ZGF0YXNldC52YWx1ZS5sZW5ndGh9YFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvbm90U2l6ZS9ub3RTaXplLnRzXG5mdW5jdGlvbiBub3RTaXplKHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJub3Rfc2l6ZVwiLFxuICAgIHJlZmVyZW5jZTogbm90U2l6ZSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogYCEke3JlcXVpcmVtZW50fWAsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmIGRhdGFzZXQudmFsdWUuc2l6ZSA9PT0gdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJzaXplXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICByZWNlaXZlZDogYCR7ZGF0YXNldC52YWx1ZS5zaXplfWBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL25vdFZhbHVlL25vdFZhbHVlLnRzXG5mdW5jdGlvbiBub3RWYWx1ZShyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwibm90X3ZhbHVlXCIsXG4gICAgcmVmZXJlbmNlOiBub3RWYWx1ZSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogcmVxdWlyZW1lbnQgaW5zdGFuY2VvZiBEYXRlID8gYCEke3JlcXVpcmVtZW50LnRvSlNPTigpfWAgOiBgISR7X3N0cmluZ2lmeShyZXF1aXJlbWVudCl9YCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgdGhpcy5yZXF1aXJlbWVudCA8PSBkYXRhc2V0LnZhbHVlICYmIHRoaXMucmVxdWlyZW1lbnQgPj0gZGF0YXNldC52YWx1ZSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ2YWx1ZVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgcmVjZWl2ZWQ6IGRhdGFzZXQudmFsdWUgaW5zdGFuY2VvZiBEYXRlID8gZGF0YXNldC52YWx1ZS50b0pTT04oKSA6IF9zdHJpbmdpZnkoZGF0YXNldC52YWx1ZSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL29jdGFsL29jdGFsLnRzXG5mdW5jdGlvbiBvY3RhbChtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJvY3RhbFwiLFxuICAgIHJlZmVyZW5jZTogb2N0YWwsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQ6IE9DVEFMX1JFR0VYLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC50eXBlZCAmJiAhdGhpcy5yZXF1aXJlbWVudC50ZXN0KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcIm9jdGFsXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9wYXJ0aWFsQ2hlY2svdXRpbHMvX2lzUGFydGlhbGx5VHlwZWQvX2lzUGFydGlhbGx5VHlwZWQudHNcbmZ1bmN0aW9uIF9pc1BhcnRpYWxseVR5cGVkKGRhdGFzZXQsIHBhdGhMaXN0KSB7XG4gIGlmIChkYXRhc2V0Lmlzc3Vlcykge1xuICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRoTGlzdCkge1xuICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICBsZXQgdHlwZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgYm91bmQgPSBNYXRoLm1pbihwYXRoLmxlbmd0aCwgaXNzdWUucGF0aD8ubGVuZ3RoID8/IDApO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYm91bmQ7IGluZGV4KyspIHtcbiAgICAgICAgICBpZiAocGF0aFtpbmRleF0gIT09IGlzc3VlLnBhdGhbaW5kZXhdLmtleSkge1xuICAgICAgICAgICAgdHlwZWQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdHlwZWQpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIHNyYy9hY3Rpb25zL3BhcnRpYWxDaGVjay9wYXJ0aWFsQ2hlY2sudHNcbmZ1bmN0aW9uIHBhcnRpYWxDaGVjayhwYXRoTGlzdCwgcmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcInBhcnRpYWxfY2hlY2tcIixcbiAgICByZWZlcmVuY2U6IHBhcnRpYWxDaGVjayxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKF9pc1BhcnRpYWxseVR5cGVkKGRhdGFzZXQsIHBhdGhMaXN0KSAmJiAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAhdGhpcy5yZXF1aXJlbWVudChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJpbnB1dFwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvcGFydGlhbENoZWNrL3BhcnRpYWxDaGVja0FzeW5jLnRzXG5mdW5jdGlvbiBwYXJ0aWFsQ2hlY2tBc3luYyhwYXRoTGlzdCwgcmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcInBhcnRpYWxfY2hlY2tcIixcbiAgICByZWZlcmVuY2U6IHBhcnRpYWxDaGVja0FzeW5jLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBhc3luYyBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChfaXNQYXJ0aWFsbHlUeXBlZChkYXRhc2V0LCBwYXRoTGlzdCkgJiYgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgIWF3YWl0IHRoaXMucmVxdWlyZW1lbnQoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiaW5wdXRcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3Jhd0NoZWNrL3Jhd0NoZWNrLnRzXG5mdW5jdGlvbiByYXdDaGVjayhhY3Rpb24pIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcInJhd19jaGVja1wiLFxuICAgIHJlZmVyZW5jZTogcmF3Q2hlY2ssXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBhY3Rpb24oe1xuICAgICAgICBkYXRhc2V0LFxuICAgICAgICBjb25maWc6IGNvbmZpZzIsXG4gICAgICAgIGFkZElzc3VlOiAoaW5mbykgPT4gX2FkZElzc3VlKHRoaXMsIGluZm8/LmxhYmVsID8/IFwiaW5wdXRcIiwgZGF0YXNldCwgY29uZmlnMiwgaW5mbylcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9yYXdDaGVjay9yYXdDaGVja0FzeW5jLnRzXG5mdW5jdGlvbiByYXdDaGVja0FzeW5jKGFjdGlvbikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwicmF3X2NoZWNrXCIsXG4gICAgcmVmZXJlbmNlOiByYXdDaGVja0FzeW5jLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgYXN5bmMgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBhd2FpdCBhY3Rpb24oe1xuICAgICAgICBkYXRhc2V0LFxuICAgICAgICBjb25maWc6IGNvbmZpZzIsXG4gICAgICAgIGFkZElzc3VlOiAoaW5mbykgPT4gX2FkZElzc3VlKHRoaXMsIGluZm8/LmxhYmVsID8/IFwiaW5wdXRcIiwgZGF0YXNldCwgY29uZmlnMiwgaW5mbylcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9yYXdUcmFuc2Zvcm0vcmF3VHJhbnNmb3JtLnRzXG5mdW5jdGlvbiByYXdUcmFuc2Zvcm0oYWN0aW9uKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHR5cGU6IFwicmF3X3RyYW5zZm9ybVwiLFxuICAgIHJlZmVyZW5jZTogcmF3VHJhbnNmb3JtLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IG91dHB1dCA9IGFjdGlvbih7XG4gICAgICAgIGRhdGFzZXQsXG4gICAgICAgIGNvbmZpZzogY29uZmlnMixcbiAgICAgICAgYWRkSXNzdWU6IChpbmZvKSA9PiBfYWRkSXNzdWUodGhpcywgaW5mbz8ubGFiZWwgPz8gXCJpbnB1dFwiLCBkYXRhc2V0LCBjb25maWcyLCBpbmZvKSxcbiAgICAgICAgTkVWRVI6IG51bGxcbiAgICAgIH0pO1xuICAgICAgaWYgKGRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSBvdXRwdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3Jhd1RyYW5zZm9ybS9yYXdUcmFuc2Zvcm1Bc3luYy50c1xuZnVuY3Rpb24gcmF3VHJhbnNmb3JtQXN5bmMoYWN0aW9uKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHR5cGU6IFwicmF3X3RyYW5zZm9ybVwiLFxuICAgIHJlZmVyZW5jZTogcmF3VHJhbnNmb3JtQXN5bmMsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgYXN5bmMgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCBhY3Rpb24oe1xuICAgICAgICBkYXRhc2V0LFxuICAgICAgICBjb25maWc6IGNvbmZpZzIsXG4gICAgICAgIGFkZElzc3VlOiAoaW5mbykgPT4gX2FkZElzc3VlKHRoaXMsIGluZm8/LmxhYmVsID8/IFwiaW5wdXRcIiwgZGF0YXNldCwgY29uZmlnMiwgaW5mbyksXG4gICAgICAgIE5FVkVSOiBudWxsXG4gICAgICB9KTtcbiAgICAgIGlmIChkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0gb3V0cHV0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9yZWFkb25seS9yZWFkb25seS50c1xuZnVuY3Rpb24gcmVhZG9ubHkoKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHR5cGU6IFwicmVhZG9ubHlcIixcbiAgICByZWZlcmVuY2U6IHJlYWRvbmx5LFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBfcnVuKGRhdGFzZXQpIHtcbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvcmVkdWNlSXRlbXMvcmVkdWNlSXRlbXMudHNcbmZ1bmN0aW9uIHJlZHVjZUl0ZW1zKG9wZXJhdGlvbiwgaW5pdGlhbCkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcInJlZHVjZV9pdGVtc1wiLFxuICAgIHJlZmVyZW5jZTogcmVkdWNlSXRlbXMsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG9wZXJhdGlvbixcbiAgICBpbml0aWFsLFxuICAgIF9ydW4oZGF0YXNldCkge1xuICAgICAgZGF0YXNldC52YWx1ZSA9IGRhdGFzZXQudmFsdWUucmVkdWNlKHRoaXMub3BlcmF0aW9uLCB0aGlzLmluaXRpYWwpO1xuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9yZWdleC9yZWdleC50c1xuZnVuY3Rpb24gcmVnZXgocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcInJlZ2V4XCIsXG4gICAgcmVmZXJlbmNlOiByZWdleCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogYCR7cmVxdWlyZW1lbnR9YCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQudGVzdChkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJmb3JtYXRcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3NhZmVJbnRlZ2VyL3NhZmVJbnRlZ2VyLnRzXG5mdW5jdGlvbiBzYWZlSW50ZWdlcihtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJzYWZlX2ludGVnZXJcIixcbiAgICByZWZlcmVuY2U6IHNhZmVJbnRlZ2VyLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50OiBOdW1iZXIuaXNTYWZlSW50ZWdlcixcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIXRoaXMucmVxdWlyZW1lbnQoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwic2FmZSBpbnRlZ2VyXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9zaXplL3NpemUudHNcbmZ1bmN0aW9uIHNpemUocmVxdWlyZW1lbnQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcInNpemVcIixcbiAgICByZWZlcmVuY2U6IHNpemUsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IGAke3JlcXVpcmVtZW50fWAsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmIGRhdGFzZXQudmFsdWUuc2l6ZSAhPT0gdGhpcy5yZXF1aXJlbWVudCkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJzaXplXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICByZWNlaXZlZDogYCR7ZGF0YXNldC52YWx1ZS5zaXplfWBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3NvbWVJdGVtL3NvbWVJdGVtLnRzXG5mdW5jdGlvbiBzb21lSXRlbShyZXF1aXJlbWVudCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidmFsaWRhdGlvblwiLFxuICAgIHR5cGU6IFwic29tZV9pdGVtXCIsXG4gICAgcmVmZXJlbmNlOiBzb21lSXRlbSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogbnVsbCxcbiAgICByZXF1aXJlbWVudCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudHlwZWQgJiYgIWRhdGFzZXQudmFsdWUuc29tZSh0aGlzLnJlcXVpcmVtZW50KSkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJpdGVtXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy9zb3J0SXRlbXMvc29ydEl0ZW1zLnRzXG5mdW5jdGlvbiBzb3J0SXRlbXMob3BlcmF0aW9uKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHR5cGU6IFwic29ydF9pdGVtc1wiLFxuICAgIHJlZmVyZW5jZTogc29ydEl0ZW1zLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBvcGVyYXRpb24sXG4gICAgX3J1bihkYXRhc2V0KSB7XG4gICAgICBkYXRhc2V0LnZhbHVlID0gZGF0YXNldC52YWx1ZS5zb3J0KHRoaXMub3BlcmF0aW9uKTtcbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvc3RhcnRzV2l0aC9zdGFydHNXaXRoLnRzXG5mdW5jdGlvbiBzdGFydHNXaXRoKHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJzdGFydHNfd2l0aFwiLFxuICAgIHJlZmVyZW5jZTogc3RhcnRzV2l0aCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZXhwZWN0czogYFwiJHtyZXF1aXJlbWVudH1cImAsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICFkYXRhc2V0LnZhbHVlLnN0YXJ0c1dpdGgodGhpcy5yZXF1aXJlbWVudCkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwic3RhcnRcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIHJlY2VpdmVkOiBgXCIke2RhdGFzZXQudmFsdWUuc2xpY2UoMCwgdGhpcy5yZXF1aXJlbWVudC5sZW5ndGgpfVwiYFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvdG9Mb3dlckNhc2UvdG9Mb3dlckNhc2UudHNcbmZ1bmN0aW9uIHRvTG93ZXJDYXNlKCkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcInRvX2xvd2VyX2Nhc2VcIixcbiAgICByZWZlcmVuY2U6IHRvTG93ZXJDYXNlLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBfcnVuKGRhdGFzZXQpIHtcbiAgICAgIGRhdGFzZXQudmFsdWUgPSBkYXRhc2V0LnZhbHVlLnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3RvTWF4VmFsdWUvdG9NYXhWYWx1ZS50c1xuZnVuY3Rpb24gdG9NYXhWYWx1ZShyZXF1aXJlbWVudCkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcInRvX21heF92YWx1ZVwiLFxuICAgIHJlZmVyZW5jZTogdG9NYXhWYWx1ZSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgX3J1bihkYXRhc2V0KSB7XG4gICAgICBkYXRhc2V0LnZhbHVlID0gZGF0YXNldC52YWx1ZSA+IHRoaXMucmVxdWlyZW1lbnQgPyB0aGlzLnJlcXVpcmVtZW50IDogZGF0YXNldC52YWx1ZTtcbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvdG9NaW5WYWx1ZS90b01pblZhbHVlLnRzXG5mdW5jdGlvbiB0b01pblZhbHVlKHJlcXVpcmVtZW50KSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHR5cGU6IFwidG9fbWluX3ZhbHVlXCIsXG4gICAgcmVmZXJlbmNlOiB0b01pblZhbHVlLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICByZXF1aXJlbWVudCxcbiAgICBfcnVuKGRhdGFzZXQpIHtcbiAgICAgIGRhdGFzZXQudmFsdWUgPSBkYXRhc2V0LnZhbHVlIDwgdGhpcy5yZXF1aXJlbWVudCA/IHRoaXMucmVxdWlyZW1lbnQgOiBkYXRhc2V0LnZhbHVlO1xuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvYWN0aW9ucy90b1VwcGVyQ2FzZS90b1VwcGVyQ2FzZS50c1xuZnVuY3Rpb24gdG9VcHBlckNhc2UoKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHR5cGU6IFwidG9fdXBwZXJfY2FzZVwiLFxuICAgIHJlZmVyZW5jZTogdG9VcHBlckNhc2UsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIF9ydW4oZGF0YXNldCkge1xuICAgICAgZGF0YXNldC52YWx1ZSA9IGRhdGFzZXQudmFsdWUudG9VcHBlckNhc2UoKTtcbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvdHJhbnNmb3JtL3RyYW5zZm9ybS50c1xuZnVuY3Rpb24gdHJhbnNmb3JtKG9wZXJhdGlvbikge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcInRyYW5zZm9ybVwiLFxuICAgIHJlZmVyZW5jZTogdHJhbnNmb3JtLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBvcGVyYXRpb24sXG4gICAgX3J1bihkYXRhc2V0KSB7XG4gICAgICBkYXRhc2V0LnZhbHVlID0gdGhpcy5vcGVyYXRpb24oZGF0YXNldC52YWx1ZSk7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3RyYW5zZm9ybS90cmFuc2Zvcm1Bc3luYy50c1xuZnVuY3Rpb24gdHJhbnNmb3JtQXN5bmMob3BlcmF0aW9uKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ0cmFuc2Zvcm1hdGlvblwiLFxuICAgIHR5cGU6IFwidHJhbnNmb3JtXCIsXG4gICAgcmVmZXJlbmNlOiB0cmFuc2Zvcm1Bc3luYyxcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBvcGVyYXRpb24sXG4gICAgYXN5bmMgX3J1bihkYXRhc2V0KSB7XG4gICAgICBkYXRhc2V0LnZhbHVlID0gYXdhaXQgdGhpcy5vcGVyYXRpb24oZGF0YXNldC52YWx1ZSk7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9hY3Rpb25zL3RyaW0vdHJpbS50c1xuZnVuY3Rpb24gdHJpbSgpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInRyYW5zZm9ybWF0aW9uXCIsXG4gICAgdHlwZTogXCJ0cmltXCIsXG4gICAgcmVmZXJlbmNlOiB0cmltLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBfcnVuKGRhdGFzZXQpIHtcbiAgICAgIGRhdGFzZXQudmFsdWUgPSBkYXRhc2V0LnZhbHVlLnRyaW0oKTtcbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvdHJpbUVuZC90cmltRW5kLnRzXG5mdW5jdGlvbiB0cmltRW5kKCkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcInRyaW1fZW5kXCIsXG4gICAgcmVmZXJlbmNlOiB0cmltRW5kLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBfcnVuKGRhdGFzZXQpIHtcbiAgICAgIGRhdGFzZXQudmFsdWUgPSBkYXRhc2V0LnZhbHVlLnRyaW1FbmQoKTtcbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvdHJpbVN0YXJ0L3RyaW1TdGFydC50c1xuZnVuY3Rpb24gdHJpbVN0YXJ0KCkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwidHJhbnNmb3JtYXRpb25cIixcbiAgICB0eXBlOiBcInRyaW1fc3RhcnRcIixcbiAgICByZWZlcmVuY2U6IHRyaW1TdGFydCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgX3J1bihkYXRhc2V0KSB7XG4gICAgICBkYXRhc2V0LnZhbHVlID0gZGF0YXNldC52YWx1ZS50cmltU3RhcnQoKTtcbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvdWxpZC91bGlkLnRzXG5mdW5jdGlvbiB1bGlkKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcInVsaWRcIixcbiAgICByZWZlcmVuY2U6IHVsaWQsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQ6IFVMSURfUkVHRVgsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiVUxJRFwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvdXJsL3VybC50c1xuZnVuY3Rpb24gdXJsKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcInVybFwiLFxuICAgIHJlZmVyZW5jZTogdXJsLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBleHBlY3RzOiBudWxsLFxuICAgIHJlcXVpcmVtZW50KGlucHV0KSB7XG4gICAgICB0cnkge1xuICAgICAgICBuZXcgVVJMKGlucHV0KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50KGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcIlVSTFwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvdXVpZC91dWlkLnRzXG5mdW5jdGlvbiB1dWlkKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInZhbGlkYXRpb25cIixcbiAgICB0eXBlOiBcInV1aWRcIixcbiAgICByZWZlcmVuY2U6IHV1aWQsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IG51bGwsXG4gICAgcmVxdWlyZW1lbnQ6IFVVSURfUkVHRVgsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICF0aGlzLnJlcXVpcmVtZW50LnRlc3QoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwiVVVJRFwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL2FjdGlvbnMvdmFsdWUvdmFsdWUudHNcbmZ1bmN0aW9uIHZhbHVlKHJlcXVpcmVtZW50LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJ2YWxpZGF0aW9uXCIsXG4gICAgdHlwZTogXCJ2YWx1ZVwiLFxuICAgIHJlZmVyZW5jZTogdmFsdWUsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGV4cGVjdHM6IHJlcXVpcmVtZW50IGluc3RhbmNlb2YgRGF0ZSA/IHJlcXVpcmVtZW50LnRvSlNPTigpIDogX3N0cmluZ2lmeShyZXF1aXJlbWVudCksXG4gICAgcmVxdWlyZW1lbnQsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnR5cGVkICYmICEodGhpcy5yZXF1aXJlbWVudCA8PSBkYXRhc2V0LnZhbHVlICYmIHRoaXMucmVxdWlyZW1lbnQgPj0gZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidmFsdWVcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIHJlY2VpdmVkOiBkYXRhc2V0LnZhbHVlIGluc3RhbmNlb2YgRGF0ZSA/IGRhdGFzZXQudmFsdWUudG9KU09OKCkgOiBfc3RyaW5naWZ5KGRhdGFzZXQudmFsdWUpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9jb25maWcvY29uZmlnLnRzXG5mdW5jdGlvbiBjb25maWcoc2NoZW1hLCBjb25maWcyKSB7XG4gIHJldHVybiB7XG4gICAgLi4uc2NoZW1hLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnXykge1xuICAgICAgcmV0dXJuIHNjaGVtYS5fcnVuKGRhdGFzZXQsIHsgLi4uY29uZmlnXywgLi4uY29uZmlnMiB9KTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL2dldEZhbGxiYWNrL2dldEZhbGxiYWNrLnRzXG5mdW5jdGlvbiBnZXRGYWxsYmFjayhzY2hlbWEsIGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgcmV0dXJuIHR5cGVvZiBzY2hlbWEuZmFsbGJhY2sgPT09IFwiZnVuY3Rpb25cIiA/IChcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgc2NoZW1hLmZhbGxiYWNrKGRhdGFzZXQsIGNvbmZpZzIpXG4gICkgOiAoXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIHNjaGVtYS5mYWxsYmFja1xuICApO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9mYWxsYmFjay9mYWxsYmFjay50c1xuZnVuY3Rpb24gZmFsbGJhY2soc2NoZW1hLCBmYWxsYmFjazIpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5zY2hlbWEsXG4gICAgZmFsbGJhY2s6IGZhbGxiYWNrMixcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIHNjaGVtYS5fcnVuKGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgcmV0dXJuIGRhdGFzZXQuaXNzdWVzID8geyB0eXBlZDogdHJ1ZSwgdmFsdWU6IGdldEZhbGxiYWNrKHRoaXMsIGRhdGFzZXQsIGNvbmZpZzIpIH0gOiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvZmFsbGJhY2svZmFsbGJhY2tBc3luYy50c1xuZnVuY3Rpb24gZmFsbGJhY2tBc3luYyhzY2hlbWEsIGZhbGxiYWNrMikge1xuICByZXR1cm4ge1xuICAgIC4uLnNjaGVtYSxcbiAgICBmYWxsYmFjazogZmFsbGJhY2syLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGFzeW5jIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgc2NoZW1hLl9ydW4oZGF0YXNldCwgY29uZmlnMik7XG4gICAgICByZXR1cm4gZGF0YXNldC5pc3N1ZXMgPyAoXG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgeyB0eXBlZDogdHJ1ZSwgdmFsdWU6IGF3YWl0IGdldEZhbGxiYWNrKHRoaXMsIGRhdGFzZXQsIGNvbmZpZzIpIH1cbiAgICAgICkgOiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvZmxhdHRlbi9mbGF0dGVuLnRzXG5mdW5jdGlvbiBmbGF0dGVuKGlzc3Vlcykge1xuICBjb25zdCBmbGF0RXJyb3JzID0ge307XG4gIGZvciAoY29uc3QgaXNzdWUgb2YgaXNzdWVzKSB7XG4gICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgIGNvbnN0IGRvdFBhdGggPSBnZXREb3RQYXRoKGlzc3VlKTtcbiAgICAgIGlmIChkb3RQYXRoKSB7XG4gICAgICAgIGlmICghZmxhdEVycm9ycy5uZXN0ZWQpIHtcbiAgICAgICAgICBmbGF0RXJyb3JzLm5lc3RlZCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChmbGF0RXJyb3JzLm5lc3RlZFtkb3RQYXRoXSkge1xuICAgICAgICAgIGZsYXRFcnJvcnMubmVzdGVkW2RvdFBhdGhdLnB1c2goaXNzdWUubWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmxhdEVycm9ycy5uZXN0ZWRbZG90UGF0aF0gPSBbaXNzdWUubWVzc2FnZV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmbGF0RXJyb3JzLm90aGVyKSB7XG4gICAgICAgICAgZmxhdEVycm9ycy5vdGhlci5wdXNoKGlzc3VlLm1lc3NhZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZsYXRFcnJvcnMub3RoZXIgPSBbaXNzdWUubWVzc2FnZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGZsYXRFcnJvcnMucm9vdCkge1xuICAgICAgICBmbGF0RXJyb3JzLnJvb3QucHVzaChpc3N1ZS5tZXNzYWdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZsYXRFcnJvcnMucm9vdCA9IFtpc3N1ZS5tZXNzYWdlXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZsYXRFcnJvcnM7XG59XG5cbi8vIHNyYy9tZXRob2RzL2ZvcndhcmQvZm9yd2FyZC50c1xuZnVuY3Rpb24gZm9yd2FyZChhY3Rpb24sIHBhdGhLZXlzKSB7XG4gIHJldHVybiB7XG4gICAgLi4uYWN0aW9uLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3QgcHJldklzc3VlcyA9IGRhdGFzZXQuaXNzdWVzICYmIFsuLi5kYXRhc2V0Lmlzc3Vlc107XG4gICAgICBhY3Rpb24uX3J1bihkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIGlmIChkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgaWYgKCFwcmV2SXNzdWVzPy5pbmNsdWRlcyhpc3N1ZSkpIHtcbiAgICAgICAgICAgIGxldCBwYXRoSW5wdXQgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgcGF0aEtleXMpIHtcbiAgICAgICAgICAgICAgY29uc3QgcGF0aFZhbHVlID0gcGF0aElucHV0W2tleV07XG4gICAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidW5rbm93blwiLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgIGlucHV0OiBwYXRoSW5wdXQsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBwYXRoVmFsdWVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnB1c2gocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghcGF0aFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcGF0aElucHV0ID0gcGF0aFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9mb3J3YXJkL2ZvcndhcmRBc3luYy50c1xuZnVuY3Rpb24gZm9yd2FyZEFzeW5jKGFjdGlvbiwgcGF0aEtleXMpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5hY3Rpb24sXG4gICAgYXN5bmM6IHRydWUsXG4gICAgYXN5bmMgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBwcmV2SXNzdWVzID0gZGF0YXNldC5pc3N1ZXMgJiYgWy4uLmRhdGFzZXQuaXNzdWVzXTtcbiAgICAgIGF3YWl0IGFjdGlvbi5fcnVuKGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgaWYgKGRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICBpZiAoIXByZXZJc3N1ZXM/LmluY2x1ZGVzKGlzc3VlKSkge1xuICAgICAgICAgICAgbGV0IHBhdGhJbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBwYXRoS2V5cykge1xuICAgICAgICAgICAgICBjb25zdCBwYXRoVmFsdWUgPSBwYXRoSW5wdXRba2V5XTtcbiAgICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ1bmtub3duXCIsXG4gICAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IHBhdGhJbnB1dCxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHBhdGhWYWx1ZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgucHVzaChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFwYXRoVmFsdWUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBwYXRoSW5wdXQgPSBwYXRoVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL2dldERlZmF1bHQvZ2V0RGVmYXVsdC50c1xuZnVuY3Rpb24gZ2V0RGVmYXVsdChzY2hlbWEsIGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgcmV0dXJuIHR5cGVvZiBzY2hlbWEuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiID8gKFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBzY2hlbWEuZGVmYXVsdChkYXRhc2V0LCBjb25maWcyKVxuICApIDogKFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBzY2hlbWEuZGVmYXVsdFxuICApO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9nZXREZWZhdWx0cy9nZXREZWZhdWx0cy50c1xuZnVuY3Rpb24gZ2V0RGVmYXVsdHMoc2NoZW1hKSB7XG4gIGlmIChcImVudHJpZXNcIiBpbiBzY2hlbWEpIHtcbiAgICBjb25zdCBvYmplY3QyID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hLmVudHJpZXMpIHtcbiAgICAgIG9iamVjdDJba2V5XSA9IGdldERlZmF1bHRzKHNjaGVtYS5lbnRyaWVzW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0MjtcbiAgfVxuICBpZiAoXCJpdGVtc1wiIGluIHNjaGVtYSkge1xuICAgIHJldHVybiBzY2hlbWEuaXRlbXMubWFwKGdldERlZmF1bHRzKTtcbiAgfVxuICByZXR1cm4gZ2V0RGVmYXVsdChzY2hlbWEpO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9nZXREZWZhdWx0cy9nZXREZWZhdWx0c0FzeW5jLnRzXG5hc3luYyBmdW5jdGlvbiBnZXREZWZhdWx0c0FzeW5jKHNjaGVtYSkge1xuICBpZiAoXCJlbnRyaWVzXCIgaW4gc2NoZW1hKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICBPYmplY3QuZW50cmllcyhzY2hlbWEuZW50cmllcykubWFwKGFzeW5jIChba2V5LCB2YWx1ZTJdKSA9PiBbXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIGF3YWl0IGdldERlZmF1bHRzQXN5bmModmFsdWUyKVxuICAgICAgICBdKVxuICAgICAgKVxuICAgICk7XG4gIH1cbiAgaWYgKFwiaXRlbXNcIiBpbiBzY2hlbWEpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoc2NoZW1hLml0ZW1zLm1hcChnZXREZWZhdWx0c0FzeW5jKSk7XG4gIH1cbiAgcmV0dXJuIGdldERlZmF1bHQoc2NoZW1hKTtcbn1cblxuLy8gc3JjL21ldGhvZHMvZ2V0RmFsbGJhY2tzL2dldEZhbGxiYWNrcy50c1xuZnVuY3Rpb24gZ2V0RmFsbGJhY2tzKHNjaGVtYSkge1xuICBpZiAoXCJlbnRyaWVzXCIgaW4gc2NoZW1hKSB7XG4gICAgY29uc3Qgb2JqZWN0MiA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5lbnRyaWVzKSB7XG4gICAgICBvYmplY3QyW2tleV0gPSBnZXRGYWxsYmFja3Moc2NoZW1hLmVudHJpZXNba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3QyO1xuICB9XG4gIGlmIChcIml0ZW1zXCIgaW4gc2NoZW1hKSB7XG4gICAgcmV0dXJuIHNjaGVtYS5pdGVtcy5tYXAoZ2V0RmFsbGJhY2tzKTtcbiAgfVxuICByZXR1cm4gZ2V0RmFsbGJhY2soc2NoZW1hKTtcbn1cblxuLy8gc3JjL21ldGhvZHMvZ2V0RmFsbGJhY2tzL2dldEZhbGxiYWNrc0FzeW5jLnRzXG5hc3luYyBmdW5jdGlvbiBnZXRGYWxsYmFja3NBc3luYyhzY2hlbWEpIHtcbiAgaWYgKFwiZW50cmllc1wiIGluIHNjaGVtYSkge1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgICBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgT2JqZWN0LmVudHJpZXMoc2NoZW1hLmVudHJpZXMpLm1hcChhc3luYyAoW2tleSwgdmFsdWUyXSkgPT4gW1xuICAgICAgICAgIGtleSxcbiAgICAgICAgICBhd2FpdCBnZXRGYWxsYmFja3NBc3luYyh2YWx1ZTIpXG4gICAgICAgIF0pXG4gICAgICApXG4gICAgKTtcbiAgfVxuICBpZiAoXCJpdGVtc1wiIGluIHNjaGVtYSkge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChzY2hlbWEuaXRlbXMubWFwKGdldEZhbGxiYWNrc0FzeW5jKSk7XG4gIH1cbiAgcmV0dXJuIGdldEZhbGxiYWNrKHNjaGVtYSk7XG59XG5cbi8vIHNyYy9tZXRob2RzL2lzL2lzLnRzXG5mdW5jdGlvbiBpcyhzY2hlbWEsIGlucHV0KSB7XG4gIHJldHVybiAhc2NoZW1hLl9ydW4oeyB0eXBlZDogZmFsc2UsIHZhbHVlOiBpbnB1dCB9LCB7IGFib3J0RWFybHk6IHRydWUgfSkuaXNzdWVzO1xufVxuXG4vLyBzcmMvc2NoZW1hcy9hbnkvYW55LnRzXG5mdW5jdGlvbiBhbnkoKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcImFueVwiLFxuICAgIHJlZmVyZW5jZTogYW55LFxuICAgIGV4cGVjdHM6IFwiYW55XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIF9ydW4oZGF0YXNldCkge1xuICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2FycmF5L2FycmF5LnRzXG5mdW5jdGlvbiBhcnJheShpdGVtLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgcmVmZXJlbmNlOiBhcnJheSxcbiAgICBleHBlY3RzOiBcIkFycmF5XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGl0ZW0sXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgZGF0YXNldC52YWx1ZSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBrZXkgPSAwOyBrZXkgPCBpbnB1dC5sZW5ndGg7IGtleSsrKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUyID0gaW5wdXRba2V5XTtcbiAgICAgICAgICBjb25zdCBpdGVtRGF0YXNldCA9IHRoaXMuaXRlbS5fcnVuKHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogdmFsdWUyIH0sIGNvbmZpZzIpO1xuICAgICAgICAgIGlmIChpdGVtRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBpdGVtRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSBpdGVtRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXRlbURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YXNldC52YWx1ZS5wdXNoKGl0ZW1EYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvYXJyYXkvYXJyYXlBc3luYy50c1xuZnVuY3Rpb24gYXJyYXlBc3luYyhpdGVtLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgcmVmZXJlbmNlOiBhcnJheUFzeW5jLFxuICAgIGV4cGVjdHM6IFwiQXJyYXlcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBpdGVtLFxuICAgIG1lc3NhZ2UsXG4gICAgYXN5bmMgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSBbXTtcbiAgICAgICAgY29uc3QgaXRlbURhdGFzZXRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgaW5wdXQubWFwKCh2YWx1ZTIpID0+IHRoaXMuaXRlbS5fcnVuKHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogdmFsdWUyIH0sIGNvbmZpZzIpKVxuICAgICAgICApO1xuICAgICAgICBmb3IgKGxldCBrZXkgPSAwOyBrZXkgPCBpdGVtRGF0YXNldHMubGVuZ3RoOyBrZXkrKykge1xuICAgICAgICAgIGNvbnN0IGl0ZW1EYXRhc2V0ID0gaXRlbURhdGFzZXRzW2tleV07XG4gICAgICAgICAgaWYgKGl0ZW1EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFtrZXldXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBpdGVtRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSBpdGVtRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXRlbURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YXNldC52YWx1ZS5wdXNoKGl0ZW1EYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvYmlnaW50L2JpZ2ludC50c1xuZnVuY3Rpb24gYmlnaW50KG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwiYmlnaW50XCIsXG4gICAgcmVmZXJlbmNlOiBiaWdpbnQsXG4gICAgZXhwZWN0czogXCJiaWdpbnRcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmICh0eXBlb2YgZGF0YXNldC52YWx1ZSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2Jsb2IvYmxvYi50c1xuZnVuY3Rpb24gYmxvYihtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcImJsb2JcIixcbiAgICByZWZlcmVuY2U6IGJsb2IsXG4gICAgZXhwZWN0czogXCJCbG9iXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9ib29sZWFuL2Jvb2xlYW4udHNcbmZ1bmN0aW9uIGJvb2xlYW4obWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgcmVmZXJlbmNlOiBib29sZWFuLFxuICAgIGV4cGVjdHM6IFwiYm9vbGVhblwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKHR5cGVvZiBkYXRhc2V0LnZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2N1c3RvbS9jdXN0b20udHNcbmZ1bmN0aW9uIGN1c3RvbShjaGVjazIsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwiY3VzdG9tXCIsXG4gICAgcmVmZXJlbmNlOiBjdXN0b20sXG4gICAgZXhwZWN0czogXCJ1bmtub3duXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGNoZWNrOiBjaGVjazIsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmICh0aGlzLmNoZWNrKGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvY3VzdG9tL2N1c3RvbUFzeW5jLnRzXG5mdW5jdGlvbiBjdXN0b21Bc3luYyhjaGVjazIsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwiY3VzdG9tXCIsXG4gICAgcmVmZXJlbmNlOiBjdXN0b21Bc3luYyxcbiAgICBleHBlY3RzOiBcInVua25vd25cIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBjaGVjazogY2hlY2syLFxuICAgIG1lc3NhZ2UsXG4gICAgYXN5bmMgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoYXdhaXQgdGhpcy5jaGVjayhkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2RhdGUvZGF0ZS50c1xuZnVuY3Rpb24gZGF0ZShtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcImRhdGVcIixcbiAgICByZWZlcmVuY2U6IGRhdGUsXG4gICAgZXhwZWN0czogXCJEYXRlXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgaWYgKCFpc05hTihkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgICAgcmVjZWl2ZWQ6ICdcIkludmFsaWQgRGF0ZVwiJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9lbnVtL2VudW0udHNcbmZ1bmN0aW9uIGVudW1fKGVudW1fXywgbWVzc2FnZSkge1xuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmVudHJpZXMoZW51bV9fKS5maWx0ZXIoKFtrZXldKSA9PiBpc05hTigra2V5KSkubWFwKChbLCB2YWx1ZTJdKSA9PiB2YWx1ZTIpO1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgcmVmZXJlbmNlOiBlbnVtXyxcbiAgICBleHBlY3RzOiBvcHRpb25zLm1hcChfc3RyaW5naWZ5KS5qb2luKFwiIHwgXCIpIHx8IFwibmV2ZXJcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZW51bTogZW51bV9fLFxuICAgIG9wdGlvbnMsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW5jbHVkZXMoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9maWxlL2ZpbGUudHNcbmZ1bmN0aW9uIGZpbGUobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJmaWxlXCIsXG4gICAgcmVmZXJlbmNlOiBmaWxlLFxuICAgIGV4cGVjdHM6IFwiRmlsZVwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudmFsdWUgaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvZnVuY3Rpb24vZnVuY3Rpb24udHNcbmZ1bmN0aW9uIGZ1bmN0aW9uXyhtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgcmVmZXJlbmNlOiBmdW5jdGlvbl8sXG4gICAgZXhwZWN0czogXCJGdW5jdGlvblwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKHR5cGVvZiBkYXRhc2V0LnZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9pbnN0YW5jZS9pbnN0YW5jZS50c1xuZnVuY3Rpb24gaW5zdGFuY2UoY2xhc3NfLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcImluc3RhbmNlXCIsXG4gICAgcmVmZXJlbmNlOiBpbnN0YW5jZSxcbiAgICBleHBlY3RzOiBjbGFzc18ubmFtZSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgY2xhc3M6IGNsYXNzXyxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudmFsdWUgaW5zdGFuY2VvZiB0aGlzLmNsYXNzKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvaW50ZXJzZWN0L3V0aWxzL19tZXJnZS9fbWVyZ2UudHNcbmZ1bmN0aW9uIF9tZXJnZSh2YWx1ZTEsIHZhbHVlMikge1xuICBpZiAodHlwZW9mIHZhbHVlMSA9PT0gdHlwZW9mIHZhbHVlMikge1xuICAgIGlmICh2YWx1ZTEgPT09IHZhbHVlMiB8fCB2YWx1ZTEgaW5zdGFuY2VvZiBEYXRlICYmIHZhbHVlMiBpbnN0YW5jZW9mIERhdGUgJiYgK3ZhbHVlMSA9PT0gK3ZhbHVlMikge1xuICAgICAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlMSB9O1xuICAgIH1cbiAgICBpZiAodmFsdWUxICYmIHZhbHVlMiAmJiB2YWx1ZTEuY29uc3RydWN0b3IgPT09IE9iamVjdCAmJiB2YWx1ZTIuY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUyKSB7XG4gICAgICAgIGlmIChrZXkgaW4gdmFsdWUxKSB7XG4gICAgICAgICAgY29uc3QgZGF0YXNldCA9IF9tZXJnZSh2YWx1ZTFba2V5XSwgdmFsdWUyW2tleV0pO1xuICAgICAgICAgIGlmIChkYXRhc2V0Lmlzc3VlKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YXNldDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUxW2tleV0gPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlMVtrZXldID0gdmFsdWUyW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZTEgfTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUxKSAmJiBBcnJheS5pc0FycmF5KHZhbHVlMikpIHtcbiAgICAgIGlmICh2YWx1ZTEubGVuZ3RoID09PSB2YWx1ZTIubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB2YWx1ZTEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgY29uc3QgZGF0YXNldCA9IF9tZXJnZSh2YWx1ZTFbaW5kZXhdLCB2YWx1ZTJbaW5kZXhdKTtcbiAgICAgICAgICBpZiAoZGF0YXNldC5pc3N1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlMVtpbmRleF0gPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiB2YWx1ZTEgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgaXNzdWU6IHRydWUgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvaW50ZXJzZWN0L2ludGVyc2VjdC50c1xuZnVuY3Rpb24gaW50ZXJzZWN0KG9wdGlvbnMsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwiaW50ZXJzZWN0XCIsXG4gICAgcmVmZXJlbmNlOiBpbnRlcnNlY3QsXG4gICAgZXhwZWN0czogWy4uLm5ldyBTZXQob3B0aW9ucy5tYXAoKG9wdGlvbikgPT4gb3B0aW9uLmV4cGVjdHMpKV0uam9pbihcIiAmIFwiKSB8fCBcIm5ldmVyXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG9wdGlvbnMsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgICAgbGV0IG91dHB1dHM7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBmb3IgKGNvbnN0IHNjaGVtYSBvZiB0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgICBjb25zdCBvcHRpb25EYXRhc2V0ID0gc2NoZW1hLl9ydW4oXG4gICAgICAgICAgICB7IHR5cGVkOiBmYWxzZSwgdmFsdWU6IGlucHV0IH0sXG4gICAgICAgICAgICBjb25maWcyXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAob3B0aW9uRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGlmIChkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcy5wdXNoKC4uLm9wdGlvbkRhdGFzZXQuaXNzdWVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gb3B0aW9uRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghb3B0aW9uRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgaWYgKG91dHB1dHMpIHtcbiAgICAgICAgICAgICAgb3V0cHV0cy5wdXNoKG9wdGlvbkRhdGFzZXQudmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgb3V0cHV0cyA9IFtvcHRpb25EYXRhc2V0LnZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICBkYXRhc2V0LnZhbHVlID0gb3V0cHV0c1swXTtcbiAgICAgICAgICBmb3IgKGxldCBpbmRleCA9IDE7IGluZGV4IDwgb3V0cHV0cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlRGF0YXNldCA9IF9tZXJnZShkYXRhc2V0LnZhbHVlLCBvdXRwdXRzW2luZGV4XSk7XG4gICAgICAgICAgICBpZiAobWVyZ2VEYXRhc2V0Lmlzc3VlKSB7XG4gICAgICAgICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBcInVua25vd25cIlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhc2V0LnZhbHVlID0gbWVyZ2VEYXRhc2V0LnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvaW50ZXJzZWN0L2ludGVyc2VjdEFzeW5jLnRzXG5mdW5jdGlvbiBpbnRlcnNlY3RBc3luYyhvcHRpb25zLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcImludGVyc2VjdFwiLFxuICAgIHJlZmVyZW5jZTogaW50ZXJzZWN0QXN5bmMsXG4gICAgZXhwZWN0czogWy4uLm5ldyBTZXQob3B0aW9ucy5tYXAoKG9wdGlvbikgPT4gb3B0aW9uLmV4cGVjdHMpKV0uam9pbihcIiAmIFwiKSB8fCBcIm5ldmVyXCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgb3B0aW9ucyxcbiAgICBtZXNzYWdlLFxuICAgIGFzeW5jIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgICBsZXQgb3V0cHV0cztcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IG9wdGlvbkRhdGFzZXRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgdGhpcy5vcHRpb25zLm1hcChcbiAgICAgICAgICAgIChzY2hlbWEpID0+IHNjaGVtYS5fcnVuKHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogaW5wdXQgfSwgY29uZmlnMilcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9uRGF0YXNldCBvZiBvcHRpb25EYXRhc2V0cykge1xuICAgICAgICAgIGlmIChvcHRpb25EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgaWYgKGRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzLnB1c2goLi4ub3B0aW9uRGF0YXNldC5pc3N1ZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSBvcHRpb25EYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFvcHRpb25EYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICBpZiAob3V0cHV0cykge1xuICAgICAgICAgICAgICBvdXRwdXRzLnB1c2gob3B0aW9uRGF0YXNldC52YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBvdXRwdXRzID0gW29wdGlvbkRhdGFzZXQudmFsdWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YXNldC50eXBlZCkge1xuICAgICAgICAgIGRhdGFzZXQudmFsdWUgPSBvdXRwdXRzWzBdO1xuICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMTsgaW5kZXggPCBvdXRwdXRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VEYXRhc2V0ID0gX21lcmdlKGRhdGFzZXQudmFsdWUsIG91dHB1dHNbaW5kZXhdKTtcbiAgICAgICAgICAgIGlmIChtZXJnZURhdGFzZXQuaXNzdWUpIHtcbiAgICAgICAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IFwidW5rbm93blwiXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGFzZXQudmFsdWUgPSBtZXJnZURhdGFzZXQudmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9sYXp5L2xhenkudHNcbmZ1bmN0aW9uIGxhenkoZ2V0dGVyKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcImxhenlcIixcbiAgICByZWZlcmVuY2U6IGxhenksXG4gICAgZXhwZWN0czogXCJ1bmtub3duXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGdldHRlcixcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldHRlcihkYXRhc2V0LnZhbHVlKS5fcnVuKGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbGF6eS9sYXp5QXN5bmMudHNcbmZ1bmN0aW9uIGxhenlBc3luYyhnZXR0ZXIpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwibGF6eVwiLFxuICAgIHJlZmVyZW5jZTogbGF6eUFzeW5jLFxuICAgIGV4cGVjdHM6IFwidW5rbm93blwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGdldHRlcixcbiAgICBhc3luYyBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIHJldHVybiAoYXdhaXQgdGhpcy5nZXR0ZXIoZGF0YXNldC52YWx1ZSkpLl9ydW4oZGF0YXNldCwgY29uZmlnMik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9saXRlcmFsL2xpdGVyYWwudHNcbmZ1bmN0aW9uIGxpdGVyYWwobGl0ZXJhbF8sIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwibGl0ZXJhbFwiLFxuICAgIHJlZmVyZW5jZTogbGl0ZXJhbCxcbiAgICBleHBlY3RzOiBfc3RyaW5naWZ5KGxpdGVyYWxfKSxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbGl0ZXJhbDogbGl0ZXJhbF8sXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnZhbHVlID09PSB0aGlzLmxpdGVyYWwpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9sb29zZU9iamVjdC9sb29zZU9iamVjdC50c1xuZnVuY3Rpb24gbG9vc2VPYmplY3QoZW50cmllcywgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJsb29zZV9vYmplY3RcIixcbiAgICByZWZlcmVuY2U6IGxvb3NlT2JqZWN0LFxuICAgIGV4cGVjdHM6IFwiT2JqZWN0XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGVudHJpZXMsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGlmIChpbnB1dCAmJiB0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5lbnRyaWVzKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUyID0gaW5wdXRba2V5XTtcbiAgICAgICAgICBjb25zdCB2YWx1ZURhdGFzZXQgPSB0aGlzLmVudHJpZXNba2V5XS5fcnVuKFxuICAgICAgICAgICAgeyB0eXBlZDogZmFsc2UsIHZhbHVlOiB2YWx1ZTIgfSxcbiAgICAgICAgICAgIGNvbmZpZzJcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICh2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHZhbHVlRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSB2YWx1ZURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXZhbHVlRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWVEYXRhc2V0LnZhbHVlICE9PSB2b2lkIDAgfHwga2V5IGluIGlucHV0KSB7XG4gICAgICAgICAgICBkYXRhc2V0LnZhbHVlW2tleV0gPSB2YWx1ZURhdGFzZXQudmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMgfHwgIWNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGlucHV0KSB7XG4gICAgICAgICAgICBpZiAoX2lzVmFsaWRPYmplY3RLZXkoaW5wdXQsIGtleSkgJiYgIShrZXkgaW4gdGhpcy5lbnRyaWVzKSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnZhbHVlW2tleV0gPSBpbnB1dFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbG9vc2VPYmplY3QvbG9vc2VPYmplY3RBc3luYy50c1xuZnVuY3Rpb24gbG9vc2VPYmplY3RBc3luYyhlbnRyaWVzLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcImxvb3NlX29iamVjdFwiLFxuICAgIHJlZmVyZW5jZTogbG9vc2VPYmplY3RBc3luYyxcbiAgICBleHBlY3RzOiBcIk9iamVjdFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGVudHJpZXMsXG4gICAgbWVzc2FnZSxcbiAgICBhc3luYyBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGlmIChpbnB1dCAmJiB0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSB7fTtcbiAgICAgICAgY29uc3QgdmFsdWVEYXRhc2V0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHRoaXMuZW50cmllcykubWFwKGFzeW5jIChba2V5LCBzY2hlbWFdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZTIgPSBpbnB1dFtrZXldO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTIsXG4gICAgICAgICAgICAgIGF3YWl0IHNjaGVtYS5fcnVuKHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogdmFsdWUyIH0sIGNvbmZpZzIpXG4gICAgICAgICAgICBdO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWUyLCB2YWx1ZURhdGFzZXRdIG9mIHZhbHVlRGF0YXNldHMpIHtcbiAgICAgICAgICBpZiAodmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiB2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gdmFsdWVEYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF2YWx1ZURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlRGF0YXNldC52YWx1ZSAhPT0gdm9pZCAwIHx8IGtleSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgZGF0YXNldC52YWx1ZVtrZXldID0gdmFsdWVEYXRhc2V0LnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzIHx8ICFjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgaWYgKF9pc1ZhbGlkT2JqZWN0S2V5KGlucHV0LCBrZXkpICYmICEoa2V5IGluIHRoaXMuZW50cmllcykpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC52YWx1ZVtrZXldID0gaW5wdXRba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL2xvb3NlVHVwbGUvbG9vc2VUdXBsZS50c1xuZnVuY3Rpb24gbG9vc2VUdXBsZShpdGVtcywgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJsb29zZV90dXBsZVwiLFxuICAgIHJlZmVyZW5jZTogbG9vc2VUdXBsZSxcbiAgICBleHBlY3RzOiBcIkFycmF5XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGl0ZW1zLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQga2V5ID0gMDsga2V5IDwgdGhpcy5pdGVtcy5sZW5ndGg7IGtleSsrKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUyID0gaW5wdXRba2V5XTtcbiAgICAgICAgICBjb25zdCBpdGVtRGF0YXNldCA9IHRoaXMuaXRlbXNba2V5XS5fcnVuKFxuICAgICAgICAgICAgeyB0eXBlZDogZmFsc2UsIHZhbHVlOiB2YWx1ZTIgfSxcbiAgICAgICAgICAgIGNvbmZpZzJcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChpdGVtRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBpdGVtRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSBpdGVtRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXRlbURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YXNldC52YWx1ZS5wdXNoKGl0ZW1EYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzIHx8ICFjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICBmb3IgKGxldCBrZXkgPSB0aGlzLml0ZW1zLmxlbmd0aDsga2V5IDwgaW5wdXQubGVuZ3RoOyBrZXkrKykge1xuICAgICAgICAgICAgZGF0YXNldC52YWx1ZS5wdXNoKGlucHV0W2tleV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbG9vc2VUdXBsZS9sb29zZVR1cGxlQXN5bmMudHNcbmZ1bmN0aW9uIGxvb3NlVHVwbGVBc3luYyhpdGVtcywgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJsb29zZV90dXBsZVwiLFxuICAgIHJlZmVyZW5jZTogbG9vc2VUdXBsZUFzeW5jLFxuICAgIGV4cGVjdHM6IFwiQXJyYXlcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBpdGVtcyxcbiAgICBtZXNzYWdlLFxuICAgIGFzeW5jIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3QgaW5wdXQgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0gW107XG4gICAgICAgIGNvbnN0IGl0ZW1EYXRhc2V0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgIHRoaXMuaXRlbXMubWFwKGFzeW5jIChpdGVtLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2tleV07XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIHZhbHVlMixcbiAgICAgICAgICAgICAgYXdhaXQgaXRlbS5fcnVuKHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogdmFsdWUyIH0sIGNvbmZpZzIpXG4gICAgICAgICAgICBdO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWUyLCBpdGVtRGF0YXNldF0gb2YgaXRlbURhdGFzZXRzKSB7XG4gICAgICAgICAgaWYgKGl0ZW1EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGl0ZW1EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IGl0ZW1EYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpdGVtRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhc2V0LnZhbHVlLnB1c2goaXRlbURhdGFzZXQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMgfHwgIWNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgIGZvciAobGV0IGtleSA9IHRoaXMuaXRlbXMubGVuZ3RoOyBrZXkgPCBpbnB1dC5sZW5ndGg7IGtleSsrKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnZhbHVlLnB1c2goaW5wdXRba2V5XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9tYXAvbWFwLnRzXG5mdW5jdGlvbiBtYXAoa2V5LCB2YWx1ZTIsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwibWFwXCIsXG4gICAgcmVmZXJlbmNlOiBtYXAsXG4gICAgZXhwZWN0czogXCJNYXBcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAga2V5LFxuICAgIHZhbHVlOiB2YWx1ZTIsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgZGF0YXNldC52YWx1ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgW2lucHV0S2V5LCBpbnB1dFZhbHVlXSBvZiBpbnB1dCkge1xuICAgICAgICAgIGNvbnN0IGtleURhdGFzZXQgPSB0aGlzLmtleS5fcnVuKFxuICAgICAgICAgICAgeyB0eXBlZDogZmFsc2UsIHZhbHVlOiBpbnB1dEtleSB9LFxuICAgICAgICAgICAgY29uZmlnMlxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGtleURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJtYXBcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcImtleVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5OiBpbnB1dEtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IGlucHV0VmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGtleURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0ga2V5RGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHZhbHVlRGF0YXNldCA9IHRoaXMudmFsdWUuX3J1bihcbiAgICAgICAgICAgIHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogaW5wdXRWYWx1ZSB9LFxuICAgICAgICAgICAgY29uZmlnMlxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKHZhbHVlRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcIm1hcFwiLFxuICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleTogaW5wdXRLZXksXG4gICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiB2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gdmFsdWVEYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFrZXlEYXRhc2V0LnR5cGVkIHx8ICF2YWx1ZURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YXNldC52YWx1ZS5zZXQoa2V5RGF0YXNldC52YWx1ZSwgdmFsdWVEYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbWFwL21hcEFzeW5jLnRzXG5mdW5jdGlvbiBtYXBBc3luYyhrZXksIHZhbHVlMiwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJtYXBcIixcbiAgICByZWZlcmVuY2U6IG1hcEFzeW5jLFxuICAgIGV4cGVjdHM6IFwiTWFwXCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAga2V5LFxuICAgIHZhbHVlOiB2YWx1ZTIsXG4gICAgbWVzc2FnZSxcbiAgICBhc3luYyBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgZGF0YXNldC52YWx1ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIGNvbnN0IGRhdGFzZXRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgWy4uLmlucHV0XS5tYXAoXG4gICAgICAgICAgICAoW2lucHV0S2V5LCBpbnB1dFZhbHVlXSkgPT4gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICBpbnB1dEtleSxcbiAgICAgICAgICAgICAgaW5wdXRWYWx1ZSxcbiAgICAgICAgICAgICAgdGhpcy5rZXkuX3J1bih7IHR5cGVkOiBmYWxzZSwgdmFsdWU6IGlucHV0S2V5IH0sIGNvbmZpZzIpLFxuICAgICAgICAgICAgICB0aGlzLnZhbHVlLl9ydW4oeyB0eXBlZDogZmFsc2UsIHZhbHVlOiBpbnB1dFZhbHVlIH0sIGNvbmZpZzIpXG4gICAgICAgICAgICBdKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgICAgZm9yIChjb25zdCBbXG4gICAgICAgICAgaW5wdXRLZXksXG4gICAgICAgICAgaW5wdXRWYWx1ZSxcbiAgICAgICAgICBrZXlEYXRhc2V0LFxuICAgICAgICAgIHZhbHVlRGF0YXNldFxuICAgICAgICBdIG9mIGRhdGFzZXRzKSB7XG4gICAgICAgICAgaWYgKGtleURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJtYXBcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcImtleVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5OiBpbnB1dEtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IGlucHV0VmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGtleURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0ga2V5RGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJtYXBcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBrZXk6IGlucHV0S2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogaW5wdXRWYWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgdmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IHZhbHVlRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgha2V5RGF0YXNldC50eXBlZCB8fCAhdmFsdWVEYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFzZXQudmFsdWUuc2V0KGtleURhdGFzZXQudmFsdWUsIHZhbHVlRGF0YXNldC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL25hbi9uYW4udHNcbmZ1bmN0aW9uIG5hbihtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcIm5hblwiLFxuICAgIHJlZmVyZW5jZTogbmFuLFxuICAgIGV4cGVjdHM6IFwiTmFOXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoTnVtYmVyLmlzTmFOKGRhdGFzZXQudmFsdWUpKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbmV2ZXIvbmV2ZXIudHNcbmZ1bmN0aW9uIG5ldmVyKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwibmV2ZXJcIixcbiAgICByZWZlcmVuY2U6IG5ldmVyLFxuICAgIGV4cGVjdHM6IFwibmV2ZXJcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL25vbk51bGxhYmxlL25vbk51bGxhYmxlLnRzXG5mdW5jdGlvbiBub25OdWxsYWJsZSh3cmFwcGVkLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcIm5vbl9udWxsYWJsZVwiLFxuICAgIHJlZmVyZW5jZTogbm9uTnVsbGFibGUsXG4gICAgZXhwZWN0czogXCIhbnVsbFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICB3cmFwcGVkLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgICByZXR1cm4gZGF0YXNldDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLndyYXBwZWQuX3J1bihkYXRhc2V0LCBjb25maWcyKTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL25vbk51bGxhYmxlL25vbk51bGxhYmxlQXN5bmMudHNcbmZ1bmN0aW9uIG5vbk51bGxhYmxlQXN5bmMod3JhcHBlZCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJub25fbnVsbGFibGVcIixcbiAgICByZWZlcmVuY2U6IG5vbk51bGxhYmxlQXN5bmMsXG4gICAgZXhwZWN0czogXCIhbnVsbFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIHdyYXBwZWQsXG4gICAgbWVzc2FnZSxcbiAgICBhc3luYyBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZC5fcnVuKGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbm9uTnVsbGlzaC9ub25OdWxsaXNoLnRzXG5mdW5jdGlvbiBub25OdWxsaXNoKHdyYXBwZWQsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwibm9uX251bGxpc2hcIixcbiAgICByZWZlcmVuY2U6IG5vbk51bGxpc2gsXG4gICAgZXhwZWN0czogXCIhbnVsbCAmICF1bmRlZmluZWRcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgd3JhcHBlZCxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IG51bGwgfHwgZGF0YXNldC52YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZC5fcnVuKGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbm9uTnVsbGlzaC9ub25OdWxsaXNoQXN5bmMudHNcbmZ1bmN0aW9uIG5vbk51bGxpc2hBc3luYyh3cmFwcGVkLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcIm5vbl9udWxsaXNoXCIsXG4gICAgcmVmZXJlbmNlOiBub25OdWxsaXNoQXN5bmMsXG4gICAgZXhwZWN0czogXCIhbnVsbCAmICF1bmRlZmluZWRcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICB3cmFwcGVkLFxuICAgIG1lc3NhZ2UsXG4gICAgYXN5bmMgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSA9PT0gbnVsbCB8fCBkYXRhc2V0LnZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVkLl9ydW4oZGF0YXNldCwgY29uZmlnMik7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9ub25PcHRpb25hbC9ub25PcHRpb25hbC50c1xuZnVuY3Rpb24gbm9uT3B0aW9uYWwod3JhcHBlZCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJub25fb3B0aW9uYWxcIixcbiAgICByZWZlcmVuY2U6IG5vbk9wdGlvbmFsLFxuICAgIGV4cGVjdHM6IFwiIXVuZGVmaW5lZFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICB3cmFwcGVkLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZC5fcnVuKGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbm9uT3B0aW9uYWwvbm9uT3B0aW9uYWxBc3luYy50c1xuZnVuY3Rpb24gbm9uT3B0aW9uYWxBc3luYyh3cmFwcGVkLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcIm5vbl9vcHRpb25hbFwiLFxuICAgIHJlZmVyZW5jZTogbm9uT3B0aW9uYWxBc3luYyxcbiAgICBleHBlY3RzOiBcIiF1bmRlZmluZWRcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICB3cmFwcGVkLFxuICAgIG1lc3NhZ2UsXG4gICAgYXN5bmMgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZC5fcnVuKGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvbnVsbC9udWxsLnRzXG5mdW5jdGlvbiBudWxsXyhtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcIm51bGxcIixcbiAgICByZWZlcmVuY2U6IG51bGxfLFxuICAgIGV4cGVjdHM6IFwibnVsbFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9udWxsYWJsZS9udWxsYWJsZS50c1xuZnVuY3Rpb24gbnVsbGFibGUod3JhcHBlZCwgLi4uYXJncykge1xuICBjb25zdCBzY2hlbWEgPSB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcIm51bGxhYmxlXCIsXG4gICAgcmVmZXJlbmNlOiBudWxsYWJsZSxcbiAgICBleHBlY3RzOiBgJHt3cmFwcGVkLmV4cGVjdHN9IHwgbnVsbGAsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIHdyYXBwZWQsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBpZiAoXCJkZWZhdWx0XCIgaW4gdGhpcykge1xuICAgICAgICAgIGRhdGFzZXQudmFsdWUgPSBnZXREZWZhdWx0KFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGRhdGFzZXQsXG4gICAgICAgICAgICBjb25maWcyXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YXNldC52YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVkLl9ydW4oZGF0YXNldCwgY29uZmlnMik7XG4gICAgfVxuICB9O1xuICBpZiAoMCBpbiBhcmdzKSB7XG4gICAgc2NoZW1hLmRlZmF1bHQgPSBhcmdzWzBdO1xuICB9XG4gIHJldHVybiBzY2hlbWE7XG59XG5cbi8vIHNyYy9zY2hlbWFzL251bGxhYmxlL251bGxhYmxlQXN5bmMudHNcbmZ1bmN0aW9uIG51bGxhYmxlQXN5bmMod3JhcHBlZCwgLi4uYXJncykge1xuICBjb25zdCBzY2hlbWEgPSB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcIm51bGxhYmxlXCIsXG4gICAgcmVmZXJlbmNlOiBudWxsYWJsZUFzeW5jLFxuICAgIGV4cGVjdHM6IGAke3dyYXBwZWQuZXhwZWN0c30gfCBudWxsYCxcbiAgICBhc3luYzogdHJ1ZSxcbiAgICB3cmFwcGVkLFxuICAgIGFzeW5jIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKFwiZGVmYXVsdFwiIGluIHRoaXMpIHtcbiAgICAgICAgICBkYXRhc2V0LnZhbHVlID0gYXdhaXQgZ2V0RGVmYXVsdChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBkYXRhc2V0LFxuICAgICAgICAgICAgY29uZmlnMlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gZGF0YXNldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZC5fcnVuKGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgIH1cbiAgfTtcbiAgaWYgKDAgaW4gYXJncykge1xuICAgIHNjaGVtYS5kZWZhdWx0ID0gYXJnc1swXTtcbiAgfVxuICByZXR1cm4gc2NoZW1hO1xufVxuXG4vLyBzcmMvc2NoZW1hcy9udWxsaXNoL251bGxpc2gudHNcbmZ1bmN0aW9uIG51bGxpc2god3JhcHBlZCwgLi4uYXJncykge1xuICBjb25zdCBzY2hlbWEgPSB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcIm51bGxpc2hcIixcbiAgICByZWZlcmVuY2U6IG51bGxpc2gsXG4gICAgZXhwZWN0czogYCR7d3JhcHBlZC5leHBlY3RzfSB8IG51bGwgfCB1bmRlZmluZWRgLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICB3cmFwcGVkLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IG51bGwgfHwgZGF0YXNldC52YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlmIChcImRlZmF1bHRcIiBpbiB0aGlzKSB7XG4gICAgICAgICAgZGF0YXNldC52YWx1ZSA9IGdldERlZmF1bHQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgZGF0YXNldCxcbiAgICAgICAgICAgIGNvbmZpZzJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhc2V0LnZhbHVlID09PSBudWxsIHx8IGRhdGFzZXQudmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVkLl9ydW4oZGF0YXNldCwgY29uZmlnMik7XG4gICAgfVxuICB9O1xuICBpZiAoMCBpbiBhcmdzKSB7XG4gICAgc2NoZW1hLmRlZmF1bHQgPSBhcmdzWzBdO1xuICB9XG4gIHJldHVybiBzY2hlbWE7XG59XG5cbi8vIHNyYy9zY2hlbWFzL251bGxpc2gvbnVsbGlzaEFzeW5jLnRzXG5mdW5jdGlvbiBudWxsaXNoQXN5bmMod3JhcHBlZCwgLi4uYXJncykge1xuICBjb25zdCBzY2hlbWEgPSB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcIm51bGxpc2hcIixcbiAgICByZWZlcmVuY2U6IG51bGxpc2hBc3luYyxcbiAgICBleHBlY3RzOiBgJHt3cmFwcGVkLmV4cGVjdHN9IHwgbnVsbCB8IHVuZGVmaW5lZGAsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgd3JhcHBlZCxcbiAgICBhc3luYyBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnZhbHVlID09PSBudWxsIHx8IGRhdGFzZXQudmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoXCJkZWZhdWx0XCIgaW4gdGhpcykge1xuICAgICAgICAgIGRhdGFzZXQudmFsdWUgPSBhd2FpdCBnZXREZWZhdWx0KFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIGRhdGFzZXQsXG4gICAgICAgICAgICBjb25maWcyXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YXNldC52YWx1ZSA9PT0gbnVsbCB8fCBkYXRhc2V0LnZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gZGF0YXNldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZC5fcnVuKGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgIH1cbiAgfTtcbiAgaWYgKDAgaW4gYXJncykge1xuICAgIHNjaGVtYS5kZWZhdWx0ID0gYXJnc1swXTtcbiAgfVxuICByZXR1cm4gc2NoZW1hO1xufVxuXG4vLyBzcmMvc2NoZW1hcy9udW1iZXIvbnVtYmVyLnRzXG5mdW5jdGlvbiBudW1iZXIobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJudW1iZXJcIixcbiAgICByZWZlcmVuY2U6IG51bWJlcixcbiAgICBleHBlY3RzOiBcIm51bWJlclwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKHR5cGVvZiBkYXRhc2V0LnZhbHVlID09PSBcIm51bWJlclwiICYmICFpc05hTihkYXRhc2V0LnZhbHVlKSkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL29iamVjdC9vYmplY3QudHNcbmZ1bmN0aW9uIG9iamVjdChlbnRyaWVzLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgIHJlZmVyZW5jZTogb2JqZWN0LFxuICAgIGV4cGVjdHM6IFwiT2JqZWN0XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGVudHJpZXMsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGlmIChpbnB1dCAmJiB0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5lbnRyaWVzKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUyID0gaW5wdXRba2V5XTtcbiAgICAgICAgICBjb25zdCB2YWx1ZURhdGFzZXQgPSB0aGlzLmVudHJpZXNba2V5XS5fcnVuKFxuICAgICAgICAgICAgeyB0eXBlZDogZmFsc2UsIHZhbHVlOiB2YWx1ZTIgfSxcbiAgICAgICAgICAgIGNvbmZpZzJcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmICh2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHZhbHVlRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSB2YWx1ZURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXZhbHVlRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWVEYXRhc2V0LnZhbHVlICE9PSB2b2lkIDAgfHwga2V5IGluIGlucHV0KSB7XG4gICAgICAgICAgICBkYXRhc2V0LnZhbHVlW2tleV0gPSB2YWx1ZURhdGFzZXQudmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9vYmplY3Qvb2JqZWN0QXN5bmMudHNcbmZ1bmN0aW9uIG9iamVjdEFzeW5jKGVudHJpZXMsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgcmVmZXJlbmNlOiBvYmplY3RBc3luYyxcbiAgICBleHBlY3RzOiBcIk9iamVjdFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGVudHJpZXMsXG4gICAgbWVzc2FnZSxcbiAgICBhc3luYyBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGlmIChpbnB1dCAmJiB0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSB7fTtcbiAgICAgICAgY29uc3QgdmFsdWVEYXRhc2V0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHRoaXMuZW50cmllcykubWFwKGFzeW5jIChba2V5LCBzY2hlbWFdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZTIgPSBpbnB1dFtrZXldO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTIsXG4gICAgICAgICAgICAgIGF3YWl0IHNjaGVtYS5fcnVuKHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogdmFsdWUyIH0sIGNvbmZpZzIpXG4gICAgICAgICAgICBdO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWUyLCB2YWx1ZURhdGFzZXRdIG9mIHZhbHVlRGF0YXNldHMpIHtcbiAgICAgICAgICBpZiAodmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiB2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gdmFsdWVEYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF2YWx1ZURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlRGF0YXNldC52YWx1ZSAhPT0gdm9pZCAwIHx8IGtleSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgZGF0YXNldC52YWx1ZVtrZXldID0gdmFsdWVEYXRhc2V0LnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvb2JqZWN0V2l0aFJlc3Qvb2JqZWN0V2l0aFJlc3QudHNcbmZ1bmN0aW9uIG9iamVjdFdpdGhSZXN0KGVudHJpZXMsIHJlc3QsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwib2JqZWN0X3dpdGhfcmVzdFwiLFxuICAgIHJlZmVyZW5jZTogb2JqZWN0V2l0aFJlc3QsXG4gICAgZXhwZWN0czogXCJPYmplY3RcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgZW50cmllcyxcbiAgICByZXN0LFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoaW5wdXQgJiYgdHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuZW50cmllcykge1xuICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2tleV07XG4gICAgICAgICAgY29uc3QgdmFsdWVEYXRhc2V0ID0gdGhpcy5lbnRyaWVzW2tleV0uX3J1bihcbiAgICAgICAgICAgIHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogdmFsdWUyIH0sXG4gICAgICAgICAgICBjb25maWcyXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAodmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiB2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gdmFsdWVEYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF2YWx1ZURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlRGF0YXNldC52YWx1ZSAhPT0gdm9pZCAwIHx8IGtleSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgZGF0YXNldC52YWx1ZVtrZXldID0gdmFsdWVEYXRhc2V0LnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzIHx8ICFjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgaWYgKF9pc1ZhbGlkT2JqZWN0S2V5KGlucHV0LCBrZXkpICYmICEoa2V5IGluIHRoaXMuZW50cmllcykpIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUyID0gaW5wdXRba2V5XTtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWVEYXRhc2V0ID0gdGhpcy5yZXN0Ll9ydW4oXG4gICAgICAgICAgICAgICAgeyB0eXBlZDogZmFsc2UsIHZhbHVlOiB2YWx1ZTIgfSxcbiAgICAgICAgICAgICAgICBjb25maWcyXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgdmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IHZhbHVlRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIXZhbHVlRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhc2V0LnZhbHVlW2tleV0gPSB2YWx1ZURhdGFzZXQudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9vYmplY3RXaXRoUmVzdC9vYmplY3RXaXRoUmVzdEFzeW5jLnRzXG5mdW5jdGlvbiBvYmplY3RXaXRoUmVzdEFzeW5jKGVudHJpZXMsIHJlc3QsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwib2JqZWN0X3dpdGhfcmVzdFwiLFxuICAgIHJlZmVyZW5jZTogb2JqZWN0V2l0aFJlc3RBc3luYyxcbiAgICBleHBlY3RzOiBcIk9iamVjdFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGVudHJpZXMsXG4gICAgcmVzdCxcbiAgICBtZXNzYWdlLFxuICAgIGFzeW5jIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3QgaW5wdXQgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgaWYgKGlucHV0ICYmIHR5cGVvZiBpbnB1dCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgZGF0YXNldC52YWx1ZSA9IHt9O1xuICAgICAgICBjb25zdCBbbm9ybWFsRGF0YXNldHMsIHJlc3REYXRhc2V0c10gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgLy8gUGFyc2Ugc2NoZW1hIG9mIGVhY2ggbm9ybWFsIGVudHJ5XG4gICAgICAgICAgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyh0aGlzLmVudHJpZXMpLm1hcChhc3luYyAoW2tleSwgc2NoZW1hXSkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCB2YWx1ZTIgPSBpbnB1dFtrZXldO1xuICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTIsXG4gICAgICAgICAgICAgICAgYXdhaXQgc2NoZW1hLl9ydW4oeyB0eXBlZDogZmFsc2UsIHZhbHVlOiB2YWx1ZTIgfSwgY29uZmlnMilcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKSxcbiAgICAgICAgICAvLyBQYXJzZSBvdGhlciBlbnRyaWVzIHdpdGggcmVzdCBzY2hlbWFcbiAgICAgICAgICBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGlucHV0KS5maWx0ZXIoXG4gICAgICAgICAgICAgIChba2V5XSkgPT4gX2lzVmFsaWRPYmplY3RLZXkoaW5wdXQsIGtleSkgJiYgIShrZXkgaW4gdGhpcy5lbnRyaWVzKVxuICAgICAgICAgICAgKS5tYXAoXG4gICAgICAgICAgICAgIGFzeW5jIChba2V5LCB2YWx1ZTJdKSA9PiBbXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlMixcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlc3QuX3J1bih7IHR5cGVkOiBmYWxzZSwgdmFsdWU6IHZhbHVlMiB9LCBjb25maWcyKVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgICApXG4gICAgICAgICAgKVxuICAgICAgICBdKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZTIsIHZhbHVlRGF0YXNldF0gb2Ygbm9ybWFsRGF0YXNldHMpIHtcbiAgICAgICAgICBpZiAodmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiB2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gdmFsdWVEYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF2YWx1ZURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlRGF0YXNldC52YWx1ZSAhPT0gdm9pZCAwIHx8IGtleSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgZGF0YXNldC52YWx1ZVtrZXldID0gdmFsdWVEYXRhc2V0LnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzIHx8ICFjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlMiwgdmFsdWVEYXRhc2V0XSBvZiByZXN0RGF0YXNldHMpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiB2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gdmFsdWVEYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXZhbHVlRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhc2V0LnZhbHVlW2tleV0gPSB2YWx1ZURhdGFzZXQudmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9vcHRpb25hbC9vcHRpb25hbC50c1xuZnVuY3Rpb24gb3B0aW9uYWwod3JhcHBlZCwgLi4uYXJncykge1xuICBjb25zdCBzY2hlbWEgPSB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcIm9wdGlvbmFsXCIsXG4gICAgcmVmZXJlbmNlOiBvcHRpb25hbCxcbiAgICBleHBlY3RzOiBgJHt3cmFwcGVkLmV4cGVjdHN9IHwgdW5kZWZpbmVkYCxcbiAgICBhc3luYzogZmFsc2UsXG4gICAgd3JhcHBlZCxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmIChkYXRhc2V0LnZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgaWYgKFwiZGVmYXVsdFwiIGluIHRoaXMpIHtcbiAgICAgICAgICBkYXRhc2V0LnZhbHVlID0gZ2V0RGVmYXVsdChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBkYXRhc2V0LFxuICAgICAgICAgICAgY29uZmlnMlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFzZXQudmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy53cmFwcGVkLl9ydW4oZGF0YXNldCwgY29uZmlnMik7XG4gICAgfVxuICB9O1xuICBpZiAoMCBpbiBhcmdzKSB7XG4gICAgc2NoZW1hLmRlZmF1bHQgPSBhcmdzWzBdO1xuICB9XG4gIHJldHVybiBzY2hlbWE7XG59XG5cbi8vIHNyYy9zY2hlbWFzL29wdGlvbmFsL29wdGlvbmFsQXN5bmMudHNcbmZ1bmN0aW9uIG9wdGlvbmFsQXN5bmMod3JhcHBlZCwgLi4uYXJncykge1xuICBjb25zdCBzY2hlbWEgPSB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcIm9wdGlvbmFsXCIsXG4gICAgcmVmZXJlbmNlOiBvcHRpb25hbEFzeW5jLFxuICAgIGV4cGVjdHM6IGAke3dyYXBwZWQuZXhwZWN0c30gfCB1bmRlZmluZWRgLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIHdyYXBwZWQsXG4gICAgYXN5bmMgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGlmIChcImRlZmF1bHRcIiBpbiB0aGlzKSB7XG4gICAgICAgICAgZGF0YXNldC52YWx1ZSA9IGF3YWl0IGdldERlZmF1bHQoXG4gICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgZGF0YXNldCxcbiAgICAgICAgICAgIGNvbmZpZzJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhc2V0LnZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gZGF0YXNldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZC5fcnVuKGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgIH1cbiAgfTtcbiAgaWYgKDAgaW4gYXJncykge1xuICAgIHNjaGVtYS5kZWZhdWx0ID0gYXJnc1swXTtcbiAgfVxuICByZXR1cm4gc2NoZW1hO1xufVxuXG4vLyBzcmMvc2NoZW1hcy9waWNrbGlzdC9waWNrbGlzdC50c1xuZnVuY3Rpb24gcGlja2xpc3Qob3B0aW9ucywgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJwaWNrbGlzdFwiLFxuICAgIHJlZmVyZW5jZTogcGlja2xpc3QsXG4gICAgZXhwZWN0czogb3B0aW9ucy5tYXAoX3N0cmluZ2lmeSkuam9pbihcIiB8IFwiKSB8fCBcIm5ldmVyXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG9wdGlvbnMsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW5jbHVkZXMoZGF0YXNldC52YWx1ZSkpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9wcm9taXNlL3Byb21pc2UudHNcbmZ1bmN0aW9uIHByb21pc2UobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJwcm9taXNlXCIsXG4gICAgcmVmZXJlbmNlOiBwcm9taXNlLFxuICAgIGV4cGVjdHM6IFwiUHJvbWlzZVwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKGRhdGFzZXQudmFsdWUgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvcmVjb3JkL3JlY29yZC50c1xuZnVuY3Rpb24gcmVjb3JkKGtleSwgdmFsdWUyLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcInJlY29yZFwiLFxuICAgIHJlZmVyZW5jZTogcmVjb3JkLFxuICAgIGV4cGVjdHM6IFwiT2JqZWN0XCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIGtleSxcbiAgICB2YWx1ZTogdmFsdWUyLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoaW5wdXQgJiYgdHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0ge307XG4gICAgICAgIGZvciAoY29uc3QgZW50cnlLZXkgaW4gaW5wdXQpIHtcbiAgICAgICAgICBpZiAoX2lzVmFsaWRPYmplY3RLZXkoaW5wdXQsIGVudHJ5S2V5KSkge1xuICAgICAgICAgICAgY29uc3QgZW50cnlWYWx1ZSA9IGlucHV0W2VudHJ5S2V5XTtcbiAgICAgICAgICAgIGNvbnN0IGtleURhdGFzZXQgPSB0aGlzLmtleS5fcnVuKFxuICAgICAgICAgICAgICB7IHR5cGVkOiBmYWxzZSwgdmFsdWU6IGVudHJ5S2V5IH0sXG4gICAgICAgICAgICAgIGNvbmZpZzJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAoa2V5RGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICBvcmlnaW46IFwia2V5XCIsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAga2V5OiBlbnRyeUtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogZW50cnlWYWx1ZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGtleURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IGtleURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlRGF0YXNldCA9IHRoaXMudmFsdWUuX3J1bihcbiAgICAgICAgICAgICAgeyB0eXBlZDogZmFsc2UsIHZhbHVlOiBlbnRyeVZhbHVlIH0sXG4gICAgICAgICAgICAgIGNvbmZpZzJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpZiAodmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGtleTogZW50cnlLZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IGVudHJ5VmFsdWVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiB2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gdmFsdWVEYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWtleURhdGFzZXQudHlwZWQgfHwgIXZhbHVlRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoa2V5RGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnZhbHVlW2tleURhdGFzZXQudmFsdWVdID0gdmFsdWVEYXRhc2V0LnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvcmVjb3JkL3JlY29yZEFzeW5jLnRzXG5mdW5jdGlvbiByZWNvcmRBc3luYyhrZXksIHZhbHVlMiwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJyZWNvcmRcIixcbiAgICByZWZlcmVuY2U6IHJlY29yZEFzeW5jLFxuICAgIGV4cGVjdHM6IFwiT2JqZWN0XCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAga2V5LFxuICAgIHZhbHVlOiB2YWx1ZTIsXG4gICAgbWVzc2FnZSxcbiAgICBhc3luYyBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGlmIChpbnB1dCAmJiB0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSB7fTtcbiAgICAgICAgY29uc3QgZGF0YXNldHMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgICAgICBPYmplY3QuZW50cmllcyhpbnB1dCkuZmlsdGVyKChba2V5Ml0pID0+IF9pc1ZhbGlkT2JqZWN0S2V5KGlucHV0LCBrZXkyKSkubWFwKFxuICAgICAgICAgICAgKFtlbnRyeUtleSwgZW50cnlWYWx1ZV0pID0+IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgZW50cnlLZXksXG4gICAgICAgICAgICAgIGVudHJ5VmFsdWUsXG4gICAgICAgICAgICAgIHRoaXMua2V5Ll9ydW4oeyB0eXBlZDogZmFsc2UsIHZhbHVlOiBlbnRyeUtleSB9LCBjb25maWcyKSxcbiAgICAgICAgICAgICAgdGhpcy52YWx1ZS5fcnVuKHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogZW50cnlWYWx1ZSB9LCBjb25maWcyKVxuICAgICAgICAgICAgXSlcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIGZvciAoY29uc3QgW1xuICAgICAgICAgIGVudHJ5S2V5LFxuICAgICAgICAgIGVudHJ5VmFsdWUsXG4gICAgICAgICAga2V5RGF0YXNldCxcbiAgICAgICAgICB2YWx1ZURhdGFzZXRcbiAgICAgICAgXSBvZiBkYXRhc2V0cykge1xuICAgICAgICAgIGlmIChrZXlEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJrZXlcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleTogZW50cnlLZXksXG4gICAgICAgICAgICAgIHZhbHVlOiBlbnRyeVZhbHVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBrZXlEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IGtleURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5OiBlbnRyeUtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IGVudHJ5VmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIHZhbHVlRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSB2YWx1ZURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWtleURhdGFzZXQudHlwZWQgfHwgIXZhbHVlRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoa2V5RGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgZGF0YXNldC52YWx1ZVtrZXlEYXRhc2V0LnZhbHVlXSA9IHZhbHVlRGF0YXNldC52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3NldC9zZXQudHNcbmZ1bmN0aW9uIHNldCh2YWx1ZTIsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwic2V0XCIsXG4gICAgcmVmZXJlbmNlOiBzZXQsXG4gICAgZXhwZWN0czogXCJTZXRcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgdmFsdWU6IHZhbHVlMixcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3QgaW5wdXQgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICAgICAgZm9yIChjb25zdCBpbnB1dFZhbHVlIG9mIGlucHV0KSB7XG4gICAgICAgICAgY29uc3QgdmFsdWVEYXRhc2V0ID0gdGhpcy52YWx1ZS5fcnVuKFxuICAgICAgICAgICAgeyB0eXBlZDogZmFsc2UsIHZhbHVlOiBpbnB1dFZhbHVlIH0sXG4gICAgICAgICAgICBjb25maWcyXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAodmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5OiBudWxsLFxuICAgICAgICAgICAgICB2YWx1ZTogaW5wdXRWYWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgdmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IHZhbHVlRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdmFsdWVEYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFzZXQudmFsdWUuYWRkKHZhbHVlRGF0YXNldC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3NldC9zZXRBc3luYy50c1xuZnVuY3Rpb24gc2V0QXN5bmModmFsdWUyLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcInNldFwiLFxuICAgIHJlZmVyZW5jZTogc2V0QXN5bmMsXG4gICAgZXhwZWN0czogXCJTZXRcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICB2YWx1ZTogdmFsdWUyLFxuICAgIG1lc3NhZ2UsXG4gICAgYXN5bmMgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICAgICAgICBjb25zdCB2YWx1ZURhdGFzZXRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgWy4uLmlucHV0XS5tYXAoXG4gICAgICAgICAgICBhc3luYyAoaW5wdXRWYWx1ZSkgPT4gW1xuICAgICAgICAgICAgICBpbnB1dFZhbHVlLFxuICAgICAgICAgICAgICBhd2FpdCB0aGlzLnZhbHVlLl9ydW4oXG4gICAgICAgICAgICAgICAgeyB0eXBlZDogZmFsc2UsIHZhbHVlOiBpbnB1dFZhbHVlIH0sXG4gICAgICAgICAgICAgICAgY29uZmlnMlxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICBdXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgICBmb3IgKGNvbnN0IFtpbnB1dFZhbHVlLCB2YWx1ZURhdGFzZXRdIG9mIHZhbHVlRGF0YXNldHMpIHtcbiAgICAgICAgICBpZiAodmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5OiBudWxsLFxuICAgICAgICAgICAgICB2YWx1ZTogaW5wdXRWYWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgdmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IHZhbHVlRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdmFsdWVEYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFzZXQudmFsdWUuYWRkKHZhbHVlRGF0YXNldC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3N0cmljdE9iamVjdC9zdHJpY3RPYmplY3QudHNcbmZ1bmN0aW9uIHN0cmljdE9iamVjdChlbnRyaWVzLCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcInN0cmljdF9vYmplY3RcIixcbiAgICByZWZlcmVuY2U6IHN0cmljdE9iamVjdCxcbiAgICBleHBlY3RzOiBcIk9iamVjdFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBlbnRyaWVzLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoaW5wdXQgJiYgdHlwZW9mIGlucHV0ID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuZW50cmllcykge1xuICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2tleV07XG4gICAgICAgICAgY29uc3QgdmFsdWVEYXRhc2V0ID0gdGhpcy5lbnRyaWVzW2tleV0uX3J1bihcbiAgICAgICAgICAgIHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogdmFsdWUyIH0sXG4gICAgICAgICAgICBjb25maWcyXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAodmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiB2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gdmFsdWVEYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF2YWx1ZURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlRGF0YXNldC52YWx1ZSAhPT0gdm9pZCAwIHx8IGtleSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgZGF0YXNldC52YWx1ZVtrZXldID0gdmFsdWVEYXRhc2V0LnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzIHx8ICFjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgaWYgKCEoa2V5IGluIHRoaXMuZW50cmllcykpIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUyID0gaW5wdXRba2V5XTtcbiAgICAgICAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6IHZhbHVlMixcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJuZXZlclwiLFxuICAgICAgICAgICAgICAgIHBhdGg6IFtcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3N0cmljdE9iamVjdC9zdHJpY3RPYmplY3RBc3luYy50c1xuZnVuY3Rpb24gc3RyaWN0T2JqZWN0QXN5bmMoZW50cmllcywgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJzdHJpY3Rfb2JqZWN0XCIsXG4gICAgcmVmZXJlbmNlOiBzdHJpY3RPYmplY3RBc3luYyxcbiAgICBleHBlY3RzOiBcIk9iamVjdFwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGVudHJpZXMsXG4gICAgbWVzc2FnZSxcbiAgICBhc3luYyBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGlmIChpbnB1dCAmJiB0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSB7fTtcbiAgICAgICAgY29uc3QgdmFsdWVEYXRhc2V0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHRoaXMuZW50cmllcykubWFwKGFzeW5jIChba2V5LCBzY2hlbWFdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZTIgPSBpbnB1dFtrZXldO1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTIsXG4gICAgICAgICAgICAgIGF3YWl0IHNjaGVtYS5fcnVuKHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogdmFsdWUyIH0sIGNvbmZpZzIpXG4gICAgICAgICAgICBdO1xuICAgICAgICAgIH0pXG4gICAgICAgICk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWUyLCB2YWx1ZURhdGFzZXRdIG9mIHZhbHVlRGF0YXNldHMpIHtcbiAgICAgICAgICBpZiAodmFsdWVEYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiB2YWx1ZURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gdmFsdWVEYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF2YWx1ZURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlRGF0YXNldC52YWx1ZSAhPT0gdm9pZCAwIHx8IGtleSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgZGF0YXNldC52YWx1ZVtrZXldID0gdmFsdWVEYXRhc2V0LnZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzIHx8ICFjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgaWYgKCEoa2V5IGluIHRoaXMuZW50cmllcykpIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUyID0gaW5wdXRba2V5XTtcbiAgICAgICAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6IHZhbHVlMixcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJuZXZlclwiLFxuICAgICAgICAgICAgICAgIHBhdGg6IFtcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3N0cmljdFR1cGxlL3N0cmljdFR1cGxlLnRzXG5mdW5jdGlvbiBzdHJpY3RUdXBsZShpdGVtcywgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJzdHJpY3RfdHVwbGVcIixcbiAgICByZWZlcmVuY2U6IHN0cmljdFR1cGxlLFxuICAgIGV4cGVjdHM6IFwiQXJyYXlcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgaXRlbXMsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgICAgZGF0YXNldC52YWx1ZSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBrZXkgPSAwOyBrZXkgPCB0aGlzLml0ZW1zLmxlbmd0aDsga2V5KyspIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZTIgPSBpbnB1dFtrZXldO1xuICAgICAgICAgIGNvbnN0IGl0ZW1EYXRhc2V0ID0gdGhpcy5pdGVtc1trZXldLl9ydW4oXG4gICAgICAgICAgICB7IHR5cGVkOiBmYWxzZSwgdmFsdWU6IHZhbHVlMiB9LFxuICAgICAgICAgICAgY29uZmlnMlxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGl0ZW1EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGl0ZW1EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IGl0ZW1EYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpdGVtRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhc2V0LnZhbHVlLnB1c2goaXRlbURhdGFzZXQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGRhdGFzZXQuaXNzdWVzICYmIGNvbmZpZzIuYWJvcnRFYXJseSkgJiYgdGhpcy5pdGVtcy5sZW5ndGggPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZTIgPSBpbnB1dFtpdGVtcy5sZW5ndGhdO1xuICAgICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgICAgaW5wdXQ6IHZhbHVlMixcbiAgICAgICAgICAgIGV4cGVjdGVkOiBcIm5ldmVyXCIsXG4gICAgICAgICAgICBwYXRoOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAga2V5OiB0aGlzLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvc3RyaWN0VHVwbGUvc3RyaWN0VHVwbGVBc3luYy50c1xuZnVuY3Rpb24gc3RyaWN0VHVwbGVBc3luYyhpdGVtcywgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJzdHJpY3RfdHVwbGVcIixcbiAgICByZWZlcmVuY2U6IHN0cmljdFR1cGxlQXN5bmMsXG4gICAgZXhwZWN0czogXCJBcnJheVwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGl0ZW1zLFxuICAgIG1lc3NhZ2UsXG4gICAgYXN5bmMgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSBbXTtcbiAgICAgICAgY29uc3QgaXRlbURhdGFzZXRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgdGhpcy5pdGVtcy5tYXAoYXN5bmMgKGl0ZW0sIGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUyID0gaW5wdXRba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgdmFsdWUyLFxuICAgICAgICAgICAgICBhd2FpdCBpdGVtLl9ydW4oeyB0eXBlZDogZmFsc2UsIHZhbHVlOiB2YWx1ZTIgfSwgY29uZmlnMilcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZTIsIGl0ZW1EYXRhc2V0XSBvZiBpdGVtRGF0YXNldHMpIHtcbiAgICAgICAgICBpZiAoaXRlbURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgaXRlbURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gaXRlbURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWl0ZW1EYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFzZXQudmFsdWUucHVzaChpdGVtRGF0YXNldC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoZGF0YXNldC5pc3N1ZXMgJiYgY29uZmlnMi5hYm9ydEVhcmx5KSAmJiB0aGlzLml0ZW1zLmxlbmd0aCA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2l0ZW1zLmxlbmd0aF07XG4gICAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgICBpbnB1dDogdmFsdWUyLFxuICAgICAgICAgICAgZXhwZWN0ZWQ6IFwibmV2ZXJcIixcbiAgICAgICAgICAgIHBhdGg6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBrZXk6IHRoaXMuaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy9zdHJpbmcvc3RyaW5nLnRzXG5mdW5jdGlvbiBzdHJpbmcobWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICByZWZlcmVuY2U6IHN0cmluZyxcbiAgICBleHBlY3RzOiBcInN0cmluZ1wiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgaWYgKHR5cGVvZiBkYXRhc2V0LnZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvc3ltYm9sL3N5bWJvbC50c1xuZnVuY3Rpb24gc3ltYm9sKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwic3ltYm9sXCIsXG4gICAgcmVmZXJlbmNlOiBzeW1ib2wsXG4gICAgZXhwZWN0czogXCJzeW1ib2xcIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgbWVzc2FnZSxcbiAgICBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGlmICh0eXBlb2YgZGF0YXNldC52YWx1ZSA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3R1cGxlL3R1cGxlLnRzXG5mdW5jdGlvbiB0dXBsZShpdGVtcywgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJ0dXBsZVwiLFxuICAgIHJlZmVyZW5jZTogdHVwbGUsXG4gICAgZXhwZWN0czogXCJBcnJheVwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBpdGVtcyxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3QgaW5wdXQgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgICBkYXRhc2V0LnZhbHVlID0gW107XG4gICAgICAgIGZvciAobGV0IGtleSA9IDA7IGtleSA8IHRoaXMuaXRlbXMubGVuZ3RoOyBrZXkrKykge1xuICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2tleV07XG4gICAgICAgICAgY29uc3QgaXRlbURhdGFzZXQgPSB0aGlzLml0ZW1zW2tleV0uX3J1bihcbiAgICAgICAgICAgIHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogdmFsdWUyIH0sXG4gICAgICAgICAgICBjb25maWcyXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoaXRlbURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgaXRlbURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gaXRlbURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWl0ZW1EYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFzZXQudmFsdWUucHVzaChpdGVtRGF0YXNldC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3R1cGxlL3R1cGxlQXN5bmMudHNcbmZ1bmN0aW9uIHR1cGxlQXN5bmMoaXRlbXMsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwidHVwbGVcIixcbiAgICByZWZlcmVuY2U6IHR1cGxlQXN5bmMsXG4gICAgZXhwZWN0czogXCJBcnJheVwiLFxuICAgIGFzeW5jOiB0cnVlLFxuICAgIGl0ZW1zLFxuICAgIG1lc3NhZ2UsXG4gICAgYXN5bmMgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSBbXTtcbiAgICAgICAgY29uc3QgaXRlbURhdGFzZXRzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgdGhpcy5pdGVtcy5tYXAoYXN5bmMgKGl0ZW0sIGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUyID0gaW5wdXRba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgdmFsdWUyLFxuICAgICAgICAgICAgICBhd2FpdCBpdGVtLl9ydW4oeyB0eXBlZDogZmFsc2UsIHZhbHVlOiB2YWx1ZTIgfSwgY29uZmlnMilcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZTIsIGl0ZW1EYXRhc2V0XSBvZiBpdGVtRGF0YXNldHMpIHtcbiAgICAgICAgICBpZiAoaXRlbURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoSXRlbSA9IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgaXRlbURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aC51bnNoaWZ0KHBhdGhJdGVtKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3Vlcz8ucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzID0gaXRlbURhdGFzZXQuaXNzdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWl0ZW1EYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRhdGFzZXQudmFsdWUucHVzaChpdGVtRGF0YXNldC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3R1cGxlV2l0aFJlc3QvdHVwbGVXaXRoUmVzdC50c1xuZnVuY3Rpb24gdHVwbGVXaXRoUmVzdChpdGVtcywgcmVzdCwgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJ0dXBsZV93aXRoX3Jlc3RcIixcbiAgICByZWZlcmVuY2U6IHR1cGxlV2l0aFJlc3QsXG4gICAgZXhwZWN0czogXCJBcnJheVwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBpdGVtcyxcbiAgICByZXN0LFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSBbXTtcbiAgICAgICAgZm9yIChsZXQga2V5ID0gMDsga2V5IDwgdGhpcy5pdGVtcy5sZW5ndGg7IGtleSsrKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUyID0gaW5wdXRba2V5XTtcbiAgICAgICAgICBjb25zdCBpdGVtRGF0YXNldCA9IHRoaXMuaXRlbXNba2V5XS5fcnVuKFxuICAgICAgICAgICAgeyB0eXBlZDogZmFsc2UsIHZhbHVlOiB2YWx1ZTIgfSxcbiAgICAgICAgICAgIGNvbmZpZzJcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChpdGVtRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgIG9yaWdpbjogXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBpdGVtRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGlzc3VlLnBhdGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGggPSBbcGF0aEl0ZW1dO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRhdGFzZXQuaXNzdWVzPy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXMgPSBpdGVtRGF0YXNldC5pc3N1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghaXRlbURhdGFzZXQudHlwZWQpIHtcbiAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YXNldC52YWx1ZS5wdXNoKGl0ZW1EYXRhc2V0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRhdGFzZXQuaXNzdWVzIHx8ICFjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICBmb3IgKGxldCBrZXkgPSB0aGlzLml0ZW1zLmxlbmd0aDsga2V5IDwgaW5wdXQubGVuZ3RoOyBrZXkrKykge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUyID0gaW5wdXRba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1EYXRhc2V0ID0gdGhpcy5yZXN0Ll9ydW4oeyB0eXBlZDogZmFsc2UsIHZhbHVlOiB2YWx1ZTIgfSwgY29uZmlnMik7XG4gICAgICAgICAgICBpZiAoaXRlbURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGl0ZW1EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IGl0ZW1EYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWl0ZW1EYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGFzZXQudmFsdWUucHVzaChpdGVtRGF0YXNldC52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy90dXBsZVdpdGhSZXN0L3R1cGxlV2l0aFJlc3RBc3luYy50c1xuZnVuY3Rpb24gdHVwbGVXaXRoUmVzdEFzeW5jKGl0ZW1zLCByZXN0LCBtZXNzYWdlKSB7XG4gIHJldHVybiB7XG4gICAga2luZDogXCJzY2hlbWFcIixcbiAgICB0eXBlOiBcInR1cGxlX3dpdGhfcmVzdFwiLFxuICAgIHJlZmVyZW5jZTogdHVwbGVXaXRoUmVzdEFzeW5jLFxuICAgIGV4cGVjdHM6IFwiQXJyYXlcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBpdGVtcyxcbiAgICByZXN0LFxuICAgIG1lc3NhZ2UsXG4gICAgYXN5bmMgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBjb25zdCBpbnB1dCA9IGRhdGFzZXQudmFsdWU7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgZGF0YXNldC50eXBlZCA9IHRydWU7XG4gICAgICAgIGRhdGFzZXQudmFsdWUgPSBbXTtcbiAgICAgICAgY29uc3QgW25vcm1hbERhdGFzZXRzLCByZXN0RGF0YXNldHNdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgIC8vIFBhcnNlIHNjaGVtYSBvZiBlYWNoIG5vcm1hbCBpdGVtXG4gICAgICAgICAgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICB0aGlzLml0ZW1zLm1hcChhc3luYyAoaXRlbSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlMiA9IGlucHV0W2tleV07XG4gICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlMixcbiAgICAgICAgICAgICAgICBhd2FpdCBpdGVtLl9ydW4oeyB0eXBlZDogZmFsc2UsIHZhbHVlOiB2YWx1ZTIgfSwgY29uZmlnMilcbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKSxcbiAgICAgICAgICAvLyBQYXJzZSBvdGhlciBpdGVtcyB3aXRoIHJlc3Qgc2NoZW1hXG4gICAgICAgICAgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBpbnB1dC5zbGljZSh0aGlzLml0ZW1zLmxlbmd0aCkubWFwKGFzeW5jICh2YWx1ZTIsIGtleSkgPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIGtleSArIHRoaXMuaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHZhbHVlMixcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlc3QuX3J1bih7IHR5cGVkOiBmYWxzZSwgdmFsdWU6IHZhbHVlMiB9LCBjb25maWcyKVxuICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICApXG4gICAgICAgIF0pO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlMiwgaXRlbURhdGFzZXRdIG9mIG5vcm1hbERhdGFzZXRzKSB7XG4gICAgICAgICAgaWYgKGl0ZW1EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgY29uc3QgcGF0aEl0ZW0gPSB7XG4gICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZTJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGl0ZW1EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBpZiAoaXNzdWUucGF0aCkge1xuICAgICAgICAgICAgICAgIGlzc3VlLnBhdGgudW5zaGlmdChwYXRoSXRlbSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNzdWUucGF0aCA9IFtwYXRoSXRlbV07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IGl0ZW1EYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcyLmFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFpdGVtRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhc2V0LnZhbHVlLnB1c2goaXRlbURhdGFzZXQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMgfHwgIWNvbmZpZzIuYWJvcnRFYXJseSkge1xuICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWUyLCBpdGVtRGF0YXNldF0gb2YgcmVzdERhdGFzZXRzKSB7XG4gICAgICAgICAgICBpZiAoaXRlbURhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhdGhJdGVtID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICBvcmlnaW46IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlMlxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGl0ZW1EYXRhc2V0Lmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5wYXRoKSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoLnVuc2hpZnQocGF0aEl0ZW0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpc3N1ZS5wYXRoID0gW3BhdGhJdGVtXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YXNldC5pc3N1ZXM/LnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0Lmlzc3VlcyA9IGl0ZW1EYXRhc2V0Lmlzc3VlcztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoY29uZmlnMi5hYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWl0ZW1EYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgICAgIGRhdGFzZXQudHlwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGFzZXQudmFsdWUucHVzaChpdGVtRGF0YXNldC52YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy91bmRlZmluZWQvdW5kZWZpbmVkLnRzXG5mdW5jdGlvbiB1bmRlZmluZWRfKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwidW5kZWZpbmVkXCIsXG4gICAgcmVmZXJlbmNlOiB1bmRlZmluZWRfLFxuICAgIGV4cGVjdHM6IFwidW5kZWZpbmVkXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvdW5pb24vdXRpbHMvX3N1Yklzc3Vlcy9fc3ViSXNzdWVzLnRzXG5mdW5jdGlvbiBfc3ViSXNzdWVzKGRhdGFzZXRzKSB7XG4gIGxldCBpc3N1ZXM7XG4gIGlmIChkYXRhc2V0cykge1xuICAgIGZvciAoY29uc3QgZGF0YXNldCBvZiBkYXRhc2V0cykge1xuICAgICAgaWYgKGlzc3Vlcykge1xuICAgICAgICBpc3N1ZXMucHVzaCguLi5kYXRhc2V0Lmlzc3Vlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc3N1ZXMgPSBkYXRhc2V0Lmlzc3VlcztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGlzc3Vlcztcbn1cblxuLy8gc3JjL3NjaGVtYXMvdW5pb24vdW5pb24udHNcbmZ1bmN0aW9uIHVuaW9uKG9wdGlvbnMsIG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwidW5pb25cIixcbiAgICByZWZlcmVuY2U6IHVuaW9uLFxuICAgIGV4cGVjdHM6IFsuLi5uZXcgU2V0KG9wdGlvbnMubWFwKChvcHRpb24pID0+IG9wdGlvbi5leHBlY3RzKSldLmpvaW4oXCIgfCBcIikgfHwgXCJuZXZlclwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBvcHRpb25zLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBsZXQgdmFsaWREYXRhc2V0O1xuICAgICAgbGV0IHR5cGVkRGF0YXNldHM7XG4gICAgICBsZXQgdW50eXBlZERhdGFzZXRzO1xuICAgICAgZm9yIChjb25zdCBzY2hlbWEgb2YgdGhpcy5vcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbkRhdGFzZXQgPSBzY2hlbWEuX3J1bihcbiAgICAgICAgICB7IHR5cGVkOiBmYWxzZSwgdmFsdWU6IGRhdGFzZXQudmFsdWUgfSxcbiAgICAgICAgICBjb25maWcyXG4gICAgICAgICk7XG4gICAgICAgIGlmIChvcHRpb25EYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbkRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICBpZiAodHlwZWREYXRhc2V0cykge1xuICAgICAgICAgICAgICB0eXBlZERhdGFzZXRzLnB1c2gob3B0aW9uRGF0YXNldCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0eXBlZERhdGFzZXRzID0gW29wdGlvbkRhdGFzZXRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWxpZERhdGFzZXQgPSBvcHRpb25EYXRhc2V0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh1bnR5cGVkRGF0YXNldHMpIHtcbiAgICAgICAgICAgIHVudHlwZWREYXRhc2V0cy5wdXNoKG9wdGlvbkRhdGFzZXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1bnR5cGVkRGF0YXNldHMgPSBbb3B0aW9uRGF0YXNldF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodmFsaWREYXRhc2V0KSB7XG4gICAgICAgIHJldHVybiB2YWxpZERhdGFzZXQ7XG4gICAgICB9XG4gICAgICBpZiAodHlwZWREYXRhc2V0cykge1xuICAgICAgICBpZiAodHlwZWREYXRhc2V0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZWREYXRhc2V0c1swXTtcbiAgICAgICAgfVxuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICBpc3N1ZXM6IF9zdWJJc3N1ZXModHlwZWREYXRhc2V0cylcbiAgICAgICAgfSk7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh1bnR5cGVkRGF0YXNldHM/Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gdW50eXBlZERhdGFzZXRzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgaXNzdWVzOiBfc3ViSXNzdWVzKHVudHlwZWREYXRhc2V0cylcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3VuaW9uL3VuaW9uQXN5bmMudHNcbmZ1bmN0aW9uIHVuaW9uQXN5bmMob3B0aW9ucywgbWVzc2FnZSkge1xuICByZXR1cm4ge1xuICAgIGtpbmQ6IFwic2NoZW1hXCIsXG4gICAgdHlwZTogXCJ1bmlvblwiLFxuICAgIHJlZmVyZW5jZTogdW5pb25Bc3luYyxcbiAgICBleHBlY3RzOiBbLi4ubmV3IFNldChvcHRpb25zLm1hcCgob3B0aW9uKSA9PiBvcHRpb24uZXhwZWN0cykpXS5qb2luKFwiIHwgXCIpIHx8IFwibmV2ZXJcIixcbiAgICBhc3luYzogdHJ1ZSxcbiAgICBvcHRpb25zLFxuICAgIG1lc3NhZ2UsXG4gICAgYXN5bmMgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBsZXQgdmFsaWREYXRhc2V0O1xuICAgICAgbGV0IHR5cGVkRGF0YXNldHM7XG4gICAgICBsZXQgdW50eXBlZERhdGFzZXRzO1xuICAgICAgZm9yIChjb25zdCBzY2hlbWEgb2YgdGhpcy5vcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbkRhdGFzZXQgPSBhd2FpdCBzY2hlbWEuX3J1bihcbiAgICAgICAgICB7IHR5cGVkOiBmYWxzZSwgdmFsdWU6IGRhdGFzZXQudmFsdWUgfSxcbiAgICAgICAgICBjb25maWcyXG4gICAgICAgICk7XG4gICAgICAgIGlmIChvcHRpb25EYXRhc2V0LnR5cGVkKSB7XG4gICAgICAgICAgaWYgKG9wdGlvbkRhdGFzZXQuaXNzdWVzKSB7XG4gICAgICAgICAgICBpZiAodHlwZWREYXRhc2V0cykge1xuICAgICAgICAgICAgICB0eXBlZERhdGFzZXRzLnB1c2gob3B0aW9uRGF0YXNldCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0eXBlZERhdGFzZXRzID0gW29wdGlvbkRhdGFzZXRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWxpZERhdGFzZXQgPSBvcHRpb25EYXRhc2V0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh1bnR5cGVkRGF0YXNldHMpIHtcbiAgICAgICAgICAgIHVudHlwZWREYXRhc2V0cy5wdXNoKG9wdGlvbkRhdGFzZXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1bnR5cGVkRGF0YXNldHMgPSBbb3B0aW9uRGF0YXNldF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodmFsaWREYXRhc2V0KSB7XG4gICAgICAgIHJldHVybiB2YWxpZERhdGFzZXQ7XG4gICAgICB9XG4gICAgICBpZiAodHlwZWREYXRhc2V0cykge1xuICAgICAgICBpZiAodHlwZWREYXRhc2V0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZWREYXRhc2V0c1swXTtcbiAgICAgICAgfVxuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIsIHtcbiAgICAgICAgICBpc3N1ZXM6IF9zdWJJc3N1ZXModHlwZWREYXRhc2V0cylcbiAgICAgICAgfSk7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh1bnR5cGVkRGF0YXNldHM/Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gdW50eXBlZERhdGFzZXRzWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyLCB7XG4gICAgICAgICAgaXNzdWVzOiBfc3ViSXNzdWVzKHVudHlwZWREYXRhc2V0cylcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9zY2hlbWFzL3Vua25vd24vdW5rbm93bi50c1xuZnVuY3Rpb24gdW5rbm93bigpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwidW5rbm93blwiLFxuICAgIHJlZmVyZW5jZTogdW5rbm93bixcbiAgICBleHBlY3RzOiBcInVua25vd25cIixcbiAgICBhc3luYzogZmFsc2UsXG4gICAgX3J1bihkYXRhc2V0KSB7XG4gICAgICBkYXRhc2V0LnR5cGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL3NjaGVtYXMvdmFyaWFudC91dGlscy9fZGlzY3JpbWluYXRvcnMvX2Rpc2NyaW1pbmF0b3JzLnRzXG5mdW5jdGlvbiBfZGlzY3JpbWluYXRvcnMoa2V5LCBvcHRpb25zLCBzZXQyID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSkge1xuICBmb3IgKGNvbnN0IHNjaGVtYSBvZiBvcHRpb25zKSB7XG4gICAgaWYgKHNjaGVtYS50eXBlID09PSBcInZhcmlhbnRcIikge1xuICAgICAgX2Rpc2NyaW1pbmF0b3JzKGtleSwgc2NoZW1hLm9wdGlvbnMsIHNldDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXQyLmFkZChzY2hlbWEuZW50cmllc1trZXldLmV4cGVjdHMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2V0Mjtcbn1cblxuLy8gc3JjL3NjaGVtYXMvdmFyaWFudC92YXJpYW50LnRzXG5mdW5jdGlvbiB2YXJpYW50KGtleSwgb3B0aW9ucywgbWVzc2FnZSkge1xuICBsZXQgZXhwZWN0ZWREaXNjcmltaW5hdG9ycztcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwidmFyaWFudFwiLFxuICAgIHJlZmVyZW5jZTogdmFyaWFudCxcbiAgICBleHBlY3RzOiBcIk9iamVjdFwiLFxuICAgIGFzeW5jOiBmYWxzZSxcbiAgICBrZXksXG4gICAgb3B0aW9ucyxcbiAgICBtZXNzYWdlLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgY29uc3QgaW5wdXQgPSBkYXRhc2V0LnZhbHVlO1xuICAgICAgaWYgKGlucHV0ICYmIHR5cGVvZiBpbnB1dCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yID0gaW5wdXRbdGhpcy5rZXldO1xuICAgICAgICBpZiAodGhpcy5rZXkgaW4gaW5wdXQpIHtcbiAgICAgICAgICBsZXQgb3V0cHV0RGF0YXNldDtcbiAgICAgICAgICBmb3IgKGNvbnN0IHNjaGVtYSBvZiB0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChzY2hlbWEudHlwZSA9PT0gXCJ2YXJpYW50XCIgfHwgIXNjaGVtYS5lbnRyaWVzW3RoaXMua2V5XS5fcnVuKFxuICAgICAgICAgICAgICB7IHR5cGVkOiBmYWxzZSwgdmFsdWU6IGRpc2NyaW1pbmF0b3IgfSxcbiAgICAgICAgICAgICAgY29uZmlnMlxuICAgICAgICAgICAgKS5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgY29uc3Qgb3B0aW9uRGF0YXNldCA9IHNjaGVtYS5fcnVuKFxuICAgICAgICAgICAgICAgIHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogaW5wdXQgfSxcbiAgICAgICAgICAgICAgICBjb25maWcyXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmICghb3B0aW9uRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9uRGF0YXNldDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIW91dHB1dERhdGFzZXQgfHwgIW91dHB1dERhdGFzZXQudHlwZWQgJiYgb3B0aW9uRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgICAgIG91dHB1dERhdGFzZXQgPSBvcHRpb25EYXRhc2V0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvdXRwdXREYXRhc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0RGF0YXNldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFleHBlY3RlZERpc2NyaW1pbmF0b3JzKSB7XG4gICAgICAgICAgZXhwZWN0ZWREaXNjcmltaW5hdG9ycyA9IFsuLi5fZGlzY3JpbWluYXRvcnModGhpcy5rZXksIHRoaXMub3B0aW9ucyldLmpvaW4oXCIgfCBcIikgfHwgXCJuZXZlclwiO1xuICAgICAgICB9XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIGlucHV0OiBkaXNjcmltaW5hdG9yLFxuICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZERpc2NyaW1pbmF0b3JzLFxuICAgICAgICAgIHBhdGg6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBrZXk6IHRoaXMua2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogZGlzY3JpbWluYXRvclxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy92YXJpYW50L3ZhcmlhbnRBc3luYy50c1xuZnVuY3Rpb24gdmFyaWFudEFzeW5jKGtleSwgb3B0aW9ucywgbWVzc2FnZSkge1xuICBsZXQgZXhwZWN0ZWREaXNjcmltaW5hdG9ycztcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwidmFyaWFudFwiLFxuICAgIHJlZmVyZW5jZTogdmFyaWFudEFzeW5jLFxuICAgIGV4cGVjdHM6IFwiT2JqZWN0XCIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAga2V5LFxuICAgIG9wdGlvbnMsXG4gICAgbWVzc2FnZSxcbiAgICBhc3luYyBfcnVuKGRhdGFzZXQsIGNvbmZpZzIpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZGF0YXNldC52YWx1ZTtcbiAgICAgIGlmIChpbnB1dCAmJiB0eXBlb2YgaW5wdXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvciA9IGlucHV0W3RoaXMua2V5XTtcbiAgICAgICAgaWYgKHRoaXMua2V5IGluIGlucHV0KSB7XG4gICAgICAgICAgbGV0IG91dHB1dERhdGFzZXQ7XG4gICAgICAgICAgZm9yIChjb25zdCBzY2hlbWEgb2YgdGhpcy5vcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoc2NoZW1hLnR5cGUgPT09IFwidmFyaWFudFwiIHx8ICEoYXdhaXQgc2NoZW1hLmVudHJpZXNbdGhpcy5rZXldLl9ydW4oXG4gICAgICAgICAgICAgIHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogZGlzY3JpbWluYXRvciB9LFxuICAgICAgICAgICAgICBjb25maWcyXG4gICAgICAgICAgICApKS5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgY29uc3Qgb3B0aW9uRGF0YXNldCA9IGF3YWl0IHNjaGVtYS5fcnVuKFxuICAgICAgICAgICAgICAgIHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogaW5wdXQgfSxcbiAgICAgICAgICAgICAgICBjb25maWcyXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmICghb3B0aW9uRGF0YXNldC5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9uRGF0YXNldDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIW91dHB1dERhdGFzZXQgfHwgIW91dHB1dERhdGFzZXQudHlwZWQgJiYgb3B0aW9uRGF0YXNldC50eXBlZCkge1xuICAgICAgICAgICAgICAgIG91dHB1dERhdGFzZXQgPSBvcHRpb25EYXRhc2V0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvdXRwdXREYXRhc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0RGF0YXNldDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFleHBlY3RlZERpc2NyaW1pbmF0b3JzKSB7XG4gICAgICAgICAgZXhwZWN0ZWREaXNjcmltaW5hdG9ycyA9IFsuLi5fZGlzY3JpbWluYXRvcnModGhpcy5rZXksIHRoaXMub3B0aW9ucyldLmpvaW4oXCIgfCBcIikgfHwgXCJuZXZlclwiO1xuICAgICAgICB9XG4gICAgICAgIF9hZGRJc3N1ZSh0aGlzLCBcInR5cGVcIiwgZGF0YXNldCwgY29uZmlnMiwge1xuICAgICAgICAgIGlucHV0OiBkaXNjcmltaW5hdG9yLFxuICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZERpc2NyaW1pbmF0b3JzLFxuICAgICAgICAgIHBhdGg6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgb3JpZ2luOiBcInZhbHVlXCIsXG4gICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICBrZXk6IHRoaXMua2V5LFxuICAgICAgICAgICAgICB2YWx1ZTogZGlzY3JpbWluYXRvclxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfYWRkSXNzdWUodGhpcywgXCJ0eXBlXCIsIGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvc2NoZW1hcy92b2lkL3ZvaWQudHNcbmZ1bmN0aW9uIHZvaWRfKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBraW5kOiBcInNjaGVtYVwiLFxuICAgIHR5cGU6IFwidm9pZFwiLFxuICAgIHJlZmVyZW5jZTogdm9pZF8sXG4gICAgZXhwZWN0czogXCJ2b2lkXCIsXG4gICAgYXN5bmM6IGZhbHNlLFxuICAgIG1lc3NhZ2UsXG4gICAgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBpZiAoZGF0YXNldC52YWx1ZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgIGRhdGFzZXQudHlwZWQgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2FkZElzc3VlKHRoaXMsIFwidHlwZVwiLCBkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhc2V0O1xuICAgIH1cbiAgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMva2V5b2Yva2V5b2YudHNcbmZ1bmN0aW9uIGtleW9mKHNjaGVtYSwgbWVzc2FnZSkge1xuICByZXR1cm4gcGlja2xpc3QoT2JqZWN0LmtleXMoc2NoZW1hLmVudHJpZXMpLCBtZXNzYWdlKTtcbn1cblxuLy8gc3JjL21ldGhvZHMvb21pdC9vbWl0LnRzXG5mdW5jdGlvbiBvbWl0KHNjaGVtYSwga2V5cykge1xuICBjb25zdCBlbnRyaWVzID0ge1xuICAgIC4uLnNjaGVtYS5lbnRyaWVzXG4gIH07XG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBkZWxldGUgZW50cmllc1trZXldO1xuICB9XG4gIHJldHVybiB7IC4uLnNjaGVtYSwgZW50cmllcyB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9wYXJzZS9wYXJzZS50c1xuZnVuY3Rpb24gcGFyc2Uoc2NoZW1hLCBpbnB1dCwgY29uZmlnMikge1xuICBjb25zdCBkYXRhc2V0ID0gc2NoZW1hLl9ydW4oXG4gICAgeyB0eXBlZDogZmFsc2UsIHZhbHVlOiBpbnB1dCB9LFxuICAgIGdldEdsb2JhbENvbmZpZyhjb25maWcyKVxuICApO1xuICBpZiAoZGF0YXNldC5pc3N1ZXMpIHtcbiAgICB0aHJvdyBuZXcgVmFsaUVycm9yKGRhdGFzZXQuaXNzdWVzKTtcbiAgfVxuICByZXR1cm4gZGF0YXNldC52YWx1ZTtcbn1cblxuLy8gc3JjL21ldGhvZHMvcGFyc2UvcGFyc2VBc3luYy50c1xuYXN5bmMgZnVuY3Rpb24gcGFyc2VBc3luYyhzY2hlbWEsIGlucHV0LCBjb25maWcyKSB7XG4gIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCBzY2hlbWEuX3J1bihcbiAgICB7IHR5cGVkOiBmYWxzZSwgdmFsdWU6IGlucHV0IH0sXG4gICAgZ2V0R2xvYmFsQ29uZmlnKGNvbmZpZzIpXG4gICk7XG4gIGlmIChkYXRhc2V0Lmlzc3Vlcykge1xuICAgIHRocm93IG5ldyBWYWxpRXJyb3IoZGF0YXNldC5pc3N1ZXMpO1xuICB9XG4gIHJldHVybiBkYXRhc2V0LnZhbHVlO1xufVxuXG4vLyBzcmMvbWV0aG9kcy9wYXJzZXIvcGFyc2VyLnRzXG5mdW5jdGlvbiBwYXJzZXIoc2NoZW1hLCBjb25maWcyKSB7XG4gIGNvbnN0IGZ1bmMgPSAoaW5wdXQpID0+IHBhcnNlKHNjaGVtYSwgaW5wdXQsIGNvbmZpZzIpO1xuICBmdW5jLnNjaGVtYSA9IHNjaGVtYTtcbiAgZnVuYy5jb25maWcgPSBjb25maWcyO1xuICByZXR1cm4gZnVuYztcbn1cblxuLy8gc3JjL21ldGhvZHMvcGFyc2VyL3BhcnNlckFzeW5jLnRzXG5mdW5jdGlvbiBwYXJzZXJBc3luYyhzY2hlbWEsIGNvbmZpZzIpIHtcbiAgY29uc3QgZnVuYyA9IChpbnB1dCkgPT4gcGFyc2VBc3luYyhzY2hlbWEsIGlucHV0LCBjb25maWcyKTtcbiAgZnVuYy5zY2hlbWEgPSBzY2hlbWE7XG4gIGZ1bmMuY29uZmlnID0gY29uZmlnMjtcbiAgcmV0dXJuIGZ1bmM7XG59XG5cbi8vIHNyYy9tZXRob2RzL3BhcnRpYWwvcGFydGlhbC50c1xuZnVuY3Rpb24gcGFydGlhbChzY2hlbWEsIGtleXMpIHtcbiAgY29uc3QgZW50cmllcyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEuZW50cmllcykge1xuICAgIGVudHJpZXNba2V5XSA9ICFrZXlzIHx8IGtleXMuaW5jbHVkZXMoa2V5KSA/IG9wdGlvbmFsKHNjaGVtYS5lbnRyaWVzW2tleV0pIDogc2NoZW1hLmVudHJpZXNba2V5XTtcbiAgfVxuICByZXR1cm4geyAuLi5zY2hlbWEsIGVudHJpZXMgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvcGFydGlhbC9wYXJ0aWFsQXN5bmMudHNcbmZ1bmN0aW9uIHBhcnRpYWxBc3luYyhzY2hlbWEsIGtleXMpIHtcbiAgY29uc3QgZW50cmllcyA9IHt9O1xuICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEuZW50cmllcykge1xuICAgIGVudHJpZXNba2V5XSA9ICFrZXlzIHx8IGtleXMuaW5jbHVkZXMoa2V5KSA/IG9wdGlvbmFsQXN5bmMoc2NoZW1hLmVudHJpZXNba2V5XSkgOiBzY2hlbWEuZW50cmllc1trZXldO1xuICB9XG4gIHJldHVybiB7IC4uLnNjaGVtYSwgZW50cmllcyB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9waWNrL3BpY2sudHNcbmZ1bmN0aW9uIHBpY2soc2NoZW1hLCBrZXlzKSB7XG4gIGNvbnN0IGVudHJpZXMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIGVudHJpZXNba2V5XSA9IHNjaGVtYS5lbnRyaWVzW2tleV07XG4gIH1cbiAgcmV0dXJuIHsgLi4uc2NoZW1hLCBlbnRyaWVzIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL3BpcGUvcGlwZS50c1xuZnVuY3Rpb24gcGlwZSguLi5waXBlMikge1xuICByZXR1cm4ge1xuICAgIC4uLnBpcGUyWzBdLFxuICAgIHBpcGU6IHBpcGUyLFxuICAgIF9ydW4oZGF0YXNldCwgY29uZmlnMikge1xuICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHBpcGUyLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBpZiAoZGF0YXNldC5pc3N1ZXMgJiYgKHBpcGUyW2luZGV4XS5raW5kID09PSBcInNjaGVtYVwiIHx8IHBpcGUyW2luZGV4XS5raW5kID09PSBcInRyYW5zZm9ybWF0aW9uXCIpKSB7XG4gICAgICAgICAgZGF0YXNldC50eXBlZCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YXNldC5pc3N1ZXMgfHwgIWNvbmZpZzIuYWJvcnRFYXJseSAmJiAhY29uZmlnMi5hYm9ydFBpcGVFYXJseSkge1xuICAgICAgICAgIGRhdGFzZXQgPSBwaXBlMltpbmRleF0uX3J1bihkYXRhc2V0LCBjb25maWcyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGFzZXQ7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9waXBlL3BpcGVBc3luYy50c1xuZnVuY3Rpb24gcGlwZUFzeW5jKC4uLnBpcGUyKSB7XG4gIHJldHVybiB7XG4gICAgLi4ucGlwZTJbMF0sXG4gICAgcGlwZTogcGlwZTIsXG4gICAgYXN5bmM6IHRydWUsXG4gICAgYXN5bmMgX3J1bihkYXRhc2V0LCBjb25maWcyKSB7XG4gICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgcGlwZTIubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGlmIChkYXRhc2V0Lmlzc3VlcyAmJiAocGlwZTJbaW5kZXhdLmtpbmQgPT09IFwic2NoZW1hXCIgfHwgcGlwZTJbaW5kZXhdLmtpbmQgPT09IFwidHJhbnNmb3JtYXRpb25cIikpIHtcbiAgICAgICAgICBkYXRhc2V0LnR5cGVkID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRhc2V0Lmlzc3VlcyB8fCAhY29uZmlnMi5hYm9ydEVhcmx5ICYmICFjb25maWcyLmFib3J0UGlwZUVhcmx5KSB7XG4gICAgICAgICAgZGF0YXNldCA9IGF3YWl0IHBpcGUyW2luZGV4XS5fcnVuKGRhdGFzZXQsIGNvbmZpZzIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YXNldDtcbiAgICB9XG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL3JlcXVpcmVkL3JlcXVpcmVkLnRzXG5mdW5jdGlvbiByZXF1aXJlZChzY2hlbWEsIGFyZzIsIGFyZzMpIHtcbiAgY29uc3Qga2V5cyA9IEFycmF5LmlzQXJyYXkoYXJnMikgPyBhcmcyIDogdm9pZCAwO1xuICBjb25zdCBtZXNzYWdlID0gQXJyYXkuaXNBcnJheShhcmcyKSA/IGFyZzMgOiBhcmcyO1xuICBjb25zdCBlbnRyaWVzID0ge307XG4gIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5lbnRyaWVzKSB7XG4gICAgZW50cmllc1trZXldID0gIWtleXMgfHwga2V5cy5pbmNsdWRlcyhrZXkpID8gbm9uT3B0aW9uYWwoc2NoZW1hLmVudHJpZXNba2V5XSwgbWVzc2FnZSkgOiBzY2hlbWEuZW50cmllc1trZXldO1xuICB9XG4gIHJldHVybiB7IC4uLnNjaGVtYSwgZW50cmllcyB9O1xufVxuXG4vLyBzcmMvbWV0aG9kcy9yZXF1aXJlZC9yZXF1aXJlZEFzeW5jLnRzXG5mdW5jdGlvbiByZXF1aXJlZEFzeW5jKHNjaGVtYSwgYXJnMiwgYXJnMykge1xuICBjb25zdCBrZXlzID0gQXJyYXkuaXNBcnJheShhcmcyKSA/IGFyZzIgOiB2b2lkIDA7XG4gIGNvbnN0IG1lc3NhZ2UgPSBBcnJheS5pc0FycmF5KGFyZzIpID8gYXJnMyA6IGFyZzI7XG4gIGNvbnN0IGVudHJpZXMgPSB7fTtcbiAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hLmVudHJpZXMpIHtcbiAgICBlbnRyaWVzW2tleV0gPSAha2V5cyB8fCBrZXlzLmluY2x1ZGVzKGtleSkgPyBub25PcHRpb25hbEFzeW5jKHNjaGVtYS5lbnRyaWVzW2tleV0sIG1lc3NhZ2UpIDogc2NoZW1hLmVudHJpZXNba2V5XTtcbiAgfVxuICByZXR1cm4geyAuLi5zY2hlbWEsIGVudHJpZXMgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvc2FmZVBhcnNlL3NhZmVQYXJzZS50c1xuZnVuY3Rpb24gc2FmZVBhcnNlKHNjaGVtYSwgaW5wdXQsIGNvbmZpZzIpIHtcbiAgY29uc3QgZGF0YXNldCA9IHNjaGVtYS5fcnVuKFxuICAgIHsgdHlwZWQ6IGZhbHNlLCB2YWx1ZTogaW5wdXQgfSxcbiAgICBnZXRHbG9iYWxDb25maWcoY29uZmlnMilcbiAgKTtcbiAgcmV0dXJuIHtcbiAgICB0eXBlZDogZGF0YXNldC50eXBlZCxcbiAgICBzdWNjZXNzOiAhZGF0YXNldC5pc3N1ZXMsXG4gICAgb3V0cHV0OiBkYXRhc2V0LnZhbHVlLFxuICAgIGlzc3VlczogZGF0YXNldC5pc3N1ZXNcbiAgfTtcbn1cblxuLy8gc3JjL21ldGhvZHMvc2FmZVBhcnNlL3NhZmVQYXJzZUFzeW5jLnRzXG5hc3luYyBmdW5jdGlvbiBzYWZlUGFyc2VBc3luYyhzY2hlbWEsIGlucHV0LCBjb25maWcyKSB7XG4gIGNvbnN0IGRhdGFzZXQgPSBhd2FpdCBzY2hlbWEuX3J1bihcbiAgICB7IHR5cGVkOiBmYWxzZSwgdmFsdWU6IGlucHV0IH0sXG4gICAgZ2V0R2xvYmFsQ29uZmlnKGNvbmZpZzIpXG4gICk7XG4gIHJldHVybiB7XG4gICAgdHlwZWQ6IGRhdGFzZXQudHlwZWQsXG4gICAgc3VjY2VzczogIWRhdGFzZXQuaXNzdWVzLFxuICAgIG91dHB1dDogZGF0YXNldC52YWx1ZSxcbiAgICBpc3N1ZXM6IGRhdGFzZXQuaXNzdWVzXG4gIH07XG59XG5cbi8vIHNyYy9tZXRob2RzL3NhZmVQYXJzZXIvc2FmZVBhcnNlci50c1xuZnVuY3Rpb24gc2FmZVBhcnNlcihzY2hlbWEsIGNvbmZpZzIpIHtcbiAgY29uc3QgZnVuYyA9IChpbnB1dCkgPT4gc2FmZVBhcnNlKHNjaGVtYSwgaW5wdXQsIGNvbmZpZzIpO1xuICBmdW5jLnNjaGVtYSA9IHNjaGVtYTtcbiAgZnVuYy5jb25maWcgPSBjb25maWcyO1xuICByZXR1cm4gZnVuYztcbn1cblxuLy8gc3JjL21ldGhvZHMvc2FmZVBhcnNlci9zYWZlUGFyc2VyQXN5bmMudHNcbmZ1bmN0aW9uIHNhZmVQYXJzZXJBc3luYyhzY2hlbWEsIGNvbmZpZzIpIHtcbiAgY29uc3QgZnVuYyA9IChpbnB1dCkgPT4gc2FmZVBhcnNlQXN5bmMoc2NoZW1hLCBpbnB1dCwgY29uZmlnMik7XG4gIGZ1bmMuc2NoZW1hID0gc2NoZW1hO1xuICBmdW5jLmNvbmZpZyA9IGNvbmZpZzI7XG4gIHJldHVybiBmdW5jO1xufVxuXG4vLyBzcmMvbWV0aG9kcy91bndyYXAvdW53cmFwLnRzXG5mdW5jdGlvbiB1bndyYXAoc2NoZW1hKSB7XG4gIHJldHVybiBzY2hlbWEud3JhcHBlZDtcbn1cbmV4cG9ydCB7XG4gIEJJQ19SRUdFWCxcbiAgQ1VJRDJfUkVHRVgsXG4gIERFQ0lNQUxfUkVHRVgsXG4gIEVNQUlMX1JFR0VYLFxuICBFTU9KSV9SRUdFWCxcbiAgSEVYQURFQ0lNQUxfUkVHRVgsXG4gIEhFWF9DT0xPUl9SRUdFWCxcbiAgSU1FSV9SRUdFWCxcbiAgSVBWNF9SRUdFWCxcbiAgSVBWNl9SRUdFWCxcbiAgSVBfUkVHRVgsXG4gIElTT19EQVRFX1JFR0VYLFxuICBJU09fREFURV9USU1FX1JFR0VYLFxuICBJU09fVElNRVNUQU1QX1JFR0VYLFxuICBJU09fVElNRV9SRUdFWCxcbiAgSVNPX1RJTUVfU0VDT05EX1JFR0VYLFxuICBJU09fV0VFS19SRUdFWCxcbiAgTUFDNDhfUkVHRVgsXG4gIE1BQzY0X1JFR0VYLFxuICBNQUNfUkVHRVgsXG4gIE9DVEFMX1JFR0VYLFxuICBVTElEX1JFR0VYLFxuICBVVUlEX1JFR0VYLFxuICBWYWxpRXJyb3IsXG4gIF9hZGRJc3N1ZSxcbiAgX2lzTHVobkFsZ28sXG4gIF9pc1ZhbGlkT2JqZWN0S2V5LFxuICBfc3RyaW5naWZ5LFxuICBhbnksXG4gIGFycmF5LFxuICBhcnJheUFzeW5jLFxuICBhd2FpdEFzeW5jLFxuICBiaWMsXG4gIGJpZ2ludCxcbiAgYmxvYixcbiAgYm9vbGVhbixcbiAgYnJhbmQsXG4gIGJ5dGVzLFxuICBjaGVjayxcbiAgY2hlY2tBc3luYyxcbiAgY2hlY2tJdGVtcyxcbiAgY29uZmlnLFxuICBjcmVkaXRDYXJkLFxuICBjdWlkMixcbiAgY3VzdG9tLFxuICBjdXN0b21Bc3luYyxcbiAgZGF0ZSxcbiAgZGVjaW1hbCxcbiAgZGVsZXRlR2xvYmFsQ29uZmlnLFxuICBkZWxldGVHbG9iYWxNZXNzYWdlLFxuICBkZWxldGVTY2hlbWFNZXNzYWdlLFxuICBkZWxldGVTcGVjaWZpY01lc3NhZ2UsXG4gIGVtYWlsLFxuICBlbW9qaSxcbiAgZW1wdHksXG4gIGVuZHNXaXRoLFxuICBlbnRyaWVzRnJvbUxpc3QsXG4gIGVudW1fIGFzIGVudW0sXG4gIGVudW1fLFxuICBldmVyeUl0ZW0sXG4gIGV4Y2x1ZGVzLFxuICBmYWxsYmFjayxcbiAgZmFsbGJhY2tBc3luYyxcbiAgZmlsZSxcbiAgZmlsdGVySXRlbXMsXG4gIGZpbmRJdGVtLFxuICBmaW5pdGUsXG4gIGZsYXR0ZW4sXG4gIGZvcndhcmQsXG4gIGZvcndhcmRBc3luYyxcbiAgZnVuY3Rpb25fIGFzIGZ1bmN0aW9uLFxuICBmdW5jdGlvbl8sXG4gIGdldERlZmF1bHQsXG4gIGdldERlZmF1bHRzLFxuICBnZXREZWZhdWx0c0FzeW5jLFxuICBnZXREb3RQYXRoLFxuICBnZXRGYWxsYmFjayxcbiAgZ2V0RmFsbGJhY2tzLFxuICBnZXRGYWxsYmFja3NBc3luYyxcbiAgZ2V0R2xvYmFsQ29uZmlnLFxuICBnZXRHbG9iYWxNZXNzYWdlLFxuICBnZXRTY2hlbWFNZXNzYWdlLFxuICBnZXRTcGVjaWZpY01lc3NhZ2UsXG4gIGhhc2gsXG4gIGhleENvbG9yLFxuICBoZXhhZGVjaW1hbCxcbiAgaW1laSxcbiAgaW5jbHVkZXMsXG4gIGluc3RhbmNlLFxuICBpbnRlZ2VyLFxuICBpbnRlcnNlY3QsXG4gIGludGVyc2VjdEFzeW5jLFxuICBpcCxcbiAgaXB2NCxcbiAgaXB2NixcbiAgaXMsXG4gIGlzT2ZLaW5kLFxuICBpc09mVHlwZSxcbiAgaXNWYWxpRXJyb3IsXG4gIGlzb0RhdGUsXG4gIGlzb0RhdGVUaW1lLFxuICBpc29UaW1lLFxuICBpc29UaW1lU2Vjb25kLFxuICBpc29UaW1lc3RhbXAsXG4gIGlzb1dlZWssXG4gIGtleW9mLFxuICBsYXp5LFxuICBsYXp5QXN5bmMsXG4gIGxlbmd0aCxcbiAgbGl0ZXJhbCxcbiAgbG9vc2VPYmplY3QsXG4gIGxvb3NlT2JqZWN0QXN5bmMsXG4gIGxvb3NlVHVwbGUsXG4gIGxvb3NlVHVwbGVBc3luYyxcbiAgbWFjLFxuICBtYWM0OCxcbiAgbWFjNjQsXG4gIG1hcCxcbiAgbWFwQXN5bmMsXG4gIG1hcEl0ZW1zLFxuICBtYXhCeXRlcyxcbiAgbWF4TGVuZ3RoLFxuICBtYXhTaXplLFxuICBtYXhWYWx1ZSxcbiAgbWltZVR5cGUsXG4gIG1pbkJ5dGVzLFxuICBtaW5MZW5ndGgsXG4gIG1pblNpemUsXG4gIG1pblZhbHVlLFxuICBtdWx0aXBsZU9mLFxuICBuYW4sXG4gIG5ldmVyLFxuICBub25FbXB0eSxcbiAgbm9uTnVsbGFibGUsXG4gIG5vbk51bGxhYmxlQXN5bmMsXG4gIG5vbk51bGxpc2gsXG4gIG5vbk51bGxpc2hBc3luYyxcbiAgbm9uT3B0aW9uYWwsXG4gIG5vbk9wdGlvbmFsQXN5bmMsXG4gIG5vcm1hbGl6ZSxcbiAgbm90Qnl0ZXMsXG4gIG5vdExlbmd0aCxcbiAgbm90U2l6ZSxcbiAgbm90VmFsdWUsXG4gIG51bGxfIGFzIG51bGwsXG4gIG51bGxfLFxuICBudWxsYWJsZSxcbiAgbnVsbGFibGVBc3luYyxcbiAgbnVsbGlzaCxcbiAgbnVsbGlzaEFzeW5jLFxuICBudW1iZXIsXG4gIG9iamVjdCxcbiAgb2JqZWN0QXN5bmMsXG4gIG9iamVjdFdpdGhSZXN0LFxuICBvYmplY3RXaXRoUmVzdEFzeW5jLFxuICBvY3RhbCxcbiAgb21pdCxcbiAgb3B0aW9uYWwsXG4gIG9wdGlvbmFsQXN5bmMsXG4gIHBhcnNlLFxuICBwYXJzZUFzeW5jLFxuICBwYXJzZXIsXG4gIHBhcnNlckFzeW5jLFxuICBwYXJ0aWFsLFxuICBwYXJ0aWFsQXN5bmMsXG4gIHBhcnRpYWxDaGVjayxcbiAgcGFydGlhbENoZWNrQXN5bmMsXG4gIHBpY2ssXG4gIHBpY2tsaXN0LFxuICBwaXBlLFxuICBwaXBlQXN5bmMsXG4gIHByb21pc2UsXG4gIHJhd0NoZWNrLFxuICByYXdDaGVja0FzeW5jLFxuICByYXdUcmFuc2Zvcm0sXG4gIHJhd1RyYW5zZm9ybUFzeW5jLFxuICByZWFkb25seSxcbiAgcmVjb3JkLFxuICByZWNvcmRBc3luYyxcbiAgcmVkdWNlSXRlbXMsXG4gIHJlZ2V4LFxuICByZXF1aXJlZCxcbiAgcmVxdWlyZWRBc3luYyxcbiAgc2FmZUludGVnZXIsXG4gIHNhZmVQYXJzZSxcbiAgc2FmZVBhcnNlQXN5bmMsXG4gIHNhZmVQYXJzZXIsXG4gIHNhZmVQYXJzZXJBc3luYyxcbiAgc2V0LFxuICBzZXRBc3luYyxcbiAgc2V0R2xvYmFsQ29uZmlnLFxuICBzZXRHbG9iYWxNZXNzYWdlLFxuICBzZXRTY2hlbWFNZXNzYWdlLFxuICBzZXRTcGVjaWZpY01lc3NhZ2UsXG4gIHNpemUsXG4gIHNvbWVJdGVtLFxuICBzb3J0SXRlbXMsXG4gIHN0YXJ0c1dpdGgsXG4gIHN0cmljdE9iamVjdCxcbiAgc3RyaWN0T2JqZWN0QXN5bmMsXG4gIHN0cmljdFR1cGxlLFxuICBzdHJpY3RUdXBsZUFzeW5jLFxuICBzdHJpbmcsXG4gIHN5bWJvbCxcbiAgdG9Mb3dlckNhc2UsXG4gIHRvTWF4VmFsdWUsXG4gIHRvTWluVmFsdWUsXG4gIHRvVXBwZXJDYXNlLFxuICB0cmFuc2Zvcm0sXG4gIHRyYW5zZm9ybUFzeW5jLFxuICB0cmltLFxuICB0cmltRW5kLFxuICB0cmltU3RhcnQsXG4gIHR1cGxlLFxuICB0dXBsZUFzeW5jLFxuICB0dXBsZVdpdGhSZXN0LFxuICB0dXBsZVdpdGhSZXN0QXN5bmMsXG4gIHVsaWQsXG4gIHVuZGVmaW5lZF8gYXMgdW5kZWZpbmVkLFxuICB1bmRlZmluZWRfLFxuICB1bmlvbixcbiAgdW5pb25Bc3luYyxcbiAgdW5rbm93bixcbiAgdW53cmFwLFxuICB1cmwsXG4gIHV1aWQsXG4gIHZhbHVlLFxuICB2YXJpYW50LFxuICB2YXJpYW50QXN5bmMsXG4gIHZvaWRfIGFzIHZvaWQsXG4gIHZvaWRfXG59O1xuIl0sIm5hbWVzIjpbImF3YWl0QXN5bmMiLCJraW5kIiwidHlwZSIsInJlZmVyZW5jZSIsImFzeW5jIiwiX3J1biIsImRhdGFzZXQiLCJ2YWx1ZSIsIkJJQ19SRUdFWCIsIkNVSUQyX1JFR0VYIiwiREVDSU1BTF9SRUdFWCIsIkVNQUlMX1JFR0VYIiwiRU1PSklfUkVHRVgiLCJIRVhBREVDSU1BTF9SRUdFWCIsIkhFWF9DT0xPUl9SRUdFWCIsIklNRUlfUkVHRVgiLCJJUFY0X1JFR0VYIiwiSVBWNl9SRUdFWCIsIklQX1JFR0VYIiwiSVNPX0RBVEVfUkVHRVgiLCJJU09fREFURV9USU1FX1JFR0VYIiwiSVNPX1RJTUVfUkVHRVgiLCJJU09fVElNRV9TRUNPTkRfUkVHRVgiLCJJU09fVElNRVNUQU1QX1JFR0VYIiwiSVNPX1dFRUtfUkVHRVgiLCJNQUM0OF9SRUdFWCIsIk1BQzY0X1JFR0VYIiwiTUFDX1JFR0VYIiwiT0NUQUxfUkVHRVgiLCJVTElEX1JFR0VYIiwiVVVJRF9SRUdFWCIsInN0b3JlIiwic2V0R2xvYmFsQ29uZmlnIiwiY29uZmlnMiIsImdldEdsb2JhbENvbmZpZyIsImxhbmciLCJtZXNzYWdlIiwiYWJvcnRFYXJseSIsImFib3J0UGlwZUVhcmx5IiwiZGVsZXRlR2xvYmFsQ29uZmlnIiwic3RvcmUyIiwic2V0R2xvYmFsTWVzc2FnZSIsIk1hcCIsInNldCIsImdldEdsb2JhbE1lc3NhZ2UiLCJnZXQiLCJkZWxldGVHbG9iYWxNZXNzYWdlIiwiZGVsZXRlIiwic3RvcmUzIiwic2V0U2NoZW1hTWVzc2FnZSIsImdldFNjaGVtYU1lc3NhZ2UiLCJkZWxldGVTY2hlbWFNZXNzYWdlIiwic3RvcmU0Iiwic2V0U3BlY2lmaWNNZXNzYWdlIiwiZ2V0U3BlY2lmaWNNZXNzYWdlIiwiZGVsZXRlU3BlY2lmaWNNZXNzYWdlIiwiX3N0cmluZ2lmeSIsImlucHV0IiwiT2JqZWN0IiwiZ2V0UHJvdG90eXBlT2YiLCJjb25zdHJ1Y3RvciIsIm5hbWUiLCJfYWRkSXNzdWUiLCJjb250ZXh0IiwibGFiZWwiLCJvdGhlciIsImV4cGVjdGVkIiwiZXhwZWN0cyIsInJlY2VpdmVkIiwiaXNzdWUiLCJyZXF1aXJlbWVudCIsInBhdGgiLCJpc3N1ZXMiLCJpc1NjaGVtYSIsInR5cGVkIiwicHVzaCIsIk5PTl9ESUdJVF9SRUdFWCIsIl9pc0x1aG5BbGdvIiwibnVtYmVyMiIsInJlcGxhY2UiLCJsZW5ndGgyIiwibGVuZ3RoIiwiYml0Iiwic3VtIiwidmFsdWUyIiwiX2lzVmFsaWRPYmplY3RLZXkiLCJvYmplY3QyIiwia2V5IiwiaGFzT3duIiwiZW50cmllc0Zyb21MaXN0IiwibGlzdCIsInNjaGVtYSIsImVudHJpZXMiLCJnZXREb3RQYXRoIiwiaXRlbSIsImlzT2ZLaW5kIiwiaXNPZlR5cGUiLCJpc1ZhbGlFcnJvciIsImVycm9yIiwiVmFsaUVycm9yIiwiRXJyb3IiLCJiaWMiLCJ0ZXN0IiwiYnJhbmQiLCJieXRlcyIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwiY2hlY2siLCJjaGVja0FzeW5jIiwiY2hlY2tJdGVtcyIsImluZGV4Iiwib3JpZ2luIiwiQ1JFRElUX0NBUkRfUkVHRVgiLCJTQU5JVElaRV9SRUdFWCIsIlBST1ZJREVSX1JFR0VYX0xJU1QiLCJjcmVkaXRDYXJkIiwic2FuaXRpemVkIiwic29tZSIsInJlZ2V4MiIsImN1aWQyIiwiZGVjaW1hbCIsImVtYWlsIiwiZW1vamkiLCJlbXB0eSIsImVuZHNXaXRoIiwic2xpY2UiLCJldmVyeUl0ZW0iLCJldmVyeSIsImV4Y2x1ZGVzIiwiaW5jbHVkZXMiLCJmaWx0ZXJJdGVtcyIsIm9wZXJhdGlvbiIsImZpbHRlciIsImZpbmRJdGVtIiwiZmluZCIsImZpbml0ZSIsIk51bWJlciIsImlzRmluaXRlIiwiSEFTSF9MRU5HVEhTIiwibWQ0IiwibWQ1Iiwic2hhMSIsInNoYTI1NiIsInNoYTM4NCIsInNoYTUxMiIsInJpcGVtZDEyOCIsInJpcGVtZDE2MCIsInRpZ2VyMTI4IiwidGlnZXIxNjAiLCJ0aWdlcjE5MiIsImNyYzMyIiwiY3JjMzJiIiwiYWRsZXIzMiIsImhhc2giLCJ0eXBlcyIsIlJlZ0V4cCIsIm1hcCIsImpvaW4iLCJoZXhhZGVjaW1hbCIsImhleENvbG9yIiwiaW1laSIsImludGVnZXIiLCJpc0ludGVnZXIiLCJpcCIsImlwdjQiLCJpcHY2IiwiaXNvRGF0ZSIsImlzb0RhdGVUaW1lIiwiaXNvVGltZSIsImlzb1RpbWVTZWNvbmQiLCJpc29UaW1lc3RhbXAiLCJpc29XZWVrIiwibWFjIiwibWFjNDgiLCJtYWM2NCIsIm1hcEl0ZW1zIiwibWF4Qnl0ZXMiLCJtYXhMZW5ndGgiLCJtYXhTaXplIiwic2l6ZSIsIm1heFZhbHVlIiwiRGF0ZSIsInRvSlNPTiIsIm1pbWVUeXBlIiwib3B0aW9uIiwibWluQnl0ZXMiLCJtaW5MZW5ndGgiLCJtaW5TaXplIiwibWluVmFsdWUiLCJtdWx0aXBsZU9mIiwibm9uRW1wdHkiLCJub3JtYWxpemUiLCJmb3JtIiwibm90Qnl0ZXMiLCJub3RMZW5ndGgiLCJub3RTaXplIiwibm90VmFsdWUiLCJvY3RhbCIsIl9pc1BhcnRpYWxseVR5cGVkIiwicGF0aExpc3QiLCJib3VuZCIsIk1hdGgiLCJtaW4iLCJwYXJ0aWFsQ2hlY2siLCJwYXJ0aWFsQ2hlY2tBc3luYyIsInJhd0NoZWNrIiwiYWN0aW9uIiwiY29uZmlnIiwiYWRkSXNzdWUiLCJpbmZvIiwicmF3Q2hlY2tBc3luYyIsInJhd1RyYW5zZm9ybSIsIm91dHB1dCIsIk5FVkVSIiwicmF3VHJhbnNmb3JtQXN5bmMiLCJyZWFkb25seSIsInJlZHVjZUl0ZW1zIiwiaW5pdGlhbCIsInJlZHVjZSIsInJlZ2V4Iiwic2FmZUludGVnZXIiLCJpc1NhZmVJbnRlZ2VyIiwic29tZUl0ZW0iLCJzb3J0SXRlbXMiLCJzb3J0Iiwic3RhcnRzV2l0aCIsInRvTG93ZXJDYXNlIiwidG9NYXhWYWx1ZSIsInRvTWluVmFsdWUiLCJ0b1VwcGVyQ2FzZSIsInRyYW5zZm9ybSIsInRyYW5zZm9ybUFzeW5jIiwidHJpbSIsInRyaW1FbmQiLCJ0cmltU3RhcnQiLCJ1bGlkIiwidXJsIiwiVVJMIiwidXVpZCIsImNvbmZpZ18iLCJnZXRGYWxsYmFjayIsImZhbGxiYWNrIiwiZmFsbGJhY2syIiwiZmFsbGJhY2tBc3luYyIsImZsYXR0ZW4iLCJmbGF0RXJyb3JzIiwiZG90UGF0aCIsIm5lc3RlZCIsInJvb3QiLCJmb3J3YXJkIiwicGF0aEtleXMiLCJwcmV2SXNzdWVzIiwicGF0aElucHV0IiwicGF0aFZhbHVlIiwicGF0aEl0ZW0iLCJmb3J3YXJkQXN5bmMiLCJnZXREZWZhdWx0IiwiZGVmYXVsdCIsImdldERlZmF1bHRzIiwiaXRlbXMiLCJnZXREZWZhdWx0c0FzeW5jIiwiZnJvbUVudHJpZXMiLCJQcm9taXNlIiwiYWxsIiwiZ2V0RmFsbGJhY2tzIiwiZ2V0RmFsbGJhY2tzQXN5bmMiLCJpcyIsImFueSIsImFycmF5IiwiQXJyYXkiLCJpc0FycmF5IiwiaXRlbURhdGFzZXQiLCJ1bnNoaWZ0IiwiYXJyYXlBc3luYyIsIml0ZW1EYXRhc2V0cyIsImJpZ2ludCIsImJsb2IiLCJCbG9iIiwiYm9vbGVhbiIsImN1c3RvbSIsImNoZWNrMiIsImN1c3RvbUFzeW5jIiwiZGF0ZSIsImlzTmFOIiwiZW51bV8iLCJlbnVtX18iLCJvcHRpb25zIiwiZW51bSIsImZpbGUiLCJGaWxlIiwiZnVuY3Rpb25fIiwiaW5zdGFuY2UiLCJjbGFzc18iLCJjbGFzcyIsIl9tZXJnZSIsInZhbHVlMSIsImludGVyc2VjdCIsIlNldCIsIm91dHB1dHMiLCJvcHRpb25EYXRhc2V0IiwibWVyZ2VEYXRhc2V0IiwiaW50ZXJzZWN0QXN5bmMiLCJvcHRpb25EYXRhc2V0cyIsImxhenkiLCJnZXR0ZXIiLCJsYXp5QXN5bmMiLCJsaXRlcmFsIiwibGl0ZXJhbF8iLCJsb29zZU9iamVjdCIsInZhbHVlRGF0YXNldCIsImxvb3NlT2JqZWN0QXN5bmMiLCJ2YWx1ZURhdGFzZXRzIiwibG9vc2VUdXBsZSIsImxvb3NlVHVwbGVBc3luYyIsImlucHV0S2V5IiwiaW5wdXRWYWx1ZSIsImtleURhdGFzZXQiLCJtYXBBc3luYyIsImRhdGFzZXRzIiwibmFuIiwibmV2ZXIiLCJub25OdWxsYWJsZSIsIndyYXBwZWQiLCJub25OdWxsYWJsZUFzeW5jIiwibm9uTnVsbGlzaCIsIm5vbk51bGxpc2hBc3luYyIsIm5vbk9wdGlvbmFsIiwibm9uT3B0aW9uYWxBc3luYyIsIm51bGxfIiwibnVsbGFibGUiLCJhcmdzIiwibnVsbGFibGVBc3luYyIsIm51bGxpc2giLCJudWxsaXNoQXN5bmMiLCJudW1iZXIiLCJvYmplY3QiLCJvYmplY3RBc3luYyIsIm9iamVjdFdpdGhSZXN0IiwicmVzdCIsIm9iamVjdFdpdGhSZXN0QXN5bmMiLCJub3JtYWxEYXRhc2V0cyIsInJlc3REYXRhc2V0cyIsIm9wdGlvbmFsIiwib3B0aW9uYWxBc3luYyIsInBpY2tsaXN0IiwicHJvbWlzZSIsInJlY29yZCIsImVudHJ5S2V5IiwiZW50cnlWYWx1ZSIsInJlY29yZEFzeW5jIiwia2V5MiIsImFkZCIsInNldEFzeW5jIiwic3RyaWN0T2JqZWN0Iiwic3RyaWN0T2JqZWN0QXN5bmMiLCJzdHJpY3RUdXBsZSIsInN0cmljdFR1cGxlQXN5bmMiLCJzdHJpbmciLCJzeW1ib2wiLCJ0dXBsZSIsInR1cGxlQXN5bmMiLCJ0dXBsZVdpdGhSZXN0IiwidHVwbGVXaXRoUmVzdEFzeW5jIiwidW5kZWZpbmVkXyIsIl9zdWJJc3N1ZXMiLCJ1bmlvbiIsInZhbGlkRGF0YXNldCIsInR5cGVkRGF0YXNldHMiLCJ1bnR5cGVkRGF0YXNldHMiLCJ1bmlvbkFzeW5jIiwidW5rbm93biIsIl9kaXNjcmltaW5hdG9ycyIsInNldDIiLCJ2YXJpYW50IiwiZXhwZWN0ZWREaXNjcmltaW5hdG9ycyIsImRpc2NyaW1pbmF0b3IiLCJvdXRwdXREYXRhc2V0IiwidmFyaWFudEFzeW5jIiwidm9pZF8iLCJrZXlvZiIsImtleXMiLCJvbWl0IiwicGFyc2UiLCJwYXJzZUFzeW5jIiwicGFyc2VyIiwiZnVuYyIsInBhcnNlckFzeW5jIiwicGFydGlhbCIsInBhcnRpYWxBc3luYyIsInBpY2siLCJwaXBlIiwicGlwZTIiLCJwaXBlQXN5bmMiLCJyZXF1aXJlZCIsImFyZzIiLCJhcmczIiwicmVxdWlyZWRBc3luYyIsInNhZmVQYXJzZSIsInN1Y2Nlc3MiLCJzYWZlUGFyc2VBc3luYyIsInNhZmVQYXJzZXIiLCJzYWZlUGFyc2VyQXN5bmMiLCJ1bndyYXAiLCJmdW5jdGlvbiIsIm51bGwiLCJ1bmRlZmluZWQiLCJ2b2lkIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/valibot@0.36.0/node_modules/valibot/dist/index.js\n");

/***/ })

};
;