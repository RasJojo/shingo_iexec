"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/dedent@1.7.0";
exports.ids = ["vendor-chunks/dedent@1.7.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/dedent@1.7.0/node_modules/dedent/dist/dedent.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/.pnpm/dedent@1.7.0/node_modules/dedent/dist/dedent.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return typeof key === \"symbol\" ? key : String(key);\n}\nfunction _toPrimitive(input, hint) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n        var res = prim.call(input, hint || \"default\");\n        if (typeof res !== \"object\") return res;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n}\nconst dedent = createDedent({});\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dedent);\nfunction createDedent(options) {\n    dedent.withOptions = (newOptions)=>createDedent(_objectSpread(_objectSpread({}, options), newOptions));\n    return dedent;\n    function dedent(strings, ...values) {\n        const raw = typeof strings === \"string\" ? [\n            strings\n        ] : strings.raw;\n        const { alignValues = false, escapeSpecialCharacters = Array.isArray(strings), trimWhitespace = true } = options;\n        // first, perform interpolation\n        let result = \"\";\n        for(let i = 0; i < raw.length; i++){\n            let next = raw[i];\n            if (escapeSpecialCharacters) {\n                // handle escaped newlines, backticks, and interpolation characters\n                next = next.replace(/\\\\\\n[ \\t]*/g, \"\").replace(/\\\\`/g, \"`\").replace(/\\\\\\$/g, \"$\").replace(/\\\\\\{/g, \"{\");\n            }\n            result += next;\n            if (i < values.length) {\n                const value = alignValues ? alignValue(values[i], result) : values[i];\n                // eslint-disable-next-line @typescript-eslint/restrict-plus-operands\n                result += value;\n            }\n        }\n        // now strip indentation\n        const lines = result.split(\"\\n\");\n        let mindent = null;\n        for (const l of lines){\n            const m = l.match(/^(\\s+)\\S+/);\n            if (m) {\n                const indent = m[1].length;\n                if (!mindent) {\n                    // this is the first indented line\n                    mindent = indent;\n                } else {\n                    mindent = Math.min(mindent, indent);\n                }\n            }\n        }\n        if (mindent !== null) {\n            const m = mindent; // appease TypeScript\n            result = lines// https://github.com/typescript-eslint/typescript-eslint/issues/7140\n            // eslint-disable-next-line @typescript-eslint/prefer-string-starts-ends-with\n            .map((l)=>l[0] === \" \" || l[0] === \"\t\" ? l.slice(m) : l).join(\"\\n\");\n        }\n        // dedent eats leading and trailing whitespace too\n        if (trimWhitespace) {\n            result = result.trim();\n        }\n        // handle escaped newlines at the end to ensure they don't get stripped too\n        if (escapeSpecialCharacters) {\n            result = result.replace(/\\\\n/g, \"\\n\");\n        }\n        return result;\n    }\n}\n/**\n * Adjusts the indentation of a multi-line interpolated value to match the current line.\n */ function alignValue(value, precedingText) {\n    if (typeof value !== \"string\" || !value.includes(\"\\n\")) {\n        return value;\n    }\n    const currentLine = precedingText.slice(precedingText.lastIndexOf(\"\\n\") + 1);\n    const indentMatch = currentLine.match(/^(\\s+)/);\n    if (indentMatch) {\n        const indent = indentMatch[1];\n        return value.replace(/\\n/g, `\\n${indent}`);\n    }\n    return value;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vZGVkZW50QDEuNy4wL25vZGVfbW9kdWxlcy9kZWRlbnQvZGlzdC9kZWRlbnQubWpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxTQUFTQSxRQUFRQyxNQUFNLEVBQUVDLGNBQWM7SUFBSSxJQUFJQyxPQUFPQyxPQUFPRCxJQUFJLENBQUNGO0lBQVMsSUFBSUcsT0FBT0MscUJBQXFCLEVBQUU7UUFBRSxJQUFJQyxVQUFVRixPQUFPQyxxQkFBcUIsQ0FBQ0o7UUFBU0Msa0JBQW1CSSxDQUFBQSxVQUFVQSxRQUFRQyxNQUFNLENBQUMsU0FBVUMsR0FBRztZQUFJLE9BQU9KLE9BQU9LLHdCQUF3QixDQUFDUixRQUFRTyxLQUFLRSxVQUFVO1FBQUUsRUFBQyxHQUFJUCxLQUFLUSxJQUFJLENBQUNDLEtBQUssQ0FBQ1QsTUFBTUc7SUFBVTtJQUFFLE9BQU9IO0FBQU07QUFDcFYsU0FBU1UsY0FBY0MsTUFBTTtJQUFJLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJQyxVQUFVQyxNQUFNLEVBQUVGLElBQUs7UUFBRSxJQUFJRyxTQUFTLFFBQVFGLFNBQVMsQ0FBQ0QsRUFBRSxHQUFHQyxTQUFTLENBQUNELEVBQUUsR0FBRyxDQUFDO1FBQUdBLElBQUksSUFBSWYsUUFBUUksT0FBT2MsU0FBUyxDQUFDLEdBQUdDLE9BQU8sQ0FBQyxTQUFVQyxHQUFHO1lBQUlDLGdCQUFnQlAsUUFBUU0sS0FBS0YsTUFBTSxDQUFDRSxJQUFJO1FBQUcsS0FBS2hCLE9BQU9rQix5QkFBeUIsR0FBR2xCLE9BQU9tQixnQkFBZ0IsQ0FBQ1QsUUFBUVYsT0FBT2tCLHlCQUF5QixDQUFDSixXQUFXbEIsUUFBUUksT0FBT2MsU0FBU0MsT0FBTyxDQUFDLFNBQVVDLEdBQUc7WUFBSWhCLE9BQU9vQixjQUFjLENBQUNWLFFBQVFNLEtBQUtoQixPQUFPSyx3QkFBd0IsQ0FBQ1MsUUFBUUU7UUFBTztJQUFJO0lBQUUsT0FBT047QUFBUTtBQUN6ZixTQUFTTyxn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TixDQUFBQSxJQUFLQSxDQUFDLENBQUMsRUFBRSxLQUFLLE9BQU9BLENBQUMsQ0FBQyxFQUFFLEtBQUssTUFBT0EsRUFBRU8sS0FBSyxDQUFDTixLQUFLRCxHQUFHUSxJQUFJLENBQUM7UUFDakU7UUFFQSxrREFBa0Q7UUFDbEQsSUFBSWhCLGdCQUFnQjtZQUNsQkMsU0FBU0EsT0FBT2dCLElBQUk7UUFDdEI7UUFFQSwyRUFBMkU7UUFDM0UsSUFBSXBCLHlCQUF5QjtZQUMzQkksU0FBU0EsT0FBT0UsT0FBTyxDQUFDLFFBQVE7UUFDbEM7UUFDQSxPQUFPRjtJQUNUO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNELFNBQVNHLFdBQVdqQyxLQUFLLEVBQUUrQyxhQUFhO0lBQ3RDLElBQUksT0FBTy9DLFVBQVUsWUFBWSxDQUFDQSxNQUFNZ0QsUUFBUSxDQUFDLE9BQU87UUFDdEQsT0FBT2hEO0lBQ1Q7SUFDQSxNQUFNaUQsY0FBY0YsY0FBY0gsS0FBSyxDQUFDRyxjQUFjRyxXQUFXLENBQUMsUUFBUTtJQUMxRSxNQUFNQyxjQUFjRixZQUFZVixLQUFLLENBQUM7SUFDdEMsSUFBSVksYUFBYTtRQUNmLE1BQU1YLFNBQVNXLFdBQVcsQ0FBQyxFQUFFO1FBQzdCLE9BQU9uRCxNQUFNZ0MsT0FBTyxDQUFDLE9BQU8sQ0FBQyxFQUFFLEVBQUVRLE9BQU8sQ0FBQztJQUMzQztJQUNBLE9BQU94QztBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbm90YXNjYW0tcHJvdG9jb2wvLi9ub2RlX21vZHVsZXMvLnBucG0vZGVkZW50QDEuNy4wL25vZGVfbW9kdWxlcy9kZWRlbnQvZGlzdC9kZWRlbnQubWpzP2EwNzAiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGtleSA9IF90b1Byb3BlcnR5S2V5KGtleSk7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7IHZhciBrZXkgPSBfdG9QcmltaXRpdmUoYXJnLCBcInN0cmluZ1wiKTsgcmV0dXJuIHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTsgfVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7IGlmICh0eXBlb2YgaW5wdXQgIT09IFwib2JqZWN0XCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDsgdmFyIHByaW0gPSBpbnB1dFtTeW1ib2wudG9QcmltaXRpdmVdOyBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7IHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpOyBpZiAodHlwZW9mIHJlcyAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlczsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpOyB9IHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpOyB9XG5jb25zdCBkZWRlbnQgPSBjcmVhdGVEZWRlbnQoe30pO1xuZXhwb3J0IGRlZmF1bHQgZGVkZW50O1xuZnVuY3Rpb24gY3JlYXRlRGVkZW50KG9wdGlvbnMpIHtcbiAgZGVkZW50LndpdGhPcHRpb25zID0gbmV3T3B0aW9ucyA9PiBjcmVhdGVEZWRlbnQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zKSwgbmV3T3B0aW9ucykpO1xuICByZXR1cm4gZGVkZW50O1xuICBmdW5jdGlvbiBkZWRlbnQoc3RyaW5ncywgLi4udmFsdWVzKSB7XG4gICAgY29uc3QgcmF3ID0gdHlwZW9mIHN0cmluZ3MgPT09IFwic3RyaW5nXCIgPyBbc3RyaW5nc10gOiBzdHJpbmdzLnJhdztcbiAgICBjb25zdCB7XG4gICAgICBhbGlnblZhbHVlcyA9IGZhbHNlLFxuICAgICAgZXNjYXBlU3BlY2lhbENoYXJhY3RlcnMgPSBBcnJheS5pc0FycmF5KHN0cmluZ3MpLFxuICAgICAgdHJpbVdoaXRlc3BhY2UgPSB0cnVlXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICAvLyBmaXJzdCwgcGVyZm9ybSBpbnRlcnBvbGF0aW9uXG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBuZXh0ID0gcmF3W2ldO1xuICAgICAgaWYgKGVzY2FwZVNwZWNpYWxDaGFyYWN0ZXJzKSB7XG4gICAgICAgIC8vIGhhbmRsZSBlc2NhcGVkIG5ld2xpbmVzLCBiYWNrdGlja3MsIGFuZCBpbnRlcnBvbGF0aW9uIGNoYXJhY3RlcnNcbiAgICAgICAgbmV4dCA9IG5leHQucmVwbGFjZSgvXFxcXFxcblsgXFx0XSovZywgXCJcIikucmVwbGFjZSgvXFxcXGAvZywgXCJgXCIpLnJlcGxhY2UoL1xcXFxcXCQvZywgXCIkXCIpLnJlcGxhY2UoL1xcXFxcXHsvZywgXCJ7XCIpO1xuICAgICAgfVxuICAgICAgcmVzdWx0ICs9IG5leHQ7XG4gICAgICBpZiAoaSA8IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBhbGlnblZhbHVlcyA/IGFsaWduVmFsdWUodmFsdWVzW2ldLCByZXN1bHQpIDogdmFsdWVzW2ldO1xuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kc1xuICAgICAgICByZXN1bHQgKz0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbm93IHN0cmlwIGluZGVudGF0aW9uXG4gICAgY29uc3QgbGluZXMgPSByZXN1bHQuc3BsaXQoXCJcXG5cIik7XG4gICAgbGV0IG1pbmRlbnQgPSBudWxsO1xuICAgIGZvciAoY29uc3QgbCBvZiBsaW5lcykge1xuICAgICAgY29uc3QgbSA9IGwubWF0Y2goL14oXFxzKylcXFMrLyk7XG4gICAgICBpZiAobSkge1xuICAgICAgICBjb25zdCBpbmRlbnQgPSBtWzFdLmxlbmd0aDtcbiAgICAgICAgaWYgKCFtaW5kZW50KSB7XG4gICAgICAgICAgLy8gdGhpcyBpcyB0aGUgZmlyc3QgaW5kZW50ZWQgbGluZVxuICAgICAgICAgIG1pbmRlbnQgPSBpbmRlbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWluZGVudCA9IE1hdGgubWluKG1pbmRlbnQsIGluZGVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1pbmRlbnQgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG0gPSBtaW5kZW50OyAvLyBhcHBlYXNlIFR5cGVTY3JpcHRcbiAgICAgIHJlc3VsdCA9IGxpbmVzXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdHlwZXNjcmlwdC1lc2xpbnQvdHlwZXNjcmlwdC1lc2xpbnQvaXNzdWVzLzcxNDBcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLXN0cmluZy1zdGFydHMtZW5kcy13aXRoXG4gICAgICAubWFwKGwgPT4gbFswXSA9PT0gXCIgXCIgfHwgbFswXSA9PT0gXCJcXHRcIiA/IGwuc2xpY2UobSkgOiBsKS5qb2luKFwiXFxuXCIpO1xuICAgIH1cblxuICAgIC8vIGRlZGVudCBlYXRzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UgdG9vXG4gICAgaWYgKHRyaW1XaGl0ZXNwYWNlKSB7XG4gICAgICByZXN1bHQgPSByZXN1bHQudHJpbSgpO1xuICAgIH1cblxuICAgIC8vIGhhbmRsZSBlc2NhcGVkIG5ld2xpbmVzIGF0IHRoZSBlbmQgdG8gZW5zdXJlIHRoZXkgZG9uJ3QgZ2V0IHN0cmlwcGVkIHRvb1xuICAgIGlmIChlc2NhcGVTcGVjaWFsQ2hhcmFjdGVycykge1xuICAgICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL1xcXFxuL2csIFwiXFxuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbi8qKlxuICogQWRqdXN0cyB0aGUgaW5kZW50YXRpb24gb2YgYSBtdWx0aS1saW5lIGludGVycG9sYXRlZCB2YWx1ZSB0byBtYXRjaCB0aGUgY3VycmVudCBsaW5lLlxuICovXG5mdW5jdGlvbiBhbGlnblZhbHVlKHZhbHVlLCBwcmVjZWRpbmdUZXh0KSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIgfHwgIXZhbHVlLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGNvbnN0IGN1cnJlbnRMaW5lID0gcHJlY2VkaW5nVGV4dC5zbGljZShwcmVjZWRpbmdUZXh0Lmxhc3RJbmRleE9mKFwiXFxuXCIpICsgMSk7XG4gIGNvbnN0IGluZGVudE1hdGNoID0gY3VycmVudExpbmUubWF0Y2goL14oXFxzKykvKTtcbiAgaWYgKGluZGVudE1hdGNoKSB7XG4gICAgY29uc3QgaW5kZW50ID0gaW5kZW50TWF0Y2hbMV07XG4gICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoL1xcbi9nLCBgXFxuJHtpbmRlbnR9YCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuIl0sIm5hbWVzIjpbIm93bktleXMiLCJvYmplY3QiLCJlbnVtZXJhYmxlT25seSIsImtleXMiLCJPYmplY3QiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsInB1c2giLCJhcHBseSIsIl9vYmplY3RTcHJlYWQiLCJ0YXJnZXQiLCJpIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwic291cmNlIiwiZm9yRWFjaCIsImtleSIsIl9kZWZpbmVQcm9wZXJ0eSIsImdldE93blByb3BlcnR5RGVzY3JpcHRvcnMiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiZGVmaW5lUHJvcGVydHkiLCJvYmoiLCJ2YWx1ZSIsIl90b1Byb3BlcnR5S2V5IiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJhcmciLCJfdG9QcmltaXRpdmUiLCJTdHJpbmciLCJpbnB1dCIsImhpbnQiLCJwcmltIiwiU3ltYm9sIiwidG9QcmltaXRpdmUiLCJ1bmRlZmluZWQiLCJyZXMiLCJjYWxsIiwiVHlwZUVycm9yIiwiTnVtYmVyIiwiZGVkZW50IiwiY3JlYXRlRGVkZW50Iiwib3B0aW9ucyIsIndpdGhPcHRpb25zIiwibmV3T3B0aW9ucyIsInN0cmluZ3MiLCJ2YWx1ZXMiLCJyYXciLCJhbGlnblZhbHVlcyIsImVzY2FwZVNwZWNpYWxDaGFyYWN0ZXJzIiwiQXJyYXkiLCJpc0FycmF5IiwidHJpbVdoaXRlc3BhY2UiLCJyZXN1bHQiLCJuZXh0IiwicmVwbGFjZSIsImFsaWduVmFsdWUiLCJsaW5lcyIsInNwbGl0IiwibWluZGVudCIsImwiLCJtIiwibWF0Y2giLCJpbmRlbnQiLCJNYXRoIiwibWluIiwibWFwIiwic2xpY2UiLCJqb2luIiwidHJpbSIsInByZWNlZGluZ1RleHQiLCJpbmNsdWRlcyIsImN1cnJlbnRMaW5lIiwibGFzdEluZGV4T2YiLCJpbmRlbnRNYXRjaCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/dedent@1.7.0/node_modules/dedent/dist/dedent.mjs\n");

/***/ })

};
;